Как правильно и безопасно хранить пароли в БД?
Чтобы понять лучшие практики, которые существуют на 2025, пройдёмся по всей истории, от самых наивных решений до современных криптографических стандартов, которые реально защищают пользователей.

Наивное решение 1. Просто храним пароль в БД строкой, как он есть без шифрования.
Плюсы: удобно, ничего не нужно вычислять, лего проверять пароли.
Минусы: как только злоумышленник получает доступ к базе, любыми способами, через SQL-инъекцию, уязвимость в админке или скомпрометированный сервер, то он мгновенно получает все пароли в открытом виде. После этого он может заходить под
другими пользователями, искать пароль админа, пробовать эти же пароли на других сайтах, анализировать закономерности, по которым люди придумывают свои пароли. Поэтому хранить пароли в чистом виде это полная катострофа.

Наивное решение 2. Шифруем пароль (преобразуем пароль алгоритмом в некую нечитаемую строку, которую можно расшифровать только зная ключ).  Идея кажется лучше, но не совсем. Шифрование, это обратимое преобразование данных, которое 
делает их нечитаемыми без некоторого специального ключа. Есть у нас исходные данные (пароль), есть алгоритм шифрования, есть ключ. Мы зашифровываем пароль с помощью алгоритма и ключа, получаем зашифрованный текст, который всегда 
можно расшифровать обратно, если знать ключ. Вроде бы мы зашифровали пароль, но проблема всё ровно осталась: шифрование обратимо из-за ключа, ключ тоже нужно где-то хранить, и если ключ украли, то опять все пароли раскрыты. По сути
это тоже самое что и первое наивное решение, просто проблему сместили на уровень глубже. Современные алгоритмы шифрования (например AES) работают очень быстро, а для хранения паролей скорость это минус, а не плюс. Атакующий сможет 
перебрать огромное кол-во вариантов. Поэтому пароли не шифруют, их нужно преобразовать так, чтобы это было во-первых необратимо и во-вторых максимально медленно для атакующего.

Наивное решение 3. Хеширование (необратимое преобразование). Хеш-функция это алгоритм, который превращает данные в короткую строку фиксированной длины безвозвратно, т.е. из хеша пароль получить обратно невозможно.  Например, у нас 
есть пароль "password123" и применяем для него хеш-функцию (например SHA-256). Получаем некую строку, вроде: ef92b778bafe771e9924b89ecbc08a44a4e166c06659911881f383d4473e94f, и сохраняем его на сервер. Хеш-функция работает так, 
что один и тот-же пароль превращается в одну и туже строку, если применяем один и тот-же алгоритм. Получается сервер теперь всегда хранит хешированную строку, а не сам пароль. Когда пользователь вводит пароль, он снова хешируется, и если 
хеш совпадает с тем, что в БД, то пароль верный. Многие системы храниния паролей начинали с этого способа, использовав такие хеш-функции как MD5, SHA-1, SHA-256, SHA-512 и пр.
Проблема 1: Скорость. Хеш функции слишком быстрые, поскольку MD5 и SHA-семейство создавались не для паролей, а для проверки целостности данных, поэтому они быстрые, что не подходит, потому что атакующий может перебирать миллиарды
вариантов в секунду, особенно на GPU/ASIC-фермах). В итоге перебор становится реалистичным.
Проблема 2: Радужные таблицы. Это огромные БД заранее вычесленныз хешей. Они отлично ломают популярные хеши  MD5 и SHA-1 без соли (про соль позже). На современных KDF алгоритмах радужные таблицы уже не работают, но на 
классических хешах вполне.
Проблема 3: У двух пользователей с одинаковыми паролями будет один хеш, что облегчит атакующему поиск закономерностей.
Обычные хеш-функции это плохой выбор.

Первый набор костылей (решение 4): Соль, глобальная соль, двойное хеширование. Исторически разработчики пытались улучшить ситуацию доступными способами. 
- Соль (salt) - случайная строка, которую добавляют к паролю перед хешированием, чтобы одинаковые пароли давали разные хеши, тогда получается так, что радужные таблицы перестают работать. Соль хранится прямо в БД и это нормально, 
она может быть несекретной.
- Глобальная соль (pepper - с англ. перец) - это одна общая строка, которую добавляют ко всем паролям, чтобы усложнить перебор. Хранится отдельно в конфиге или в другом сервисе, а не в БД рядом с паролем. Но у неё тоже есть проблема, 
её тоже можно перебрать, и если сервер скомпроментирован, то глобальная соль потеряет смысл.
- Хеширование хеша - чтобы сделать вычисление медленее. Но современный GPU всё равно такое посчитает относительно быстро. 
Все эти техники неплохие, но для своего времени.


Решение 5: Современные алгоритмы KDF (Key Derivation Function - Ключевая функция вывода). После многолетних эксперементов, крипто-сообщество пришло к стандарту: пароли нельзя хешировать обычными хешами, нужны специализированные 
функции KDF. Это функции, у которых есть следующие главные требования:
- Медленность (искусственная растяжка) - искусственное замедление вычисления хеша, например, bcrypt 100мс на один пароль. Перебор для злоумышленника станет значительно медленнее. 
- Сложность для GPU/ASIC (memory-hard). GPU и ASIC умеют очень быстро считывать простые хеши, но у них есть слабое место - это операции, требующие много памяти, поэтому алгоритм должен требовать много памяти. Т.е. наша KDF должна
требовать много RAM, например 256 мб на один пароль, они могут обращатся к памяти в случайном порядке. У GPU мало памяти на поток, медленее доступ к памяти и много параллельных потоков, которые начинают душить друг друга
за память, в итоге GPU очень медленно их вычисляет. 
- Обязательная соль - одинаковые пароли теперь имеют разный хеш, радужные таблицы не работают. Т.е. нельзя понять что у двух пользователей одинаковый пароль. Соль всегда рандомная и длинная.
- Стабильность и стандартизация - алгоритм должен быть исследован криптографами много лет, должен быть принят стандартами RFC и NIST, должен быть предсказуем по результатам во всех реализациях, поддерживаться библиотеками 
на разных языках, не иметь чёрных ящиков (неких магических параметров которые всё ломают), и т.д.

На момент 2025 стандарт KDF-функции это:
1. Argon2id: 
- Защищён от GPU
- Нагрузка задаётся памятью (например, 64-256 МБ)
- Время вычисления можно регулировать.
Это лучший вариант.

2. PBKDF2-HMAC-SHA256:
- Медленный и стабильный. Время тоже можно регулировать.
- FIPS-совместимый, что означает что он сертифицирован для enterprise и государственных систем и часто в них используется (В Legacy)
- Более слабый, чем Argon2 (потому что не memory-hard), но всё ещё надёжный 
Повторяет обычный SHA256 много раз (десятки или сотни тысяч раз). 

3. bcrypt
- Исторический стандарт с 1999 года, всё ещё приемлем, но устаревает из-за слабой защиты от GPU.
Хеширует пароли с солью и включает встроенную растяжку 2^n повторений. Довольно простой в реализации, почти все ЯП поддерживают его.

4. scrypt
- Тоже memory-hard, но менее популярен, сложнее настраивать. 


Что в итоге делать с паролем?
1) Используем Argon2id и другие KDF с параметрами:
- Память: 64-256 МБ
- Параллелизм: 1-4
- Итерации: 2-4

2) Храним соль вместе с хешем:
- Соль - не секрет.
- Генерируем минимум 16 байт криптостойким генератором.

3) Опционально используем глобальную соль?
- Храним в конфиге или KMS, но не как замену соли, а как дополнительный слой.

4) Стараемся не использовать MD5/SHA1/SHA256/SHA512 для паролей - даже с солью это устаревшая практика.

5) Ставим rate-limit на вход, чтобы ограничить попытки при онлайн-атаке.




