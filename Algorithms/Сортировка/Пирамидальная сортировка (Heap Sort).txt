Принцип: Строит двоичную кучу (heap) и извлекает максимальный элемент из кучи, перестраивая её после каждого извлечения.
Сложность: O(n log n) в худшем, среднем и лучшем случаях.
Применение: Эффективен для больших массивов, но не является стабильным.

   void heapify(std::vector<int>& arr, int n, int i) {
       int largest = i;
       int left = 2 * i + 1;
       int right = 2 * i + 2;
       if (left < n && arr[left] > arr[largest]) {
           largest = left;
       }
       if (right < n && arr[right] > arr[largest]) {
           largest = right;
       }
       if (largest != i) {
           std::swap(arr[i], arr[largest]);
           heapify(arr, n, largest);
       }
   }

   void heapSort(std::vector<int>& arr) {
       int n = arr.size();
       for (int i = n / 2 - 1; i >= 0; --i) {
           heapify(arr, n, i);
       }
       for (int i = n - 1; i > 0; --i) {
           std::swap(arr[0], arr[i]);
           heapify(arr, i, 0);
       }
   }


#########################################################################
Алгоритм сортировки кучей
https://evileg.com/ru/post/463/

Сортировка кучей - популярный и эффективный алгоритм сортировки в компьютерном программировании. Чтобы научиться писать алгоритм сортировки кучей, требуется знание двух типов структур данных - массивов и деревьев. Сортировка кучей 
работает путем визуализации элементов массива как особого вида полного двоичного дерева, называемого кучей.

##############################
Для начала разберём базовые понятия: Что такое бинарное дерево? Какие виды бинарных деревьев существуют?
Бинарное дерево - это структура данных дерева, в которой каждый родительский узел может иметь не более двух дочерних элементов:
 	
	1
       / \
     12   9
    /  \   \
   5    6   8
  / \    \
 2   3    4


Полное бинарное дерево - это особый тип бинарного дерева, в котором у каждого родительского узла есть два или нет дочерних элементов:

	  1
	 / \
        12  9
       / \
      5	  6
	 / \
 	3   4


Идеальное бинарное дерево похоже на полное бинарное дерево, но с двумя основными отличиями:
1.Каждый уровень должен быть полностью заполнен.
2.Все элементы листа должны наклоняться влево.

Примечание: Последний элемент может не иметь правильного брата, то есть идеальное бинарное дерево не обязательно должно быть полным бинарным деревом.

Примеры:

x Небинарное дерево			 1
x Неполное дерево		       / | \
x Неидеальное дерево		      12 9 10
					 |
					 5


v Бинарное дерево			1
x Неполное дерево		       / \
x Неидеальное дерево 		     12   9
				    / \    \
				   5   6    8


v Бинарное дерево			1
x Неполное дерево		      /   \
v Идеальное дерево		     12    9
				    / \   /
				   5   6 5


v Бинарное дерево			1
v Полное дерево		      	      /   \
v Идеальное дерево		     12    9
				    / \   
				   5   6 


###
Как создать полное бинарное дерево из несортированного списка (массива)?
- Выберите первый элемент списка, чтобы он быть корневым узлом. (Первый уровень - 1 элемент).
- Поместите второй элемент в качестве левого дочернего элемента корневого узла, а третий элемент - в качестве правого дочернего элемента. (Второй уровень - 2 элемента).
- Поместите следующие два элемента в качестве дочерних элементов левого узла второго уровня. Снова, поместите следующие два элемента как дочерние элементы правого узла второго уровня (3-й уровень - 4 элемента).
- Продолжайте повторять, пока не дойдете до последнего элемента.

	1				1 12 9 5 6 10
					^

	1				1 12 9 5 6 10
       /				   ^
      12

	1			  	1 12 9 5 6 10
       / \				     ^
      12  9


	1			  	1 12 9 5 6 10
       / \				       ^
      12  9
     /
    5

	1			  	1 12 9 5 6 10
       / \				         ^
      12  9
     / \
    5   6


	 1			  	1 12 9 5 6 10
       /  \				            ^
     12    9
    / \   /
   5   6 10


###
Связь между индексами массива и элементами дерева
Полное бинарное дерево обладает интересным свойством, которое мы можем использовать для поиска дочерних элементов и родителей любого узла. Если индекс любого элемента в массиве равен i, элемент в индексе 2i + 1 станет левым потомком, а 
элемент в индексе 2i + 2 станет правым потомком. Кроме того, родительский элемент любого элемента с индексом i задается нижней границей (i-1) / 2.

	 (0)				0 1  2 3 4 5 (индексы)
	 1			  	1 12 9 5 6 10
    (1)/  \(2)				            
     12    9
    / \   /
   5   6 10
 (3) (4)  (5)


Т.е. чтобы найти в массиве левый дочерний элемент текущего элемента нужно использовать формулу 2i + 1, где i - индекс текущего элемента, а чтобы найти правый дочерний элемент, нужно использовать 2i + 2. И также чтобы найти родительский
элемент текущего элемента, нужно использовать формулу (i-1) / 2.

Понимание этого сопоставления индексов массива с позициями дерева имеет решающее значение для понимания того, как работает структура данных кучей и как она используется для реализации сортировки кучей.


##############################
Что такое структура данных кучи?

Куча - это специальная древовидная структура данных. Говорят, что двоичное дерево следует структуре данных кучи, если
- это полное бинарное дерево;
- все узлы в дереве следуют тому свойству, что они больше своих потомков, то есть самый большой элемент находится в корне, и оба его потомка меньше, чем корень, и так далее. Такая куча называется убывающая куча (Max-Heap). Если вместо 
этого все узлы меньше своих потомков, это называется возрастающая куча (Min-Heap).

         12   	 		  1			  		
        /  \            	/   \				            
      10    9          	       5     9
     /  \  /   		      / \   /
    5   6 1                 10   6 12

  убывающая куча           возрастающая куча


###
Как выстроить дерево

Начиная с идеального бинарного дерева, мы можем изменить его, чтобы оно стало убывающим, запустив функцию heapify для всех неконечных элементов кучи. Поскольку heapfiy использует рекурсию, это может быть трудно для понимания. Итак, 
давайте сначала подумаем о том, как бы вы сложили дерево из трех элементов.

Псевдокод:
heapify(array)
    Root = array[0]
    Largest = largest( array[0] , array [2*0 + 1]. array[2*0+2])
    if(Root != Largest)
          Swap(Root, Largest)


Сценарий 1:

	7 -------> Здесь родитель изначально больше
       / \
      2   4



Сценарий 2:

	2		7 -------> Поменяли 7 и 2, теперь родитель больше
       / \	-->    / \
      7   4           2   4
      :
      :
      :
     Дочерний элемент больше чем родитель


В приведенном выше примере показаны два сценария - один, в котором корень является самым большим элементом, и нам не нужно ничего делать. И еще один, в котором корень имеет дочерний элемент большего размера, и нам нужно было поменять их
местами, чтобы сохранить свойство убывающей кучи. Если вы раньше работали с рекурсивными алгоритмами, то вы поняли, что это должен быть базовый случай.

Теперь давайте подумаем о другом сценарии, в котором существует более одного уровня.

	 2
       /  \
     10    9
    / \   /
   5   6 1


На рисунке оба поддерева корневого элемента второго уровня уже являются
убывающими кучами.
Верхний элемент не подходит под убывающую кучу, но все поддеревья являются убывающими.
Чтобы сохранить свойство убывания для всего дерева, нам нужно будет "протолкнуть" родителя вниз, пока он не достигнет своей правильной позиции.

Меняем 2 и 10:

	10
       /  \
     2     9
    / \   /
   5   6 1

Теперь нужно поменять 2 и 6:

	10
       /  \
     6     9
    / \   /
   5   2 1


Таким образом, чтобы сохранить свойство убывания в дереве, где оба поддеревья являются убывающими, нам нужно многократно запускать heapify для корневого элемента, пока он не станет больше, чем его дочерние элементы, или он не станет 
листовым узлом.

Мы можем объединить оба эти условия в одну функцию heapify следующим образом:

void heapify(int arr[], int n, int i)			// arr массив, n его размер, i текущий индекс
{
   int largest = i;					// largest это индекс наибольшего элемента, по умолчанию это индекс текущего элемента
   int left = 2 * i + 1;				// Индекс левого дочернего элемента
   int right = 2 * i + 2;				// Индекс правого дочернего элемента

   if (left  < n && arr[left] > arr[largest])		// Условие l < n проверяет что левый дочерний элемент вообще существует. Условие arr[l] > arr[largest] сравнивает значения дочернего левого элемента с наибольшим элементом. (В 
     largest = l;					// данном случае наибольший элемент считается текущим родительским). И если значение левого дочернего элемента больше текущего, то индекс наибольшего элемента изменяется.

   if (right < n && arr[right] > arr[largest])		// Тоже самое делаем с правым дочерним элементом. Таким образом мы нашли наибольший из этих трёх элементов.
     largest = r;					 

   if (largest != i)					// И если индекс наибольшего элемента не совпадает с индексом текущего элемента 
   {
     swap(arr[i], arr[largest]);			// Тогда меняем местами два элемента (Текущий, и дочерний наибольший).

     // Recursively heapify the affected sub-tree
     heapify(arr, n, largest);				// Вызываем рекурсивно эту же функцию на изменённый дочерний элемент, для того чтобы ветка дочернего элемента, которую мы только что изменили, тоже пришла в правильное состояние.
   }
}

Эта функция работает как для базового случая, так и для дерева любого размера. Таким образом, мы можем переместить корневой элемент в правильное положение, чтобы поддерживать статус убывающей кучи для любого размера дерева, пока 
поддеревья являются убывающими.


##############################
Сборка убывающей кучи

Чтобы собрать убывающую кучу из любого дерева, мы можем начать выстраивать каждое поддерево снизу вверх и получить убывающую кучу после применения функции ко всем элементам, включая корневой элемент.
В случае полного дерева первый индекс неконечного узла определяется как n / 2 - 1. Все остальные узлы после этого являются листовыми узлами и, следовательно, не нуждаются в куче. 

Т.е. начинать алгоритм нужно с элемента, индекс которого равен n / 2 - 1. Это последний родительский элемент в дереве (узел), у его дочерних элементов нет потомков.

Мы можем выстроить убывающую кучу так:

// Build heap (rearrange array)
   for (int i = n / 2 - 1; i >= 0; i--)
     heapify(arr, n, i);



Массив arr = {1, 12, 9, 5, 6, 10}
n = 6
i = 6 / 2 - 1 = 2 - это индекс последнего узла


	 (0)				0 1  2 3 4 5 (индексы)
	 1			  	1 12 9 5 6 10
    (1)/  \(2)				            
     12    9
    / \   /
   5   6 10
 (3) (4)  (5)

В цикле в первой итерации вызываем heapify(arr, 6, 2). Функция heapify меняет нам 2 и 5 элементы:

	 (0)				0 1  2  3 4 5 (индексы)
	 1			  	1 12 10 5 6 9
    (1)/  \(2)				            
     12    10
    / \   /
   5   6  9
 (3) (4)  (5)

в цикле --i поэтому i становится равным 1. Во второй итерации вызываем heapify(arr, 6, 1). Функция heapify нам ничего не меняет, потому что у 1-ого элемента всё в порядке:


	 (0)				0 1  2  3 4 5 (индексы)
	 1			  	1 12 10 5 6 9
    (1)/  \(2)				            
     12    10
    / \   /
   5   6  9
 (3) (4)  (5)

в цикле --i поэтому i становится равным 0. Во третьей итерации вызываем heapify(arr, 6, 0). Функция heapify меняет нам 0 и 1 элементы:


       (0)				0  1 2  3 4 5 (индексы)
       12			  	12 1 10 5 6 9
   (1)/  \(2)				            
     1    10
    / \   /
   5   6  9
 (3) (4)  (5)

поскольку мы поменяли элемент, функция heapify рекурсивно вызывает heapify(arr, 6, 1) т.е.себя же для проверки дочерних элементов. Она видит что сейчас дочерний левый элемент под индексом 1 находится не на своём месте, 
поэтому меняет 1 и 4:

       (0)				0  1 2  3 4 5 (индексы)
       12			  	12 6 10 5 1 9
   (1)/  \(2)				            
     6    10
    / \   /
   5   1  9
 (3) (4)  (5)

Дочерний правый элемент пож индексом 2 находится на своём месте, поэтому алгоритм завершается.

Как показано на диаграмме выше, мы начинаем с кучи самых маленьких деревьев и постепенно продвигаемся вверх, пока не достигнем корневого элемента.


##############################
Процедуры для Heapsort

1. Поскольку дерево удовлетворяет свойству убывающей, самый большой элемент сохраняется в корневом узле.
2. Удалите корневой элемент и поместите в конец массива (n-я позиция). Поместите последний элемент дерева (кучу) в свободное место.
3. Уменьшите размер кучи на 1 и снова укрупните корневой элемент, чтобы у вас был самый большой элемент в корне.
4. Процесс повторяется до тех пор, пока все элементы списка не будут отсортированы.

Исходный массив:

       (0)				0  1 2  3 4 5 (индексы)
       12			  	12 6 10 5 1 9
   (1)/  \(2)				            
     6    10
    / \   /
   5   1  9
 (3) (4)  (5)

Удаляем корневой элемент 12(0) и помещаем его в конец массива, а последний элемент кучи 9(5) ставим на освободившееся место (меняем местами 12 и 9):

       (0)				0 1 2  3 4 |5 (индексы)
        9			  	9 6 10 5 1 |12
   (1)/   \(2)				            
     6     10
    / \   X	- Удаляем последний элемент.
   5   1 12
 (3) (4)  (5)


Уменьшаем размер кучи на 1 и проверяем кучу на правильность расположения элементов. У нас элемент 2 имеет значаение 10, что больше чем корневой элемент 0 со значением 9, поэтому вызываем функцию heapify и располагаем элементы правильно:

       (0)				0  1 2 3 4 |5 (индексы)
       10			  	10 6 9 5 1 |12
   (1)/  \(2)				            
     6    9
    / \     
   5   1    
 (3) (4)     

Выполняем вторую итерацию, удаляем корневой элемент 10(0) и помещаем его на место последнего элемента кучи, а последний элемент кучи 1(4) ставим на освободившееся корневое место (меняем местами 10 и 1):

       (0)				0 1 2 3 |4  5 (индексы)
       1			  	1 6 9 5 |10 12
   (1)/ \(2)				            
     6   9
    / X     
   5   10    
 (3) (4)    

Уменьшаем размер кучи на 1 и проверяем кучу на правильность расположения элементов. У нас элемент 2 имеет значение 9, что больше чем корневой элемент 0 со значением 1, поэтому вызываем функцию heapify и располагаем элементы правильно:

       (0)				0 1 2 3 |4  5 (индексы)
       9			  	9 6 1 5 |10 12
   (1)/ \(2)				            
     6   1
    /      
   5       
 (3)   

Выполняем третью итерацию, удаляем корневой элемент 9(0) и помещаем его на место последнего элемента кучи, а последний элемент кучи 5(3) ставим на освободившееся корневое место (меняем местами 9 и 5):


       (0)				0 1 2 |3 4  5 (индексы)
       5			  	5 6 1 |9 10 12
   (1)/ \(2)				            
     6   1
    X      
   9       
 (3)   

Уменьшаем размер кучи на 1 и проверяем кучу на правильность расположения элементов. У нас элемент 1 имеет значение 6, что больше чем корневой элемент 0 со значением 5, поэтому вызываем функцию heapify и располагаем элементы правильно:

       (0)				0 1 2 |3 4  5 (индексы)
       6			  	6 5 1 |9 10 12
   (1)/ \(2)				            
     5   1            

Выполняем четвёртую итерацию, удаляем корневой элемент 6(0) и помещаем его на место последнего элемента кучи, а последний элемент кучи 1(2) ставим на освободившееся корневое место (меняем местами 6 и 1):

       (0)				0 1 |2 3 4  5 (индексы)
       1			  	1 5 |6 9 10 12
   (1)/ X(2)				            
     5   6 

Уменьшаем размер кучи на 1 и проверяем кучу на правильность расположения элементов. У нас элемент 1 имеет значение 5, что больше чем корневой элемент 0 со значением 1, поэтому вызываем функцию heapify и располагаем элементы правильно:

       (0)				0 1 |2 3 4  5 (индексы)
       5			  	5 1 |6 9 10 12
   (1)/ 				            
     1    

Выполняем пятую итерацию, удаляем корневой элемент 5(0) и помещаем его на место последнего элемента кучи, а последний элемент кучи 1(1) ставим на освободившееся корневое место (меняем местами 5 и 1):

       (0)				0 |1 2 3 4  5 (индексы)
       1			  	1 |5 6 9 10 12
   (1)X 				            
     5   

Уменьшаем размер кучи на 1 и проверяем кучу на правильность расположения элементов. Однако поскольку у нас остался только один элемент, то прекращаем алгоритм:

       (0)				0 1 2 3 4  5 (индексы)
       1			  	1 5 6 9 10 12		- отсортировано.


Код выглядит так:

for (int i=n-1; i>=0; i--)
   {
     // Переместить текущий корень в конец
     swap(arr[0], arr[i]);

     // вызовите максимальный heapify на уменьшенной куче
     heapify(arr, i, 0);
   }			


##############################
Представление

Сортировка кучи имеет O(n log n) временные сложности для всех случаев (лучший случай, средний случай и худший случай). В чем же причина? Высота полного бинарного дерева, содержащего n элементов, равна log (n). Как мы видели ранее, чтобы 
полностью накапливать элемент, чьи поддеревья уже являются убывабщими кучами, нам нужно продолжать сравнивать элемент с его левым и правым потомками и толкать его вниз, пока он не достигнет точки, где оба его потомка меньше его.

В худшем случае нам потребуется переместить элемент из корневого узла в конечный узел, выполнив несколько сравнений и обменов log (n).

На этапе build_max_heap мы делаем это для n / 2 элементов, поэтому сложность шага build_heap в наихудшем случае равна n / 2 * log (n) ~ nlogn.

На этапе сортировки мы обмениваем корневой элемент с последним элементом и подкачиваем корневой элемент. Для каждого элемента это снова занимает большое время, поскольку нам, возможно, придется перенести этот элемент от корня до листа. 
Поскольку мы повторяем операцию n раз, шаг heap_sort также nlogn.

Кроме того, поскольку шаги build_max_heap и heap_sort выполняются один за другим, алгоритмическая сложность не умножается и остается в порядке nlogn.

Также выполняется сортировка в O (1) пространстве сложности. По сравнению с быстрой сортировкой, в худшем случае (O (nlogn)). Быстрая сортировка имеет сложность O (n ^ 2) для худшего случая. Но в других случаях быстрая сортировка 
выполняется достаточно быстро. Introsort - это альтернатива heapsort, которая сочетает в себе quicksort и heapsort для сохранения преимуществ, таких как скорость heapsort в худшем случае и средняя скорость quicksort.

В среднем HeapSort медленнее QuickSort, но выигрывает в худшем случае.


##############################
Реализация C++

// C++ program for implementation of Heap Sort
#include <iostream>
using namespace std;

void heapify(int arr[], int n, int i) {	 		// arr массив, n его размер, i текущий индекс
	// Find largest among root, left child and right child
	int largest = i;				// largest это индекс наибольшего элемента, по умолчанию это индекс текущего элемента
	int left = 2 * i + 1;				// Индекс левого дочернего элемента
	int right = 2 * i + 2;				// Индекс правого дочернего элемента

	if (left  < n && arr[left] > arr[largest])	// Условие l < n проверяет что левый дочерний элемент вообще существует. Условие arr[l] > arr[largest] сравнивает значения дочернего левого элемента с наибольшим элементом. (В 
		largest = left;				// данном случае наибольший элемент считается текущим родительским). И если значение левого дочернего элемента больше текущего, то индекс наибольшего элемента изменяется.

	if (right < n && arr[right] > arr[largest])	// Тоже самое делаем с правым дочерним элементом. Таким образом мы нашли наибольший из этих трёх элементов.
		largest = right;

	// Swap and continue heapifying if root is not largest
	if (largest != i) {				// И если индекс наибольшего элемента не совпадает с индексом текущего элемента 	
		std::swap(arr[i], arr[largest]);	// Тогда меняем местами два элемента (Текущий, и дочерний наибольший).
		heapify(arr, n, largest);		// Вызываем рекурсивно эту же функцию на изменённый дочерний элемент, для того чтобы ветка дочернего элемента, которую мы только что изменили, тоже пришла в правильное состояние.
	}
}

// main function to do heap sort
void heapSort(int arr[], int n)					
{
	// Build max heap
	for (int i = n / 2 - 1; i >= 0; i--)		// Строим кучу
		heapify(arr, n, i);					

	// Heap sort
	for (int i = n - 1; i >= 0; i--) {		// Сортируем кучу
		std::swap(arr[0], arr[i]);		// Меняем местами корневой и последний элемен кучи

		// Heapify root element to get highest element at root again
		heapify(arr, i, 0);			// Проверяем кучу на корректное расположение элементов
	}
}


//Проверка

void printArray(int arr[], int n)
{
   for (int i=0; i<n; ++i)
     cout << arr[i] << " ";
   cout << "\n";
}

int main()
{
   int arr[] = {1,12,9,5,6,10};
   int n = sizeof(arr)/sizeof(arr[0]);
   heapSort(arr, n);

   cout << "Sorted array is \n";
   printArray(arr, n);
}



###
Применение сортировки кучей

Системы, связанные с безопасностью, и встроенные системы, такие как ядро Linux, используют сортировку кучей из-за верхней границы O (n log n) времени работы Heapsort и постоянной верхней границы O (1) его вспомогательного хранилища.

Хотя сортировка кучей имеет O (n log n) временную сложность даже для наихудшего случая, у нее нет больше приложений (по сравнению с другими алгоритмами сортировки, такими как быстрая сортировка, сортировка слиянием). Тем не менее, его 
базовая структура данных, куча, может быть эффективно использована, если мы хотим извлечь наименьший (или наибольший) из списка элементов без дополнительных затрат на сохранение оставшихся элементов в отсортированном порядке. Например, 
приоритетные очереди.

