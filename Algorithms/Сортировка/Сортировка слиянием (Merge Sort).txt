Merge Sort  (Сортировка слиянием)

Сортировка слиянием - классический алгоритм, который использует подход "Разделяй и властвуй". Алгоритм делит массив на две части, рекурсивно сортирует каждую из них, а затем объединяет их в один отсортированный массив.

Принцип:
1) Делим массив на две равные части, пока каждая не станет состоять только из одного элемента.
2) Сравниваем элементы каждой пары и сливаем их в один отсортированный подмассив. 
3) Повторяем шаг 2, пока не получим один полностью отсортированный массив.

Рассмотрим шаг 2 подробнее: Пусть мы имеем два уже отсортированных по возрастанию подмассива, тогда нам нужно выполнить слияние этих двух подмассивов в третий результирующий массив. Мы берём цикл и сравниваем первые элементы из
обоих подмассивов. Наименьший из этих двух элементов записываем в результирующий массив. Счётчики номеров элементов результирующего массива и подмассива, из которого был взят наименьший элемент, увеличиваем на 1. Т.о. у подмассива 
из которого взяли наименьший элемент берём следующий элемент и опять сравниваем с первым элементом второго подмассива. Когда один из подмассивов закончился, мы добавляем все оставшиеся элементы другого подмассива в 
результирующий массив.

Пример:
Массив: 			13,3,8,1,15,2,3,7,4
Делим на равные части:		13,3,8,1 - 15,2,3,7,4
Делим на равные части:		13,3 - 8,1 - 15,2 - 3,7 - 4
Делим на равные части:		13 - 3 - 8 - 1 - 15 -2 -3 -7- 4
Сортируем соседние пары:	3,13 - 1,8 - 2,15 - 3,7 - 4
Сортируем соседние пары:	1,3,8,13 - 2,3,7,15 - 4
Сортируем соседние пары:	1,2,3,3,7,8,13,15-4
Сортируем соседние пары:	1,2,3,3,4,7,8,13,15


Сложность: 
Временаая сложность: Один из немногих алгоритмов которые гарантируют временную сложность O(n log n) в худшем, среднем и лучшем случаях. Всё это благодаря рекурсивному делению массива и упорядочиванию уже отсортированных подмассивов.
Пространственная сложность: O(n). Требуется дополнительная память для хранения временных массивов, используемых на каждом этапе рекурсии.

Применение: Эффективен для больших массивов, стабилен и может быть реализован для сортировки на внешней памяти. 

   void merge(std::vector<int>& arr, int left, int mid, int right) {
       std::vector<int> temp(right - left + 1);
       int i = left, j = mid + 1, k = 0;
       while (i <= mid && j <= right) {
           if (arr[i] <= arr[j]) {
               temp[k++] = arr[i++];
           } else {
               temp[k++] = arr[j++];
           }
       }
       while (i <= mid) {
           temp[k++] = arr[i++];
       }
       while (j <= right) {
           temp[k++] = arr[j++];
       }
       for (int i = left, k = 0; i <= right; ++i, ++k) {
           arr[i] = temp[k];
       }
   }

   void mergeSort(std::vector<int>& arr, int left, int right) {
       if (left < right) {
           int mid = left + (right - left) / 2;
           mergeSort(arr, left, mid);
           mergeSort(arr, mid + 1, right);
           merge(arr, left, mid, right);
       }
   }




