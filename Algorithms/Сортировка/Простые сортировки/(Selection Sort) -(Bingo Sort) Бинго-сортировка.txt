##############################
Bingo Sort (Бинго-сортировка)

Интересной особенностью сортировки выбором (Selection Sort) является независимость скорости от характера сортируемых данных. Например, если массив почти отсортирован, то как известно, сортировка вставками (Insertion Sort) его обработает
гораздо быстрее (даже быстрее чем QuickSort (быстрая сортировка)), однако реверсно упорядоченный массив для сортировки вставками ( Insertion Sort ) является вырожденным случаем, она будет сортировать максимально долго.  А для нашей 
сортировки выбором частичная или реверсная упорядоченность массива роли не играет - она обработает его примерно с той же скоростью что и обычный рандом. Также для нашей классической сортировки выбором неважно, состоит ли массив из 
уникальных или повторяющихся элементов - на скорость это практически не влияет.

Но в принципе можно исхитриться и модифицировать алгоритм так, чтобы при некоторых наборах данных сортировка работала быстрее, например Bingo Sort учитывает, если массив состоит из повторяющихся элементов. Здесь фокус в том, что в 
неупорядоченной части запоминается не только максимальный элемент, но и определяется максимум для следующей итерации. Это позволяет при повторяющихся максимумах не искать их заново каждый раз, а ставить на своё место сразу как только этот
максимум в очередной раз встретили в массиве. 

Алгоритмическая сложность осталась та же. Но если массив состоит из повторяющихся чисел, то бинго-сортировка справися в десятки раз быстрее, чем обычная сортировка выбором.

// Функция для нахождения максимального и минимального элементов из массива.
void maxMin(std::vector<int> vec, int n, int& bingo, int& nextBingo) {
    for (int i = 1; i < n; bingo = std::min(bingo, vec[i]), nextBingo = std::max(nextBingo, vec[i]), ++i);
}

void BingoSort(std::vector<int>& vec, int n) {
	int bingo = vec[0];
	int nextBingo = vec[0];
	maxMin(vec, n, bingo, nextBingo);
	int largestEle = nextBingo;
	int nextElePos = 0;
	while (bingo < nextBingo) {
		int startPos = nextElePos;	// Будет отслеживать положение элементов, чтобы переместить их в правильное положение
		for (int i = startPos; i < n; ++i) {
			if(vec[i] == bingo) {
				std::swap(vec[i], vec[nextElePos]);
				nextElePos = nextElePos + 1;
			}
			// Здесь мы находим следующий элемент Бинго для следующего прохождения
			else if (vec[i] < nextBingo)
				nextBingo = vec[i];
		}
		bingo = nextBingo;
		nextBingo = largestEle;
	}
}