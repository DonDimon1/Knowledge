Сортировка расчёской (англ. comb sort) — это довольно упрощённый алгоритм сортировки. Сортировка расчёской улучшает сортировку пузырьком, и конкурирует с алгоритмами, подобными быстрой сортировке. Основная идея — устранить черепах, или 
маленькие значения в конце списка, которые крайне замедляют сортировку пузырьком (кролики, большие значения в начале списка, не представляют проблемы для сортировки пузырьком) (Смотри в Bubble Sort). 

В сортировке пузырьком, когда сравниваются два элемента, промежуток (расстояние друг от друга) равен 1. Основная идея сортировки расчёской в том, что этот промежуток может быть гораздо больше, чем единица (сортировка Shell sort (Шелла) 
также основана на этой идее, но она является модификацией сортировки вставками, а не сортировки пузырьком).

В «пузырьке», «шейкере» и «чёт-нечете» при переборе массива сравниваются соседние элементы. Основная идея «расчёски» в том, чтобы первоначально использовать достаточно большое расстояние между сравниваемыми элементами и по мере 
упорядочивания массива уменьшать это расстояние вплоть до минимального. Таким образом, мы как бы причёсываем массив, постепенно разглаживая на всё более аккуратные пряди. Первоначальный разрыв между сравниваемыми элементами лучше брать 
с учётом специальной величины, называемой фактором уменьшения (коэффициент сжатия), который может быть, например, 1,247 (1.25 или 1,3). Сначала расстояние между элементами максимально, то есть равно размеру массива минус один. Затем, 
пройдя массив с этим шагом, необходимо поделить шаг на фактор уменьшения и пройти по списку вновь. Так продолжается до тех пор, пока разность индексов не достигнет единицы, а когда достигнет, то сортировка будет продолжаться с 
расстоянием 1 между элементами (как в Bubble sort), пока список не будет полностью отсортирован. В этом случае сравниваются соседние элементы как и в сортировке пузырьком, но к этому времени с большинством черепах уже разобрались и 
возможно такой проход будет только один, поэтому сортировка пузырем будет эффективной.

Коэффициент усадки оказывает большое влияние на эффективность сортировки гребней. Добосевич предположил, что k = 4/3 = 1,333..., в то время как Лейси и Бокс предлагают 1,3 в качестве идеального коэффициента сжатия после эмпирического 
тестирования на более чем 200 000 случайных списков длиной около 1000. Слишком маленькое значение замедляет работу алгоритма, делая ненужное количество сравнений, в то время как слишком большое значение не может эффективно работать с 
черепахами, из-за чего ему требуется много проходов с интервалом 1.


Пузырьковая сортировка, как правило, более медленный алгоритм, является основой сортировки по гребням. Хотя в среднем Comb Sort работает лучше, чем Bubble Sort, в худшем случае остается O(n^2).
Коктейльная сортировка, или двунаправленная сортировка пузырьков, — это разновидность сортировки пузырьков, которая также решает проблему черепах, хотя и менее эффективно.

Производительность в худшем случае: O(n^2)
Производительность в наилучшем случае: O(n log n)
Средняя производительность: O(n^2 / 2^p), где p - количество приращений.

Пространственная сложность: O(1).



// C++ implementation of Comb Sort
#include<bits/stdc++.h>
using namespace std;

// getNextGap нужна чтобы найти зазор между элементами
int getNextGap(int gap)
{
    // Уменьшение зазора с помощью фактора уменьшения
    gap = (gap * 10) / 13;

    if (gap < 1)
        return 1;
    return gap;
}

//Функция для сортировки a[0..n-1] с помощью Comb Sort
void CombSort(int* arr, int size) {
    // Инициализация зазора
    int gap = size;

    // Инициализируйте swapped как true, чтобы убедиться, что цикл выполняется
    bool swapped = true;

    // Продолжайте выполнение, пока разрыв больше 1 и пока последняя итерация вызвала подмену
    while (gap != 1 || swapped == true)
    {
        // Найдите следующий зазора
        gap = getNextGap(gap);

        // Инициализируйте swapped как false, чтобы мы могли проверить, произошла ли подмена или нет
        swapped = false;

        // Сравните все элементы с текущим зазором
        for (int i = 0; i < size - gap; i++)
        {
            if (arr[i] > arr[i + gap])
            {
                std::swap(arr[i], arr[i + gap]);

                swapped = true;
            }
        }
    }
}

// Driver program
int main()
{
    int a[] = {8, 4, 1, 56, 3, -44, 23, -6, 28, 0};
    int n = sizeof(a)/sizeof(a[0]);

    combSort(a, n);

    printf("Sorted array: \n");
    for (int i=0; i<n; i++)
        printf("%d ", a[i]);

    return 0;
}


###
Шаблон повторяющихся проходов сортировки с уменьшением пропусков аналогичен Shellsort, но в Shellsort массив полностью сортируется каждый проход, прежде чем перейти к следующему наименьшему пропуску. Проходы сортировки гребней не 
полностью сортируют элементы. По этой причине последовательности зазоров Shellsort имеют больший оптимальный коэффициент усадки, равный примерно 2,25.

Еще одно уточнение, предложенное Лейси и Боксом, — это «правило 11»: всегда используйте размер зазора 11, округляя размеры зазора 9 или 10 (достигаются путем деления промежутков 12, 13 или 14 на 1,3) до 11. Это исключает выживание 
черепах до финального прохода gap-1.



