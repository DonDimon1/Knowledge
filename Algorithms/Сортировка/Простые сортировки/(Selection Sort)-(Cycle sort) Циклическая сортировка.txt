
##############################
Cycle sort (Циклическая сортировка)

Циклическая сортировка интересна и ценна тем, что изменения среди элементов массива происходят тогда и только тогда, когда элемент ставится на своё конечное место. Это может пригодиться, если перезапись в массиве - слишком дорогое удовольствие и 
для бережного отношения к физической памяти требуется свести к минимуму количество изменений элементов массива, для данного случая это оптимальный алгоритм.  

Основная идея заключается в том, чтобы разделить вкходной массив на циклы, где каждый цикл состоит из элементов, которые принадлежат к одной и той же позиции в отсортированном массиве выходных данных. Затем алгоритм выполняет серию обменов,
чтобы поместить каждый элемент в правильное положение в течение цикла, пока все циклы не будут завершены и массив не будет отсортирован. 

Т.е. мы перебираем массив, и называем X очередную ячейку в этом внешнем цикле, и смотрим на какое место в массиве нужно вставить очередной элемент из этой ячейки. На том месте, куда нужно вставить, находится какой-то другой элемент, и его мы
отправляем в буфер обмена. Для этого элемента в буфере тоже ищем его место в массиве и вставляем на это место, а в буфер отправляем элемент, который был на этом месте, и для нового числа в буфере производим те же действия. До каких пор должен
продолжаться этот процесс? Пока очередной элемент в буфере обмена не окажется тем элементом, который нужно вставить именно в ячейку (текущее место в массиве в главном цикле алгоритма). Рано или поздно этот момент произойдёт и тогда во внешнем 
цикле можно перейти к следующей ячейке и повторить для неё ту же процедуру.

В других сортировках выбором мы ищем максимум/минимум, чтобы поставить их на последнее/первое место. В cycle sort так получается, что минимум на первое место в подмассиве как бы находится сам, в процессе того, как несколько других элементов
ставятся на свои законные места где-то в середние массива. И здесь алгоритмическая сложность так же остаётся в пределах O(n^2). На практике цикличная сортировка работает даже в несколько раз медленнее, чем обычная сортировка выбором, т.к.
приходится больше бегать по массиву и чаще сравнивать. Эта цена за минимально возможное количество перезаписей.

Одним из преимуществ данной сортировки является то, что он имеет низкий объём памяти т.к. он сортирует массив на месте и не требует дополнительной памяти для временных переменных. Однако он м.б. медленный особенно когда входной массив имеет 
большой диапазон значений. 

Код:

void CycleSort(int arr[], int n) {
    //int writes = 0; // Если нужно подсчитать количество операций записи в память

    // обход элементов массива и размещение его в нужном месте
    for (int cycle_start = 0; cycle_start <= n - 2; ++cycle_start) {
        int item = arr[cycle_start]; // инициализировать item в качестве начальной точки
        int pos = cycle_start;       // Найдите позицию, куда мы поместили item. Мы в основном считаем все меньшие элементы с правой стороны item.

        for (int i = cycle_start + 1; i < n; ++i) {
            if (arr[i] < item)
                ++pos;
            if (pos == cycle_start)  // Если item уже находится в правильном положении
                continue;

            while (item == arr[pos]) // игнорируем все повторяющиеся элементы
                pos += 1;
            if (pos != cycle_start) {// помещаем item в правильное положение
                std::swap(item, arr[pos]);
                //++writes;
            }

            while (pos != cycle_start) { // Поворачиваем остальную часть цикла
                pos = cycle_start;
                for (int i = cycle_start + 1; i < n; ++i) // Находим позицию, куда мы помещаем элемент
                    if (arr[i] < item)
                        pos += 1;

                while (item == arr[pos]) // игнорируем все повторяющиеся элементы
                    pos += 1;

                if (item != arr[pos]) { // помещаем item в правильное положение
                    std::swap(item, arr[pos]);
                    //++writes;
                }
            }
        }
    }

    //std::cout << writes << '\n';
}


Анализ временной сложности:
Худший, средний, лучший случай: O(n^2)
Вспомогательная память: O(1)


Ситуационная оптимизация:
Когда массив содержит только дубликаты относительно небольшого количества элементов, идеальная хеш-функция может значительно ускорить поиск, куда поместить элемент, превратив сортировку из времени O(n^2), в время O(N + k), где k - это общее
количество хешей. Массив в конечном итоге сортируется в порядке хешей, поэтому выбор хеш-функции, которая даёт нам правильный порядок, важен. https://en.m.wikipedia.org/wiki/Cycle_sort


