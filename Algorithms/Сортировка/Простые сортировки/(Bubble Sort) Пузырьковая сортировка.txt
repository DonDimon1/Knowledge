Пузырьковая сортировка (Bubble Sort)

Пузырьковая сортировка - наверно самая простая сортировка, которую я встречал. Обычно она встречается в книгах по программированию и не выходит за ее пределы. Так как она работает намного медленнее, чем другие алгоритмы сортировки.

Принцип работы пузырьковой сортировки можно описать в три пункта:
1. Прохождение по всему массиву;
2. Сравнивание между собой пар соседних ячеек;
3. Если при сравнении оказывается, что значение ячейки i больше, чем значение ячейки i + 1, то мы меняем значения этих ячеек местами;

Т.е. Повторно проходит по списку, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.

for (int i = 0; i < 10; i++) {
    for (int j = 0; j < 9; j++) {
      if (digitals[j] > digitals[j + 1]) {
        int b = digitals[j]; 			// создали дополнительную переменную
        digitals[j] = digitals[j + 1]; 		// меняем местами
        digitals[j + 1] = b; 			// значения элементов
      }
    }
}


Чтобы оптимизировать пузырьковую сортировку нужно:
1) изменить условие внутреннего цикла на i < 10 - ( i + 1).
Дело в том, что за первый полный проход циклом по массиву самый большой элемент всплывет вверх (переместится в конец массива). Второй по размерам элемент всплывет на предпоследнюю ячейку уже за второй проход цикла и т.д. Поэтому чтобы 
лишний раз не сравнивать элементы массива тратя на это время, мы решили уменьшать отрезок внутреннего цикла на 1, после каждого полного прохода внешнего цикла.

2) Вы могли заметить, что если даже массив стал отсортирован (или сразу был отсортирован) алгоритм все равно продолжает сравнивать элементы. Для того чтобы пузырьковая сортировка останавливалась (когда массив уже стал отсортирован), мы 
объявили булеву переменную flag (ее обычно называют флаг или флажок). Еще при ее инициализации мы поместили значение true, но она меняется на false, если результат условия digitals[j] > digitals[j + 1] положительный. Чтобы мы могли выйти
из алгоритма мы проверяем: Если булева переменная равна true, значит массив уже полностью отсортирован и можно выйти. Для этого используем оператор break. Если же значение flag равно false, то продолжаем сортировать массив.

 for (int i = 0; i < 10; i++) {
    bool flag = true;
    for (int j = 0; j < 10 - (i + 1); j++) { 
       if (digitals[j] > digitals[j + 1]) {
        flag = false;
        swap (digitals[j], digitals[j + 1]);
      }
    }
    if (flag) {
      break;
    }
  }


Версия для вектора:


void bubbleSort(std::vector<int>& arr) {
    for (size_t i = 0; i < arr.size() - 1; ++i) {
        for (size_t j = 0; j < arr.size() - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
            }
        }
    }
}


В худшем случае производительность: O(n^2) сравнения и O(n^2) перестановки.
Наилучшая производительность: O(n) сравнения и O(1) перестановки.
Средняя производительность: O(n^2) сравнения и O(n^2) перестановки.

Применение: Образовательные цели, так как алгоритм прост для понимания, но неэффективен для больших данных.



##############################
Кролики и черепахи

Почему Bubble Sort так медленно работает? Расстояние и направление, в котором должны перемещаться элементы во время сортировки, определяют производительность пузырьковой сортировки, поскольку элементы движутся в разных направлениях с 
разной скоростью. Элемент, который должен переместиться в конец списка, может перемещаться быстро, потому что он может участвовать в последовательных обменах. Например, самый большой элемент в списке будет выигрывать каждый обмен, 
поэтому он перемещается на свою отсортированную позицию при первом проходе, даже если он начинается в самом начале (такие элементы называют кроликами).С другой стороны, элемент, который должен перемещаться к началу списка, не может 
перемещаться быстрее, чем на один шаг за проход, поэтому элементы перемещаются к началу очень медленно (такие элементы называют черепахами). Если самый маленький элемент находится в конце списка, он займет n - 1 проходы, чтобы 
переместить его в начало. Это привело к тому, что эти типы элементов были названы кроликами и черепахами соответственно, в честь персонажей басни Эзопа «Черепаха и заяц».

Были предприняты различные усилия по устранению черепах, чтобы повысить скорость сортировки пузырей. Cocktail shaker sort (Коктейльная сортировка) — это двунаправленная сортировка пузырьков, которая идет от начала к концу, а затем 
переворачивается, идя от начала к началу. Он может довольно хорошо передвигать черепах, но при этом сохраняет O(n^2) сложность в наихудшем случае. Comb sort (Сортировка расчёской) сравнивает элементы, разделенные большими промежутками, 
и может очень быстро перемещать черепах, прежде чем переходить к все меньшим и меньшим промежуткам, чтобы сгладить список. Его средняя скорость сравнима с более быстрыми алгоритмами, такими как быстрая сортировка.







