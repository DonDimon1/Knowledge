Вы разрабатываете модуль обработки записей логов, поступающих от различных серверов. Требуется для заданного набора логов подсчитать статистику результатов обработки запросов для всех различных значений поля Status.
Результатом работы модуля является список различных значений поля Status с количеством встречающихся операций.
Каждый сервер выдает лог в следующем виде:
[TimeStamp] Status: Message.
Например:
[12:30:45] INFO: System started.
Поле Status определяет результат обработки запроса, поступившего на сервер.
У каждого сервера существует свой набор вариантов значений Status, которые могут быть записаны в разном регистре, например, error и ERROR — это варианты написания одного и того же значения Status.
Вам нужно разработать:
● класс StatusData, реализующий хранение информации о статусе;
● класс ProcessingLogData, содержащий метод ProcessingInputLines, для обработки входных данных.
Используйте Span<T> и Slice для парсинга строки без выделения дополнительной памяти.
Формат ввода
На вход модуля подаётся набор записей логов сервера — строки, содержащие информацию о результате обработки запроса, поступившего на сервер:
[TimeStamp] Status: Message.
После символа квадратная скобка “]” идет ровно один пробел.
После двоеточия “:” идет ровно один пробел.
Поля TimeStamp, Status, Message всегда корректные, не пустые, поля TimeStamp и Status не содержат пробелов, но могут быть пробелы в начале и конце строки.
Значение поля TimeStamp — временная метка в формате ЧЧ:ММ:СС.
Значение поля Status — набор символов английского алфавита длиной от 2 до 10 символов включительно без пробелов и других символов.
Два значения поля Status считаются одинаковыми, если они совпадают при записи в нижнем регистре.
Значение поля Message — произвольная строка, состоящая из любых символов, длиной от 1 до 100 символов включительно.
Количество строк — от 1 до 1 000 000. Гарантируется, что есть хотя бы одна строка.
Формат вывода
Строки с обработанными данными о статистике по результатам обработки запросов на сервере в формате:
Status;StatusCount.
Выходные строки сортируются по полю Status по алфавиту. Поле Status выводится со всеми символами в верхнем регистре.
Пример 1
Входные данные:
[12:30:45] INFO: System started
[12:31:10] WARN: Low memory
[12:32:00] INFO: User logged in
[12:33:15] ERROR: Connection failed
[12:34:20] info: System check
Выходные данные:
ERROR;1
INFO;3
WARN;1
Пример 2
Входные данные:
[12:30:45] InFO: System started
[12:31:10] INFO: System started
[12:32:00] InfO: User logged in
[12:33:15] info: System started
[12:34:20] INFO: System check
Выходные данные:
INFO;5














Динамическая сортировка для каталога товаров
Сложный
Обработка слабоструктурированных данных
LiNQ
Коллекции
Вы разрабатываете модуль сортировки товаров для фронтенд-панели сайта интернет-магазина.
Требуется разработать метод для сортировки товаров по произвольному полю с учетом направления (по возрастанию или по убыванию); если основное поле совпало, сортировка производится по названию товаров в алфавитном порядке. Также метод должен учитывать как возможность изменения состава полей класса Product в связи с постоянной доработкой бэкенда сайта интернет-магазина.
Данные о продуктах хранит класс
public class Product
{
public string Name { get; set; }
public int Price { get; set; }
public int Stock { get; set; }
public string Category { get; set; }
public DateTime ReleaseDate { get; set; }
public override string ToString() =>
$"{Name};{Price};{Stock};{Category};{ReleaseDate:yyyy-MM-dd}";
}
Описание полей приведено во входных данных.
Вам нужно разработать:
● класс QueryableExtensions, реализующий сортировку по произвольному полю с использованием метода
public static IQueryable<T> OrderByCustomField<T>(this IQueryable<T> queryable,
string fieldName, bool ascending = true);
● класс ProcessingProductSorting, содержащий метод ProcessingInputLines, для обработки входных данных с использованием PLINQ.
Формат ввода
В первой строке находится название поля и направление сортировки, разделенные пробелом:
fieldName SortDirection
fieldname — принимает одно из значений (ReleaseDate, Name, Price, Stock, Category);
SortDirection — принимает одно из двух значений (asc или desc), сортировка по возрастанию и по убыванию соответственно.
Далее идут строки, содержащие значение полей класса Product:
Name1;Price1;Stock1;Category1;ReleaseDate1
Name2;Price2;Stock2;Category2;ReleaseDate2
…
NameN;PriceN;StockN;CategoryN;ReleaseDateN
Name — строка символов английского алфавита и цифр длиной от 1 до 30 включительно;
Price — целое число от 1 до 999999 включительно;
Stock — целое число от 0 до 9999 включительно;
Category — строка английских символов длиной от 3 до 16 включительно;
ReleaseDate — имеет формат ГГГГ-ММ-ДД.
Входные данные корректные, не содержат пробелов внутри полей, могут быть пробелы в начале и конце строки с данными.
Количество строк — от 1 до 10 000 000. Гарантируется, что есть хотя бы одна строка.
Формат вывода
Данные с выполненной сортировкой по указанному полю в указанном направлении в том же формате, что и для входных данных:
Name1;Price1;Stock1;Category1;ReleaseDate1
Name2;Price2;Stock2;Category2;ReleaseDate2
…
NameN;PriceN;StockN;CategoryN;ReleaseDateN
Пример 1
Входные данные:
Price asc
Laptop;999;10;Electronics;2023-01-15
Phone;699;25;Electronics;2023-03-10
Book;19;100;Books;2022-11-05
Выходные данные:
Book;19;100;Books;2022-11-05
Phone;699;25;Electronics;2023-03-10
Laptop;999;10;Electronics;2023-01-15
Пример 2
Входные данные:
Stock desc
Monitor;249.99;15;Electronics;2023-02-20
Keyboard;49.99;50;Electronics;2023-04-05
Mouse;29.99;75;Electronics;2023-01-30
Выходные данные:
Mouse;0;75;Electronics;2023-01-30
Keyboard;0;50;Electronics;2023-04-05
Monitor;0;15;Electronics;2023-02-20




















Выбор сервера в MMORPG
Сложный
Имитационное моделирование
Валидация данных
Коллекции
В связи с модернизацией модуля обработки потока запросов на подключение игроков к игровым серверам MMORPG-игры возникла проблема с увеличением числа отказов в подключении.
Вам необходимо разработать модуль анализа отказов в подключении игроков.
От игроков поступают запросы вида UserID:Action.
Action определяет два вида запросов:
● connect — запрос на подключение к серверу;
● disconnect — запрос на отключение от сервера.
Существуют три сервера с ограниченной очередью. При поступлении запроса на подключение выбирается сервер с наименьшим количеством игроков.
Если все серверы заполнены максимально возможным количеством игроков, то игрок в ответ на свой запрос получает отказ в подключении (этот запрос на подключение повторно не обрабатывается).
В случае успешного подключения игрок может провести на сервере неограниченное время.
Игрок удаляется с сервера при поступлении от него запроса с Action=disconnect с тем же userID, который использовался для подключения.
В систему может поступить запрос с Action=disconnect от пользователя, который не является подключенным ни к одному из серверов. Такой запрос считается некорректным и игнорируется.
В систему может поступить запрос с Action=connect от пользователя, который уже является подключенным к одному из серверов. Такой запрос считается некорректным и игнорируется.
Вам нужно разработать:
● класс Server для обработки подключения к серверу;
● класс ConnectionModelling, обрабатывающий подключение игроков к серверу, содержащий метод processingInputLines, который возвращает количество игроков, которым было отказано в подключении.
Формат ввода
q1 q2 q3
UserID1:Action1
…
UserIDN:ActionN
В первой строке содержатся три целых числа (от 1 до 1000 включительно), разделенных пробелом, — размеры очереди игроков на каждом из трех серверов: q1 для сервера 1, q2 для сервера 2, q3 для сервера 3.
Далее идут строки, содержащие UserID:Action:
UserID — целое число от 100000 до 999999 включительно;
Action — одно из двух значений (connect, disconnect).
Все значения полей UserID:Action корректные и не пустые. Могут быть пробелы в начале и конце строки с данными.
Количество строк — от 1 до 10 000. Гарантируется, что есть хотя бы одна строка с данными.
Формат вывода
Одно целое число (≥ 0) — количество игроков, которым было отказано в подключении.
Пример 1
Входные данные:
2 2 2
100001:connect
100002:connect
100003:connect
100004:connect
100005:connect
100006:connect
100007:connect
Выходные данные:
1
Пример 2
Входные данные:
1 2 1
100001:connect
100002:connect
100001:connect
100003:connect
100001:disconnect
100004:connect
100005:disconnect
Выходные данные:
0










Медианная фильтрация
Сложный
Обработка временных рядов
LINQ
Паттерны проектирования
Вы разрабатываете модуль предварительной обработки данных для системы компьютерного зрения на основе медианного фильтра для последующего определения сильно зашумленных изображений.
На вход модуля подается изображение в виде матрицы точек размером N×N, элемент матрицы — это код цвета в оттенках серого (целое число от 0 до 255 включительно). Число N — это количество строк и столбцов в матрице. N является степенью 2 и N больше или равно 2.
Необходимо выполнить медианную фильтрацию изображения следующим образом.
Матрица изображения разбивается на блоки точек размером 2×2 начиная с верхнего левого угла. Для каждого блока вычисляется медиана точек по следующему правилу: все четыре кода цветов блока упорядочиваются по возрастанию:
c1<=c2<=c3<=c4,
тогда медиана — это цвет с кодом (c2+c3)/2 (значение медианы округляется до целого путем отбрасывания дробной части).
После применения медианного фильтра из матрицы N×N получается матрица N/2×N/2.
Вам нужно разработать класс SeriesAnalyser, содержащий метод processingInputLines, который принимает на вход исходную матрицу цветов и возвращает матрицу цветов, полученную в результате обработки медианным фильтром. Необходимо разработать синглтон MedianCalculator для вычисления медианы и декоратор MatrixValidator для валидации входных данных, другие необходимые вспомогательные классы.
Формат ввода
N
с11 с12 … с1N
…
сN1 сN2 … cNN
В первой строке содержится одно целое число N — размер матрицы цветов изображения.
N является степенью двойки и находится в интервале от 2 до 1024 включительно.
Далее идет N строк, каждая из которых содержит N кодов цвета точки изображения, разделенных одним пробелом.
cij — это код цвета, целое число от 0 до 255 включительно.
Количество строк — от 2 до 1024.
Формат вывода
Матрица кодов цветов изображения, полученная в результате медианной фильтрации, в формате:
M
c11 c12 … c1M
…
cM1 cM2 … cMM
М — это целое число, равное N/2, cij — это код цвета, целое число от 0 до 255 включительно.
Если входные данные не прошли валидацию, то вывести 0.
Пример 1
Входные данные:
2
10 20
30 40
Выходные данные:
1
25
Пример 2
Входные данные:
4
10 20 30 40
50 60 70 80
90 100 110 120
130 140 150 160
Выходные данные:
2
35 55
115 135











