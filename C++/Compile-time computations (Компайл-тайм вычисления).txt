Compile-time computations	(Компайл-тайм вычисления)

_____________________________________________
Basic usages of constexpr

Сейчас мы обсудим что такое constexpr и научимся им пользоваться. Начиная с C++11 можно попросить компилятор сделать какую-то переменную или функцию constexpr. 

constexpr int x = 5;

Это ключевое слово, применённое к переменной означает, что это должна быть не просто константа, а константа времени компиляции (т.е. в частности это константа). Из constexpr следуе const, но не в обратную сторону, т.е. не все const это
constexpr. Например:

int y;
std::cin >> y;
const int z = y;		// Так мы можем сказать
//constexpr int z2 = y;	// Так мы уже не можем сказать, это CE

Мы не можем так сказать, хоть это и константа, но это не м.б. константой времени компиляции, потому что мы не можем в компайл тайме вычислить чему будет равен z2. По сути это ровно то, что требуют шаблоны в своих параметрах, когда мы
передаём в шаблоны число в качестве шаблонного параметра, чтобы выражение которое мы туда передаём было constexpr. В данном случае в последней строчке будет CE: the value of 'y' is not usable in a constant expression. Эта фраза несколько 
проясняет как компилятор мыслит о происходящем. Он ожидает, что то, что справа должно быть constant expression. constant expression это особый вид выражений, которые можно подставлять в шаблонные параметры, и их же использовать для
инициализации constexpr переменных. Существует длинный список того, какие выражения считаются constant expression и только такие выражения можно одновременно и подставлять в шаблоны и использовать для инициализации constexpr 
переменных (и ещё для static_assert тоже требует от выражения быть constant expression). В принципе практически все выражения являются constant expression кроме некоторых. 

Также мы можем сказать про какую-нибудь функцию, что она является constexpr:

constexpr int max(int x, int y) {
	return x > y ? x : y;
}

Что означает что эта функция constexpr? Это означает, что вызов этой функции является constant expression, при условии что переданные в неё аргументы тоже constant expression. Однако это не значит что эта функция объязательно вычисляется 
в компайл тайме, мы можем вызвать её и в рантайме, т.е. то что эта функция constexpr не объязывает нас вызывать её только от констант времени компиляции, оно лишь означает что мы можем вызвать эту функцию в контексте где ожидается 
константа времени компиляции, поэтому constexpr от constexpr не имеет смысла. Поэтому мы можем написать так:

std::array<int, max(5, 6)> a;

потому что в данном случае max это constexpr функция, но если мы уберём из max constexpr, то мы не сможем так написать, потому что вызов функции max формально не constant expression, мы не можем вызывать функции там, где ожидаются
constant expression, только если эти функции не помечены как constexpr.


Тема Compile-time computations это отличный повод повторить всё то, что мы проходили. Сейчас мы будем думать что можно делать в компайл тайме, а что нельзя. Можно ли использовать тернарный оператор как в функции max выше?
Можем, и вообще мы можем использовать любые built-in (встроенные) операторы над примитивными типами, это корректно. Кроме экспрешеннов у нас ещё бывают декларейшены и контролстейтменты. Можно ли в constexpr функции
объявить переменную, а потом ещё написать какой нибудь if, for или while? Можно, начиная с C++14. В C++11 constexpr функции могли быть только такими как max, они могли состоять только из одного return и дальше один экспрешен и всё.
Начиная с C++14 в constexpr функциях можно писать контролстейтменты над примитивными типами и можно объявлять переменные:

constexpr bool is_prime(int n) {
	for(int i = 2; i * i <=n; ++i) {
		if (n % i == 0) return false;
	}
	return n > 1;
}

int main() {
	static_assert(is_prime(1'000'000'009));	// Это число простое, и мы проверили это в компайл тайме. 	
}

Такую функцию можно посчитать в компайл тайме начиная с C++14. Но при этом нам никто не запрещает вычислить её в рантайме:

static_assert(is_prime(1'000'000'009));

int y;
std::cin >> y;
std::cout << is_prime(y);

Во время компиляции компилятор сделал static_assert, а потом во время рантайма мы можем проверить другое число. В рантайме компилятор вычисляет побыстрее, потому что рантайм оптимизирован, а компайлтайм не очень. 

Можем ли мы в constexpr функции использовать массивы? Например мы хотим завести массив чисел, и посчитать количество простых чисел.

constexpr int count_primes() {
	int a[11] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int count = 0;
	for (int* p = a; p < a + 11; ++p) {
		count += is_prime(*p);
	}
	return count;
} 

int main() {
	static_assert(count_primes() == 4);
}

Всё компилируется и мы можем в компайлтайме в constexpr функциях создавать массивы на стеке, и указатели, и делать арифметику указателей, и разыменовывать их. 

Предположим если мы чуть-чуть ошиблись и допустили разыменование невалидного указателя в компайлтайме, что тогда будет? Это будет CE: non-constant condition for static assertion, потому что array subscript value '11' is outside
the bounds of array 'a' of type 'int[11]'. Т.е. если мы переполняем int в компайлтайме то это тоже CE и разыменование невалидного указателя в компайлтайме это CE и битая ссылка тоже CE, получатся компилятор в компайлтайме это 
вообщем-то безопасный язык программирования, поэтому вычисления в компайл тайме работают медленее чем в рантайме. Т.е. вещи, которые были UB над интами в рантайме, при переводе их в constexpr вычисления становятся 
гарантированными CE, компилятор обьязан нам сказать что мы разыменовали невалидный указатель или сделали переполнение инта, потому что компилятор не может допустить UB в компайлтайме. Однако есть ньюанс XD. Есть 
у нас такое выражение:

count++ + ++count;

Формально это UB, но проблема в том, что это выражение хоть и UB, но компилятор не задетектит его в компайл тайме. Есть пропоузал (баг), формально компилятор должен детектит возникшие UB над интами в компайлтайме, но 
просто никто не знает как это сделать XD, там есть известный баг, что не gcc, не clang не умеют такое детектить в constexpr функциях в компайлтайме, видимо они просто пока не смогли это реализовать в компиляторах, хотя компилятор
должен такое выдавать как CE, поскольку формально это выражение это UB.


Можно ли в компайлтайме бросать исключения?

constexpr bool is_prime(int n) {
	for(int i = 2; i * i <=n; ++i) {
		if (n % i == 0) return false;
	}
	if (n > 100)
		throw 1;
	return n > 1;
}

int main() {
	static_assert(is_prime(37));	
}

Тут доходит дело до того, что можно делать в constexpr функциях, а что можно делать в компайлтайме, потому что мы можем что-то сделать в constexpr функции по условию, которое в компайлтайме никогда не выполниться, и то что там
будет написано, оно до его выполнения не дойдёт, и поэтому всё нормально, как например здесь есть условие при n > 100, а is_prime у нас только от 37. Т.е. одно дело мы в constexpr функции что-то пишем, а другое дело что до этого реально 
доходит выполнение. Данный код компилируется, т.е. throw можно писать в constexpr функциях, но только при условии что до него реально не дойдёт исполнение. Если до throw дойдёт выполнение, то оно превратиться в CE. Однако try-catch
делать в компайлтайме уже нельзя, т.е. не получится отловить исключение, потому что бросание исключения требует вызова оператора new (до него мы дойдём позже).


_____________________________________________
OOP in compile-time 

Это раздел будет почти полностью состоять из вопроса "А это можно сделать или нет?".

Допустим у нас есть структура S, и мы хотим в какой-нибудь constexpr функции создать объект S.

struct S {
	int x = 5;
};

constexpr int f() {
	S s;
	return s.x;
}

int main() {
	static_assert(f() == 5);
}

Объекты можно создавать в constexpr функциях.  Однако если мы сделаем нетривиальный конструктор в структуре S, то это уже не скомпилируется

struct S {
	int x = 5;
	S(int x): x(x) {}		// Нетривиальный конструктор
};

constexpr int f() {
	S s = 10;			// Создаём S
	return s.x;
}

int main() {
	static_assert(f() == 10);	// Не скомпилируется
}

Когда мы добавили нетривиальный конструктор и в строке S s = 10 вызвали конструктор, но конструктор, как и любая другая функция, для того чтобы быть вызванной в компайл-тайме, нужно чтобы она была constexpr. Поэтому так тоже
можно, но при условии что у нас конструктор тоже помечен constexpr:

constexpr S(int x): x(x) {}

Именно поэтому так много всего в STL помечено constexpr. Деструкторы тоже нужно будет помечать constexpr.

Также у нас есть перегрузка методов, и один метод может быть помечен как constexpr, а другой нет:

struct S {
	int x = 5;
	S(int x): x(x) {}			

	int getInt() {			// Верся 1
		return x;
	}
	constexpr int getInt() const {		// Версия 2 помечена constexpr
		return x + 1;	
	}
};

constexpr int f() {
	S s = 10;			
	return s.getInt();			// Вызываем функцию
}	

Здесь будет CE, поскольку выбор версии перегрузки делается независимо от constexpr, компилятор поймёт что ему нужно будет выбрать версию 1, но она не constexpr. Перегружать по constexpr нельзя, поскольку это не часть сигнатуры.

###################################
Если объекты теперь можно создавать в компайл-тайме, так м.б. теперь их можно делать параметрами шаблонов? (Чего ляя) Можно ли так:

template <S s>
class MyClass {
	std::array<int, s.x> a;
};

int main() {
	constexpr S s = 5;
	static_assert(sizeof(MyClass<s>) = 20);	// работает
}

Да, теперь и параметры шаблонов можно делать объектами, при условии что эти объекты можно создавать в компайл-тайме, т.е. что у них конструкторы помечены constexpr. s это компайл-тайм параметр, как будто это просто int. Размер
структуры не увиличивается из-за этого. Можем ли из MyClass вызвать какие-нибудь неконстантные методы s? 

template <S s>
struct MyClass {
	std::array<int, s.x> a;
	int x = s.getInt();
};

int main() {
	constexpr S s = 5;
	constexpr MyClass<s> c{};	// constexpr влечёт const, а мы знаем что константы объязательно должны быть инициализированны, значит нужно написать инициализатор по умолчанию написать
	static_assert(c.x = 6);		// Работает
}


###################################
constexpr наследование

Сейчас продемонстрируем стандартный пример с виртуальностью. Здесь непонятно заранее как тип, он зависимост от того что мы передали в функцию g. Статический тип этого выражения это Base, но в зависимости от параметра, это 
может оказаться либо Base, либо Derived, и в зависимости от этого вернётся 0 или 1. 

struct Base {
	int x = 0;
	constexpr virtual int f() {
		return x;
	}
};

struct Derived: Base {
	constexpr int f() override {
		return x + 1;
	}
};

constexpr int g(int x) {
	Base b
	Derived d;
	Base& bb = d;

	return (x % 2 ? bb : b).f();
}

int main() {
	constexpr int y = g(0);
	constexpr int z = g(1);
	static_assert(y == 0);
	static_assert(z == 1);
}

Это компилируется и работает, другой вопро, что если одна из функций f() constexpr, а другая нет? Может ли не constexpr функция оверрайдить(перегружать) constexpr функцию? Компилятор просто упадёт, как только поймёт что мы попали
в не constexpr версию. Правила virtual и override работают как раньше, и constexpr на них не влияет, просто как только во время вычислений в компайл-тайме реально доходит дело до того, что компилятор попадает в не constexpr функцию,
то это CE.

Хорошо, как вы думаете можно ли делать dynamic_cast в компайл-тайме?

constexpr int g(int x) {
	Base b
	Derived d;
	Base& bb = d;

	Base& b2 = x % 2 ? bb : b;
	dynamic_cast<Derived&>(b2);
}

Да можно. А что будет если dynamic_cast не правильный?

dynamic_cast<Derived&>(b2).x;

Будет CE, dynamic_cast к ссылке не удался: dynamic type 'Base' of its operand does not have a base class of type 'Derived'. Ели бы мы кастили к указателю:

dynamic_cast<Derived*>(&b2)->x;

То тоже CE, и он бы сказал что это разыменование nullptr: dereferencing a null pointer. Это же круто, мы избавляемся от UB в C++ с помощью constexpr. Теперь попробуем такую вещь, можно ли так:

constexpr bool is179prime = [](int n) {
	for (int i = 2; i * i <= n; ++i) {
		if (n % i ==0) return false;
	}
	return n > 1;
}(179);

static_assert(is179prime);

Там создаётся класс, а функция в нём будет constexpr или нет? Да это работает. А что если мы чуть усложним этот пример:

constexpr auto is_prime = [](int n) {
	for (int i = 2; i * i <= n; ++i) {
		if (n % i ==0) return false;
	}
	return n > 1;
};

constexpr bool is179prime = is_prime(179);
static_assert(is179prime);

Можно и так, лямбда выражения считаются constant expression начиная с C++17, поэтому лямбдой можно инициализировать constexpr переменную. Однако если мы в данном случае уберём constexpr и оставим только auto:

auto is_prime = [](int n) {

это всё ровно будет работать. Видимо комилятор по умолчанию делать конструктор лямбды и оператор круглые скобочки constexpr. Раз уж лямбды это constexpr функции, то можно сделать ещё кое-что. Начиная C++20 шаблонным 
праметром может быть auto. И в данном случае Cheker будет такая структура, у которой шаблонным параметром будет лямбда, поскольку лямбда это constant expression.

template <int N, auto f>					// Здесь f Это объект а не тип
struct Checker {
	static_assert(f(N));
	std::array<int, N> a;
};

int main() {
	Checker<5, [](int n) {
		for (int i = 2; i * i <= n; ++i) {
			if (n % i ==0) return false;
		}
		return n != 1;			// Изначально здесь написали >, но компилятор это распарсил как закрите угловой скобки хахаха
	}> c{};
}

Также можно написать requiers вместо static_assert, а ещё интереснее можно навешивать concept на типы, в том числе и на auto:

template <int N, std::invocable<int> auto f>

###################################
new/delete в компайл-тайме

Можно делать new и delete в компайл тайме, начиная с C++20:

constexpr int max(int x, int y) {
	return x > y ? x : y;
}

constexpr bool is_prime(int n) {
	for (int i = 2; i * i <= n; ++i) {
		if (n % i == 0) return false;
	}
	return n > 1;
}

constexpr int count_primes(int n) {
	int* a = new int[n];					// Выделяем память динамически
	std::iota(a, a + n, 0);
	int count = 0;
	for (int* p = a; p < a + n; ++p) {
		count += is_prime(*p);
	}
	delete[] a;
	return count;
}

int main() {
	contexpr int countPrimesTo100 = count_primes(100);
	static_assert(countPrimesTo100 == 25);
}

Вопрос, а что если мы в компайл-тайме допустим утечку памяти? Например сделаем new, и не сделаем delete? Правильный ответ - CE, и это прекрасно, потому что мы теперь можем в компайл тайме ловить утечки памяти. (да ну на это круто).
CE будет с вердиктом: 'count_primes(100)' is not a constant expression because allocated storage has not been deallocated. В том числе разумеется это будет CE если мы сделали например двойной free (удалили дважды), удалили не по нужному
указателю, удалили чуть-чуть со сдвинутом указателем, сделали delete вместо delete[] или наоборот, всё это раньше было UB, а теперь в компайл-тайме CE. А что мы в компайл-тайме запросим слишком много "динамической" памяти? Это всё
ровно что, если сделать слишком большую шаблонную рекурсию, компилятор упадёт, потому что он запросил слишком много памяти для компиляции. Начиная с C++20 компилятор умеет в компайл-тайме имитировать по сути всё что есть в
C++, он умеет имитировать new/delete вызовы и ещё ведёт учёт памяти, правда ли вся память была освобождена корректно? Ну а раз можно делать new/delete в компайл тайме, так почему не научиться создавать std::string и std::vector в
компайл тайме? И это правильная мысль. У std::string и std::vector все конструкторы и методы помечены constexpr начиная с C++20. 


_____________________________________________
Ключевое слово consteval и std::is_constant_evaluated

Начиная с C++20 кроме constexpr есть ещё и consteval. constexpr функции это такие, которые могут быть вызваны в компайл-тайме, но их можно вызывать и в ран-тайме. Но что если мы хотим написать функцию, которую было запрещено
вызывать в рантайме, чтобы любой её вызов гарантированно происходил только в компайл-тайме? В этом нам поможет ключевое слово consteval, функции помеченные consteval нельзя вызывать в ран-тайме.

В C++20 есть функция std::is_constant_evaluated. Она проверяет в каком контексте мы сейчас находимся, в компайл-тайме или нет, эта функция является проверкой, что мы сейчас вычисляемся в компайл тайме или нет. Представим что у нас
есть какая-то constexpr функция, она может быть вызвана как в компайл-тайм, так и в рантайме, но при этом в ран-тайме мы допустим выделяем какие-нибудь огромные массивы или сложные вычисления, а в компайл-тайме мы не можем
себе позволить такое, или напимер они просто не могут быть проделаны, потому что там например не constexpr функциивызываются, тогда мы можем написать if(std::is_constant_evaluated) сделай одно, а иначе сделай другое.

В C++23 std::is_constant_evaluated вообще заменили на if consteva:

constexpr bool is_constant_evaluated() noexcept {
	if(consteval) 				// Мы сейчас в компайл тайме?
		return true;			// Если да
	else 
		return false;			// Если нет
}

Есть очень важное предупреждение относительно std::is_constant_evaluated. Главное что нужно запомнить про std::is_constant_evaluated, это то, что его нужно писать под обычным if, а не под if constexpr. Если мы находимся под if constexpr, 
то std::is_constant_evaluated всегда true, потому что под if constexpr мы всегда находимся в компайл-тайм контексте.