
Работа с файлами. Запись в файл.

Работа с чтением и записью данных из файла и в файлы осуществляется с помощью библиотеки fstream, в которой хранится реализация логики работы с потоками ввода-вывода.
Потоки ввода-вывода это некоторая последовательность байтов, которая либо последовательно списываются, либо последовательно записываются. В этой библиотеке есть три 
основных класса: fstream, ifstream, ofstream.

#include <iostream>
#include <string> // Работа со строками
#include <fstream> // Работа с файлами в стиле C++

using namespace std;


int main()
{
	setlocale(LC_ALL, "Russian");
	string path = "myFile.txt"; //Создаём файл в папке с проектом.
	ofstream fout; //объект класса ofstream, отвечающий за вывод данных в файл.
	fout.open(path); //Открываем (Создаём) файл по пути path
	if (!fout.is_open()) //Если открыть файл не удалось.
		cout << "Ошибка открытия файла!" << endl;
	else {
		fout << "Это наши данные"; //Записываем в файл наши данные.
	}
	fout.close(); //Закрываем файл

	fout.open(path, ofstream::app); //Открываем файл без его очистки
	if (!fout.is_open()) //Если открыть файл не удалось.
		cout << "Ошибка открытия файла!" << endl;
	else {
		fout << "\nЭто новые данные"; //Записываем в файл наши данные.
	}
	fout.close(); //Закрываем файл
	
	return 0;
}


______________________________________________________________________________________
Чтение из файла

int main()
{
	setlocale(LC_ALL, "Russian");
	string path = "myFile.txt"; //Создаём файл в папке с проектом.
	ifstream fin; //объект класса ofstream, отвечающий за вывод данных из файла.
	cout << "Метод 1" << endl;
	fin.open(path); //Открываем файл по пути path
	if (!fin.is_open()) //Если открыть файл не удалось.
		cout << "Ошибка открытия файла!" << endl;
	else {
		cout << "Файл открыт!" << endl;
		//Посимвольное считывание
		char ch;
		while (fin.get(ch))//метод get считывает посимвольно (по одному символу). Если методу get удалось чтото считать то он возвращает true, иначе false.
			cout << ch; //Выводим в консоль считанный символ.
		cout << endl;
	}
	cout << endl;
	fin.close(); //Закрываем файл

	//Считывание до пробела.
	cout << "Метод 2" << endl;
	fin.open(path); //Открываем файл по пути path
	if (!fin.is_open()) //Если открыть файл не удалось.
		cout << "Ошибка открытия файла!" << endl;
	else {
		string str;
		while (!fin.eof()) {//Метод eof отлавливает конец файла. Вернёт true, когда в нашем файле не останется данных.
			str = "";//Удаление старых данных.
			fin >> str; //Извлекаем строки. Оператор >> по умолчанию считывает до первого пробела
			cout << str << endl;
		}
		cout << endl;
	}
	fin.close(); //Закрываем файл

	//Построчное считывание
	cout << "Метод 3" << endl;
	fin.open(path); //Открываем файл по пути path
	if (!fin.is_open()) //Если открыть файл не удалось.
		cout << "Ошибка открытия файла!" << endl;
	else {
		string str;
		while (!fin.eof()) {//Метод eof отлавливает конец файла. Вернёт true, когда в нашем файле не останется данных.
			str = "";//Удаление старых данных.
			getline(fin, str); //Построчное считывание.
			cout << str << endl;
		}
	}
	fin.close(); //Закрываем файл
	return 0;
}


______________________________________________________________________________________
Запись и чтение ОБЪЕКТА КЛАССА в файл

Для сохранения сразу всего объекта нужно использовать метод write(). Он принимает два параметра: тот объект, который нужно сохранить в файл, и размер этого объекта. Первый
парметр это указатель на char. Для этого нужно привести данные, которые мы будем передавать в тип указатель на char. Это нужно для того, чтобы побайтово записать в поток
данные нашего объекта. Второй параметр отвечает за то, сколько всего таких байт будет. 

class Point {
public:
	Point() {
		x = y = z = 0;
	};
	Point(int x, int y, int z) {
		this->x = x;
		this->y = y;
		this->z = z;
	}
	void Print() {
		cout << "x = " << x << "\ty = " << y << "\tz = " << z << endl;
	}
	int x, y, z;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	string path = "myFile.txt";					//Создаём файл в папке с проектом.
	//Запись объекта в файл.
	Point point(34, 154, 3);

	ofstream fout;							//объект класса ofstream, отвечающий за вывод данных в файл.
	fout.open(path, ofstream::app);					//Открываем (Создаём) файл по пути path
	if (!fout.is_open())						//Если открыть файл не удалось.
		cout << "Ошибка открытия файла!" << endl;
	else {
		cout << "Файл открыт" << endl;
		fout.write((char*)&point, sizeof(Point));		//Приводим ссылку на объект к типу указателя на char. Также указываем размер нашего класса.
	}
	fout.close();							//Закрываем файл

	//Чтение объекта из файла.
	ifstream fin;
	fin.open(path);
	if (!fin.is_open())
		cout << "Ошибка открытия файла!" << endl;
	else {
		cout << "Файл открыт" << endl;
		Point pnt; //Создаём с конструктором по умолчанию.
		//Цикл нужен для того, чтобы получить все данные по всем объектам из файла.
		while (fin.read((char*)&pnt, sizeof(Point))) { 		// Чтение из файла в объект pnt. Те же самые параметры что и write(). Если получилось считать файл отправляет true.
			pnt.Print(); 					//Выводим записанные данные
		} 
	}
	fin.close();
	return 0;
}


Коментарий под видосом:
ОЧЕНЬ ВАЖНО:
Способ рабочий только для простейший структур. Если есть хоть одно поле string в структуре, работать не будет. Можно конечно сделать вместо string массив из char, 
но тогда все преимущества строк пропадают.

А каким образом это можно преодолеть?

почитайте что такое JSON или XML

Проблема в том, что в файл сохраняется не поле строчки, а указатель на поле строчки. Естественно, при считывании по том адресу уже этой строчки возможно и нет.

______________________________________________________________________________________
Чтение и запись в файл fstream
Этот класс умеет и читать и записывать данные, в зависимости от параметров.



#include <iostream>
#include <fstream> // Работа с файлами в стиле C++
#include <string> // Работа со строками
#include <Windows.h>//Для русских букв в файле

using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    string path = "myFile.txt";

    fstream fs;
    //Первый параметр - путь к файлу, второй режим открытия файла.
    fs.open(path, fstream::in | fstream::out | fstream::app); //Открыть файл для чтения и записи, при этом предыдущие данные не стираются
    if (!fs.is_open())
        cout << "Ошибка открытия файла" << endl;
    else {
        int value;
        string msg;
        cout << "Файл открыт" << endl;
        cout << "Введите 1 для записи сообщения в файл: " << endl;
        cout << "Введите 2 для считывания всех сообщений из файла: " << endl;
        cin >> value;

        if (value == 1) {
            cout << "Введите Ваше сообщение " << endl;
            SetConsoleCP(1251);                     //Переключение кодировки консоли для отоброжения кириллицы в файле
            cin >> msg;                             //Запись сообщения в строку
            fs << msg << "\n";                      //Запись данных из строки в файл
            SetConsoleCP(866);                      //Возвращаем кодировку консоли по умолчанию
        }
        else {
            cout << "Чтение данных из файла " << endl;
            while (fs.eof()) {
                msg = "";                           //Затираем старые данные временной строки
                fs >> msg;                          //Считываем сообщение в строку
                cout << msg << endl;
            }
        }
    }
    fs.close();

    
    return 0;
}


______________________________________________________________________________________

Потоковый ввод вывод в файл. Перегрузка оператора << и >>

#include <iostream>
#include <fstream> // Работа с файлами в стиле C++
#include <string> // Работа со строками
#include <Windows.h>//Для русских букв в файле

using namespace std;

class Point {							//Наш класс
public:
    Point()
    {
        x = y = z = 0;
    }
    Point(int x, int y, int z)
    {
        this->x = x;
        this->y = y;
        this->z = z;
    }
    int x, y, z;
};

//Перегрузка операторов << и >>
ostream& operator<<(ostream& os, const Point& point) {     	//Возвращает ссылку на объект ostream
    os << point.x << " " << point.y << " " << point.z;
    return os;
}
istream& operator>>(istream& is, Point& point) {            	//Считывание из файла
    is >> point.x >> point.y >> point.z;
    return is;
}

int main()
{
    setlocale(LC_ALL, "Russian");
    Point p(233, 34, 565);
    //cout << p;

    string path = "myFile.txt";
    fstream fs;
    fs.open(path, fstream::in | fstream::out | fstream::app);
    if (!fs.is_open())
        cout << "Ошибка открытия файла" << endl;
    else {
        cout << "Файл окрты" << endl;
        fs << p << "\n";                                    	//Запись объекта в файл

        while (!fs.eof()) {                                 	//Считывание из файла
            Point p2;
            fs >> p2;
            cout << p << endl;
        }
    }
    fs.close();
    
    return 0;
}



































