
Работа с файлами. Запись в файл.

Работа с чтением и записью данных из файла и в файлы осуществляется с помощью библиотеки fstream, в которой хранится реализация логики работы с потоками ввода-вывода.
Потоки ввода-вывода это некоторая последовательность байтов, которая либо последовательно списываются, либо последовательно записываются. В этой библиотеке есть три 
основных класса: fstream, ifstream, ofstream.

#include <iostream>
#include <string> // Работа со строками
#include <fstream> // Работа с файлами в стиле C++

using namespace std;


int main()
{
	setlocale(LC_ALL, "Russian");
	string path = "myFile.txt"; //Создаём файл в папке с проектом.
	ofstream fout; //объект класса ofstream, отвечающий за вывод данных в файл.
	fout.open(path); //Открываем (Создаём) файл по пути path
	if (!fout.is_open()) //Если открыть файл не удалось.
		cout << "Ошибка открытия файла!" << endl;
	else {
		fout << "Это наши данные"; //Записываем в файл наши данные.
	}
	fout.close(); //Закрываем файл

	fout.open(path, ofstream::app); //Открываем файл без его очистки
	if (!fout.is_open()) //Если открыть файл не удалось.
		cout << "Ошибка открытия файла!" << endl;
	else {
		fout << "\nЭто новые данные"; //Записываем в файл наши данные.
	}
	fout.close(); //Закрываем файл
	
	return 0;
}


______________________________________________________________________________________
Чтение из файла

int main()
{
	setlocale(LC_ALL, "Russian");
	string path = "myFile.txt"; //Создаём файл в папке с проектом.
	ifstream fin; //объект класса ofstream, отвечающий за вывод данных из файла.
	cout << "Метод 1" << endl;
	fin.open(path); //Открываем файл по пути path
	if (!fin.is_open()) //Если открыть файл не удалось.
		cout << "Ошибка открытия файла!" << endl;
	else {
		cout << "Файл открыт!" << endl;
		//Посимвольное считывание
		char ch;
		while (fin.get(ch))//метод get считывает посимвольно (по одному символу). Если методу get удалось чтото считать то он возвращает true, иначе false.
			cout << ch; //Выводим в консоль считанный символ.
		cout << endl;
	}
	cout << endl;
	fin.close(); //Закрываем файл

	//Считывание до пробела.
	cout << "Метод 2" << endl;
	fin.open(path); //Открываем файл по пути path
	if (!fin.is_open()) //Если открыть файл не удалось.
		cout << "Ошибка открытия файла!" << endl;
	else {
		string str;
		while (!fin.eof()) {//Метод eof отлавливает конец файла. Вернёт true, когда в нашем файле не останется данных.
			str = "";//Удаление старых данных.
			fin >> str; //Извлекаем строки. Оператор >> по умолчанию считывает до первого пробела
			cout << str << endl;
		}
		cout << endl;
	}
	fin.close(); //Закрываем файл

	//Построчное считывание
	cout << "Метод 3" << endl;
	fin.open(path); //Открываем файл по пути path
	if (!fin.is_open()) //Если открыть файл не удалось.
		cout << "Ошибка открытия файла!" << endl;
	else {
		string str;
		while (!fin.eof()) {//Метод eof отлавливает конец файла. Вернёт true, когда в нашем файле не останется данных.
			str = "";//Удаление старых данных.
			getline(fin, str); //Построчное считывание.
			cout << str << endl;
		}
	}
	fin.close(); //Закрываем файл
	return 0;
}


______________________________________________________________________________________
Запись и чтение ОБЪЕКТА КЛАССА в файл

Для сохранения сразу всего объекта нужно использовать метод write(). Он принимает два параметра: тот объект, который нужно сохранить в файл, и размер этого объекта. Первый
парметр это указатель на char. Для этого нужно привести данные, которые мы будем передавать в тип указатель на char. Это нужно для того, чтобы побайтово записать в поток
данные нашего объекта. Второй параметр отвечает за то, сколько всего таких байт будет. 

class Point {
public:
	Point() {
		x = y = z = 0;
	};
	Point(int x, int y, int z) {
		this->x = x;
		this->y = y;
		this->z = z;
	}
	void Print() {
		cout << "x = " << x << "\ty = " << y << "\tz = " << z << endl;
	}
	int x, y, z;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	string path = "myFile.txt";					//Создаём файл в папке с проектом.
	//Запись объекта в файл.
	Point point(34, 154, 3);

	ofstream fout;							//объект класса ofstream, отвечающий за вывод данных в файл.
	fout.open(path, ofstream::app);					//Открываем (Создаём) файл по пути path
	if (!fout.is_open())						//Если открыть файл не удалось.
		cout << "Ошибка открытия файла!" << endl;
	else {
		cout << "Файл открыт" << endl;
		fout.write((char*)&point, sizeof(Point));		//Приводим ссылку на объект к типу указателя на char. Также указываем размер нашего класса.
	}
	fout.close();							//Закрываем файл

	//Чтение объекта из файла.
	ifstream fin;
	fin.open(path);
	if (!fin.is_open())
		cout << "Ошибка открытия файла!" << endl;
	else {
		cout << "Файл открыт" << endl;
		Point pnt; //Создаём с конструктором по умолчанию.
		//Цикл нужен для того, чтобы получить все данные по всем объектам из файла.
		while (fin.read((char*)&pnt, sizeof(Point))) { 		// Чтение из файла в объект pnt. Те же самые параметры что и write(). Если получилось считать файл отправляет true.
			pnt.Print(); 					//Выводим записанные данные
		} 
	}
	fin.close();
	return 0;
}


Коментарий под видосом:
ОЧЕНЬ ВАЖНО:
Способ рабочий только для простейший структур. Если есть хоть одно поле string в структуре, работать не будет. Можно конечно сделать вместо string массив из char, 
но тогда все преимущества строк пропадают.

А каким образом это можно преодолеть?

почитайте что такое JSON или XML

Проблема в том, что в файл сохраняется не поле строчки, а указатель на поле строчки. Естественно, при считывании по том адресу уже этой строчки возможно и нет.

______________________________________________________________________________________
Чтение и запись в файл fstream
Этот класс умеет и читать и записывать данные, в зависимости от параметров.



#include <iostream>
#include <fstream> // Работа с файлами в стиле C++
#include <string> // Работа со строками
#include <Windows.h>//Для русских букв в файле

using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    string path = "myFile.txt";

    fstream fs;
    //Первый параметр - путь к файлу, второй режим открытия файла.
    fs.open(path, fstream::in | fstream::out | fstream::app); //Открыть файл для чтения и записи, при этом предыдущие данные не стираются
    if (!fs.is_open())
        cout << "Ошибка открытия файла" << endl;
    else {
        int value;
        string msg;
        cout << "Файл открыт" << endl;
        cout << "Введите 1 для записи сообщения в файл: " << endl;
        cout << "Введите 2 для считывания всех сообщений из файла: " << endl;
        cin >> value;

        if (value == 1) {
            cout << "Введите Ваше сообщение " << endl;
            SetConsoleCP(1251);                     //Переключение кодировки консоли для отоброжения кириллицы в файле
            cin >> msg;                             //Запись сообщения в строку
            fs << msg << "\n";                      //Запись данных из строки в файл
            SetConsoleCP(866);                      //Возвращаем кодировку консоли по умолчанию
        }
        else {
            cout << "Чтение данных из файла " << endl;
            while (fs.eof()) {
                msg = "";                           //Затираем старые данные временной строки
                fs >> msg;                          //Считываем сообщение в строку
                cout << msg << endl;
            }
        }
    }
    fs.close();

    
    return 0;
}


______________________________________________________________________________________

Потоковый ввод вывод в файл. Перегрузка оператора << и >>

#include <iostream>
#include <fstream> // Работа с файлами в стиле C++
#include <string> // Работа со строками
#include <Windows.h>//Для русских букв в файле

using namespace std;

class Point {							//Наш класс
public:
    Point()
    {
        x = y = z = 0;
    }
    Point(int x, int y, int z)
    {
        this->x = x;
        this->y = y;
        this->z = z;
    }
    int x, y, z;
};

//Перегрузка операторов << и >>
ostream& operator<<(ostream& os, const Point& point) {     	//Возвращает ссылку на объект ostream
    os << point.x << " " << point.y << " " << point.z;
    return os;
}
istream& operator>>(istream& is, Point& point) {            	//Считывание из файла
    is >> point.x >> point.y >> point.z;
    return is;
}

int main()
{
    setlocale(LC_ALL, "Russian");
    Point p(233, 34, 565);
    //cout << p;

    string path = "myFile.txt";
    fstream fs;
    fs.open(path, fstream::in | fstream::out | fstream::app);
    if (!fs.is_open())
        cout << "Ошибка открытия файла" << endl;
    else {
        cout << "Файл окрты" << endl;
        fs << p << "\n";                                    	//Запись объекта в файл

        while (!fs.eof()) {                                 	//Считывание из файла
            Point p2;
            fs >> p2;
            cout << p << endl;
        }
    }
    fs.close();
    
    return 0;
}


______________________________________________________________________________________
Потоки Streams

###################
Буферизация

std::cin, std::cout, std::cerr это некоторые объекты, которые являются потоками.

Когда мы чтото выводим в cout, оно не сразу выводится, т.е. программа в этот момент не приостанавливается, и не дожидается пока текст появиться в консоли. cout это объект, который в 
себе хранит некоторый буфер(массив) символов(чаров), который он собирается вывести, но он выводит их не сразу, как только мы в него пихнули эти символы. И когда мы говорим в cout 
оператор вывода (cout <<) он просто записывает в этот момент массив нескольких чаров, и реально выводит их на консоль тогда, когда у него буфер заполнится. Дело в том, что выводить
что либо на консоль это долгая операция, как и вызывать оператор new. Стандартная библиотека написана так, чтобы к ОС обращаться пореже. И поэтому когда мы чтото записываем в cout, 
он это выводит не сразу, а сначала записывает это в свой массив, и когда этот массив переполняется тогда он уже выводит в консоль. Но если например у нас случилось падение программы
до того как мы успели очистить этот буфер, то мы потеряем эти данные.

int main() {
	std::cout << 123;	
	assert(false);		// Падение программы. 123 не успеет вывестись на консоль.
}

Для того, чтобы информация точно успела вывестись, следует очищать буфер. Для очистки буфера есть 2 способа:

1) Явно написать std::cout.flush(); // Очистить буфер

int main() {
	std::cout << 123;
	std::cout.flush();	// Очистка буфера. Теперь 123 успеет вывестись на консоль.
	assert(false);		// Падение программы. 
}

Однако flush() это долгая операция, во время её выполнения программа замирает, дожидаясь очистки буфера. Делать flush() после каждого вывода в буфер, это будет сильное замедление
работы. 

2) std::endl; Можно сделать flush() неявно, а именно можно вывести в cout специальный символ, который в числе прочего ведёт flush буфера. Для этого используется std::endl. 
std::endl это такой специальны объект, который будучи выведеным в cout, не просто выводить \n, а ещё и делает flush().


################################
Связывание потоков.

Представим такую программу:

int main() {
	int x;
	std::cout << 123;
	std::cin >> x;
	std::cout << x + 5;
}

Вывод в консоль 123
Я ввожу		11
Вывод в консоль 16

Если знать о буферизации, то совершенно непонятно почему 123 вывелось до того как мы попали в std::cin >> x и он начал ввод от пользователя. На самом деле, между тем как сделаны
cout << 123 и cin >> x тоже происходит flush(). По умолчанию cout и cin связаны. Объект cout хранит в себе не только буфер, а ещё и указатель на cin, а cin хранит в себе указатель на
cout. Это сделано для того, чтобы когда мы в cin чтото хотим ввести, первым делом он делал flush() cout, который он помнит. Это нужно для того, чтобы не получилось так, cout ещё не
успел вывести, а мы уже начали cin. По умолчанию потоки связаны, но можно их отвязать друг от друга. Это приводит к тому, что у нас ввод вывод начинает работать быстрее, если мы
независимо делаем ввод вывод из разных источников.
	
std::cin.tie(nullptr);	// Отвязать потоки
std::cout.tie(nullptr);


Ещё по умолчанию cin cout синхронизированы со стандартными сишными потоками ввода вывода printf scanf. printf и scanf тоже буферизованы, у них свой буфер, и по умолчанию 
cin cout реализованы так, что если мы попеременно пользовались то ptintf то cout, оно бы отображалось корректно и выводилось в том порядке в котором было написано.
Это можно отключить:

std::cin.sync_with_stdio(fasle);
std::cout.sync_with_stdio(fasle);


################################
cin cout это глобальные переменные. У них есть тип std::istream и std::ostream соответственно. Как и любые глобальные переменные они создаются до main, а деструкторы их вызываются
после main. 

Гарантируется ли мне что всё будет корректно?

#include <iostream>

struct A {
	A() {std::cout << "A";}
};

A a;				// Глобальная область видимости

Да гарантируется поскольку iostream инклюдится выше чем присходит создание a. Получается cin cout создадутся до того, как создастся a, и к этому моменту уже можно будет пользоваться 
cin cout. Уничтожутся они в обратном порядке, поэтому в деструкторе мы тоже можем пользоваться cin cout. 


________________________________
Файловые и строковые потоки

С помощью файловых потоков ifstream (fail stream) мы можем открывать файлы писать и читать их.

std::ifstream in("input.txt");	// Читаем из файла
std::ofstream // Вывод в файл

Строковый поток sstream (string stream)
Допустим у нас есть код, который вводит и выводит чтото в поток. Нам нужно протестировать как он это делает. Проще всего сделать строку, в которую просто записать последовательность
того, что мы хотим на вход отдать. А дельше мы просто создаём sstream от этой строки.

int main() {
	std::strint str("1 2 3 4 5");
	std::iStringStream iss(str);
	
	int x;
	iss >> x;
	std::cout << x + 5;
}

Это будет быстрее чем cin, поскольку sstream никак не нужно будет взаимодействовать с ОС, в отличие от cin.

osstream это аналог cout для строки.



________________________________
Потоковые итераторы (stream iterators)

Можно заводить итераторы на потоки: std::istream_iterator и std::ostream_iterator

При инкрементировании такого итератора, он будет считывать следующее значение из потока. Т.е. итератор позволяет делать вид что я инкрементирую итератор, но на самом деле при этом
происходит ввод из потока.

#include <iterator>
#include <vector>

int main() {
	std::istream_iterator<int> it(std::cin); // Итератор на поток ввода
	std::vector<int> v;			

	for(int i = 0; i < 5; ++i, ++it) {
		v.push_back(*it);
	} 

	for(int i = 0; i < v.size(); ++i) {
		std::cout << v[i] << std::endl;
	}
}


##########################
Реализуем istream_iterator:

template <typename T>	
class istream_iterator {
	std::istream* in = nullptr;	// Указатель на поток
	T value; 			// Текущее значение. 
public:
	// Для работы с std::copy
	using iterator_categoty = std::input_iterator_tag;	
	using pointer = T*;
	using value_type = T;
	using reference = T&;
	using difference_type = int;

	istream_iterator(std::istream& in) : in(&in) {
		in >> value;				// Это не скомпилируется если у T не будет значения по умолчанию.
	}
	istream_iterator() {}				// Конструктор по умолчанию
	istream_iterator& operator++() {
		if(!*in >> value)		// Если в потоке ещё есть что считывать, то мы считываем, а если он закончился, то мы себе присваиваем istream_iterator по умолчанию.
			*this = istream_iterator;
		return *this;
	}
	T& operator*() {
		return value;
	}
};

Это пример инпут но не форвард итератора. Эти итераторы различаются.

Ввод из потока в вектор можно сделать по другому: Мы можем с помощью std::copy считать элементы для вектора из потока. Однако в std::copy нам нужно передать диапазон и нам нужно 
понять какой итератор будет концом диапазона? Поток работает так, если в нём не осталось элементов, то итератор будет приведён в состояние по умолчанию. Соответсвенно концом 
диапазона нужно сделать итератор по умолчанию.

std::istream_iterator<int> it(std::cin); 		// Итератор на поток ввода
std::vector<int> v(10);

std::copy(it, std::istream_iterator<int>(), v.begin());	// Считывание до конца потока
std::copy_n(it, 10, v.begin()) 				// Считывание только 10 char из потока (since C++11)


######################
std::back_inserter
Самый козырный способ читать вектор из cin

Т.е. мы не хотим заранее знать сколько будет элементов в векторе, мы просто считываем из потока, пока поток не кончился.

int main() {
	std::istream_iterator<int> it(std::cin); // Итератор на поток ввода
	std::vector<int> v;			

	std::copy(it, std::istream_iterator<int>(), std::back_inserter(v));

	for(int i = 0; i < v.size(); ++i) {
		std::cout << v[i] << std::endl;
	}
}


Однако вектор можно сконструировать от пары инпут итераторов. Т.е. на самом деле можно просто сказать что мы создаём вектор от итератора it, а также от итератора по умолчанию
std::istream_iterator<int>():

std::istream_iterator<int> it(std::cin); // Итератор на поток ввода
std::vector<int> v(it, std::istream_iterator<int>());



##################################
std::ostream_iterator

Это аутпут итератор на поток

Мы можем сделать std::copy не в вектор а в поток или файл:

std::ifstream in("input.txt");
std::istream_iterator<int> it(in); // Итератор на поток ввода

std::copy(it, std::istream_iterator<int>(), std::ostream_iterator<int>(std::cout));

Вывод в файл будет без пробелов: 12345
Чтобы добавить разделитель между символами нужно добавить его в ostream_iterator:

std::copy(it, std::istream_iterator<int>(), std::ostream_iterator<int>(std::cout, " "));


std::ostream_iterator реализован примерно как back_insert_iterator


______________________________________________________________________________________
Манипуляторы потоков (stream_manipulators)

Манипуляторы это специальные функции, которые если вводишь в поток то поток меняет свой стейт.

Примеры:

std::cout << std::hex;

std::hex - это объект, который будучи выведен в cout, меняет его стейт. Он ничего не выводит. После этого cout начинает выводить числа в 16-иричном формате.

int x = 123;
std::cout << x;

Вывод: 7b

Ещё полезные манипуляторы:
set_presition - с каким кол-во цифр выводить double
std::cin >> std::noskipws; - не пропускать пробелы в cin. Это работает на char но не на string 



______________________________________________________________________________________
std::filesystem (C++17)

std::filesystem — это стандартная библиотека C++17 для работы с файлами, директориями и путями в кросс-платформенном стиле. До C++17 для этого использовали либо платформо-зависимый код (Windows API, POSIX), 
либо Boost.Filesystem. Теперь всё в std — просто, безопасно и единообразно.

Библиотека живёт в заголовке <filesystem> и в namespace std::filesystem.

Зачем это нужно?
- Чтение/запись файлов, создание/удаление директорий.
- Рекурсивный обход папок.
- Получение информации: размер файла, дата изменения, права доступа.
- Нормализация и манипуляции с путями (разделение на компоненты, расширение и т.д.).


###
Основные типы и концепции
- std::filesystem::path — основной класс для представления путей. Работает с строками, автоматически обрабатывает слеши (/ или \ в зависимости от ОС).
- std::filesystem::directory_entry — элемент в директории (файл или папка).
- std::filesystem::file_status — информация о типе и правах.


###
Базовые примеры

#include <filesystem>
#include <iostream>

namespace fs = std::filesystem;  						// удобный алиас

int main() {
    // 1. Работа с путями
    fs::path p = "folder/subfolder/file.txt";

    std::cout << "Полный путь: " << p << '\n';
    std::cout << "Родительская папка: " << p.parent_path() << '\n';           	// folder/subfolder
    std::cout << "Имя файла: " << p.filename() << '\n';                       	// file.txt
    std::cout << "Расширение: " << p.extension() << '\n';                     	// .txt
    std::cout << "Без расширения: " << p.stem() << '\n';                       	// file

    // Конкатенация путей (безопасно)
    fs::path new_path = p.parent_path() / "new_file.png";
    std::cout << "Новый путь: " << new_path << '\n';

    // 2. Проверка существования и типа
    if (fs::exists(p)) {
        if (fs::is_regular_file(p)) {
            std::cout << p << " — обычный файл, размер: "
                      << fs::file_size(p) << " байт\n";
        } else if (fs::is_directory(p)) {
            std::cout << p << " — директория\n";
        }
    }

    // 3. Информация о файле
    auto last_write = fs::last_write_time(p);
    // last_write — file_time_type, можно конвертировать в time_t (C++20 проще)
}


###
Операции с файловой системой

// Создание директорий
fs::create_directory("new_folder");
fs::create_directories("parent/child/grandchild");  			// рекурсивно

// Копирование, перемещение, удаление
fs::copy("source.txt", "destination.txt");
fs::copy("source_dir", "dest_dir", fs::copy_options::recursive);  	// рекурсивно

fs::rename("old_name.txt", "new_name.txt");
fs::remove("file.txt");                    				// удаляет файл
fs::remove_all("folder");                  				// рекурсивно удаляет всё внутри

// Размер
uintmax_t size = fs::file_size("big_file.bin");

// Временные файлы
fs::path temp = fs::temp_directory_path() / "my_temp.txt";


###
Обход директорий (самое полезное в реальной работе)

// Простой обход (не рекурсивный)
for (const auto& entry : fs::directory_iterator("my_folder")) {
    std::cout << entry.path() << " — размер: ";
    if (entry.is_regular_file()) {
        std::cout << entry.file_size() << " байт\n";
    } else {
        std::cout << "<директория>\n";
    }
}

// Рекурсивный обход
for (const auto& entry : fs::recursive_directory_iterator("project")) {
    std::cout << entry.path() << '\n';
    
    // Можно фильтровать
    if (entry.is_regular_file() && entry.path().extension() == ".cpp") {
        std::cout << "  <- C++ файл\n";
    }
}


###
Обработка ошибок

Большинство функций имеют два варианта:
- Бросают filesystem_error при проблеме.
- Версии с суффиксом _error_code принимают std::error_code& и не бросают.

std::error_code ec;
fs::remove("file.txt", ec);  // не бросит исключение
if (ec) {
    std::cout << "Ошибка удаления: " << ec.message() << '\n';
}


###
Полезные практические примеры
1) Найти все .txt файлы рекурсивно

void find_txt(const fs::path& root) {
    for (const auto& entry : fs::recursive_directory_iterator(root)) {
        if (entry.is_regular_file() && entry.path().extension() == ".txt") {
            std::cout << entry.path() << '\n';
        }
    }
}


2) Вычислить размер директории

uintmax_t dir_size(const fs::path& dir) {
    uintmax_t total = 0;
    for (const auto& entry : fs::recursive_directory_iterator(dir)) {
        if (entry.is_regular_file()) {
            total += entry.file_size();
        }
    }
    return total;
}

В реальных проектах она используется постоянно: логгеры, конфиги, сборщики, инсталляторы, парсеры данных — везде, где нужно взаимодействовать с файлами.



______________________________________________________________________________________


