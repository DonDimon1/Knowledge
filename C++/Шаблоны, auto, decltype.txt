Шаблоны в C++ — это мощная функция, позволяющая писать общий код, то есть вы можете написать одну функцию или класс, которые могут работать с разными типами данных. Это означает, что 
вам не нужно писать отдельные функции или классы для каждого типа данных, с которым вы хотите работать.

______________________________________________________________________________________
Идея шаблонов и базовые примеры

template <typename T> и template <class T> это одно и тоже кроме возможно одного заковырестого случая. По кодстайлу шаблонные параметры называть с большой буквы.

1) Шаблон функции:

Чтобы создать функцию шаблона, вы используете ключевое слово template, за которым следуют параметры типа или заполнители, заключенные в угловые скобки <>. Затем вы определяете свою
функцию, как обычно, используя параметры типа для указания универсальных типов.

template <typename T>
void swap(T& x, T& y){
	T t = x;
	x = y;
	y = t;
}


Вот пример простой шаблонной функции, которая принимает два аргумента и возвращает больший из двух:

template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

Чтобы использовать эту функцию, вы можете явно указать параметр типа:

int result = max<int>(10, 20);

Или вы можете позволить компилятору определить тип за вас:

int result = max(10, 20);



2) Шаблонный класс:

template <typename T>
class vector {
   	T* arr;
	size_t sz;
	size_t cap;
};

Аналогичным образом вы можете создавать классы шаблонов, используя ключевое слово template. Вот пример простого класса шаблона, который представляет пару значений:

template <typename T1, typename T2>
class Pair {
public:
    T1 first;
    T2 second;

    Pair(T1 first, T2 second) : first(first), second(second) {}
};

Чтобы использовать этот класс, вам необходимо указать параметры типа при создании объекта:

Pair<int, std::string> pair(1, "Hello");



3) Шаблонный using (C++11)
Например у нас есть очень длинный тип, и мы хотим для любого T определить алиас этоготипа (другое название).

template <typename T>
using mymap = std::map<T, T, std::greater<T>>; 	// std::greater - компоратор, который сравнивает на больше
mymap<T> m;


4) Шаблонные переменные (C++14)
Для произвольного типа T можно определить переменную или константу, которая для разных T будет значить разное.


##################################
При указании разных типов будет CE
template <typename T>
void swap(T& x, T& y){
	T t = x;
	x = y;
	y = t;
}

int main() {
	int a = 0;	
	long b = 1;
	swap(a, b); // CE, компилятор не понимает что в качестве T int, или long?
}


Тут не применяется правило что типо конверсия long в int хуже чем конверсия int в long. Сначала компилятору нужно решить для каких T ему сгенирировать версию swap, для разных
типов код асемблера будет разный. 

Шаблоны это кодогенерация, нужно воспринимать шаблоны не как готовый код, а как такой паттерн, по которому компилятор должен сгенирировать код. Т.е. функция swap это не 
реальный код, а паттерн по которому компилятор в дальнейшем будет генирировать код для разных типов T. То для каких T компилятору сгенирировать swap, это вопрос первой 
стадии компиляции, которая выполняется до всех, которые мы обсуждали ранее, до перегрузки, до выбора имён (т.е. это не препроцессинг). 

Можно подсказать компилятору какую версию генирировать, указав шаблонный аргумент T явно:

template <typename T>
void swap(T x, T y){
	T t = x;
	x = y;
	y = t;
}

int a = 0;
long long b = 1;
swap<long long>(a, b);


Когда мы имеем дело с классами, нам обычно нужно явно указывать шаблонный аргумент, например: vector<int> v, в качестве T мы ставим int. Для всякого T генирируется свой
класс. Если мы сделаем 5 векторов например от int, double, char, float, string, это всё 5 разных классов, компилятор просто накопипастит код вектора 5 раз. 


______________________________________________________
Перегрузка шаблонных функций

template <typename T>	// У нас есть шаблонная функция
void f(T x){}

void f(int x) {}	// А также её перегрузка с типом int

int main() {
	int x = 0;
	f(x);		// Что выберется? 
}

Ответ: выберется вторая версия с типом int. Почему мы хотим, чтобы это работало именно так? Здесь работает правило частоное лучше общего. Если у нас есть инструкция как 
действовать в общем случае, а ещё есть частная инструкция, которая говорит что если случай конкретный действуй иначе, то предпочитается частная инструкция.


На самом деле, генерация шаблонных версий делается не полностью до выбора версии. Если у нас есть выбор между шаблонной версией и нешаблонной, то это решение компилятору 
нужно принять раньше, до того как он начнёт генирировать шаблонную версию. Компилятор понимает что под этот вызов f подходит как шаблонная версия, и он может сгенирировать
T = int, и подходит нешаблонная и он может ничего не генирировать, и просто выбрать версию от int, тогда он предпочтёт второй вариант. Но если частная версия не так хорошо
подходит как общая, то он предпочтёт общую версию T = int.

Есть два правила как действует компилятор:
1) частоное лучше общего
2) но несмотря на это точное соответствие лучше, чем какой нибудь каст.

Т.е. если компилятор способен сгенирировать шаблонную версию так, что там будет идеальное соответсвтие типа, то это лучше чем выбрать частную версию но сделать хоть какое
привидение типа.

template <typename T>	
void f(T x){
	std::cout << 1;
}

void f(long long x) {
	std::cout << 2;
}	

int main() {
	int x = 0;
	f(x);		// Сейчас выберется 1.
}



##########################################
Мы можем указать шаблонный параметр явно:

template <typename T>	
void f(T x){
	std::cout << 1;
}

void f(int x) {
	std::cout << 2;
}	

int main() {
	int x = 0;
	f<int>(x);		// Сейчас выберется 1.
}

Если я явно указываю шаблонный параметр, тем самым я обязываю компилятор выбрать какую то шаблонную версию, даже если есть частная перегрузка с нужным типом.



#################################################
Можем указывать шаблонный аргумент по умолчанию:

template <typename T = int>	
void f(T x){
	std::cout << 1;
}

У нас может быть шаблонный аргумент, который если явно не указан, то компилятор должен подставить конкретный (в нашем случае int).

По переданным аргументам в функцию компилятор иногда может сам понять, что за тип ему передали без явного указания. Когда я указываю шаблонные аргументы при вызове функции, 
я могу указывать не все, он применяет только те, которые я указал первые по списку, а остальные пытается вывести сам.
Например:

template <typename U, typename T>	
U f(T x){
	std::cout << 1;
	return x;
}

void f(int x) {
	std::cout << 2;
}

int main() {
	int x = 0;
	int g = f<int>(x);	// Говорим что <int> это тип U, а x с типом int это тип T x в функции f.
}

Мы указываем что в функции f typename U это тип int, т.е. в функции f возвращаемый тип это int. Какой тип T он должен угадать сам, и он сможет догадаться, поскольку T это 
переданный аргумент, с уже заданным типом. Но вот если мы поменяем U и T местами, тогда это уже CE, поскольку он не может догадаться какой теперь возвращаемый тип:

template <typename T, typename U>	
U f(T x){				// U непонятно какой тип
	std::cout << 1;
	return x;
}

void f(int x) {
	std::cout << 2;
}

int main() {
	int x = 0;
	int g = f<int>(x);		// CE
}



########################
 1) Какая функция вызовется?

template <typename T>
void f(T& x) {		// Аргумент по ссылке
	std::cout << 1;
}


template <typename T>
void f(T x) {		// Аргумент по значению
	std::cout << 2;
}

int main() {
	int x = 0;
	f(x);		// Вызываем функцию от int x = 0;
}


Ответ: Будет CE, call of overloaded f(int&) is ambiguous.

 2) А вот если мы вызовем функцию с rvalue, то тогда выберется второй вариант.

int main() {
	int x = 0;
	f(1);		// Вывод в консоль 2.
}


 3) А если мы вызовем функцию с константой, тогда будет CE, обе версии одинаково подходят:

template <typename T>
void f(const T& x) {		// Константный аргумент по ссылке
	std::cout << 1;
}

template <typename T>
void f(T x) {			// Аргумент по значению
	std::cout << 2;
}

int main() {
	int x = 0;
	f(1);			// CE
}


 4) Можно принять 1 как в качестве константной ссылки, так и в качестве просто значения, и одно не лучше другого. Анологично CE и в следующем примере:

template <typename T>
void f(const T& x) {		// Константный аргумент по ссылке
	std::cout << 1;
}


template <typename T>
void f(T& x) {			// Аргумент по значению
	std::cout << 2;
}

int main() {
	f(1);			// CE
}


______________________________________________________________________________________
Специализация шаблонов классов Template specializations.

Иногда вам может потребоваться особое поведение для определенного типа данных. В этом случае вы можете использовать специализацию шаблона. Это может быть полезно, если вы хотите 
оптимизировать поведение или предоставить конкретную реализацию для определенного типа, не влияя на общее поведение шаблона для других типов.

Представим что мы реализуем шаблонный класс (например вектор). Всё хорошо, но мы хотим чтобы для какого то конкретного T этот класс был не таким, как для всех остальных,
например чтобы вектор bool был не таким как всё остальное, а именно чтобы вектор bool хранил не массив bool, а массив char, но при этом в нём когда мы записываем элемент,
он менял соответствующий бит в массиве, а не целый байт. Мы можем это добиться путём специализации шаблона.


Существует два основных способа специализации шаблона:

1) Полная специализация. Это происходит, когда вы предоставляете конкретную реализацию для определенного типа или набора типов.

2) Частичная специализация. Это происходит, когда вы предоставляете более общую реализацию для подмножества типов, соответствующих определенному шаблону или условию.


#####################################
Полная специализация класса (Full specializations):

Полная специализация шаблона позволяет предоставить конкретную реализацию или поведение шаблона при использовании с определенным набором параметров типа.

Чтобы создать полную специализацию шаблона, вам необходимо определить конкретный тип, для которого должна произойти специализация. Синтаксис выглядит следующим образом:

template <> 			//Indicates that this is a specialization
className<specificType>

Пример 1):

template <typename T>						// Общий шаблонный класс
class MyContainer {
public:
    void print() {
        std::cout << "Generic container." << std::endl;
    }
};

template <>							// Полная специализация класса для типа int
class MyContainer<int> {
public:
    void print() {
        std::cout << "Container for integers." << std::endl;
    }
};

int main() {
    MyContainer<double> d;
    MyContainer<int> i;

    d.print(); // Output: Generic container.
    i.print(); // Output: Container for integers.

    return 0;
}

В этом примере мы определили общий MyContainer класс шаблона вместе с полной специализацией для int типа. Когда мы используем контейнер с типом, вызывается метод int 
специализированной реализации. print Для других типов будет использоваться реализация общего шаблона.

Пример 2):

template <typename T>	// Общий шаблонный класс
class vector {
	T* arr;
	size sz;
	size_t cap;
};

template <>		// Полная специализация класса 
class vector<bool> {
	char* arr;
	size_t sz;
	size_t cap;
}

Т.е. для каких то типов, в нашем случае bool, делаем класс иным, нежели для всех остальных типов.
В угловых скобочках я перечисляю фиксированные аргументы. Они могут быть не конкретными. Т.е. у нас могут быть шаблон от двух аргументов, и мы можем отдельно определить
шаблон от одного аргумента, если эти аргументы одинаковые.



#####################################
Частичная специализация (Partial specialization):

Частичная специализация шаблона — это концепция шаблонов C++, которая позволяет специализировать шаблон для подмножества его возможных аргументов типа. Это особенно полезно, когда вы 
хотите предоставить индивидуальную реализацию для определенной группы типов без необходимости определять отдельные специализации для всех типов в этой группе.

Частичная специализация шаблона достигается путем предоставления специализации шаблона с новым набором параметров шаблона. Этот новый шаблон будет выбран, когда компилятор определит 
типы, соответствующие частичной специализации.

Пример 1) Вот пример кода, демонстрирующий частичную специализацию шаблона:

template <typename T>					// Primary template
struct MyTemplate {
    static const char* name() {
        return "General case";
    }
};


template <typename T>					// Partial specialization for pointers
struct MyTemplate<T*> {
    static const char* name() {
        return "Partial specialization for pointers";
    }
};

template <>						// Full specialization for int
struct MyTemplate<int> {
    static const char* name() {
        return "Full specialization for int";
    }
};

int main() {
    MyTemplate<double> t1; 				// General case
    MyTemplate<double*> t2; 				// Partial specialization for pointers
    MyTemplate<int> t3; 				// Full specialization for int

    std::cout << t1.name() << std::endl;
    std::cout << t2.name() << std::endl;
    std::cout << t3.name() << std::endl;

    return 0;
}

В приведенном выше примере мы определили основной шаблон MyTemplate с одним параметром типа T. Затем мы предоставляем частичную специализацию шаблона для типов указателей, указав 
MyTemplate<T*>. Это означает, что частичная специализация будет выбрана, когда аргумент типа является типом указателя. Наконец, мы обеспечиваем полную специализацию типа, int указав 
MyTemplate<int>. Это будет выбрано, если аргумент типа равен int.


Пример 2):

template <typename T, typename U>	// Общий вариант
struct S {};

// Частичная специализация 
template <typename T>			// В этом префиксе шаблонов я перечисляю те аргументы, которые мне здесь пригодятся для объяснения того, какую специализацию я хочу объявить.
struct S<T, T> {};			// Здесь в <> я описываю метасигнатуру, которая является частным случаем класса выше.

В данном случае мы видим пример частичной специализации. Для любых T и U, S определена общим вариантом, но для любого T, если первый аргумент равен второму, S определена иначе.
Можно написать по разному, например:

template <typename T>	
struct S<int, T> {};	// Для любого T структура с первым аргументом int, определена иначе



Мы можем сделать несколько частичных специализаций:

template <typename T, typename U>	
struct S {};

template <typename T>
struct S <int, T>{};

template <typename T>
struct S <T, int>{};

int main() {
	S<int, int> s;	// CE, ambigous template instantiation (неоднозначаное инстанцированние шаблона)
}

Инстанцированние - это начальная генерации шаблона. 

Компилятору непонятно int подставить в качестве первого аргумента подставить, или в качестве второго. Однако если бы мы имели полную специализацию, без каких либо параметров 
просто от двух int, то компилятор бы предпочёл её:

template <>
struct S <int, int>{};


Так же частичную специализацию можно написать вот так:

template <typename T>	// Обычная версия
struct S {};

template <typename T>	// Для всех типов, являющиеся ссылками сделаем свою версию.
struct S<T&> {};

template <typename T>	// От константного T это третья версия
struct S<const T> {};



#############
Итог:

Полная специализация, это когда template <> мы пишем с пустыми угловыми скобочками, тем самым мы говорим что мы хотим определить частный случай этого шаблона для некоторых
конкретных наборов аргументов, без использования всяких метапеременных T и прочее. Проще говоря реализация шаблона для конкретного типа данных.

Частичная специализация, это когда мы пишем (template), и дальше в угловых скобочках чтото пишем (<typename T>), но потом объявляем класс который уже был выше (struct S),
и просто в угловые скобочки ставим чтото более частное (<int, T>). Частичная специализация повзоляет уточнить поведение шаблона для подмножества типов, но при этом сохранить общую 
реализацию для других случаев. Это полезно, когда нужно специализированное поведение для определённых шаблонных параметров, но не для конкретного типа, как в полной специализации.



______________________________________________________
Специализация шаблонов функций Template specializations.

Представим две шаблонные функции, с одним и двумя разными аргументами. Какая версия выберется?

template <typename T, typename U>	// Версия 1
void f(T, U){
	std::cout << 1:
}

template <typename T>			// Версия 2
void f(T, T){
	std::cout << 2:
}

int main() {
	f(0, 0);			// Вызываемся от двух int
}

Вторая версия более частная чем первая, всё что подходит во вторую версию подходит и в первую, а обратно так не работает. Поэтому в данном случае выбирается вторая версия.


Добавим полную специализацию которая принимает 2 int:

template <typename T, typename U>	// Версия 1
void f(T, U){
	std::cout << 1:
}

template <>				// Версия 3
void f(int, int){
	std::cout << 3:
}

template <typename T>			// Версия 2
void f(T, T){
	std::cout << 2:
}

int main() {
	f(0, 0);			// Вызываемся от двух int
}

В консоль всё ровно выведется 2. Но если мы переставим определение от (int, int) ниже, то:

template <typename T, typename U>	// Версия 1
void f(T, U){
	std::cout << 1:
}

template <typename T>			// Версия 2
void f(T, T){
	std::cout << 2:
}

template <>				// Версия 3
void f(int, int){
	std::cout << 3:
}

int main() {
	f(0, 0);			// Вызываемся от двух int
}

Теперь выведется 3. (Я так полагаю из-за перегрузки функций)



У нас бывает перегрузка функций, а бывает специализация шаблонных функций, и это разные вещи. Для функций, в отличие от классов, существует перегрузка, нельзя переопределить
структуру, с другим количеством шаблонных параметров, а функцию можно. 

void f(T, U){
	std::cout << 1:			// Функция с 2 шаблонными параметрами 			(номер 1)
}

template <typename T>			// Функция с 1 шаблонным параметром			(номер 2)
void f(T, T){
	std::cout << 2:
}

template <>				// Частный случай функции с 1 шаблонным параметром	(номер 3)
void f(int, int){
	std::cout << 3:
}

void f(int, int ){			// Нешаблонная функция					(номер 4)
	std::cout << 4;			
}

int main() {
	f(0, 0);			// Вызываемся от двух int
}

Здесь у нас есть 3 разных версии перегрузки функции f, у одной из которых есть ещё специализация. В данном случае выведется 4, потому что есть шаблонная версия номер 1, есть 
шаблонная версия номер 2, есть обычная версия номер 4 (нешаблонная), а у шаблонной версии номер 2 есть частный случай номер 3. Когда компилятор решает какую версию функции 
ему выбрать, он сначала смотрит на версии перегрузки, а перегрузки здесь 3 (1, 2 и 4). Но у некоторых из них могут быть специализации, в нашем случае у 2 есть специализация, под
номером 3. Тем немение, компилятор, сначало выбирает между версиями перегрузки, какая более предпочтительна, а потом, уже после того как он выбрал версию перегрузки, он 
решает нет ли у неё подходящей специализации.

Сначала у нас делается перегрузка между шаблонами, потом в выбранный шаблон подставляются аргументы, и генирируются нужные версии, потом делается перегрузка между тем, что 
получилось.

Для функцию несуществует понятия частичная специализация, есть только полная специализация, поскольку частичная специализация лишена смысла, так как у функции есть перегрузки.



Под какой функцией мы пишем специализацию, к той функции и будет привязана специализация:

Пример 1:

void f(T, U){
	std::cout << 1:			// Функция с 2 шаблонными параметрами 			(номер 1)
}

template <>				// Специализация функции, написанной над нами (специализация функции номер 1)
void f(int, int){
	std::cout << 3:
}

template <typename T>			// Функция с 1 шаблонным параметром			(номер 2)
void f(T, T){
	std::cout << 2:
}


Пример 2:

void f(T, U){
	std::cout << 1:			// Функция с 2 шаблонными параметрами 			(номер 1)
}

template <typename T>			// Функция с 1 шаблонным параметром			(номер 2)
void f(T, T){
	std::cout << 2:
}

template <>				// Специализация функции, написанной над нами (специализация функции номер 2)
void f(int, int){
	std::cout << 3:
}



______________________________________________________
NTTP 	(Non-type template parameters)

Не только типы могут быть параметрами шаблона, а ещё и числа. Мы можем сделать параметром шаблона число.

#include <array> 			// Массив фиксированного размера

int main() {
	std::array<int, 100> a;		// Здесь 100 это параметр шаблона, но он является числом а не типом (Non-type парметр)
}

Как такое объявлять?

template <typename T, size_t N>
class array {
	T arr[N];
};

int main() {
	std::array<int, 100> a;
}



#######################
Матрица 

template <size_t M, size_t N, typename Field = Rational> 	// Матрица над полем из M строк, N столбцов
class Matrix {};						// Rational это класс рациональных произвольной точности

template <size_t N, typename Field = Rational> 			// Тип квадратная матрица
using SquareMatrix = Matrix<N, N, Field>			// матрица с параметром N на N

int main() {
	std::array<int, 100> a;
	Matrix<5, 5> m;
	SquareMatrix<5> sm;
}

Здесь очень удобно что, эти числа являются параметрами типа, т.е. матрица 4 на 3 и матрица 3 на 4 это разные типы, и они друг с другом с точки зрения кодогенерации никак не 
связаны.

Определим умножение разных матриц. Нам нужно сделать так, что только лишь матрицы соответствующих размеров можно перемножать над одним и тем же полем, а если мы попытаемся 
умножить матрицы несоответствующих размеров то будет CE, потому что компилятор не сможет вывести шаблонные параметры.

template <size_t M, size_t K, size_t N, typename Field>
Matrix<M, N, Field> operator*(const Matrix<M, K, Field>& a, const Matrix<K, N, Field>& b);

Таким образом у классов могут быть числовые параметры, однако эти параметры должны быть известны на этапе компиляции. Например, вот так нельзя делать:

int main(){
	int x = 5;
	Matrix<x, x> m;	// CE
}

Здесь переменная x не является константой, которой можно подставить в шаблон (с const сработает).



#####################
constexpr (C++11)

constexpr означает не просто константу, а константу, известную на этапе компиляции. В шаблоны мы должны передавать именно такие константы.

constexpr int x = 5; 


______________________________________________________
template template parameters

Параметры шаблонов бывают типами (typename), бывают целочисленными (size_t, int и все его вариации, bool, char), а так же бывает третий вид шаблонных параметров: параметры шаблонов
которые сами являются шаблонами.

Например я хочу реализовать стек. Стек будет состоять из какого то типа, и я стек реализую как обёртку над каким то контейнером. Например std stack по сути в себе хранит дек или 
вектор. Так вот мы тоже можем параметром стека сделать вид шаблонного контейнера, который мы хотим принять в качетсве параметра. Т.е. мы можем сделать стек на векторе или стек на 
деке или стек на листе. Для этого можно написать:

template <typename T, template<typename> class Container>
class Stack {
	Container<T> container;
};

Здесь мы написали что вторым параметром шаблона является контейнер, но контейнер это не конкретный тип, это другой шаблон, у которого есть свои шаблонные параметры:
, template - означает что вторым параметром мы передали другой шаблон, дальше открывается угловая скобочка <typename> и перечесляются виды шаблонных параметров(метатипы).

Вот здесь есть одна тонкость, в которой слова template и class имеют разный смысл в упоминании шаблонных параметров: Когда я объявляю параметр шаблонна, который сам является
шаблоном вот здесь может быть важно написать class или typename. До C++17 здесь нужно было писать именно class, начиная с C++17 здесь тоже не важно что писать class или typename.

Здесь Container это не тип, а шаблон, и сам по себе Container это непонятно что, но в Container можно передавать шаблонные параметры. Т.е. Container это некоторый шаблон, с 
шаблонным параметром один тип, и вот его уже можно параметризовать типом уже внутри тела класса.

Мы можем установить его по умолчанию. Однако на самом деле у вектора 2 шаблонных аргумента, второй аргумент по умолчанию это алокатор, и он всегда по умолчанию равен std::allocator 
от T. Он есть у каждого контейнера. Поэтому если мы хотим сделать std::vector пенредать в качестве шаблона, то нам нужно указать 2 шаблонных параметра

template <typename T, template<typename, typename> class Container = std::vector>
class Stack {
	Container<T, std::allocator<T>> container;
};

int main(){
	Stack<int, std::vector> s;
};


______________________________________________________
Вычисление в компалтайме (Basic compile time computations)

Допустим я хочу узнать чему равно 20-ое число Фибоначи:
Мы просим компилятор рекурсивно инстанцировать шаблон шаг за шагом, но у компилятора есть встроенный лимит на глубину шаблонной рекурсии. Т.е. когда он инстанцирует шаблон, ему 
потребовалось инстанцировать другой шаблон, и так шаг за шагом. По умолчинию стоит лимит глубины и если он привышает то получается fatal error. Например: 

template <int N>
struct Fibonacci {
	static constexpr int value = Fibonacci<N-1>::value + Fibonacci<N-2>::value;		// CE
};

int main() {
	std::cout << Fibonacci<20>::value;
}

Для того чтобы это пофиксить нужно написать специализацию:

template <int N>
struct Fibonacci {
	static constexpr int value = Fibonacci<N-1>::value + Fibonacci<N-2>::value;
};

template <>
struct Fibonacci<1> {
	static constexpr int value = 1;
};

template <>
struct Fibonacci<0> {
	static constexpr int value = 0;
};

int main() {
	std::cout << Fibonacci<20>::value;
}

За какую асимптотику это отрабатывает? За линейную. Потому что единожды сгенирировав реализацию для какого то N он потом не генирирует её вторично. В реальности оказалось
сгенирировано 21 класс, поскольку Фибоначи от 0 и от 1 это всё разные типы. Компилятор их всех сгенирировал, и они все единожды были сгенирированы.


#################
2-ое упражнение. Как проверить в компайлтайме является ли число простым за линейное время?

template<int N, int D>
struct IsPrimeHelper {
	static constexpr bool value = N % D == 0 ? false : IsPrimeHelper<N, D-1>::value;
};


template<int N>
struct IsPrimeHelper<N, 1> {
	static constexpr bool value = true;
};

template <int N>
struct IsPrime {
	static constexpr bool value = IsPrimeHelper<aN, N-1>::value;
};

template <>
struct IsPrime<1> {
	static constexpr bool value = false;
};

int main() {
	std::cout << IsPrime<257>::value;
}



Дополнения:
1) Мы можем объявлять шаблонные переменные:

...

template <int N>					// Объявляем шаблонную переменную
const bool is_prime = IsPrime<N>::value;

int main() {
	std::cout << is_prime;				// Обращение к структуре с помощью is_prime без ::value
}

Можно сказать что это метафункция: она принимает int в угловых скобочках а не круглых, и это возвращает мне true или false, смотря какой int я передал и всё это делается в 
компайл тайме.


2) Существует такое ключевое слово static_assert. Есть просто assert, это функция которая падает в рантайме (она вызывает std::abort если условие ложно). static_assert это
функция, которая кидает CE если ей передали false, но ей тоже нужно передать константу времени компиляции.

int main() {
	static_assert(is_prime<257>);			// Вызываем CE если это false.
}

Смысл в том, что например, если матрица неквадратная, нельзя будет вызвать её определитель.



______________________________________________________
Зависимые имена (Dependent name)

Рассмотрим такой пример:

template <typename T>
struct S {
	using A = int;		// Публичный using
};

template <typename T>
void f(){
	S<T>::A* x;		// Из струткуры S достаём тип A
}

int main(){
	f<int>();
}

Здесь будет CE. Объяснение: допишем в код специализацию:

template <typename T>
struct S {
	using A = int;		// A обозначает тип int 
};

template <>			// Добавим специализацию
struct S<double> {
	static const int A = 5; // A обозначает переменную типа int 
}

int x = 0;

template <typename T>
void f(){
	S<T>::A* x;		// Неопределённость declaration or expression???
}

Здесь есть проблема, мой шаблонный класс может иметь специализацию и в одной из версии шаблона имя может обозначать тип, а в другой версии шаблона имя может обозначать 
переменную. И вот компилятор пытается скомпилировтаь шаблонную функцию f, которая обращается к шаблонной структуре S, и в ней к сущности под названием A и видит строчку:
S<T>::A* x; С одной стороны это может быть int* x и это дикларейшен, с другой стороны это может быть 5 * x и это экспрешен, в зависимости от T. В данном случае A это зависимое
имя, то чем является A зависит от T, но T это шаблонный параметр, компилятор до подстановки T не может понять что это за конструкция. Поэтому компилятор хочет на стадии 
семантического парсинга, до подстановки всяких T, понять что это за конструкция. Поэтому в стандарте введено следующее правило: во всех таких ситуациях компилятор считает по
умолчанию что это экспрешен. Т.е. все зависимые имена по умолчанию парсятся как выражения, а не как названия типов.

Если закоментировать строчку int x = 0; то такой код даст CE по причине x was not declared in this scope.

Что нужно сделать чтобы компилятор это воспринял как тип а не как имя: Нужно написать typename перед зависимым именем:

template <typename T>
void f(){
	typename S<T>::A* x;		// Неопределённость declaration or expression???
}

Нельзя чтобы в зависимости от T это было то declaration то expression, язык это запрещает.

Но если мы теперь вызовем f<double> то это будет CE  

int main(){
	f<int>();
	f<double>(); // CE no type named A in struct S<double>
}



####################

Что тут теперь написано?

#include <array>

template <typename T>
struct S {
	template <int N>
	using A = std::array<int, N>;	
};

template <>			
struct S<double> {
	static const int A = 5;
}

template <typename T>
void f() {
	typename S<T>::A<10> x;		
}

int main() {
	f<int>();
}

Данный случай можно распарсить как экспрешен A < 10 > x (A меньше 10 больше x). Правда если стоит typename это нельзя так распарсить, однако если бы написали вот так:
typename S<T>::A() <10> x; то это можно было бы распарсить даже если там стоит typename.

Особая боль ситуации заключается в том что слово typename недостаточно здесь, потому что когда мы пишем typename он считает что это название типа, но он всё ещё не считает что
это название шаблона. Слово typename заставляет компилятор думать что это название типа но не шаблона. И чтобы он считал это названием шаблона нужно дописать template.

typename S<T>::template A<10> x;


2 пример:

template <typename T>
struct S {
	template <int N>
	void foo(int) {}	
};

template <typename T>
void bar(int x, int y) {
	S<T> s;
	s.foo<S>(x + y);	// парситься неоднозначно экспрешен или шаблонная функция???
}

int main() {
	bar<int>(2, 3);
}

Строка s.foo < S >(x + y); означает что я взял переменную foo сравнил её с 5, а потом полученный результат сравнил с суммой x + y 
ИЛИ
строка s.foo<S>(x + y); означчает что я вызвал шаблонную функцию с шаблонным параметром 5 от x + y ???

s.foo это может быть переменная а не функция. Это будет эксперешен но у этого будет разный смысл. В данном случае здесь уже никак не обойтись без template:

s.template foo<S>(x + y);	// Это будет компилироваться



##############
Что здесь не так? В чём проблема этого кода?

template <typename T>
struct Base {
	int x = 0;
};

template <>
struct Base<double> {
};

template <typename T>
struct Derived: Base<T> {
	void f() {
		++x;
	}
};

int main(){}

Непонятно что такое x. В зависимости от T, x может то присутствовать то отсутствовать, а может это вообще быть тип, или функция. Когда мы говорим ++x компилятор не понимает что
мы ему говорим, поскольку компилятор не залезает в шаблонного родителя, чтобы посмотреть, что это такое. Это можно починить следующим образом:

++this->x; 

Если мы хотим обратиться к полю шаблонного родителя из наследника, то нам нужно явно указывать this. Так же можно явно указать родителя: ++Base<T>::x;


Компиляция это сложный многостадийный процесс. Есть так называемая Two face translation. Это такой термин, применимый к шаблоном, когда компилятор компилирует шаблоный код, он
это делает в два прохода. Первый проход до того как мы подставили T, второй проход, после того как мы подставили T. До того как мы подставиил T, мы смотрим на синтаксис, на
базовые симантические проверки, на имена независимые от T, но мы не можем полностью проверить всю корректность кода, с точки зрения компиляции, до тех пор, пока T не подставили.
Тем не менее при первом проходе нужно до какой то степени проверить корректнось, чтобы часть ошибок отловить на первой стадии. Но вот вторая стадия, когда мы подставили 
конкретное T, возникают новые ошибки. Именно поэтому когда мы написали например какой нибудь шаблонный контейнер, но пока не использовали его в main(), часть ошибок компиляции
может не найтись, но как только мы инстанцировали в мейне может выпасть ещё куча ошибок компиляции.



______________________________________________________
Metafunctions and type traits.

Шаблоны дают нам возможность писать метафункции. Метафункции это как бы функции от типов. Например можно представить функцию, которая принимает не объекты, а типы и возвращает
их. Простейшая метафункция это проверка равны ли два типа в компайлтайме:

template <typename T, typename U>			// Шаблонная структура
struct is_same {
	static constexpr bool value = false;
};

template <typename T>					// Специализация структуры если T и U одинаковые
struct is_same<T, T> {
	static constexpr bool value = true;
};

// Если типы T и U одинаковые, то выполняется специализация и value становиться true. Если типы T и U разные то выполняется обычный шаблон, и поле value = false;


// Вызов проверки
template <typename T, typename U>			// Просто шаблонная функция
void f(T x, U y) {
	//... 						// Какая то куча действий
	
	// Как нам написать что, Если типы T и U одинаковы то сделай одно, а иначе другое

	// Вариант 1:
	
	/*
	if(typeid(x) == typeid(y)) {} 			// Это работает но это плохо, потому что это рантайм проверка, а нам нужно проверить в компайлтайме. Это безсмысленно,
	*/						// если типы в компайл тайме известны. typeid осмысленны когда у нас x и y полиформны.

	// Вариант 2:
	
	// Мы говорим компилятору что для разных пар T и U, нагенирировал разный код. Когда мы вызываем f от T и U, мы для каждой пары T и U компилятором генерируем свою версию 
	// f. Мы можем сделать так, что в одинх версиях f будет нагенерирован этот код который мы сейчас написали, а в других не будет:
 	
	/*
	if(is_same<T, U>::value) {
		
	}
	*/

	// Однако есть проблема с if. Хоть и условие if(is_same<T, U>::value) известно в компайлтайме, сам этот if всё ровно вычисляться будет в рантайме. Вот чтобы ещё и сам
	// if вычислялся в компайлтайме нужно constexpr прописать после слова if:

	if constexpr (is_same<T, U>::value) {
		x = y;
	}
}

int main() {
	f<int, std::string>(5, "abc");
}

Без constexpr было бы CE. Когда я написал if и поставил какое то условие. В данный момент условие ложно, но код всё ровно компилировать надо, компилятор смотрит и дальше 
компилирует инструкции, это же не важно что это условие можно в компайлтайме проверить, код всё ровно компилировать надо. Так вот constexpr говорит компилятору, что нужно просто
выкинуть этот if из кода и не смотреть на то что внутри него, если это условие ложно, но условие должно быть проверено в компайлтайме. Т.е. если я хочу написать какую то вещь,
которая компилируема только при условии, что выполнено какое то свойство над типами, я могу её обернуть в if constexpr и что находиться под этим if будет компилятором расмотрено
и синтактически распаршено, но семантика того что здесь делается не будет проверена, корректность типов не будет определяться, при условии что if constexpr ложно.


######################
Существует стандарнтая структура сравнения типов C++11:

#include <type_traits>

int main() {
	std::if_same<int, float>;	// Простая мета функция которая по двум типам возвращает bool
}


####################
Бывают метафункции которые по типу возвращают другой тип:

template <typename T>
struct remove_reference {
	using type = T;
};

template <typename T>
struct remove_reference<T&> {
	using type = T;
};

template <typename T>
void f() {
	typename remove_reference<T>::type x;
}


####################
Можно сделать remove_pointer, или remove_const - снимает константность с типа:

template <typename T>
struct remove_const {
	using type = T;
};

template <typename T>
struct remove_const<const T> {
	using type = T;
};

В чём разница между remove_const и const_cast? Это вприницпе разные вещи, мало что общего они имеют между собой.

Аналогично есть функции is_const, is_pointer, is_reference, is_array. Они лежат в заголовочном файле #include <type_traits> C++11

Вот один из type_traits под названием std::conditional

template <bool B, typename T, typename F>
struct conditional {
	using type = F;
};

template <typename T, typename F>
struct conditional <true, T, F>{
	using type = T;
};

Это тернарный оператор только для типов. 


Вывод: не использовать эти структуры в чистом виде, а использовать шаблонные алиасы.


______________________________________________________________________________________
Признаки типа <type_traits>

Признаки типа — это набор классов шаблонов в C++, которые помогают получить информацию о свойствах, поведении или характеристиках типа. Их можно найти в <type_traits> заголовочном 
файле. Используя признаки типа, вы можете адаптировать свой код в зависимости от свойств данного типа или даже применять определенные свойства для параметров вашего типа в коде 
шаблона.

Некоторые общие черты типа:

std::is_pointer: Проверяет, является ли данный тип типом указателя.
std::is_arithmetic: Проверяет, является ли данный тип арифметическим типом.
std::is_function: Проверяет, является ли данный тип типом функции.
std::decay: применяет правила decltype к входному типу (удаляет ссылки, cv-квалификаторы и т. д.).

Применение

#include <iostream>
#include <type_traits>

int main() {
    int a;
    int* a_ptr = &a;

    std::cout << "Is 'a' a pointer? " << std::boolalpha << std::is_pointer<decltype(a)>::value << std::endl;
    std::cout << "Is 'a_ptr' a pointer? " << std::boolalpha << std::is_pointer<decltype(a_ptr)>::value << std::endl;

    return 0;
}

Составление типовых черт
Некоторые черты типа помогают вам составить другие черты или изменить их, например:

std::conditional: Если данное логическое значение истинно, используйте тип A; в противном случае используйте тип B.
std::enable_if: Если данное логическое значение истинно, используйте тип A; в противном случае вложенный тип отсутствует.

Пример:

#include <iostream>
#include <type_traits>

template <typename T>
typename std::enable_if<std::is_arithmetic<T>::value, T>::type find_max(T a, T b) {
    return a > b ? a : b;
}

int main() {
    int max = find_max(10, 20);
    std::cout << "Max: " << max << std::endl;

    return 0;
}

В этом примере find_max функция шаблона определяется только в том случае, если T имеет арифметический тип (например, int, float, double). Это предотвращает непреднамеренное 
использование функции find_maxс неарифметическими типами. В целом, признаки типов — это мощный инструмент для создания более универсального, расширяемого и эффективного кода C++, 
предоставляющий возможность запрашивать и адаптировать ваш код на основе характеристик типа.


______________________________________________________________________________________
Вариативные шаблоны. Шаблоны с переменным количеством аргументов (variadic templates C++11)

Шаблоны с переменным числом аргументов — это функция C++11, позволяющая определять шаблон с переменным количеством аргументов. Это особенно полезно, когда вам нужно написать функцию 
или класс, которые могут принимать разные числа и типы аргументов.

Синтаксис вариативных шаблонов очень прост. Чтобы определить вариативный шаблон, используйте ...обозначение (многоточие):

template <typename... Types>		// Передаём пакет типов. Здесь ... означает что мы объявили пачку типов.
void f(Types.. tx) {			// Распаковка пакета. А здесь ... означает что мы распаковали пачку типов, и это означает что tx теперь пачка переменных.
	
}

Здесь Types это пакет типов, особый вид шаблонного архумента, который представляет из себя пачку типов. Эту пачку можно распаковывать. Пакет может быть пустым. Этот пакет параметров 
можно использовать как список переменных параметров шаблона в определении шаблона.


Примеры:
1) Суммирование нескольких аргументов с использованием шаблонов с переменным числом аргументов:

#include <iostream>

// Base case for recursion
template <typename T>
T sum(T t) {
  return t;
}

// Variadic template
template <typename T, typename... Args>
T sum(T t, Args... args) {
  return t + sum(args...);
}

int main() {
  int result = sum(1, 2, 3, 4, 5);  // expands to 1 + 2 + 3 + 4 + 5
  std::cout << "The sum is: " << result << std::endl;

  return 0;
}

2) Класс кортежа с использованием шаблонов Variadic

template <typename... Types>
class Tuple;

// Base case: empty tuple
template <>
class Tuple<> {};

// Recursive case: Tuple with one or more elements
template <typename Head, typename... Tail>
class Tuple<Head, Tail...> : public Tuple<Tail...> {
 public:
  Tuple(Head head, Tail... tail) : Tuple<Tail...>(tail...), head_(head) {}

  Head head() const { return head_; }

 private:
  Head head_;
};

int main() {
  Tuple<int, float, double> tuple(1, 2.0f, 3.0);
  std::cout << "First element: " << tuple.head() << std::endl;
  return 0;
}

Обратите внимание, что показанные примеры предназначены для образовательных целей и могут быть не самыми эффективными и готовыми к использованию реализациями. В C++17 и более поздних 
версиях появились еще более лаконичные способы обработки шаблонов с переменным числом вариантов, например использование выражений свертки.


3) Пример: Представим что мы хотим написать функцию print, которая берёт переменное кол-во параметров, и выводит их по одному в консоль. Здесь нам пригодится шаблонная рекурсия. 
Нужно понимать, что когда я вызываю print от 10 шаблонных параметров, а потом вызываю print от 9, это всё разные принты будут, будет 10 разных версий принт сгенерировано 
компилятором. И мы хотим чтобы принт от 10 шаблонных параметров нам выводил первый из них, и вызывал рекурсивно принт от 9 шаблонных параметров.

Для того чтобы это реализовать, нам нужно откусить голову. Когда люди пишут код с переменным кол-во шаблонных аргрументов, они обычно делают так: они говорят что есть первый 
аргумен Head, и он имеет тип, а есть ещё хвост, который является пакетом оставшихся типов. 

void print() {}						// Без этого CE. Эта функция на случай, если аргументов не осталось.

template <typename Head, <typename... Tail>		// Эта функция подходит для случаем, когда хоть 1 аргумент есть. Пакет может быть пустым, но первый аргумент должен быть всё ровно.	
void print(const Head& head, const Tail&... tail) {	// Константные ссылки нужны для передачи далее без копирования.		
	std::cout << head << ' ';
	print(tail...);
}

int main() {
	print(1, 2.0, "abc");
}

Пустая функция print без аргуметов нужна для рекурсии.


#####################
Упражнение: Давайте напишем метафункцию, которая проверяет, что все типы в пакете одинаковые.

template <typename First, typename Second, typename... Types>
struct is_homogeneous { 
	static constexpr bool value = std::is_same_v<First, Second>
		&& is_homogeneous<Second, Types...>::value;
};

template <typename First, typename Second>
struct is_homogeneous <First, Second> {
	static constexpr bool value = std::is_same<First, Second> 
};


#####################
Оператор sizeof...

Есть встроенный оператор sizeof... и его можно вызывать от пакетов:

std::cout << sizeof...(tail);

Он возвращает в компайлтайме число, равное размеру пакета (Как от пакета переменных, так и от пакета типов.)



______________________________________________________
Выражения свёртки (fold expressions) C++17

В C++17 добавили более крутую функцию. Допустим мы хотим проверить что все типы в пакете это указатели. Мы имеем метафункцию std::is_pointer_v, которая для данного типа 
проверяет указатель ли это или нет.

template <typename ... Types>
struct all_pointers {
	static const bool value = (std::is_pointer_v<Types> && ...);
};

Если у нас есть пакет, то мы можем засунуть его в fold expressions. fold expressions это когда мы берём какой нибудь expressions, в котором фигурирует пакет, и бинарным 
оператором его соединяем просто с многоточием (...). Это всё разворачивается в компайлтайме. Т.е. это означает для всех типов из пакета повтори вот эту штуку через коньюнкицю и.


Реализуем  is_homogeneous с помощью fold expressions:

template <typename Head, typename... Tail>
struct is_homogeneous {
	static const bool value = (std::is_same_v<Head, Tail> && ...);
};


Реализуем print:

template <typename... Types>
void print(const Types&... types){
	(std::cout << ... << types);
}


У fold expressions есть 4 разновидности:

1) ( pack op ... )
2) ( ... op pack )
3) ( pack op ... op init )
4) ( init op ... op pack )

где, pack - пакет, op - оператор, init - инициализатор.

В чём разница между 1) и 2)? Разница в ассоциативносию. Разные операторы имеют разную ассоциативность, кто-то лево ассоциативен, кто-то право ассоциативен. 1) вид выражения
превращается в правоассоциативную штуку. Т.е. написать вариант 1) это тоже самое что написать (E_1 op (... op (E_N - 1 op E_N))), т.е. скобки справа налево расставлены.
2) вариант эквивалентно написанию (((E_1 op E_2) op ...) op E_N).

3) и 4) тоже самое, только с инициализацией.


______________________________________________________
Неочевидное использование шаблоннов

1) Паттерн CRTP 

template <class T>
struct Base {
	
	/* Просто пояснения, это не входит в пример	
	// T x;    Не будет работать
	T* ptr;	// Будет работать
	T& rtf;
	*/
	
	void interface() {
		// ...
		static_cast<T*>(this)->implementation();
		// ...
	}
	
	static void static_func() {
		// ...
		T::static_sub_finc();
		// ...
	}
};

struct Derived : Base<Derived> {
	void implementation();
	static void static_sub_finc();
};

Класс Derived наследуется от Base с шаблонным параметром Derived. Т.о. Base в некотором смысле знает что T это его потомок. С помощью этого паттерна мы можем в каком то смысле 
иметировать поведение виртуальных функций. У нас есть функция interface, определённая у базового класса, которая для разных T она себя ведёт по разному, и мы, обращаясь к 
базовому классу, можем вызвать эту функцию. Но по факту будет делаться static_cast к наследнику и вызываться его реализация. 

Шаблоны это просто генерация кода, т.е. когда я говорю Derived : Base<Derived>, я просто говорю компилятору подставь T = Derived в Base и просто возьми этот кусок кода и 
скопипасть его, но только чтобы вместо T везде напиши Derived.



2) Expression templates

Очень долгое объяснение. Лекция 26 21.40


______________________________________________________________________________________
SFINAE (Отказ от замены не является ошибкой)

SFINAE — это принцип метапрограммирования шаблонов C++, который позволяет компилятору выбирать соответствующую функцию или класс, когда конкретная специализация шаблона терпит неудачу
во время замены. Термин «ошибка замены» относится к процессу, в котором компилятор пытается заменить аргументы шаблона в шаблон функции или шаблон класса. Если замена вызывает ошибку,
компилятор не будет рассматривать эту конкретную специализацию как кандидата и продолжит поиск допустимой.

Ключевая идея SFINAE заключается в том, что если возникает ошибка замены, она молча игнорируется, и компилятор продолжает исследовать другие специализации или перегрузки шаблона. Это 
позволяет вам писать более гибкий и универсальный код, поскольку позволяет иметь несколько специализаций для разных сценариев.

Пример кода
Вот пример, демонстрирующий SFINAE в действии:

#include <iostream>
#include <type_traits>

template <typename T, typename = void>
struct foo_impl {
    void operator()(T t) {
        std::cout << "Called when T is not arithmetic" << std::endl;
    }
};

template <typename T>
struct foo_impl<T, std::enable_if_t<std::is_arithmetic<T>::value>> {
    void operator()(T t) {
        std::cout << "Called when T is arithmetic" << std::endl;
    }
};

template <typename T>
void foo(T t) {
    foo_impl<T>()(t);
}

int main() {
    int a = 5;
    foo(a); // output: Called when T is arithmetic

    std::string s = "example";
    foo(s); // output: Called when T is not arithmetic
}


В этом примере мы определяем две foo_impl специализированные функции на основе логического значения std::is_arithmetic<T>. Первый активируется, если T это арифметический тип, а второй
активен, если T не является арифметическим типом. Затем функция foo вызывает соответствующую foo_implспециализацию на основе результата признака типа.

При вызове foo(a) целого числа выбирается первая специализация, а при вызове foo(s) строки — вторая специализация. Если действующей специализации нет, код не сможет скомпилироваться.






______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Вывод типов auto, decltype(auto)

Начиная с C++11 в язык добавлено слово auto. Мы можем объявлять переменные с типом auto и компилятор сам догадается какой у них тип. Однако стоит помнить что все типы переменных фиксированны и известны на этапе копиляции.

int main() {
	auto x = 5;
}

Чтобы компилятор понял какой тип у переменной, он посмотрит на выражение справа. Этот механизм вывода типа с помощью auto сводится к уже известному нам механизму вывода типа шаблона. Тип который назначается x по сути 
такой же тип как если бы мы написали так:

template <typename T>
void f(T x) {}

int main() {
	int x = 5;
	f(x);
}

Компилятор умеет отгадывать T исходя из того, что мы передали в функцию. auto работает также. Компилятор это понимает потому что формально у каждого експрешена есть тип, для примитивных типов тип определён и зашит в 
стандарт, если это вызов функции то у неё есть возвращаемый тип, вот он и берётся. Однако в данном случае здесь T мы берём по значению, это значит что ссылки будут отброшены. Это главное что нужно знать про auto: он работает
так же как и если бы в шаблонную функцию передавали, в том числе с ссылками.

Если мы хотим сделать ссылку, то нужно указать это явно:

int x = 5;
auto& y = x;		// Написали &

Это будет работать как если бы мы в функцию передавали параметр по ссылке:

template <typename T>
void f(T& x) {}

Т.е. когда мы написали auto& y =  справа чтото, это как если бы мы в функцию передали то что справа по ссылке. 

Так же мы можем сделать так:

auto x = 5;			// тип int
auto& y = x;			// тип int&
const auto& z = y; 		// тип const int&
auto&& t = x;			// тип универсальная ссылка
auto&& t1 = std::move(x);	// тип rvalue-ссылка 


auto&& работает также как и:

template <typename T>
void f(T&& x) {}

Здесь в шаблонной функции T&& это не rvalue, а универсальная ссылка. auto&& работает так же, это не rvalue, а универсальная ссылка. Это второй случай когда двойной амперсанд && работает не как rvalue ссылка. Т.е. это 
попрежнему работает также как и если бы мы в шаблонную функцию передавали по типу T&&, поэтому здесь t это lvalue ссылка на x, несмотря на то что мы написали auto&&, t это lvalue-ссылка, а не rvalue-ссылка, потому что 
произошёл reference collapsing, т.е. навесился дополнительный амперсанд на auto, auto превратилось в int&, и t стал типом int&. Но если бы мы написали так std::move(x) то t стало бы rvalue ссылкой, потому что справа написано
rvalue експрешен, auto превращается в int, auto&& это int&&, получаем t это int&&. 


Представим что у нас есть какая нибудь шаблонная функция, в которую мы принимаем контейнер и мы хотим обойти этот контейнер. Иногда мы можем увидеть такой синтаксис:

template <typename Container>
void f(Container&& container) {
	for(auto&& value : container) {
		// Что-то делаем
	}
}

Почему такой синтаксис иногда лучше чем const auto&, или тем более просто auto, или auto&, ну т.е. когда мы делаем range-based for по какому то контейнеру. Когда мы пишем auto&& мы позволяем обработать как lvalue так и 
rvalue правильно, это работает как универсальная ссылка опять. Этот for по сути синтаксический сахар для обхода по итераторам. Но если у нас в контейнере квадратные скобочки [] могут возвращать rvalue а не lvalue ссылку по 
какой либо причине:

template <typename Container>
void f(Container&& container) {
	for(auto&& value : std::forward<Container>(container)) {
		// Что-то делаем
	}
}

Вот мы приняли контейнер по какой то ссылке, и хотим эту ссылку сохранить, т.е. либо у lvalue, либо у rvalue вызывать квадратные скобочки и т.д., и тогда по такой ссылке мы сохраним вид value, если у нас  был rvalue - мы 
получим rvalue ссылку, если было lvalue - то получим lvalue ссылку. Поэтому обход контейнера по такой штуке бывает иногда лучше. 

Однако стандартные контейнеры всегда возвращают lvalue и у них нет перегрузки по ссылочным квалификаторам и для них это не важно, однако мы можем мувать результат квадратных скобочек. Но если у нас свой контейнер или 
например мы можем обрабатывать функцию которая возвращает нечто у которого есть диапазон begin и end. Допустим у нас там мув итераторы begin и end, и тогда такми синтаксисом мы сможем корректно обработать и lvalue и rvalue:

template <typename Container>
void f(Container&& container) {
	for(auto&& value : func(container)) {
		// Что-то делаем
	}
}


Аналогично если мы напишем так:

auto& a = 0;	// Это будет CE, потому что это lvalue ссылка и её нельзя инициализировать через rvalue.
auto&& a = 0;	// Так будет корректно, потому что справа rvalue, значит auto выведится как int, auto&& выведется как int&& и это будет продление жизни. 


auto можно комбинировать и со звёздочкой *:

auto* p = &x;	// auto это будет int, auto* будет int*. Точно так же как мы принимае T* в шаблонную функцию.

Можно ещё написать так:

int* p = new auto(5);



#########################################
auto можно писать в возвращаемом типе функций:

template <typename T>
auto g(T x) {
	return ++x;
}

int main() {
	auto x = g(1);		// Какой тип будет у x?
}

Какой возвращаемый тип будет у функции g? Будет int а не int&, потому что мы не поставили амперсанд в возвращаемый тип, поэтому мы возвращаем по значению. Если мы поставим ссылку:

template <typename T>
auto g(T x) {
	return ++x;
}

int main() {
	auto& x = g(1);	// Поставили &
}

то будет CE, потому что справа rvalue. Если сделаем так: 

int main() {
	auto&& x = g(1);
}

то всё хорошо, мы сделали продление жизни rvalue. 

Если мы напишем так:

template <typename T>
auto& g(T x) {				// Добавили &
	return ++x;
}

int main() {
	auto&& x = g(1);		
}

то это UB, здесь битая ссылка, потому что x это временный объект функции g, который мы возвращаем по ссылке, и привязываем его к ссылке в main, но объект был временный и мы получили ссылку на временный объект, который был
уничтожен при выходе из функции g. При этом не важно напишем мы так: auto& x = g(1) или так: auto&& x = g(1), это все ровно будет битая ссылка и будет UB. Когда у нас возвращаемый тип просто auto мы создаём копию от возвращаем
её, а когда auto& мы передаём ссылку на локальный объект, который удалиться при выходе из функции g.


Что если мы попытаемся вернуть из функции разные типы, в зависимости от какого-то условия с помощью auto? 

template <typename T>
auto g(T x) {				
	if(x > 0) 
		return 0;		// Тип int
	else
		return 1u;		// Тип unsigned int
}

Здесь будет CE, компилятор не сможет вывести возвращаемый тип функции. Причём не важно что типы приводятся друг к другу, это не важно. 


Что если мы будем использовать if constexpr, который в зависимости от условия будет подставлять один кусок кода или другой кусок кода? 

template <typename T>
auto g() {				
	if constexpr (std::is_same_v<T, int>) 
		return 0;		// Тип int
	else
		return 1u;		// Тип unsigned int
}

int main() {
	g<int>();			// Это будут две разные функции с разными возвращаемыми типами. 
	g<double>();
}

Однако при этом взвращаемое auto тоже должно превратиться в разные типы. Вопрос: что происходит раньше, компилятор попытается понять чему равно auto, или уберает одно из веток if constexpr? Да, это будут две разные функции с 
разными возвращаемыми типами, всё корректно потому что if constexpr преобразовывает код ДО того как компилятор пытается понять что такое auto. При вызове функции g: g<int>(), компилятор сначало поймёт что такое T, затем 
подставит правильный кусок кода в зависимости от условия if constexpr, и затем он поймёт что такое возвращаемое auto.

Но что если мы попытаемся вернуть вызов этой же функции? Компилятор захочет узнать что вернёт g(x).

template <typename T>
auto g(T x) {					
	if constexpr (std::is_same_v<T, int>) 
		return g(x);	// Вместо 0 пишем g(x)
	else
		return 1u;		
}

int main() {
	auto x = 5;
	g(x);
}

На такой случай у компилятора есть защита от бесконечной рекурсии в компайл тайме, пытаясь вычислить что такое auto будет CE. 


trailing return type
Иногда мы пишем auto в возвращаемом типе не для того чтобы компилятор догадался какой возвращаемый тип, а просто для удобства. Иногда возвращаемые типы функций очень длинные и сложные и начиная с C++11 есть такой 
синтаксис, чтобы возвращаемый тип писался после сигнатуры функции а не до неё:

// Обычный синтаксис:
template <typename T>
std::remove_reference_t<T>&& move(T&& value) {
	return static_cast<std::remove_reference_t<T>&&(value);
}

// Новый синтаксис trailing return type:
template <typename T>
auto move(T&& value) -> std::remove_reference_t<T>&&
{
	return static_cast<std::remove_reference_t<T>&&(value);
}

Эти две формы записи эквивалентны. Так просто читабильнее. Здесь должно быть обязательно просто auto, здесь не может быть auto& например. Стрелка это не вывод типа, это просто перенос сигнатуры возвращаемого типа после 
функции а не до неё.


Начиная с C++20 auto можно писать в принимаемых типах функций (в аргументах):

// Старая запись:
template <typename T>
void f(T&& x) {}

// Новая запись
void f(auto&& x) {}

Эти две записи эквивалентны. Написать f(auto x) это всё ровно что написать template <typename T> f(T x), это просто сокращение (синтаксический сахар).

Так же можно делать так:

void f(auto... x) {}

Это будет сокращённая форма записи для template <typename T, typename... Args> void f(Args... args) {}. 


auto также можно писать в параметрах шаблона. У шаблона могут буть числовые параметры int, char, bool и компилятор тоже может определить что бы дали в шаблон:

template <auto N>
struct Example {};

int main() {
	Example<2> ei;		// auto = int
	Example<'a'> ec;		// auto = char
}
						
Начиная с C++20 в параметры шаблона можно передавать не только числа, но об этом потом. 


По сути auto это сокращение для template <typename T> т.е. механизм такой же. Он даже работает в случае с std::initializer_list: 

template <typename T>
void h(T) {}

int main() {
	h({1, 2, 3});		// Так не работает
	auto lst = {1, 2, 3};		// Так работает
}

Шаблонный параметр функции в качестве initializer_list не получается вывести, однако auto переменную фигурные скобочки получается. При этом понятно что если мы сделаем вот так:

auto lst = {1, 2.0, 3};

то мы не можем так сделать, потому что разные типы в initializer_list.


_____________________________________________
decltype (since C++11)

Это ключевое слово позволяет узнать нам тип выражения в компайл тайме, не в рантайме как это делает typeid, а в компайл тайме. decltype это штука, которая в компайл тайме превращается в тип, и то что в скобках означет то, типом чего 
она станет. 

int main() {
	int x = 0;
	decltype(x) y = x;
}

Мы можем про произвольный экспрешен спросить какой у него тип, и вот такой тип в компайл тайме и подставить. 

int main() {
	int x = 0;
	decltype(x) y = x;
	
	std::vector<decltype(y)> v;
}

decltype это штука, которую мы можем подставлять всюду без проблем, где ожидается название типа, и в компайл тайме всё прекрасно развернётся в настоящий тип. В данном случае у нас будет вектор int.

decltype, в отличие от auto, не отбрасывает ссылки, decltype называет нам точный тип.

int main() {
	int x = 0;
	int& y = x;
	decltype(y) z = y;	// Тип z будет int& , а не просто int.
}

Это неочевидно но очень важно. Ссылка от оригинального объекта неотличимы ничем и никто не может их отличить, только decltype умеет отличать ссылки от оригинальных объектов, поскольку он называет точный тип. В данном случае
y от x в рантайме никак не отличим, но в компайл тайме мы можем спросить про x и y с помощью decltype, и он по разному ответит.


Мы можем на decltype навешивать & и const:

int main() {
	int x = 0;
	int& y = x;
	decltype(y) z = y;	
	decltype(x)& t = x;		// Это будет ещё одна ссылка на x
}

В данном случае мы создали 4 разные переменные, однако они обозначают один и тот же int. Два амперсанда тоже можно, однако это уже не унивирсальная ссылка, а rvalue - ссылка.

int main() {
	int x = 0;
	int& y = x;
	decltype(y) z = y;	
	//decltype(x)&& t = x;		// Это CE
	decltype(x)&& t = std::move(x);		// Всё корректно
}

Также мы можем навесить указатель или const на decltype:

int main() {
	int x = 0;
	int& y = x;
	const decltype(y) z = y;	
}

Однако в данном случае decltype от z: decltype(z) это не const int& , а просто int&, потому что const навешивается сверху над decltype, а не под ссылку, а int& const это всё ровно что просто int&. Поэтому const отброситься. Чтобы добавить
const под ссылку нужно делать remove_reference и уже затем добавлять const. 


Лайфхак: Как понять какой тип вывелся decltype? Чтобы нам узнать какой тип у экспрешена или какой тип вывел decltype:

template <typename T>
struct Debug {
	Debug() = delete;
};

int main() {
	int x = 0;
	int& y = x;

	Debug<decltype(y)>();
}

Мы передаём в Debug какой от шаблонный аргумент явно и сейчас мы увидим CE со словами "Не могу создать Debug с таким то шаблонным параметром".

Если мы напишем так:

int main() {
	int x = 0;
	int& y = x;
	decltype(y)& z = y;		// Добавили &
}

то произойдёт reference collapsing, и в итоге будет один амперсанд. 

const можно навеситься на указатель:

int main() {
	int x = 0;
	
	decltype(&x) const p = &x;
	Debug<decltype(p)>();
}

decltype от адреса x: decltype(&x) - это int*, и мы ещё const навесили сверху, должен получиться int* const. Этот const никуда не делся потому что на ссылку сверху навесить const это бессмыслено, а вот на указатель сверху навесить const это
осмыслено. Если мы напишем слева то ничего не поменяется, const всё ровно навеситься на указатель сверху. 


decltype можно брать от производного выражения. Например что если:

int x = 0;
decltype(++x) u = x;
++u
std::cout << x << " " << u;

Вывод в терминал:1 1

decltype не вычисляет выражения под собой, он лишь смотрит на его тип. Это впринципе не может так работать потому что decltype в компайл тайме должен отработать, под decltype ничего не может вычислится. Роль decltype лишь в том,
чтобы посмотреть какой тип был бы, если бы это вычислилось, но вовсе не может впринципе никак вычислится, потому что decltype разворачивается в компайл тайме. Поэтому u это будет ссылка на x. А почему ссылка то а не просто тип?
decltype(++x), где x типа int возвращает ссылку int&, а вот decltype(x++) возвращает значение типа int (при этом x бы не увеличился), потому что в одном случае lvalue, в другом rvalue.  

decltype(std::move(x)) u = x;		// Так будет CE, потому что rvalue ссылку нельзя инициализировать lvalue.	
decltype(std::move(x))& u = x;		// Так будет снова нормально, здесь сработает reference collapsing. 

decltype сохраняет амперсанды, если мы делаем decltype от std::move(), то получаемый тип это int&&, но мы навесили ещё один амперсанд & и тип получился int&. 

Что будет в таком случае, корректно или нет?:

int x = 0;
decltype(throw 1)* p = &x;

Тип выражения у throw 1 это void. Это корректно, это будет void*. Исключения не будет потому что мы находимся в компайл тайме. 

В прошлый раз в указателе decltype возвращал int* , однако сейчас он возвращает просто void. В данном случае у нас decltype возвращает просто void а не указатель void*. Поэтому если мы теперь напишем const у нас будет 
тип const void*, и теперь при добавлении const должен лечь под указатель а не над ним:

int x = 0;
const decltype(throw 1)* p = &x;
Debug<decltype(p)>();

И теперь decltype вывел тип const void*. 



Ещё странный но важный пример - decltype от x в скобках:

int main() {
	int x = 0;
	decltype((x)) y = x;
}

Сейчас y это будет ссылка на int, а не просто int. Дело в том что decltype работает по разному от имён переменных и от експрешенов. По сути это два разных механизма.  CPP Reference: если аргумент не обёрнутый в скобки индификатор
(т.е. имя переменной) или это не обёрнутое в скобки обращение к члену класса, то decltype просто даёт нам тип этого (Это случай decltype от entity). Но если это любое другое выражение, включая выражения в скобочках, то возникают
следующие правила: 
1) Если категория value это xvalue, то тогда decltype навешивает два амперсанда &&.
2) Если категория value это lvalue, то тогда decltype навешивает один амперсанд &.
3) Если категория value это prvalue, то тогда decltype ничего не навешивает. 

Получается формально decltype от выражения ведёт себя по разному, смотря какой вид value у этого выражения. Если мы берём x в скобочках: (x) - это lvalue, но это не просто имя переменной, это експрешен нетривиальный уже, поэтому 
навешивается амперсанд. 

Если мы возьмём такое експрешен:

struct S {
	int x = 0;
};

int main() {
	int x  = 0;
	decltype(S().x) z = x;
}

то тип у z будет int, потому что это обращение к члену класса не обёрнутое в скобочки и это подходит под случай decltype от entity а не от expression. Но если это был бы xvalue експрешен и даже если тип был бы int, то он бы сгенерировал 
int&&, а не int.



Иногда нам может хотеться, чтобы мы из функции возвращали тип, определённый правилам decltype. Представим что у нас есть функция которая принимает контейнер и индекс и мы хотим из этой функции вернуть ссылку на элемент, так
чтобы можно было бы присваивать, т.е. обёртку над обращением по индексу для разных контейнеров. если мы напишем функцию с возвращаемым типом просто auto то это не будет работать, потому что мы возвращаем без амперсандов,
т.е. rvalue, и никакого присваивания не будет:

template <typename Container>
auto getElement(Container& cont, size_t index) {
	return cont[index];
}

int main() {
	std::vector<int> v(5);
	getElement(v, 0) = 1;
}

Если мы поставим амперсанд, это будет работать, мы возвращаем ссылку на элемент, возвращаем с сохранением ссылки и присвоили, но это будет работать невсегда. Это не будет работать с вектором bool. Иногда нам может хотеться 
возвращать из функции то ссылку то не ссылку. Если мы напишем auto или auto& это приведёт к тому, что мы всегда будем возвращать ссылку или не ссылку. Но что если мы хотим возвращать иногда ссылку, а иногда не ссылку, смотря 
какой тип вот у того, что написано после return. В таком случае нам может понадобиться decltype в возвращаемом типе, потому что мы хотим чтобы оно само определилось какой возвращаемый тип, но по правилам decltype а не по 
правилам auto, чтобы он не отбрасывал амперсанды, если они были. На такой случай у нас есть два синтаксиса:

1) Начиная с C++11 синтаксис trailing return type:

template <typename Container>
auto getElement(Container& cont, size_t index)
	-> decltype(cont[index])
{
	return cont[index];
}

Этот синтаксис говорит нам, что компилятор не будет выводить тип с помощью правил auto, он будет выводить тип с помощью правил decltype, т.е. возвращаемый тип будет таким, каким скажем мы, а не таким, каким компилятор сам 
догадался, поэтому возвращаемый тип будет такой, какой у этого выражения: decltype(cont[index]). Почему мы не можем написать это выражение в начале? Потому что формально переменные cont и index ещё не объявлены на момент
написания возвращаемого типа. Т.е. если мы напишем определение возвращаемого типа в начале, то это CE, не понятно что такое cont и index. Но если мы напишем в синтаксисе trailing return type то всё норм. 

2) Начиная с C++14 есть новый синтаксис: decltype(auto):

template <typename Container>
decltype(auto) getElement(Container& cont, size_t index)
{
	return cont[index];
}

Это означает тоже самое что и написано раньше в первом синтаксисе, просто короче. Т.е. decltype(auto) это значит компилятор выведи тип самостоятельно, но по правилам decltype а не просто auto, в частности, не отбрасывая амперсанды.
Такая запись означает что тип будет выведен автоматически из того, что написано после return, но по правила decltype а не по правилам auto.

А теперь внимание кринж. Что будет сейчас?

template <typename Container>
decltype(auto) getElement(Container& cont, size_t index)
{
	return (cont[index]);		// Добавили скобки
}

В кодстайле сказано: никогда не ставьте круглые скобки после return. Это пример демонстрирует почему так не нужно делать. Сейчас всегда будет возвращаться ссылка, даже в случае вектора bool, потому что после return стоит не просто 
выражение, а выражение в скобочках, а выражение в скобочках навешивает амперсанд. cont[index] это prvalue, но когда мы берём это выражение в скобочки оно становиться lvalue. (Лекция 43 1.17.00 непонятно объяснил).

Вот так точно: decltype(auto) можно делать и в объявлениях переменных. 

template <typename Container>
decltype(auto) getElement(Container& cont, size_t index)
{
	decltype(auto) element = cont[index];
	return element;		
}

Здесь написано тоже самое, мы достали элемент и это либо ссылка либо не ссылка в зависимости от того это вектор bool или не bool, и теперь мы возвращаем этот элемент как переменную а не выражение. Сейчас если бы это было 
ссылкой, то и decltype(auto) тоже был бы ссылкой, но если бы это был вектор bool, этот element имеет тип bool reference без амперсанда, значит decltype(auto) от этой штуки имеет тип bool reference без амперсанда, и вернётся bool
reference без амперсанда, но возми это в скобочки и амперсанд добавиться, потому что это выражение а не просто имя переменной, и вот таким образом мы вернём битую ссылку, потому что мы вернём ссылку на локальный объект 
bool reference. От того что мы поставили скобочки после return получилось UB. 


Исправление emplace_back() в векторе:

void emplace_back(auto&&... args) {
	if(sz == cap_) {
		reserve(cap_ > 0 ? cap_ * 2 : 1); 	
	}
	AllocTraits::construct(alloc_, arr_ + sz_, 
		std::forward<decltype(args)>(args)...);
	++sz_;
}

Если мы принимаем по универсальной ссылке то нам также нужно понять что отдать в forward, для этого нужно использовать decltype. Если args изначально был lvalue, то тип args будет с одним амперсандом & и мы в forward отдадим
с одним амперсандом &. Если args изначально приняли rvalue, то в forward мы отдадим тип с двумя амперсандами &&, такого раньше мы не делали, это новый случай. Это первый раз когда у нас происходит reference collapsing когда 
два амперсанда и два амперсанда. Раньше, когда мы принимали Args, мы в forward передавали Args и два амперсанда навешивались на сырой тип, а когда мы принимаем так, мы в forward передаём decltype от args, но там уже два 
амперсанда, однако это тоже правильно работает. 



_____________________________________________
Deducing this (since C++23)

Вообще std::optional это класс из стандартной библиотеки, который может пригодиться на замену exception. Если функция может завершиться неудачно, то с помощью std::optional функция
может либо вернуть T, либо ничего. Так он обходит выделение динамической памяти, при использовании placement new мы понимаем что можем просто на массиве char либо положить value,
либо не положить. Если мы разыменуем optional в котором ничего не лежало, то это UB. 


template <typename T>						// Реализация std::optional C++17
class optional {
	char val[sizeof(T)];
	bool initialized = false;
public:
	optional(const T& newvalue) : initialized(true) {
		new (val) T(newvalue);
	}
	optional() {} 						// optional по умолчанию ничего не делает
	~optional() {
		if(initialized) {
			reinterpret_cast<T>(val)->~T();
		}
	}
	bool has_value() const {				
		return initialized;
	}
	operator bool() const {					// Можно проверить лежит ли чтото в optional, просто скастив его к bool.
		return initialized;
	}
	T& operator*() {					// Вернуть из optional, то что в нём лежит
		return reinterpret_cast<T&>(*val);		
	}
	const T& value_or(const T& other) const {		// Если в optional что то лежит, то верни мне это, а иначе верни константу которую мы передали в параметр.
		return initialized ? reinterpret_cast<T&>(*val) : other;
	}
};


Есть ещё глобальная переменная std::nullopt.  

struct nullopt_t();
nullopt_t nullopt;

Она нужна для того, чтобы optional проинициализировать явно пустым значением.


(Дополнение лекция 44 начало)
В классе std::optional есть оператор звёздочка * и метод value, который возвращает значение. Данный методы нужно реализовывать аккуратно, например оператору * нужно 4 перегрузки. Если мы хотим правильно реализовать optional,
нам нужно писать так:

T& operator*() {					// Обычная версия
	return reinterpret_cast<T&>(*val);		
}

const T& operator*() const {				// Навесили const
	return reinterpret_cast<const T&>(*val);		
}

T&& operator*() && {					// Перегрузка для rvalue-ссылок
	return reinterpret_cast<T&&>(*val);		
}

const T&& operator*() const && {			// Навесили и const и &&
	return reinterpret_cast<const T&&>(*val);		
}

Для метода value тоже имеется 4 перегрузки, однако он кидает исключение если небыло значения:

T& value() & {
	if(!initialized)
		throw std::bad_optional_access();
	else
		return reinterpret_cast<T&>(*val);
}

И таких нам нужно написать ещё 3. Можно сталкнуться с такой проблемой когда пишем например реализацию std::deque, у нас там есть оператор квадратных скобочек [], который нужно отдельно определеить для константного дека и
неконстантного дека. Этот оператор пишется не в одну строчку, он нетривиальный. И нам нужно написать его для const дека и не const дека и разница только в том, что в одном тип у нас возвращаемый тип T&, а в другом const T&.
Можно вызвать одно из другого, но для этого потребуется const_cast. Но ещё нам нужно поддержать для квадратных скобочек виды value, чтобы квадратные скобочки для rvalue возвращали rvalue ссылку, тогда нам нужен не только
const_cast а ещё и move навесить, т.е. у нас опять 4 перегрузки, и чтобы эти перегрузки работали корректно нужно все эти 4 перегрузки по всем видам value. 

Хватит это терпеть, есть ещё один контекст в котором можно использовать auto, это такая фича которая называется Deducing this. Начиная с C++23 Можно писать так:

template <typename Self>					// Self - это просто имя типа
decltype(auto) value(this Self&& self) {
	if(!initialized)
		throw std::bad_optional_access();
	else
		return reinterpret_cast<???>(*self.val);	// Непонятно что нужно написать
}

Т.о. мы одним махом реализовываем все 4 перегрузки. Эта версия метода будет работать и для lvalue-ссылки и для const lvlaue-ссылки и для rvalue и для const rvalue. Синтаксис в аргументе метода означает, что мы хотим this принять по 
такому виду ссылку, смотря от какого типа мы вызвались. Если мы пишем обычный метод класса то по умолчанию Self был бы неявным аргументом, но начиная с C++23 мы можем первым аргументом в метод класса принять Self явно, и
это позволяет нам сказать по какой ссылке мы хотим принять Self, т.о. мы можем не делать перегрузку методов, которые отличаются только видом ссылки Self.

Главаня фишка в том что мы можем написать так:
				
decltype(auto) value(this auto&& self) {
	if(!initialized)
		throw std::bad_optional_access();
	else
		return reinterpret_cast<???>(*self.val);	
}

Здесь в аргументе мы можем написать auto и без амперсандов или с одним или с двумя амперсандами и это будет работать по обычным правилам. Если мы постамим один амперсанд то мы auto выведем как наш тип и на него будет
навешан один &, если два амперсанда то мы сможем вызываться себя как от lvalue, так и от rvalue. Но мы можем не ставить амперсандов впринципе здесь, тогда мы примем себя по значению, это тоже бывает нужно. Представим что
у нас есть класс итератора и мы не хотим себя принимать по ссылке, раньше когда мы писали код мы всегда неявно принимали себя по ссылке и мы ничего не могли с этим сделать, и если у нас класс такой, что его выгоднее принимать
по значению а не по ссылке, то мы никак не можем иизбежать этого, от чего у нас лишнее разыменования. Начиная с C++23 мы можем в себя принять себя по значению. 

Что же нужно написать вместо ???

Есть такая функция forward_like (since C++23). Она работает как forward, только она сохраняет вид value для типа, но сам тип она подменяет.

template< class T, class U >
[[nodiscard]] constexpr auto&& forward_like( U&& x ) noexcept; 

Мы передаём ей U и она возвращает нам U, но с такими же свойствами как и T.  (Короче он тут сам запутался Лекция 44 18.30)

decltype(auto) value(this auto&& self) {
	if(!initialized)
		throw std::bad_optional_access();
	using DesiredType = decltype(std::forward_like<decltype(self)>(std::declval<T>()));
	return reinterpret_cast<DesiredType >(*self.val);	
}

Короче этот пример он привёл зря. Здесь главная проблема в том что тут нет никакого значения типа T чтобы от него вызвать std::forward_like. Нам нужно из ничего нужно получить вещь типа T и для этого есть магическая функция 
std::declval, которая по данному типу даёт нам значение данного типа. Можно считать std::declval это операция обратная std::decltype. Мы взяли нечто типа T сдеали (std::forward_like<decltype(self)>, т.е. сделали T с такой же константностью
и амперсандами как self,  и вот decltype от этого и есть наш желаемый тип. К такому типу мы и кастим value.



_____________________________________________
CTAD - Class Template Argument Deduction

CTAD - это способность компилятора выводить типы шаблонов не только функций, но и классов. Начиная с C++17 мы можем писать:

int main() {
	std::vector v = {1, 2, 3, 4, 5};
}

и не указывать от чего вектор, он сам догадается. Это очень полезная штука, когда нам нужно объявить tuple, пару или кортеж из нескольких элменетов. tuple - это кортеж из нескольких элементов нескольких типов. 

Тут возникает много вопросов и проблем: как именно он догадывается какие аргументы подставить? В данном случае понятно что может быть только int, однако:

int main() {
	std::vector v2(5);
}

Будет CE потому что непонятно какой тип мы имеем ввиду. 

Есть ещё более кринжовый пример: представим что у нас есть вектор из int и мы говорим:

int main() {
	std::vector v = {1, 2, 3, 4, 5};

	std::vector v2{v.begin(), v.end()};
}

У нас есть уже вектор v, и тут мы решили создать второй сектор от таких параметров. Как вы думаете v2 это будет вектор из чего? Это будет вектор из итераторов на вектор int. Потому что скобочки фигурные а не круглые. Когда мы пишем 
фигурные скобочки, тогда в приоритете конструктор от initializer_list, а этот конструктор понимает из чего создать вектор глядя на то, что в initializer_list, поэтому получиться вектор из итераторов. 

Ну и вообще часто бывает так, что мы не хотим чтобы CTAD выводил тот тип, который он бы вывел автоматически.

Если мы всё таки напишем круглые скобки, то у нас будет вектор из int:

std::vector v2(v.begin(), v.end());	// v2 - это ветор из int

А как он догадался? У вектора есть шаблонный конструктор от пары произвольных типов. Т.е. у вектора есть шаблонный конструктор от input iterator it1, input iterator it2, и вот мы создали вектор, не указав ему шаблонные параметры, 
от двух каких то вещей одинакового типа, но это не подходит ни в один из нешаблонных конструкторов вектора, т.е. это не конструктор вектора от числа или списка значений. Каким же образом вектор догадался от чего он должен 
создсться, если мы передали ему просто каких то два шаблонных типа. 

У вектора прописаны специальные правила, как выводить тип своего шаблонного аргумента в такой ситауции - это называется explicit template deduction guides (Явные правила шаблонного вывода). В случае Class Template Argument 
Deduction мы можем для своего типа написать кастомные правила как вывести тип аргумента шаблонного класса, если передали чтото. В случае вектора там написано, что если ему передали два шаблонных аргумента одинакового типа и 
это не подошло ни по до что выше, то он просто делает то что написано - он считает что T это typename iterator_traits от этого типа :: value_type. Это пишеться так:

template <typename T>
struct vector {
	template <typename Iter>	// Шаблонный конструктор
	vector(Iter, Iter) {}
};


// Пишем explicit template deduction guides	
template <typename Iter>			
vector(Iter, Iter -> vector<typename std::iterator_traits<Iter>::value_type>

Это пригодиться нам если мы будем реализовывать свой tuple. например когда мы создаём tuple от пары, мы не хотим писать явно tuple<T1, T2>, но мы не хотим чтобы если мы создаём tuple от пары то это был tuple с шаблонным
параметром Pair<T1, T2>, нет мы хотим чтобы был tuple с параметрами T1, T2, поэтому например у tuple есть такой template deduction guides: tuple от std::pair от T1, T2 это всё ровно что tuple от T1, T2.

Начиная с C++20 Template Argument Deduction работает даже для using (элиесов), а не только для классов.


###########################
Агрегатная инициализация

Представим что у нас есть:

template<typename T, typename U>
struct S {
	T x;
	U y;
};

int main() {
	S s{1, 2.0};
}

Справится ли CTAD с таким выводов типов? Мы запустили агрегатную инициализацию структуры, не указав шаблонные аргументы. Да справится, но только начиная с C++20. 


Агрегатная инициализация наследования:

struct A {};
struct B {};

template<typename T, typename U>
struct S: T, U {};

int main() {
	S s {A(), B()};
}

Начиная с C++20 с помощью агрегатной инициализации можно инициализировать не только поля, но и родителей, и это работает настолько хорошо, что он даже догадывается какие у нас должны быть родители. В C++17 это не работает,
однако мы можем обойти эту проблему написав deduction guide:

template<typename T, typename U>
struct S: T, U {};

template<typename T, typename U>
S(T, U) -> S<T, U>;

Теперь это скомпилируется и с C++17, но с C++20 эти deduction guide стали ненужны, потому что компилятор умеет догадываться сам какие у нас родители, исходя из переданных аргументов. 


Представим что у нас несколько разных типов.

template<typename... Args>
struct S: Args... {};

int main() {
	S s {A(), B()};
}

Можем ли мы наследоваться от переменного числа? Да можем, причём это можно ещё с C++11. Мы можем писать распаковку параметров шаблона писать здесь, и т.о. начиная с C++20 мы можем создавать структуру, которая является 
наследником от всех переданных нами аргументов, и компилятор сам догадается от каких параметров шаблона. Это полезная фича. На typename... Args мы тоже можем написать deduction guid:

template<typename... Args>
struct S: Args... {};

template<typename... Args>
S(Args...) -> S<Args...>;



_____________________________________________
std::tuple and structured bindings.

Оффтоп:
Задание: Для закрепления материала можно попробовать реализовать std::tuple.

У tuple есть deduction guides (их 5 штук): 

template<class T1, class T2>			
tuple(std::pair<T1, T2>) -> tuple<T1, T2>;			// Если мы создаём tuple от пары, то это tuple от <T1, T2>

template<class Alloc, class... UTypes>				// Если мы создаём tuple от параметров std::allocator_arg_t, аллокатор Alloc, и набор типов UTypes..., то это просто tuple от этих типов, а аллокатор не является шаблонным
tuple(std::allocator_arg_t, Alloc, UTypes...) -> tuple<UTypes...>;		// параметром tuple.

template<class Alloc, class T1, class T2>				
tuple(std::allocator_arg_t, Alloc, std::pair<T1, T2>) -> tuple<T1, T2>;

std::allocator_arg_t - это тег, который нужен для того, чтобы отличить один конструктор от другого. Любой такой тип, который имеет в конце _t - это всегда тег. Если мы первым параметром передали этот аргумент, то т.о. перегрузка понимает,
что мы собираемся следующим аргументом передать объект аллокатора. std::allocator_arg_t это фейковая пустая структура. Это нужно для того, если мы хотим tuple от нестандартного аллокатора. Если бы мы не передали сначала 
std::allocator_arg_t а сразу бы передали аллокатор, то компилятор бы посчитал что аллокатор должен быть частью tuple, а так он поймёт что аллокатор это отдельная структура. 
Конец оффтопа.


У нас есть класс std::tuple который является по сути кортежем. Это обощение пары, но на переменное кол-во типов:

int main() {
	std::tuple<int, double, char> t {1, 2.0, 'a');
}

Теперь зная, что мы умеем выводить шаблонные аргументы, мы можем не писать явно от каких типов tuple, и он сам догадается от каких он типов. 

Мы можем брать по индексу элемент tuple, для этого есть внешняя функция std::get() с шаблонным параметром N принимающая tuple (но это не метод tuple):

int main() {
	std::tuple<int, double, char> t {1, 2.0, 'a');
		
	auto& d = std::get<1>(t);
}

1 - это компайл тайм константа, а в параметр передаём tuple. 1 - это компайл тайм константа (константа времени компиляции) т.е. мы не можем подставить переменную, если бы мы могли подставить переменную, то мы бы не могли знать 
тип во времени компиляции.

Какой возвращаемый тип у функции std::get? Как правильно объявить функцию std::get? Чтобы объявить эту функцию нам нужно использовать decltype(auto), потому что её возвращаемый тип такой: у нас есть пакет типов и нам нужно
достать из него k-ый по счёту тип и он то и будет возвращаемым. Но при этом нам нужно уметь сохранить вид value, потому что например если мы скажем так:

auto& d = std::get<1>(std:move(t));

то это не должно скомпилироваться. У нас get должна работать правильно, в завсисимости от вида value переданного tuple. Если мы передавали ей rvalue tuple, то он должна вернуть rvalue ссылку, соотетсвтенно если мы передали ей
константный tuple, то она должна вернуть константную ссылку, а если мы передали const rvalue tuple, то она должна вернуть const rvalue ссылку. 

Мы можем написать и так, тогда мы сделаем просто копию:

auto d = std::get<1>(std:move(t));

Понятно что если мы объявили ссылку, то если мы поменяем d мы поменяем и элемент tuple, потому что мы получили ссылку на элемент tuple, а не копию:

std::tuple<int, double, char> t {1, 2.0, 'a');
auto& d = std::get<1>(t);	// d это сслыка
d = 3.14;

std::cout << std::get<1>(t);	// Теперь 3.14 а не 2.0


Что будет если мы напишем так:

auto&& d = std::get<1>(t);	// Теперь это универсальная ссылка.

Теперь это универсальная ссылка, теперь она будет правильной независимо от того что стоит справа: const, не  const, lvalue, rvalue - эта ссылка станет правильным видом ссылки в зависимости от того, какой справа был tuple.  

auto&& d = std::get<1>(std:move(t));	// rvalue-ссылка на double
d = 3.14;				// d это тоже ссылка просто она rvalue, но от этого она не перестаёт быть ссылкой. d это теперь другое название для поля tuple, просто инициализировать можно через rvalue.

Теперь d это rvalue-ссылка на поле tuple.  С t ничего не случилось, мы просто скастили t к rvalue-ссылке на tuple, а потом сделали get первого элемента. get нам просто вернул rvalue-ссылку на соответсвтующий элемент tuple, с остальными 
элементами tuple тоже ничего не случилось. Но если бы мы написали так:

auto d = std::get<1>(std:move(t));	// Без амперсандов

d теперь не ссылка, и теперь мы бы мувнули из этого элемента tuple в d. Средний элемент tuple теперь опустел, его данные перешли в d, остальные элементы tuple не изменились.  


#################
Structured bindings

Что если мы хотим распаковать tuple? Мы можем обратиться к конкретному элменту tuple, но мы можем хотеть как бы сразу распаковать tuple и сказать: пусть x, y, z это соответственно 1-ый, 2-ой и 3-ий элементы tuple. Для этого мы 
можем написать:

std::tuple<int, double, char> t {1, 2.0, 'a');
auto [x, y, z] = t;			// Structured bindings (since C++17)

И теперь x это 1, y это 2.0, z это 'a',  причём их типы автоматически выведены у них всех. Однако сейчас мы сделали копии, но если бы мы написали auto&:

std::tuple<int, double, char> t {1, 2.0, 'a');
auto& [x, y, z] = t;

и тогда бы x это была ссылка на 1-ый элемент tuple, y это 2-ая ссылка на элемент tuple, z на 3-ий и типы под ссылкой вывелись. А можно было бы написать auto&&:

std::tuple<int, double, char> t {1, 2.0, 'a');
auto&& [x, y, z] = t;

тогда в зависимости от того, справа lvalue или rvalue tuple, у нас были бы либо rvalue-ссылки либо lvalue-ссылки на элементы tuple.

std::tuple<int, double, char> t {1, 2.0, 'a');
auto&& [x, y, z] = std::move(t);
z = 'b';
std::cout << std::get<2>(t);		// Вывод в консоль: b

Последний элемент tuple стал равен 'b', потому что мы сделали на него ссылку.

Такой синтаксис очень полезен когда нам нужно распокавать std::tuple или std::pair. Такое можно увидить в контексте обхода map например:

for(const auto& [key, value]: map) {}	// Это range-based for на максималках

Это будет работать точно также, как если бы мы написали const auto& [key, value] = *it, где it проходит по всем элементам map. Это range-based for на максималках, мы теперь не просто проходим по всем элементам map автоматически 
разыменовывая итератор, но ещё и распаковываем. 

А как это работает? К чему ещё они применимы кроме tuple? К структурам и массиву. тип должен обладать некоторыми свойствами и тогда к нему будет применим Structured bindings, его можно будет распаковыввать. 

У нас есть 3-и вида типов к которым применим Structured bindings: 
1) с array (как с std::Array, так и с сишным array).
2) tuple-like type - это такой тип для которого корректно определена мета-функция std::tuple_size, а также для каждого числа E от 0 до std::tuple_size - 1 определена мета-функция std::tuple_element<i, E>::type (с параметрами это число - i и E,
и наш тип (type), который даёт нужный тип. Т.е. мы можем сделать так, чтобы в нашем собственном класса Structured bindings работал и для него. Для этого нам нужно доопределить для своего класса мета-функции  tuple_size и 
tuple_element для всех соответствующих E, т.е. tuple_element для данного числа должен давать такой тип, который сидит на i-том месте нашего tuple. Тогда наш тип будет считаться  tuple-like type.
3) структура которая допускает агрегатную инициализацию. 	
(Лекция 44 конец).


###############################
Функции хелперы связанные с tuple

Три способа создать tuple из набора значений.

1) Вариант: По аналогии с функцией std::make_pair, есть функция std::make_tuple. Она берёт аргументы и делает tuple из них. Эта функция как и make_tuple нужна для того чтобы не приходилось явно называть аргументы. Когда появилось 
CTAD эта функция как будто бы стала не нужна, мы и так можем в конструктор не писать аргументы, и не писать make_tuple. Тем не менее посмотрим на плохой пример использования make_tuple:

template <typename... Ts>
struct X {
	explicit X(const Ts&... values) : values(std::make_tuple(values...)) {}

	std::tuple<const Ts&...> values;
};

int main() {
	int i = 42;
	auto s = std::string("universe");
	
	auto x = X<int, std:;string>(i, s);

	std::cout << "i = " << std::get<0>(x.value) << '\n';
	std::cout << "s = " << std::get<1>(x.value) << '\n';
}

Это компилируется, но что здесь не так? Что вообще такое tuple от ссылок? - это tuple который хранит ссылки, и мы можем его создать, тогда обращаясь к соответствующему элементу tuple мы будем получать ссылку на на объект. 
Но что происходит когда мы пытаемся создать tuple от ссылок и делаем make_tuple? Какой возвращаемый тип у make_tuple? 

Реализация make_tuple:

template <typename... Types>
auto make_tuple(Types&&... args) -> tuple<std::decay_t<Types>...> {
	return {std::forward<Types>(args)...};
}

Мы создаём tuple из типов с уже отброшенными ссылками и каждый аргумент проинициализировали либо rvalue либо lvalue ссылками. Tuple получается от самих типов а не от ссылок, поэтому получается что когда мы вызываем 
make_tuple, мы теряем амперсанды. Т.е. make_tuple это создание tuple с отбрасыванием ссылок.

В коде выше UB. Мы сказали values(std::make_tuple(values...)) - что здесь произошло? Здесь создался временный tuple из копий, а проинициализировали мы tuple из ссылок. Мы создали tuple из ссылок от tuple оригинальных объектов, 
получилось что мы получили ссылки на временные штуки, которые уничтожились и мы получили битые ссылки. (Короче он здесь сам запутался лекция 45 начало до 13 минуты)


2) Вариант: Чтобы такого не происходило нам нужно использовать функцию std::tie это тоже самое, только ссылки не теряются.

Реализация tie:

template <typename... Types>
auto tie(Types&... args) -> tuple<Types&...> {
	return {args}...;
} 

Она принимает lvalue ссылки и возвращает tuple из ссылок. Т.о. если мы вызываем tie:

template <typename... Ts>
struct X {
	explicit X(const Ts&... values) : values(std::tie(values...)) {}

	std::tuple<const Ts&...> values;
};

то вот здесь уже не будет битых ссылок, потому что мы не создавали временные копии, мы просто реально создали tuple из ссылок. 


3) Вариант: std::forward_as_tuple - она делает tuple из ссылок, только с сохранением вида ссылок. Если std::tie даёт просто набор ссылок, то std::forward_as_tuple даёт нам либо lvalue либо rvalue ссылки. 

Реализация std::forward_s_tuple:

template <typename... Types>
auto forward_as_tuple(Types&&... args) -> tuple<Types&&...> {
	return {std::forward<Types>(args)...};
}


###############################
Несколько примеров с функцией std::tie

Пример 1:

Эта функция очень мощная штука. Представим структуру S с тремя полями. И мы хотим определить лексико-графическое сравнение:

struct S {
	int n;
	std::string s;
	float d;
	
	friend bool operator<(const S& lhs, const rhs) noexcept {
		return std::tie(lhs.n, lhs.s, lhs.d) < std::tie(rhs.n, rhs.s, rhs.d);
	}
};

Над tuple определено сравнение, и мы можем просто сравнение над своей структуры сделать как tie 3-ёх полей < чем tie от других 3-ёх полей. Т.о. они сравняться как tuple. Т.е. мы заменили сравнение своей структуры на сравнение tuple. 
Поскольку это tie, то мы заведём ссылки а не копии. 

Пример 2:

У нас есть set или map и там есть функция insert которая вставляет в них значение. Эта функция защищает пару - итератор куда вставили, и bool вставили или нет. Что мы можем сделать? 

int main() {
	std::set<S> set_of_s;
	S value{42, "Test", 3.14};
	std::set<S>::iterator iter;	
	bool is_inserted;

	// Unpack a pair:
	std::tie(iter, is_inserted) = set_of_s.insert(value);
	assert(is_inserted);
}

У нас есть две переменные: итератор и bool и мы можем одной строкой присвоить им двоим с помощью: std::tie(ссылка на итератор, ссылка на is_inserted) = результат вставки. Теперь iter и is_inserted присваивается результат. Мы здесь 
завели временный tuple, содержащий ссылку на итератор и ссылку на bool, и этому tuple сделалось присваивание, тем самым поменялся и итератор и bool.

Это не Structured bindings. Structured bindings это когда мы объявляем две новые переменные, а если у нас уже есть две существующие переменные и мы хотим им разом присвоить, тогда мы используем std::tie.
Если у нас есть несколько переменных и функция которая возвращает tuple, мы хотим сразу всем этим переменным присвоить соответствующий элемент tuple, тогда мы используем std::tie от набора этих переменных тем самым создаётся
tuple из ссылок и тем самым каждой переменной присваивается соответствующий элемент tuple. 

Пример 3:

Structured bindings and std::tie

auto position = [](int w) {return std::tuple(1 * w, 2 * w); };

auto [x, y] = position(1);
assert(x == 1 && y == 2);
std::tie(x, y) = position(2);	// reuse x, y whith tie
assert(x == 2 && y == 4);

Здесь мы используем std::tie со Structured bindings. Сначала мы объявляем auto [x, y] = position(1), потом std::tie т этих вещей, и потом присвоили ему результат снова.

Пример 4:

У нас разрешены неявные конверсии.

std::tuple<char, short> coordinates(6, 9);
std::tie(x, y) = coordinates;
assert(x == 6 && y == 9);

У нас есть std::tuple из char и short, а x и y это int. И во мы делаем std::tie от x и y и присваиваем им coordinates. У нас есть tuple в котором есть две ссылки на int, и мы решаем присвоить этому другой tuple, в котором первый элемент 
char, а второй short. Почему это не CE и неявные конверсии прокатывают? По сути у нас уже создан tuple, в котороместь поле int& и другое поле int&. Отныне они ведут себя неотличимо от оригинальных int, т.е. мы можем присвоить одному
char другому short и всё заработает.  


###############################
Ещё немного про std::tie

1) В стандартной библиотеке есть структура std::ignore_t и её единственный экземпляр называется std::igonre. 

struct ignore_t {
	template <typename U>		// Шаблонный оператор присваивания
	void operator=(const U&) {}	
};


Также в STL есть стандартная переменная std::ignore. Она хороша тем, что её можно присвоить что угодно, и ничего не произойдёт. Это действительно полезно, например если нам нужно в какой-то функции явно сказать, что мы не 
используем какой-то из параметров, то мы можем написать std::igonre и присвоить свою переменную. Это еще один способ явно сказать что мы не используем какой-то из парамтров. 1-ый способ это просто не дать ему имя, а 2-ой дать ему имя 
но написать std::ignore = этот параметр. Однако изначально std::ignore была придумана для такого:

std::set<S> set_of_s;
S value{42, "Test", 3.14};
std::set<S>::iterator iter;	

// Unpack a pair:
std::tie(iter, std::ignore) = set_of_s.insert(value);

Так мы говорим, что ничему не хотим присваивать второй элемен пары. Т.е. если например если у нас есть какая то функция, которая возвращает нам pair или tuple, и мы хотим забрать в какую-то переменную только первый элемент контейнера, 
а второй проигнорировать, тогда нам поможет std::ignore. (Он отлично помогает при пользовании интерфейсами).


Начиная с C++23 или C++26 в Structured bindings можно писать переменные _ (знак подчёркивания) несколько раз. Если нам кто-то возвращает tuple а мы делаем Structured bindings и хотим использовать только некоторые элементы из этого 
tuple, то для того чтобы проигнорировать элементы мы можем назвать их _, и компилятор разрешит в одной области видимости иметь несколько переменных с именем _ при условии что мы не будем их использовать:

auto position = [](int w) {return std::tuple(1 * w, 2 * w); };

auto [x, _, _] = position(1);


2) Класс std::piecewuse_construct_t и его единственный экземпляр std::piecewuse_construct. Это просто тег, и он нужен для того, чтобы в одном из конструкторов пары уметь создавать элементы пары по отдельности. Например мы хотим создать пару,
причём мы сразу хотим сразу создать и первый элемент пары и второй, мы не хотим создавать временный промежуточные объекты чтобы потом куда то их мувать или форвордить, мы хотим сразу их емплейснуть и первый кусок и второй и создать
из них пару. Но если мы в конструктор пары передаём список аргументов первого и список аргументов второго, то как он поймёт из каких аргументов создавать первый элемент, а из каких второй. Для этого у нас есть тег std::piecewuse_construct
который если мы передали первым аргументом, то следующим аргументом будет ожидаться tuple, из которого будет создан первый элемент пары, а вторым аргументом будет ожидаться второй tuple, из которого будет создан второй элемент
пары. 

Это пригождается когда мы хотим что нибудь положить в std::map. В map есть метод emplace. В этот метод нам нужно передать std::pair<Ключ, значение>, но мы хотим и ключ и значение сконструировать наместе. Тогда мы можем сделать так:

std::map<std::string, std::string> m;
m.emplace(std::piecewuse_construct, 		// Тег
	  std::forward_as_tuple("c"),		// tuple аргументов, из которых мы создадим ключ (первый элемент пары)
	  std::forward_as_tuple(10, "c"));	// tuple аргументов, из которых мы создадим значение (второй элемент пары)


_____________________________________________
Краткая идейная реализация std::tuple

Как реализовать tuple, какие поля у него должны быть, что хранить в нём? Мы не можем использовать контейнеры с индерекциями, потому что мы хотим чтобы всё лежало на стеке, а не в динамической памяти. Одно из возможных решений 
выглядит так: 

template <typename... Types>
struct tuple;

// Специализация
template <typename Head, typename... Tail> // Класс принимает 1 объязательный шаблонный аргумент и ещё какой то пакет
class tuple {
private:
	Head head;	// Храним голову
	tuple<Tail...> tail;	// и tuple из остальных

	template <size_t N,  typename... Types>		// Функцию get делаем другом
	fruend decltype(auto) get(tuple<Types...>&);
	
	// Конструктор 
};

// Специализация для пустого tuple
template<>
struct tuple<> {};

В конструкторе мы просто конструируем Head от Head и Tail... от Tail... с использованием std::froward.

Как реализовать функцию get? Сначала ответим на вопрос: почему функция get не является методом tuple, а является внешней функцией? Давайте представим что get был бы метом класса, тогда:

template <typename... Types>
void f() {
	std::tuple<Types...> t;	// Все типы создаются по умолчанию
	t.get<1>();
}

Что здесь не так? Здесь t это зависимое имя (dependent name), и если мы хотим позвать метод get, то нам нужно писать так:

t.template get<1>();

Если бы get был бы методом класса tuple, то всякий раз вызывая его от шаблонного tuple, нам бы приходилось писать t.template get а не просто t.get. Поэтому get это внешняя функция (писать буедт не удобно).


Реализация get:

template<size_t N, typename... Types>		// get для lvalue tuple
decltype(auto) get (tuple<Types...>& t) {
	if constexpr (N == 0) {
		return t.head;
	}
	else {
		return get<N - 1>(t.tail);
	}
}

Нам нужен ещё get для rvalue tuple, const lvalue tuple и для const rvalue tuple. Можно ли эти 4 функции get объединить в 1? Тут нужна чуть более сильная шаблонная магия чем мы с вами изучали, поскольку если мы будем принимать параметр по
универсальной ссылке сюда, то мы начёнм принимать не только tuple. Главная проблема в том, что у нас нет синтаксиса принятия сюда универсальную ссылку, которая принимала бы только tuple. Главная проблема универсальных ссылок в том,
что либо мы принимаем вообще любой тип, либо это не универсальная ссылка. И поэтому чтобы универсальной ссылке принимать не любые типы, нам нужно знать ещё некоторые вещи, которые ограничивают набор принимаемых типов, 
например std::enable_if или requers (C++20) (но сейчас не об этом).


###############################
Оффтоп: std::enable_if. Представим что у нас много конструкторов. Нам иногда нужно умееть некоторые версии перегрузок выключать из множества рассматриваемых версий, т.е. нам не просто нужно чтобы компилятор передпочитал другую
версию, нам нужно чтобы он какую то из версий не рассматривал вообще, потому что если бы он её оставил, то она по правилу вывода версий была бы предпочтительнее, но она могла бы не сработать. Для этого есть std::enable_if. 

У нас есть структура и в ней есть два конструктора от typename Integer другой от typename Floating. Мы хотим чтобы если тип относиться к целочисленным, то рассматривался бы только первая перегрузка, а если тип относиться к дробным, то 
рассматривалась вторая перегрузка.

struct T {
	enum {int_t, float_t} type;
	
	// Первая перегрузка
	template<typename Integer,  std::enable_if_t<std::is_integral<Integer>::value, bool> = true>
	T(Integer) : type(int_t) {}

	// Вторая перегрузка
	template<typename Floating,  std::enable_if_t<std::is_floating_point<Floating>::value, bool> = true>
	T(Floating) : type(float_t) {}
};

первый параметр  std::enable_if_t: std::is_integral<Integer>::value - компайл тайм проверяемое условие, второй параметр - bool. Это всё некоторый тип которому мы по умолчанию присваиваем значение true: = true>

std::enable_if это такая структура, которая первым параметром принимает bool, а вторым параметром принимает некоторый тип (по умолчанию void), и если bool это false, то std::enable_if это пустая структура, а если bool это true, то в теле этой
структуры написано type = T который мы передали вторым:

template <bool B, class T = void>
using enable_if_t = typename enable_if<B,T>::type;		// using. B это условие, T это тип (В нашем случае тип = bool).

template <bool B, class T = void>
struct enable_if {};					// Если bool это false то это пустая структура

template <class T>
struct enable_if <true, T> { typedef T type; };		// Если bool это true

Что это значит? Мы передаём в enable_if  в первый параметр некторое value: std::is_integral<Integer>::value (это bool), а вторым параметром тип который равен bool:

std::enable_if_t<std::is_integral<Integer>::value, bool>

Если условие std::is_integral<Integer>::value верно, то в using enable_if_t  = typename enable_if< наше условие которое = true, наш тип T который в данном случае равен bool>;  Получается если наше условие верно, то enable_if_t это просто bool:

std::enable_if_t<std::is_integral<Integer>::value, bool> = true 	// это всё bool, и этому bool мы присвоили true по умолчанию. Т.е. это превратиться в bool если условие std::is_integral<Integer>::value верно. Если же это условие не верно, то в std::enable_if
не будет никакого type, и тогда это будет не корректный тип, но есть такое правило, что тогда эта версия просто выключится из множества рассматриваемых версий перегрузки поскольку тип некорректен. И это не будет CE,это просто будет версия,
которая не рассматривается. 

Короче если мы хотим чтобы какой то из конструкторов не попал в множество версий для перегрузки если какое то условие ложно, то мы пишем так.

Конец оффтопа
###############################


Есть у нас ещё и такая функция: tuple_cat - это конкатенация tuple. Мы берём переменное кол-во tuple и делаем один tuple. Проблема tuple_cat в том, что мы хотим взятьнесколько тюплов и составить из них один, но вот какой будет возвращаемый 
тип? 

struct tuple_cat_tag {};			// Тег для tuple_cat

// Специализация tuple_cat от первого пустого tuple.
template <typename... Us>
auto tuple_cat(tuple<> t, tuple<Us...>& u) {
	return u;
}

// tuple_cat от двух тюплов
template <typename... Ts, typename... Us>
auto tuple_cat(tuple<Ts...>& t, tuple<Us...>& u) {	// для lvalue
	return tuple(tuple_cat_tag(), t.head, tuple_cat(t.tail, u));	
}

Здесь мы откусываем по одному элементу от первого tuple пока он не опустеет. Тег нужен для того, чтобы мы попали в специальный приватный конструктор, который бы первое и второе поле инициализировал тем что мы дали непосредственно.
Это решение плохо тем что мы много раз копируем tuple, мы бы хотели сделать это напрямую. 









