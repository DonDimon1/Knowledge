
_____________________________________________
###################################
_____________________________________________
lambdas, closures and elements of functional prog (Лямбды, замыкания и элементы функционального программирования)


_____________________________________________
Базовое применения лямбда - функций

Лямбда, это способ создать функцию на месте. Например нам нужно сделать сортировку вектора по какому - нибудь нестандартному критерию, например по возрастанию квадрата числа.

Синтаксис: [Работа со внешним контекстом](Параметры){тело функции}.

Примеры использования:

void DoWork(vector<int> &vc, function<void(int)> func) { 	//Пербор вектора
	for (auto el : vc) { 					//Перебор всех чисел в векторе
		func(el);					//Вызов анонимной функции
	}
}
int main()
{
	setlocale(LC_ALL, "Russian");
	vector<int> vc = { 1,51,4,10,44,98,8,12,22,29,49 };

	function<void(int)> f; 					//Полиморфная обёртка функции
	f = [](int a) { 					//Объект класса function ссылается на анонимную функцию
		cout << "Вызвана анонимная функция с параметром - " << a << endl;
	};
	
	DoWork(vc, f); 						//Вызов функции 



	/*DoWork(vc, [](int a) { 				//2-ой вариант вызова функции DoWork. Вместо f просто пишем лямбда функцию.
		cout << "Вызвана анонимная функция с параметром - " << a << endl;
	}); 							//Вызов функции */

	return 0;
}

Смысл [] в лямбда функции: Всё пространство, которое находится рядом с нашей анонимной функцией это контекст этой функции. Реализация лямбда функции изолирована от этой функции.

//контекст 

[](){
    //Внутренний контекст (реализация). Изолирован от внешнего контекста.
};

//контекст 





int main() {
    std::vector v = { 5, -1, 4, -2, -3 };

    std::sotr(v.begin(), v.end(),
        [](int x, int y) {return x * x < y * y; });

    for (auto x : v) {
        std::cout << x << ' ';
    }
}

Здесь [](int x, int y) { return x*x < y*y; }) - это некоторое выражение. Также мы могли объявить лямбду заранее, а в sort передать её уже готовую:

С 14 стандарта с++ мы можем присвоить переменной лямбда функцию:

auto cmp = [](int x, int y) { return x*x < y*y; };
std::sotr(v.begin(), v.end(), cmp);

Здесь cmp это некторая переменная. Какой тип у переменной cmp, и что это вообще такое ? Тип этой штуки, это некий тип, сгенирированный компилятором, специально под это лямбду. В данном случае, это  lambda(int, int). Название этого
типа мы не знаем, но нас не должно это волновать, поскольку мы и не должны использовать название этого типа. Функцию cmp можно вызывать много раз после создания, или передавать её как объект в другие функции. cmp по сути это
функциональный объект, т.е.это тип, у которого оперделён оператор круглые скобочки() от этих двух int, который делает то, что написано.


Представим что мы хотим в std::set инты упорядочить также по возрастанию квадрата числа. У std::set есть второая параметр компаратор, им и воспользуемся.

int main() {
    auto cmp = [](int x, int y) { return x*x < y*y; };
    std::set<int, decltype(cmp)> s;

    s.insert(-1);
    s.insert(-3);
    s.insert(2);

    for (int x : s) {
        std::cout << x << ' ';
    }
}

Вывод в консоль:
-1 2 -3

Здесь cmp является компаратором, который будет сравнивать ключи. 

На самом деле до C++20 так было делать нельзя, потому что у типа, который компилятор генерирует для лямбды, изначально не было конструктора по умолчанию. Компилятор генерирует некоторый тип и у этого типа есть оператор круглые скобочки
от того, что мы написали, но чтобы мы могли так писать, нужно чтобы объект этой штуки можно было сконструировать по умолчанию без аргументов. До C++20 типы лямбд быле не default constructible, и поэтому в этом случае нужно было бы 
передавать объект компоратора в конструктор set явно:

auto cmp = [](int x, int y) { return x*x < y*y; };
std::set<int, decltype(cmp)> s(cmp);

Но копирование можно было делать и до C++20, т.е. лямбды до C++20 были только copy constructible, но не default constructible, default constructible лямбды стали только начиная с C++20.


Что будет если написать так, CE или все хорошо?

auto cmp = [](int x, int y) { return x*x < y*y; };
std::set<int, decltype([](int x, int y) { return x*x < y*y; })> s(cmp);

Будет CE с замечанием: lambda-expression is unevaluated context only available with -std=c++20(лямбда-выражения под decltype запрещены до C++20). Если запустить на C++20 все ровно будет CE по причине того, что несмотря на то, что 
синтаксически эти лямбды одинаковые, типы у них разные, под каждую новую лямбду тип генирируется свой, это разные для компилятора типы и они несовместимы между собой. Если убрать скобочки (cmp), то он создаст лямбду по умолчанию, но
попрежнему тип будет отличаться от cmp.


Реальное полезное применение расмотренно в файле "Многопоточном программирование" в четвёртой теме.


###################################
Closures(замыкание) называется тип лямбды, то, что генерирует компилятор для лямбды называется замыканием. Те типы, которые компилятор генерирует для того, чтобы ими были лямбды, называются замыкания. В данном случае cmp это объект
замыкания, т.е. объект - тип которого некоторое замыкание. Лямбда это название выражения, тип этого выражения называется замыканием, а cmp это объект замыкания.

Какой возвращаемый тип у лямбда-выражений? Как компилятор понимает какой он? Компилятор сам генерирует возвращаемый тип по обычным правилам вывода типа. 

auto cmp = [](int x, int y) {
	if(x > y)
		return 1;
	else
		return 1u;
};

Однако здесь будет CE, потому что компилятор не может вывести тип: inconsistent types 'int' and 'unsigned int'. У обычных функций чтобы тип был выведен компилятором, нужно написать auto или decltype(auto). У лямбд тип автоматически 
выводиться по умолчанию, нам не нужно явно писать возвращаемый тип лямбды. В данном примере мы явно не указываем возвращаемый тип лямбды, auto это тип cmp, а не лямбды. Но сейчас у нас CE из-за разных возвращаемых типов. Как нам 
сказать явно какой будет возвращаемый тип, если в лямбде не понятно какой будет возвращаемый тип? Нам нужно сделать trailing return type после сигнатуры:

auto cmp = [](int x, int y) -> int {	// trailing return type
	if(x > y)
		return 1;
	else
		return 1u;
};

Так можно делать, даже когда компилятор в состоянии вычислить возвращаемый тип. Теперь будет компилироваться.

По умолчанию возвращаемый тип будет auto. Допустим у нас есть лямбда, которая принимает x по ссылке, делает ++x, и возвращает x.

auto inc = [](int& x) {
	++x;
	return x;
};

int x = 0;
int& y = inc(x);

Поскольку возвращаемый тип у лямбды это просто auto, это означает что в inx мы будем возвращать x по значению, а соответсвтенно это будет CE, поскольку мы не сможем присвоить икс игрику&. Чтобы попросить inc вернуть по ссылке нужно
использовать trailing return type:

auto inc = [](int& x) -> decltype(auto) {
	++x;
	return x;
};

и теперь это будет компилироваться.



###################################
Ещё пара замечаний.

1) Не только return type, но ещё и аргументы являются необязательной частью лямбда-выражения, лямбду можно делать и без аргументов, т.е. если у нас лямбда без аргументов, то можно не писать круглые скобки:

auto helloworld = [] {
	std::cout << "Hello world!\n";
};

helloworld();


2) Идеома Immediate invocation (Немедленный вызов). 

Ещё одна полезная, но неочевидная вещь: иногда лямбды полезны не только для того, чтобы их как функции передавать куда-то. Иногда лямбды полезны для того-чтобы их никуда не передавать и не создавать переменных, а просто сразу 
вызвать на месте:

[] {
	std::cout << "Hello world!\n";
}();						// Круглые скобочки

Здесь всё корректно. Мы объявили некоторый closures и сразу же вызвали его как функцию. Сама лямбда это rvalue. В частности можно написать так:

[](){}();

и это корректный код XD. И вот так можно написать:

[]{}();		//Это анонимная функция, которая пока что ничего не умеет.

это тоже корректный код. Это называется Immediate invocation. Т.е. мы создали лямбду не для того, чтобы куда то передать, или чтобы какую-то переменную так назвать, а для того, чтобы создать и сразу вызвать. Это бывает очень полезно.

Пример 1: Представим, что нам нужно инициализировать константу, но её инициализировать нужно со сложными условиями, мы хотим создать константную переменную, которая в зависимости от разных условий, должна быть равна разному, но
при этом переменная должна быть константной. Мы не можем написать const int x = 0, а потом присвоить другое значение, но мы можем сказать:

const int x = [](int y) {
	if(y % 2 == 0)
		return y / 2;
	else
		return 3 * y + 1;
}(2025);

Если у нас есть какое-то сложно вычисление, в результате которого мы хотим получить константное значение, то мы можем использовать Immediate invocation.

Пример 2: Member initializer list. Например у нас в классе много полей являющимеся ссылками, и нам нужно проинициализировать эту ссылку, а чтобы её проинициализировать нужно дофига чего сделать и только потом привязать её к тому, что 
получилось. Как это написать в списке инициализации? Immediate invocation позволяет нам это сделать. Если нам нужна какая то сложная функция, которая должна выполниться и после чего у нас получится то, к чему можно привязать ссылку,
чтобы это было нашим полем, без захода в тело конструктора, а мы не можем зайти в тело конструктора пока не проинициализируем поля, а ссылка должна быть проинициализирована. Здесь поможет лямбда выражение immediate invocation.


_____________________________________________
Captures in lambdas. (Захват в лямбдах)

До сих пор мы говорили про лямбды только с какими-то параметрами, как функции, но не говорили про то, зачем нужны квадратные скобочки перед параметрами. В лямбдах, помимо параметров функций, могут быть ещё переменные, которые 
используются лямбдой, но не являются параметрами функции. Например у нас есть вектор, и мы хотим отсортировать его по возрастанию расстояния до некоторой точки(больше тот, кто дальше от центра). 

std::vector v = {1, 2, -3, 4, -5, 6};
int center = 3;

std::sort(v.begin(), v.end(), );

Какую здесь написать лямбду для компоратора? Здесь center это некоторая переменная, которая у нас тоже есть в области видимости, но она не фиксированная, она м.б. разной. Мы могли бы попробовать написать так:

std::vector v = {1, 2, -3, 4, -5, 6};
int center = 3;

auto cmp = [](int x, int y) {
	return (x-center)*(x-center) < (y-center)*(y-center);
};

std::sort(v.begin(), v.end(), cmp);

однако это не скомпилируется, потому что 'c' is not captured. Когда мы находимся в теле лямбды, мы вообще то не имеем доступа к переменным, которые у нас были локальными во вне области видимости самой лямбды. Внутри этой лямбды у нас
есть только x и y, ну ещё и глобальные переменные, например std::cout, но переменные которые были локальными в функции в который мы создаём лямбду, из лямбды мы не видим. Чтобы они стали нам из лямбды видны и доступны, нужно из
захватить, и их нужно указать в квадратных скобках. В квадратных скобках мы указываем то, к чему мы хотим иметь доступ из лямбды, но что не является её параметрами. Внутреннее пространство лямбда функции изолировано от внешнего 
контекста. За захват контекста у нас отвечают [] скобки.

auto cmp = [center](int x, int y) {
	return (x-center)*(x-center) < (y-center)*(y-center);
};

Теперь это будет компилироваться. А зачем вообще нужен список захвата, если всё можно передать как аргументы? Этот пример и показывает зачем он нужен, мы не можем в сортировку отдать функцию, которая требует три аргумента. Нам нужно
чтобы аргументов было два, но при этом нам нужна ещё какая-то переменная, которая должна фигурировать в теле лямбды, и она не является аргументом. Если бы мы написали так:

auto cmp = [](int x, int y, int center) {
	return (x-center)*(x-center) < (y-center)*(y-center);
};

то мы бы получили CE, со словами: no match for call to '(main()::<lambda(int, int, int)>) (int&, int&)' - не совпадает с вызовом лямбды с тремя аргументами от двух аргументов.


Теперь представим что у нас этот вектор был из каких-нибудь тяжёлых объектов, например из строк. Хотим сделать find_if с предикатом, который проверяет содержит ли строка подстроку. find_if требует предикат от одного аргумента

std::vector <std::string> v = {"abcde", "cdefg", "fgeab"};
std::string sub = "def";

auto contains_substring = [sub](const std::string& str) {
	return str.find(sub) != std::string::npos;		// str.find(sub) ищет подстроку sub в строку str. Если не нашлась, то find возвращает std::string::npos. В возврате мы проверяем равно ли find std::string::npos или нет.
};
auto iter = std::find_if(std::begin(v), std::end(v), contains_substring);
std::cout << *iter;

Ну что классный код? Если бы нам такое пришло на ревью, чтобы вы сказали? А что будет если переменная sub большая? Мы её копируем или что? Правда ли что sub скопируется? Да правда. Если мы так напишем, то sub скопируется в функцию
contains_substring, и это означает, что если мы в sub что-нибудь добавим:

std::vector <std::string> v = {"abcde", "cdefg", "fgeab"};
std::string sub = "def";

auto contains_substring = [sub](const std::string& str) {
	return str.find(sub) != std::string::npos;		
};

sub += 'h';									// Добавили h в sub, теперь sub = "defh"
auto iter = std::find_if(std::begin(v), std::end(v), contains_substring);
std::cout << *iter;

то он всё ровно найдёт старую подстроку "def", а не новую "defh", потому-что в момент когда мы создали объект contains_substring, строка sub была в него скопирована, и строка sub хранится в самом объекте contains_substring. Переменная,
захваченная в closures (замыкание), хранится в нём как поле. И поскольку мы её скопировали, то когда мы поменяли исходный sub, это не повлияло на тот sub, который был скопирован. Как же сделать так чтобы не копировать, а брать ссылку?
Для этого нужно поставить знак амперсанда перед sub в списке захвата:

auto contains_substring = [&sub](const std::string& str) {	// Добавили &
	return str.find(sub) != std::string::npos;		
};

Выглядит как будто мы захватили адрес sub, но на самом деле этот синтаксис означает, что мы хотим захватить sub по ссылке. Теперь в contains_substring мы сохраним ссылку на sub, не её саму, и теперь когда мы поменяли sub, это повлияло на
тот самый sub в лямбде, потому что теперь там хранится ссылка, а не копия. Хорошо, теперь такой вопрос: а это константная ссылка или нет? Можем ли мы из лямбды поменять sub:

auto contains_substring = [&sub](const std::string& str) {
	sub += 'h';						// Можно ли?
	std::cout << sub << '\n';
	return str.find(sub) != std::string::npos;		
};

Да это скомпилируется и действительно sub поменяется, причём разумеется поменяется столько раз, сколько будет вызван предикат, т.е. при каждом вызове функции будет меняться эта строка, т.е. мы захватили по обычной ссылке, а не 
константной. 

Хорошо, а что если мы захватим не поссылке, но всё ровно поменяем sub, что будет? 

auto contains_substring = [sub](const std::string& str) {	// Убрали &
	sub += 'h';						
	std::cout << sub << '\n';
	return str.find(sub) != std::string::npos;		
};

Правильный ответ, это не скомпилируется. no match for 'operator+=' (operand types are 'const std::string'). Короче если мы захватываем по значению, то внезапно мы не можем менять объект, который мы захватили, а если захватили по ссылке,
то можем. Тут ещё один вопрос: а почему так? Это кажется контринтуитивным. Казалось бы логичным наоборот, если по ссылке захватили, то нефиг менять, а если по значению меняй сколько хочешь, но почему так? Дело в том, что оператор
круглые скобочки () это константный метод, а не в том что какие то поля константные. const не навешивается на захваченные переменные, const навешивается на круглые скобочки у этого объекта. И поэтому если мы захватили копию,
const навешивается на неё, и её менять нельзя, но если мы захватили ссылку, const навешивается на неё справа, и это на неё не влияет, поэтому то, что захватили по ссылке менять можно. Когда у нас метод константный, и у нас есть поля 
ссылки, const на них не влияет. Если мы добавляем переменну по значению, нам доступна только операция чтения, но не изменения.

Что делать, если мы бы хотели чтобы круглые скобочки были бы не константными, и могли менять свои поля. По умолчанию то что мы захватили менять нельзя, но как сделать чтобы лямбда могла менять захваченные переменные, чтобы этот const
отменился? Нужно использовать ключевое слово mutable. Но где его написать? Слово mutable в лямбдах пишется после сигнатуры:

auto contains_substring = [sub](const std::string& str) mutable {	// Добавили mutable
	sub += 'h';						
	std::cout << sub << '\n';
	return str.find(sub) != std::string::npos;		
};

Мы можем написать про лямбду mutable, это будет означать, что в ней круглые скобочки неконстантный метод. Сейчас это скомпилируется, но у нас будет не такой вывод как мы ожидаем:

defh
defh
defh

а всё ровно такой:

defh
defhh
defhhh

Каждый раз будет добавляться по новой букве, потому что у нас в std::find_if всего один экземпляр компаратора хранится, поэтому мы увидим снова, что по одной букве добавляется каждый раз (как и в случае если бы мы передали по ссылке).


###################################
Как захватить по константной ссылке? Решим такую задачу: мы хотим захватить в лямбду не строку в исходном виде, а чуть изменённую, но чтобы при этом исходная осталась. Можем ли мы в квадратных скобках написать выражение? Не просто 
переменную захватить, или ссылку на неё, а выражение? Т.е. мы хотим в лямбде сохранить некую штуку, но не копию исходной переменной и не ссылку, а что-то третье, видоизменённое. Можем, для этого у нас есть такой синтаксис и это
называется capture with initialization (Захват с инициализацией). Мы можем написать в квадратных скобках sub = и некоторое выражение:

auto contains_substring = [sub = sub + 'g'](const std::string& str) {	
	return str.find(sub) != std::string::npos;		
};

Выражение в квадратных скобках будет работать также, как и список инициализации конструктора, второй sub (sub + 'g') возьмётся из локальной области видимости, а первый sub (sub = ) будет полем нашей лямбды. Мы можем написать даже 
[sub = sub], но это будет тоже самое, что если бы мы скопировали сюда sub. Однако этот синтаксис, в качестве побочного эффекта даёт нам некоторые новые возможности, например мы можем сказать:

auto contains_substring = [sub = std::move(sub)](const std::string& str) {	
	return str.find(sub) != std::string::npos;		
};
auto iter = std::find_if(std::begin(v), std::end(v), contains_substring);

std::cout << sub << '\n';							// sub станет пустым из-за std::move

Как нам захватить чтото в лямбду путём мува, а не копирования? У нас небыло бы такого синтаксиса, если бы не захват с инициализацией. Написать &&sub нельзя, такого синтаксиса нет, есть только два варианта, либо просто переменная sub, 
либо амперсанд переменная &sub, мы не можем написать какое-то другое выражение, но можем  написать переменная = значение, и вот тут мы можем написать что угодно, например std::move. В данном случае sub станет пустым.

Чтобы захватить по константной ссылке, нам нужно использовать стандартную функцию std::as_const, которая принимает свой аргумент, и возвращает константную ссылку на него:

auto contains_substring = [sub = std::as_const(sub)](const std::string& str) {	
	return str.find(sub) != std::string::npos;		
};

Эта функция вернёт константную ссылку на sub. Однако, если написать так, то тип sub ещё пока не будет константной ссылкой, потому что, хоть мы и захватили по константной ссылке, мы всё ровно скопировали. Поэтому нужно написать так:

auto contains_substring = [&sub = std::as_const(sub)](const std::string& str) {	
	return str.find(sub) != std::string::npos;		
};

то теперь это будет константная ссылка. Можно представлять что захват по значению это типо auto sub, а захват по ссылке это типо auto& sub.

Вопрос на понимание, что будет если мы напишем так:

auto contains_substring = [&sub = std::move(sub)](const std::string& str) {	
	return str.find(sub) != std::string::npos;		
};

Будет CE, потому что мы пытаемся инициализировать lvalue ссылку через rvalue.

###
Что если нам нужно захватить несколько переменных в лямбду? Тогда мы их просто перечисляем через запятую. Например мы хотим захватить sub и sub2, и проверить что они обе входят в str. Мы можем каждую из них захватить независимо, как по 
ссылке, так и по значению. Например захватим sub по значению, а sub2 по ссылке:

std::string sub = "def";
std::string sub2 = "efg";

auto contains_substring = [sub, &sub2](const std::string& str) {	
	return str.find(sub) != std::string::npos 
	    && str.find(sub2) != std::string::npos;		
};

Некоторые из них мы можем захватить с инициализацией:

auto contains_substring = [sub = std::move(sub), &sub2](const std::string& str) {	
	return str.find(sub) != std::string::npos 
	    && str.find(sub2) != std::string::npos;		
};

Другого синтаксиса нет, мы не можем захватывать выражения. Мы можем захватывать либо имя переменной, либо ссылку, либо захват с инициализацией. 

###
Бывает, что мы хотим захватить сразу всё, что имеем в локальной области видимости. Если мы хотим захватить всё по значению, то мы пишем просто знак равно в квдратных скобочках:

auto contains_substring = [=](const std::string& str) { 
	// Тело
};

Если мы всё захотим принять по ссылке, то нужно написать один амперсанд в квадратных скобках:

auto contains_substring = [&](const std::string& str) {
	// Тело
};

По кодстайлу так не рекомендуется писать, не пишите так никогда ни с [=], ни с [&]. Это появилось в C++11, но уже в C++14 комитет по стандартизации понял что ошибся с этой возможностью, и не рекомендовал так писать. По кодстайлу 
рекомендуется явно писать всё то, что мы захватываем.

Если мы тем не менее всё захватили по значению, у нас всё ровно есть возможность что-то захватить по ссылке, например так:

auto contains_substring = [=, &sub2](const std::string& str) {
	// Тело
};

Это означает всё захвати по значению, кроме sub2, а его захвати по ссылке. И наоборот тоже работает, захвати всё по ссылке, а sub2 захвати по значению:

auto contains_substring = [&, sub2](const std::string& str) {
	// Тело
};


###
Захват пакета
Представим следующую ситуацию, мы хотим сделать find по всем строкам, т.е. мы хотим в лямбду захватить переменное число шаблонных аргументов. Как нам захватить сразу целый пакет, т.е. переменное кол-во аргументов? Есть такой синтаксис,
многоточие ставится после именем переменной - subs... Для того чтобы взять их по ссылке, нам нужно написать &subs... Для того чтобы просто расскрыть пакет, многоточие нужно ставить после имени переменной, а амперсанд перед.

template <typename... Strings>
requires ((std::is_same_v<Strings, std::string> && ...))		// Проверка на то, что все типы это std::string
void test(const Strings&... subs) {

	auto contains_substring = [&subs...](const std::string& str) {	
	return ((str.find(subs) != std::string::npos) && ...);		// Проверяем через fold expression
	};
	auto iter = std::find_if(std::begin(v), std::end(v), contains_substring);

	std::cout << *iter << '\n';
}

int main() {
	std::string sub = "cd";
	std::string sub = "de";
	test(sub, sub2);
}

Но, если мы хотим расскрыть пакет с инициализацией, например если бы строки были переданы по ссылке, а мы бы хотели их мувнуть, то тогда нужно написать многоточие перед именем переменной:

template <typename... Strings>
requires ((std::is_same_v<Strings, std::string> && ...))		// Проверка на то, что все типы это std::string
void test(Strings&... subs) {

	auto contains_substring = [...subs = std::move(subs)](const std::string& str) {	
	return ((str.find(subs) != std::string::npos) && ...);		// Проверяем через fold expression
	};
	auto iter = std::find_if(std::begin(v), std::end(v), contains_substring);

	std::cout << *iter << '\n';
}



###################################
Захват текущего объекта capture this
У нас есть структура S, в которой мы создаём некоторое closure, и его возвращаем наружу, а потом его (то что мы получили) вызываем.

struct S {
	int a = 3;
	auto getLambda() {
		auto f = [=](int x) {
			return x + a;
		};
		return f;
	}
};

int main() {
	S s;
	auto f = s.getLambda();
	std::cout << f(5);
}

По идее должно вывестись 8, так и произошло. Теперь немного видоизменим main, что будет теперь?

int main() {
	S* s = new S();
	auto f = s->getLambda();
	delete s;
	
	std::cout << f(5);
}

Что если объект удалился до того, как мы воспользовались той лямбдой, которую он нам вернул? К сожалению это UB, хотя казалось бы что мы сделали не так? Мы вроде бы захватили всё по значению, вроде бы a должно было скопироваться, и 
вроде бы оно должно существовать в лямбде, s удалился, ну что, мы же захватили по значению, а значит скопировали. Но нет. Мы не захватили a по значению. Когда мы написали [=], мы не захватили ни какое a, потому что a это не локальная
переменная. Захватываются только локальные переменные. То что нам в лямбде доступно a, не значит что мы его захватили. Когда мы написали вот так [=], мы могли подумать что мы чё то там захватили, но нет, на самом деле мы захватили не a,
и a доступна нам в лямбде, потому не потому что мы захватили a. a доступно поскольку это не локальная переменная а поле класса, и поэтому несмотря на то, что казалось бы написали равно явно, и нам стало можно обращаться ко всем 
переменным благодарая этому, у нас не произошёл захват того, чего мы ожидали. А что тогда мы захватили? Произошел захват объекта, в котором мы сейчас находимся, т.е. произошел захват this. Когда мы хотим захватить поля класса, нам
нужно писать так:

struct S {
	int a = 3;
	auto getLambda() {
		auto f = [this](int x) {	// Добавили this
//...

Так мы явно говорим, что хотим захватить поля класа, в котором мы сейчас находимся. Таким способом мы не копируем объект класса, а получаем на него указатель, и теперь из лямбды мы имеем доступ к полям, но они доступны через этот 
указатель. Когда мы находимся в методе класса, поля этого класса нам по умолчанию не доступны:

struct S {
	int a = 3;
	auto getLambda() {
		auto f = [](int x) {	// Убрали всё
			return x + a;   // Поле a по умолчанию недоступно, здесь будет CE.
//...

И если бы мы написали так:

struct S {
	int a = 3;
	auto getLambda() {
		auto f = [a](int x) {	// Добавили a
			return x + a;   
//...

Это будет CE всё-ровно, потому что захватывать так можно только локальные переменные, но a это не локальная переменная, это поле, а поля захватывать таким способом нельзя. Чтобы захватить поле, нам нужно явно сказать что мы захватываем
this: [this]. Когда мы так пишем, мы уже не тешим себя иллюзиями, что у нас a захватилось по значению, здесь на самом деле захватился указатель на себя (т.е. указатель на s), который мы храним в лямбде. Если мы всё таки захотим захватить
a по значению, то мы можем написать так: [a = a]. 

Т.е. если в данном случае написать так: [a = a], то это корректно и всё будет правильно работать, если написать так: [a], то это CE, если написать так:[=], то это UB. Это самая большая беда связанная с лямбдами и самая большая опасность
в использовании лямбд. Нам нужно всегда помнить, что лямбда не должна переживать то, что она захватила. Если мы используем лямбду внутри какого-то класса, и эту лямбду куда-то отдаём наружу, или даже если мы просто берём лямбду, которая
захватила какие-то вещи по ссылкам, или указатель на this, и её куда то передаём, то мы всегда должны помнить, что если вдруг мы вызовем эту лямбду после того, как тот объект, который она захватила по ссылке, был уничтожен, мы словим UB.
Это самая большая проблема работы с лямбдами. Нужно очень внимательным быть, когда мы делаем захват в лямбду. Когда мы что-то захватываем в лямбду, всегда спрашивайте себя, что именно мы захватили сейчас. Если мы хотим захватить какие-то
лёгкие вещи по значению, то лучше перечислить их явно, тогда у нас точно ничего не сломается, и не будет таких странных подвохов, что мы вдруг захватили this по значению. Если мы вдруг захватываем this, или захватываем что-то по ссылке, 
то внимательно думайте про каждое из того, что мы захватили, точно ли не получится так, то что мы захватили будет уничтожено раньше чем мы используем эту лямбду, иначе UB.



###################################
static и лямбды

Пример 1. Каким будет x в следующем коде?

int x = 0;
auto f = [=]() mutable {
	++x;
}

f();
std::cout << x;

Будет 0, т.к. в лямбде x захвачен по значению. Хорошо, а что будет теперь:

static int x = 0;			// Добавили static
auto f = [=]() {
	++x;
}

f();
std::cout << x;

Теперь будет 1, потому что статические переменные тоже не подлежат захвату, они на то и статические, они не относятся к числу локальных, которые можно захватить. Статические переменные будут доступны без всякого захвата, если у нас 
статическая переменная, то можно её не захватывать, она и так доступна, потому что статические переменные общие для всех объектов. Статические переменные нельзя захватывать, если сейчас мы явно напишем [x], то будет warning.


Пример 2 (сложный но я разобрался). Вот ещё вопрос, что выведется?

auto factory (int parameter) {
	static int a = 0;
	return [=](int argument) {
		static int b = 0;
		a += parameter; b += argument;
		return a + b;
	};
}

int main() {
	auto func1 = factory(1);
	auto func2 = factory(2);

	std::cout << func1(20) << " " << func1(30) << " " << 
		  << func2(20) << " " << func2(30) << std::endl;
}

Будет 21 52 74 106. Как так произошло? У нас есть func1 и func2. func1 и func2 это два разных объекта closures, одного и того же типа. У этих объектов есть метод от (int argument). В теле этого метода есть статическая переменная b, раз
она статическая, это означает что она общая на все вызовы этого метода, неважно откуда. Это локальная статическая переменная в методе, и она инициализируется первый раз при заходе в функцию, а дальше каждый раз при вызове этого метода,
неважно из какого именно объекта, эта переменная инкрементируется заново. Тоже самое про a, переменная a статическая для функции factory, это значит что она создаётся один раз, когда мы в первый раз заходи в функцию factory, и поскольку
она статическая, в лямбду она не захватывается, копия её не делается, и в строчке a += parameter; b += argument; мы работаем прям с ней самой. Получается, что каждый раз, когда мы инкрементируем a из тела лямбды, мы на самом деле 
обращаемся к одной и той же статической переменной, и инкрементируем её каждый раз одну и ту же. Тоже самое и с переменной b, каждый раз когда мы инкрементируем b мы опять обращаемся к одной и той же переменной всегда, потому что она
статическая для этой функции лямбда, это значит что она одна на все вызовы этого метода и одна на все объекты. В момент func1(20) у нас становится a = 20, b = 1, в момент func1(30) a = 50, b = 2, в момент func2(20) a = 70, b = 4,
в момент func2(30) a = 100, b = 6

Кстати если здесь будет написано так: return [&](int argument), то это UB, поскольку parameter это локальная переменная, при выходе из функции factory она уничтожается, а мы вызываем лямбду уже после того, как вышели из функции factory.



_____________________________________________
Closures as objects (Внутреннее устройство closures как обектов)

Сейчас мы увидим какие реально классы генерирует компилятор, когда мы пишем лямбды. (С помощью сайта https://cppinsights.io/)

Начнём с чего нибудь простого, например:

auto f = [](int x, int y) { return x < y; };

Для этого кода компилятор сгенерировал класс:

#include <cstdio>

int main()
{
    
  class __lambda_4_11
  {
    public: 
    inline /*constexpr */ bool operator()(int x, int y) const
    {
      return x < y;
    }
    
    using retType_4_11 = bool (*)(int, int);				// Указатель на функцию
    inline constexpr operator retType_4_11 () const noexcept		// Оператор приведения
    {
      return __invoke;
    };
    
    private: 
    static inline /*constexpr */ bool __invoke(int x, int y)
    {
      return __lambda_4_11{}.operator()(x, y);
    }
  };
  
  __lambda_4_11 f = __lambda_4_11{};					// Создание лямбды (В данном случае с конструктором по умолчанию)
  return 0;
}

Как мы видим в этом классе есть не только оператор круглые скобочки (), хотя этот оператор самая важная часть этого класса, вообщем то этот оператор и вызывается, мы им всегда и пользовались. Заметим что этот класс локальный
для функции, т.е. он не где-то вне объявлен, он объявлен прям в функции. Также мы видим указатель на функцию, которая из себя представляет этот оператор круглые скобочки. Также класс имеет оператор приведения типа к этому
указателю на функцию. Т.е. на самом деле лямбду неявно можно привести к указателю на функцию, такого типа, которого она является, т.е. лямбду можно отдать туда, где ожидается указатель на функцию, и тогда произойдёт неявное
приведение. Также помимо просто оператора круглые скобочки () у этого Closure есть ещё статическая функция __invoke, которая просто возвращает оператор круглые скобочки() от себя созданного по умолчанию. Это нужно для того, 
чтобы оператор приведения к сишному указателю понимал что он будет возвращать, он же не может вернуть указатель на метод оператор круглые скобочки (), поэтому ему нужно какую то функцию иметь, которая обладает такой сигнатурой,
т.о. лямбду можно вызывать как сишную функцию. 

Теперь если мы что-нибудь в лямбду захватим, 

int c = 0;
auto f = [c](int x, int y) { return x + c < y; };

то ситуация несколько меняется:

int main()
{
  int c = 0;
    
  class __lambda_6_11
  {
    public: 
    inline /*constexpr */ bool operator()(int x, int y) const
    {
      return (x + c) < y;
    }
    
    private: 
    int c;					// Поле c
    
    public:
    __lambda_6_11(int & _c)			// Конструктор от поля c
    : c{_c}
    {}
    
  };
  
  __lambda_6_11 f = __lambda_6_11{c};		// Создание лямбды от c
  return 0;
}

Этот int c становиться полем, и также у нас неявно появляется конструктор от этого поля. Это довольно интересно, и означает то, что теперь эту лямбду мы можем создать от int, а создать по умолчанию нельзя, и это логично, поскольку
лямбда и создаётся от c, которое мы захватили. Также теперь нет оператора приведения к указателю на функцию и нет статического метода, потому что уже не понятно как приводить к указателю на функцию, к указателю на функцию можно
приводить только лямбды, у которых нет захвата. Ну и c менять нельзя, поскольку оператор круглые скобочки это константный метод.

Что если мы захватили бы по ссылке? Тогда у нас поле c стало полем int& c, и тогда менять c их функции было бы можно. Упражнение на понимание: можно спросить sizeof от нашего f, и убедиться, что sizeof(f), в который ничего не 
захвачено это 1, sizeof(f) в который захвачен int по значению это 4, sizeof(f) в который захвачен int по ссылке это будет 8.

Что поменяется если мы напишем mutable?

int c = 0;
auto f = [c](int x, int y) mutable { return x + c < y; };

Уберётся const из 

inline /*constexpr */ bool operator()(int x, int y)  // const больше нет
{
	return (x + c) < y;
}

Когда мы объявлем лямбду mutable, это означает что мы просто просим оператор круглые скобочки делать неконстантным.

Что если мы напишем так? Какой sizeof лямбды будет сейчас?

int c = 0;
int cc = 1;
auto f = [=](int x, int y) mutable { return x + c < y; };

Есть такая оптимизация, что если мы пишем захват всего, то захватывается не вообще всё, а только то, что мы реально используем, поэтому в данном случае, несмотря та то, что у нас было две локальные переменные, используем мы только 
первую переменную, поэтому компилятор не будет добавлять вторую переменную в класс, чтобы сэкономить место.

Так устроены объекты лямбд изнутри.

###
Особенности

Из кода сверху следует что можно делать с лямбдой, и что нельзя. Например лямбды можно копировать, поскольку копи конструктор сгенерируется неявно:

auto f = [=](int x, int y) mutable { return x + c < y; };
auto f2 = f;

Так же мы можем мувнуть, однако присваивать мы не можем, только в случае если мы ничего не захватываем.

###
positive lambda hack

С лямбдой есть следующий трюк, мы пишем лямбду и пишем перед ней знак плюс +: 

auto f = +[](int x, int y) { return x < y; };
 
Что это такое? Что означает + перед лямбдой? Это нужно для того, чтобы если нам нужно лямбду использовать лямбду как c-style функцию. Поскольку у лямбды есть неявный оператор конверсии к сишному указателю, то компилятор попробует 
привести лямбду к чему либо, от чего может работать унарный плюс, а он работает как раз от сишного указателя, поэтому если мы плюс перед лямбдой напишем, то результрующий тип выражения будет сишный указатель на эту функцию, это 
даст нам возможность трактовать лямбду как сишную функцию. Для этого-же мы можем использовать и static_cast.



_____________________________________________
Genetalized (templated) lambdas (Обобщённые лямбды)

Лямбды можно делать с шаблонными параметрами. Например мы обходим map, и с помощью std::transform хотим выполнить функцию над каждым его элементом. Однако когда мы разыменовываем итератор, мы получаем std::pair от const key,
value, но мы не хотим в лямбде писать принимаемый тип.

std::map<std::string, int> m;
decltype(m) m2;

m["abc"] = 1;
m["cde"] = 2;

std::transform(m.begin(), m.end(),
	[]( /* и что здесь писать? std::pair?*/ ))

Мы можем написать так:

std::transform(m.begin(), m.end(), std::inserter(m2, m2.begin()),
	[](auto& item) { 
		++item.second; 
		return item;
	}
);

Вопрос: что такое лямбда, которая принимает auto? Если мы сделаем так:

auto f = [](auto& item) {
	++item.second;
	return item;	
};

то вопрос, как будет выглядить сам класс, который генерируется под лямбду с принимаемым типом auto? Здесь есть неочивидный момент: здесь должен быть шаблонным не класс, а только оператор круглые скобочки, это большая разница. Нам 
нужно чтобы тип f был известен на этапе компиляции. Сам класс лямбды т.е. сам тип closure он не шаблонный, но в нём есть однашаблонная функция - это оператор круглые скобочки от typename T, и у неё столько инстанцированней 
происходит, от сколько разных типов мы эту лямбду в коде повызывали. У класса лямбды теперь будет публичный шаблонный оператор круглые скобочки:

class __lambda_16_9
  {
    public: 
    template<class type_parameter_0_0>
    inline /*constexpr */ auto operator()(type_parameter_0_0 & item) const
    {
      ++item.second;
      return item;
    }
//...

Земетим что в объявлении написано auto, поскольку он не знает заранее какой у него тип. Теперь уже positive lambda hack работать не будет от шаблонный лямбды, потому что непонятно к какому указателю на функцию его привести.

Хорошо, допустим мы хотим навестить concept, что item должен быть каким нибудь, например чтобы у item был item.second. requires как раз можно писать после сигнатуры:

auto f = [](auto& item) 
	requires requires(decltype(item) a) { a.second; }
{
	++item.second;
	return item;	
};

std::transform(m.begin(), m.end(), std::inserter(m2, m2.begin()), f);


Поскольку вы хотим написать expression, requires нужно написать два раза. Однако это выглядит не очень красиво. В лямбдах есть способ указывать явно шаблонный аргумент:

auto f = []<typename T>(T& item) 
	requires requires(T a) { a.second; }
{
	++item.second;
	return item;	
};


###
Начиная с C++23 мы можем добавлять атрибуты к лямбдам:

auto f = []<typename T>(T& item) [[nodiscard]]
	requires requires(T a) { a.second; }
{
	++item.second;
	return item;	
};


###
Пара примеров функционального программирования. 

1) Как можно из лямбд делать другие лямбды? Функциональное программирование это когда мы берём функции и делаем из них другие функции. Представим что у нас есть какая нибудь функция:

auto sum = [](int x, int y) { return x + y; };

Мы хотим сделать другую функцию, которая как бы фиксирует второй аргумент и вызывает первую функцию с фиксированным вторым аргументом от второго. Мы хотим чтобы у нас была такуя штука fix_second_argument, которая умеет брать 
функции от двух аргументов и некоторый аргумент, и возвращать функцию которая получится, если фиксировать этот аргумент:

auto sum = [](int x, int y) { return x + y; };

//fix_second_argument

auto sum_with_five = fix_second_argument(sum, 5);
sum_with_five(3); 					// Должно быть 8

Операция sum_with_five(3) называется коррирование (currying). Это термин из функционального программирования, когда мы берём функцию с несколькими аргументами, зашиваем в неё какие то аргументы в качестве констант, и получаем
на выход функцию с меньшим числом аргументов. Напишем fix_second_argument с помощью лямбды.

auto sum = [](int x, int y) { return x + y; };

auto fix_second_argument = [](auto f, auto second_arg) {
	return [f, second_arg](auto first_arg) {
		return f(first_arg, second_arg);
	};
};

auto sum_with_five = fix_second_argument(sum, 5);
std::cout << sum_with_five(3); 

Здесь самое неочивидное что в лямбде нужно сделать ещё одну лямбду, т.е. вернуть лямбду из лямбды. Этот пример ради примера, он не эффективный, здесь можно сделать получше:

auto fix_second_argument = [](auto&& f, auto&& second_arg) {
	return [f = std::forward<decltype(f)>(f), 
		second_arg = std::forward<decltype(second_arg)>(second_arg)]
		(auto&& first_arg) {
	    return f(std::forward<decltype(first_arg)>(first_arg), second_arg);
	};
};


2) Давайте напишем функцию, которая берёт другую функцию и возвращает функцию, которая выполняет её дважды. 

auto print_hellow = [](){ std::cout << "Hello!\n"; };	// Функция которая пишет Hellow!

auto print_hello_hello = do_twice(print_hellow);	// Эта функция означает выполнить дважды функцию print_hellow

print_hello_hello();					// При вызове дважды должно напичататься Hello

Как должен выглядить функтор do_twice?

auto do_twice = [](auto&& f) {
	return [f = std::forward<decltype(f)>(f)]() {
		f();
		f();
	};
};

Получилось легко. Просто для красоты допишем переменное кол-во аргументов:

auto do_twice = [](auto&& f) {
	return [f = std::forward<decltype(f)>(f)](const auto&... args) {
		f(args...);
		f(args...);
	};
};



###################################
Recursive lambdas (Рекурсивные лямбды)

Попробуем с помощью лямбды посчитать n-ое число Фибоначи:

auto fibonacci = [](int n) -> int{
	return n > 2 ? fibonacci(n-1) + fibonacci(n-2) : 1;
};

Это не скомпилируется, потому что fibonacci это имя переменной, которая какой-то класс на самом деле, мы пытаемся в теле этого объякта вызвать его же ещё раз рекурсивно, а мы ещё даже не поняли какой у него тип. Однако у нас есть
шаблонные лямбды и deduction this (начиная с C++23), которые позволяют нам:

auto fibonacci = [](this auto& self, int n) {
	return n > 2 ? self(n-1) + self(n-2) : 1;
};

this auto& self это явный захват себя (фича C++23 deduction this), мы можем в любой метод класса принять себя явно в первый параметр, в том числе и в лямбду.



_____________________________________________
std::function Базовое представление

Задание на дом(Реализовать std::function).


Класс function является полиморфной обёрткой для функций. Объект такого класса может хранить, копировать любой вызываемы объект (функцию, метод класса, лямбда выражение).
Это некий аналог указателя на функцию, только из мира ООП. #include <functional> //Для использования function 

Класс function может создать объект, который будет ссылаться на какую либо функцию, либо лямбда выражение. При создании объекта класса function у него должа быть указана сигнатура функции, с которой такой объект может взаимодействовать.
Т.о. этот объект function сможет ссылаться на любую функцию с аналогичной сигнатурой. Далее мы можем работать с функцией через этот объект.

void Foo() {
	cout << "Foo()" << endl;
}
void Bar() {
	cout << "Bar()" << endl;
}
int Sum(int a, int b) {
	return a + b;
}
int main()
{
	setlocale(LC_ALL, "Russian");
	function<void()> f; //Объект класса function
	f = Foo; //Аналогично указателю на функцию, мы можем указать что наш объект будет ссылатьяс на функцию.
	f(); // Вызов функции Foo (оператор вызова хранимой функции).
	f = Bar; //Присваиваем объекту другую функцию с той же сигнатурой
	f();

	function<int(int, int)> f2; //<тип возвращаемого значения(тип параметра 1, тип параметра 2)>
	f2 = Sum;
	cout << f2(2, 3) << endl;;

	return 0;
}


Пример передачи указателя на функцию в параметре:

void Foo(int a) {	//Вывод только диапазон чисел
	if (a > 10 && a < 40)
		cout << a << endl;
}
void Bar(int a) {	//Вывод только чётных функций
	if (a % 2 == 0)
		cout << a << endl;
}
void DoWork(vector<int> &vc, function<void(int)> f) { //Пербор вектора
	for (auto el : vc)
		f(el);	//Вызов функции в параметре
}
int main()
{
	setlocale(LC_ALL, "Russian");
	vector<int> vc = { 1,51,4,10,44,98,8,12,22,29,49 };
	DoWork(vc, Foo); //Передача указателя на функцию в параметре
	DoWork(vc, Bar);
	return 0;
}


Но что если нам нужно передавать в качестве параметра не просто любую функцию, а нам нужно чтобы мы выполняли в коде набор различных функций, при чём кол-во функций не было
постоянным.

void Foo(int a) {							//Вывод толкь диапазон числе
	if (a > 10 && a < 40)
		cout << "FOO\t"<< a << endl;
}
void Bar(int a) {							//Вывод только чётных функций
	if (a % 2 == 0)
		cout << "BAR\t" << a << endl;
}
void DoWork(vector<int> &vc, vector<function<void(int)>> funcVector) { 	//Пербор вектора
	for (auto el : vc) { 						//Перебор всех чисел
		for (auto &fel : funcVector) { 				//Перебор всех функций для обработки чисел.
			fel(el); 					//На каждой итерации новая функция вызывается с параметром текущего числа.
		}
	}
}
int main()
{
	setlocale(LC_ALL, "Russian");
	vector<int> vc = { 1,51,4,10,44,98,8,12,22,29,49 };
	vector <function<void(int)>> fVector; 				//Вектор функций для работы функции DoWork.
	fVector.emplace_back(Foo); 					//Добавить в вектор функций нужные нам функции.
	fVector.emplace_back(Bar);

	DoWork(vc, fVector); 						//Вызов функции 

	return 0;
}



###################################
Функторы. Функциональные объекты.

Функтор это класс, у которого переопределён оператор (). Мы получаем объект класса, который ведёт себя как функция. Отличительной особенностью функтора, является то что по сути,
хотя он и ведёт себя как функция, но это в тоже время объект класса, а значит он может иметь и все остальные функции признаки и возможности класса. То есть в отличие от функции,
функтор может хранить состояния полей.

class MyFunctor {
public:
	void operator ()() { 					//Перегрузка круглых скобок
		cout << "Я функтор " << count << endl;
		count++;					//Каждый раз переменная становится на + 1
	}
private:
	int count = 0;						//И она сохраняется 
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyFunctor f;						//Создание объекта класса (функтора)
	f();							//Вызов перегруженного метода класса MyFunctor
	f();
	f();

	return 0;
}


Так же мы можем принимать параметры в методе функтора.

class MyFunctor {
public:
	int operator ()(int a, int b) { 			//Перегрузка круглых скобок
		cout << "Я функтор " << endl;
		return a + b;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyFunctor f;
	int res = f(5, 2); 					//Функтор превратился в функцию, задача которой сложить два числа.

	return 0;
}


Простейший пример использования функторов:

class EvenFunctor {
public:
	void operator()(int value) { 					//Узнаём чётное или нечётное число
		if (value % 2 == 0) {
			evenSum += value;
			evenCount++;
		}

	}
	void ShowEvenSum() { 						//Метод вывода суммы чётных чисел
		cout << "Сумма чётных чисел = " << evenSum << endl;
	}
	void ShowEvenCount() { 						//Метод вывода кол-ва чётных чисел
		cout << "Кол-во чётных чисел = " << evenCount << endl;
	}
private:
	int evenSum = 0; 						//Сумма всех чётных чисел.
	int evenCount = 0; 						//Их количество.
};

int main()
{
	setlocale(LC_ALL, "Russian");
	int arr[] = {1,2,55,99,44,3, 6};
	EvenFunctor ef;							//Создаём объект класса
	
	for (auto element : arr){					//Перебор всех чисел
		ef(element);						//Вызов перегруженного метода
	}
	ef.ShowEvenCount();						//Вызов методов
	ef.ShowEvenSum();
	return 0;
}


###################################
Предикаты

Предикат это функция или функтор, которая возвращает логическое значение (bool). Задача предиката ответить на вопрос - да или нет.


bool GreaterThenZero(int a) { 				//Предикат отвечающий на вопрос больше ли наше число чем ноль.
	return a > 0;
}

int main()
{
	setlocale(LC_ALL, "Russian");
	
	cout << GreaterThenZero(1) << endl;		//Вывод ответа в консоль.

	return 0;
}


Вроде бы просто, тогда зачем их выделяют как то отдельно? Всё дело в их применении, наиболее типичным применением предикатов является их использования с алгоритмами STL. 
Допустим нам нужно подсчитать кол-во элементов в вектора, которое больше нуля. Мы можем сделать цикл и отдельный счётчик, но в реальных проектах так никто не делает. Просто
воспользуемся алгоритмами STL.

#include <algorithm> 							//Для того чтобы пользоваться алгоритмами STL.


bool GreaterThenZero(int a) { 						//Предикат отвечающий на вопрос больше ли наше число чем ноль. 
	return a > 0;							//Если предикат возвращает true то счётчик count_if увеличивается.
}

int main()
{
	setlocale(LC_ALL, "Russian");
	
	vector<int> v = { 1,-2,-55,9,-3,8 };				//Наша коллекция.

	int res = count_if(v.begin(), v.end(), GreaterThenZero); 	//Алгоритм STL, который может подсчитать что либо в коллекции

	cout << res << endl;		 //Выведет число 3. Т.е. count_if подсчитал, что в нашей коллекции v есть три числа, отвечающие требованиям предиката GreaterThenZero.
	
	return 0;
}



Допустим нам нужно подсчитать кол-во студентов, проходной балл которых больше 180:

class Person { //Класс студентов
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 	//Функтор предикат
		return p.score > 180;		
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	
	vector<Person> people{			//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150)
	};
	
	int res = count_if(people.begin(), people.end(), people.front()); //Подсчёт 

	cout << res << endl;

	return 0;
}


Для тех у кого были проблемы с .front() как и у меня. Функция count_if третьим параметром принимает предикат. Если не перегружен оператор (), то .front() просто вернет ссылку 
на первый элемент класса и выкинет ошибку. Работать будет только если мы перегрузили оператор (), и таким образом третьим параметром у нас получился перегруженный предикат.



Предикат унарный, если он принимает один входящий параметр:
bool GreaterThenZero(int a) { 						
	return a > 0;							
}


Бинарный предикат имеет два входящих параметра:

bool MyPred(int a, int b){
	return a > b;
}



______________________________________________________________________________________
Наивная реализация std::function

std::function это полезный класс. Этот класс, также как и умные указатели, много кто реализует по своему. Что это за класс? Он позволяет нам хранить любой callable объект, но с фиксированными принимаемым и возвращаемым типами. 
Например у нас есть функция square которая принимает и возвращает int. При присваиваем в f указатель на эту функцию, потом вызываем f от 5, в консоль выведеться 25.  Хорошо, также у у нас есть функциональный класс AddOne с оператором 
круглые скобочки от int, и теперь мы присваиваем f этот класс, и теперь f это функтор, в f теперь хранится функциональный класс. Потом мы можем присвоить в f какую нибудь лямбду. 

#include <iostream>
#include <functional>

int square(int x) {
	return x*x;
}

struct AddOne {
	int operator()(int x) {
		return x+1;
	}
}

int main() {
	std::function<int(int)> f = square;	// Кладём в f указатель на функцию
	
	std::cout << f(5) << '\n';		// Результат будет 25.	

	f = AddOne();

	std::cout << f(5) << '\n';		// Результат будет 6.

	f = [](int x) { return x * 10; };

	std::cout << f(5) << '\n';		// Результат будет 50.
}

Что такое <int(int)>? Это тип, который является функцией. Это валидный тип, просто нельзя объявлять переменнные такого типа.

Что может быть внутри std::function? Это должно нам напоминать std::any и std::shared_ptr с кастомным делитером и аллокатером. Нужно реализовать похожую идеалогию, нам нужно хранить нечто, что в рантайме может подменяться на другой тип,
а стало быть вероятно придётся опять использовать виртуальное наследование. Но на самом деле std::function реализован без использования виртуальности. Мы попробуем реализовать type erasure(Стирание типа) без использования виртуальных 
функций. При реализации shared_ptr мы говорили что есть два способа реализации: простой и сложный. shared_ptr мы реализовали попроще, с помощью виртуальности, а здесь мы выберем способ посложнее.


Однако это ещё не всё что умеет std::function, он умеет муваться и копироваться:

std::function<int(int)> f = [](int x) { return x * 10; };
auto f2 = f;

std::cout << f(5) << '\n';		// Результат будет 50.
std::cout << f2(7) << '\n';		// Результат будет 70.

А если бы у лямбды были какие нибудь захваченные поля? Сможем ли мы тогда скопировать?

int c = 10;
f = [c](int x) { return x * c; };
auto f2 = f;

Да смогли, просто наш объект он должен вызвать копи конструктор от объекта, который в нём лежит. А что если при этом у нас c захвачен по ссылке? 

int c = 10;
f = [&c](int x) { 		// Захватили c по ссылке
	++c;			// Инкрементируем c
	return x * c; 
};

auto f2 = f;

Мы захватили c по ссылке, и инкрементируем его в теле лямбды. Если мы копируем объект, в f2 сохраняется ссылка на тот же самый int, и получается что инкремент ++c будет инкрементироваться в каждом вызове и f и f2, т.е. от каждого 
вызова f и от каждого вызова f2 будет инкрементироваться int c.

Как на счёт присваивания? Мы выяснили что присваивать лямбды друг другу нельзя, а можно ли делать так:

f = [](int x) { return x * 10; };
auto f2 = f;
f = f2;					// Можно ли?

Можно. Мы бы хотели чтобы std::function можно было присваивать друг другу, чтобы если совпадает сигнатура, можно было бы присвоить одной функции другую. Т.е. std::function можно присвоить std::function. Ну и понятно что у std::function
должен быть деструктор, который уничтожает объект, который в нём сейчас лежит. 

Сейчас мы рассмотрели три callable случая std::function: В std::function положить просто сишную функцию, можем положить нами написанный класс с оператором круглые скобочки, и можем положить лямбду т.е. closure. Однако можно ещё положить
указатель на метод. Взять указатель на метод просто: &Strange::moduloSeven. Однако если мы попробуем указатель на метод положить в std::function так:

struct Strange {
	int c = 7;
	int modulo(int n) {
		return n % c;
	}
};

int main() {
	std::function<int(int)> f = [](int x) { return x * 10; };
	f = &Strange::modulo;	
}

то будет CE, потому что типы не соответсвтуют. std::function у нас принимает int и возвращает int, а чтобы вызвать указатель на метод недостаточно иметь только int, ножно ещё иметь объект s. Вообщем здесь нужен не такой std::function:

std::function<int(Strange&, int)> ff = &Strange::modulo;
Strange s{7};
ff(s, 5);

потому что указатель на метод первым аргументом неявно принимает ссылку на объект. 

Ещё callable считаются не только указатели на методы, но и указатели на поля. Мы можем в std::function подсунуть указатель на поле. Если мы вызовем такую функцию, то мы увидим просто число:

std::function<int(Strange&)> f3 = &Strange::c;
std::cout << f3(s) << '\n';

Это осмысленно, это не глупость, иногда это м.б. полезно. Теперь вопрос, если мы напишем const в структуре, будет CE или нет:

struct Strange {
	int c = 7;
	int modulo(int n) const {
		return n % c;
	}
};

std::function<int(Strange&)> f3 = &Strange::c;

Нет так можно, а вот наоборот нельзя:

struct Strange {
	int c = 7;
	int modulo(int n) {
		return n % c;
	}
};

std::function<const int(Strange&)> f3 = &Strange::c;

Потомучто у нас функция, которая обещает работать с константными Strange, а мы ей подсовываем функцию, которая работает с неконстантными Strange, это делать нельзя, но в обратную сторону можно, если у нас функция которая работает с
неконстантными Strange, а мы ей подсовываем штуку, которая не меняет Strange, ну ничего страшного.

Что если у нас сам std::function константный, влияет ли это на то, какие методы мы можем вызывать у объектов? Нет не влияет. Если у нас сама функция была неконстантной, то это не мешает константному std::function её вызывать.


###################################
Начало реализации.

Мы хотим чтобы function можно было создавать только от типов, которые являются функциями.

template <typename T>
class function;

template <typename Ret, typename... Args>
class function<Ret(Args...)> {

};

Мы будем определять class function<Ret(Args...)>, а исходный class function мы оставим без определения. За счёт такой специализации мы добьёмся того, что function можно вызывать только от таких типов. Также мы можем написать requiers.

Теперь вспомним как делать type erasure(Стирание типа). Сначала напишем как умеем, потом обсудим почему это плохо, и исправим.

template <typename T>
class function;

template <typename Ret, typename... Args>
class function<Ret(Args...)> {
private:
	struct Base {
		virtual Ret call(Args...) = 0;
		virtual ~Base() = default;
	};

	template <typename F>
	struct Derived: Base {
		F f;
		~Derived override = default;
		Derived(const F& f): f(f) {}
		Derived(F&& f): f(std::move(f)) {} 

		Ret call(Args... args) override {
			return f(std::forward<Args>(args)...);
		}
	};

private:
	Base* fptr;

public:
	function(auto&& func)
		: fptr(new Derived<
			std::remove_reference_t<decltype(func)>
			>(func)) {}					//TODO what if decltype(func) == const T&

	~function() {
		delete fptr;
	}

	Ret operator()(Args... args) const {
		return fptr->call(std::forward<Args>(args)...) 
	}

};

Пишем классы и поля отдельно. У Base должен быть виртуальный деструктор, чтобы корректно уничтожались типы. Также нужен шаблонный наследник Derived с полем F f, и с конструкторами. Далее пишем реализацию конструктора самого function,
там поле fptr инициализиурется выделенным в куче объектом дочернего класса. Далее пишем оператор круглые скобочки (). У него возвращаемый тип это Ret. В объявлении этого оператора не должно быть амперсантов (например Args&&... args), 
потому что эти Args в себе уже содержат все амперсанды если надо. Если у нас функция принимает ссылки, они уже зашиты в этот typename... Args, поэтому оператор круглые скобочки у function принимает Args по значению, Args и Ret это 
шаблонные параметры класса в которых уже зашиты амперсанды. Также здесь этот оператор константный. Определяем метод call в наследнике. Константность оператора круглые скобочки у function ничего не говорит о константности самого
функтора. 

Эта реализация будет работать не во всех случаях, например это не будет работать с pointer to member. Нам нужно разобрать два случая когда f это указатель на метод или когда f это указатель на поле.

Ret operator()(Args... args) const {
	if constexpr (std::is_member_function_pointer_v<F>) {		// Если f это указатель на метод 
		///TODO call with correct syntax
	} else  if constexpr (std::is_member_object_pointer_v<F>) {	// Если f это указатель поле
		//TODO 
	} else {
		return f(std::forward<Args>(args)...);
	}
}

На самом деле есть способ сделать это красиво, а именно использовать std::invoke (since C++17)(с англ. вызвать). Казалось бы зачем нужна std::invoke если можно просто вызвать функцию, но дело в том, что std::invoke это штука, которая 
умеет вызывать функцию правильно, в зависимости от того, была ли она функцией, или указателем на член, или указателем на поле. Эта функция экономит нам много сил и нервов и позволяет нам не переберать нам случаи вызовов от указателя на 
метод или указатель на поле, она делает сама корректный вызов.

Есть две большие проблемы которые у нас остались связанные с эффективностью. 1-ая: эта function которую мы написали феерически неэффективна, она очень медленная, потому что на каждое присваивание даже сишного указателя, она делает new.
Получается каждое создание объекта function, это вызов оператора new, это жесть. Мы хотим, чтобы у нас в function функтор если он маленький хранился на стеке. В shared_ptr так не делается, потому что там подразумевается что всё хранится
в динамической памяти, но в function и ещё с некоторыми классами это очень распрастранённая оптимизация, и она называется Small Object Optimization (SOO). В большинстве случаев наши функциональные объекты маленькие, поэтому под них 
можно не выделять память динамически, редко бывает так что у нас функциональный объект больше чем например 16 байт, у нас же в большинстве случаев function содержит либо сишные функции, либо указатели на функции или методы, либо это 
лямбды, у которых что нибудь захвачено, но врядли много чего, редко бывает когда у нас функцтор это тяжёлый объект. Поэтому совершенно неразумно в function всё выделять через new. Эта оптимизация применимо не только к function, она очень
распространена, например в std::string. 

Мы хотим написать следующее, если sizeof от того что нам дали в конструктор или оператор присваивания меньше 16, то мы не будем делать new, а положим в локальный буффер. Для этого мы добавим свой буффер, выравненый под самый большой тип
потому что мы не знаем какой нам дадут тип. Теперь в конструкторе если у нас sizeof того, что нам дали меньше или равен размеру буффера, то мы не делаем new, мы просто записываем в этот буффер объект.

private:
	static const size_t BUFFER_SIZE = 16;
	Base* fptr;
	alignas(max_align_t) char buffer[BUFFER_SIZE ];
 
Это 1-ая оптимизация, которую объязательно нужно сделать в function. 2-ая мы хотим избавиться от виртуальных функций, потому что вызов функций был очень быстрым. Чтобы если мы в function сохранили сишный указатель, то вызов function это
был просто вызов этого сишного указателя, но сейчас у нас любой вызов функций через function это вызов виртуальной функции, мы не хотим этого, мы хотим чтобы вызов функции делался напрямую по указателю, поэтому мы хотим сделать type 
erasure по другому. А как можно сделать type erasure без виртуальных функций? Мы хотим убить двух зайцев, т.е. чтобы мы могли как-то хранить объект функтора в полях без виртуальных механизмов, но при этом знали бы куда идти если бы нас 
попросили вызвать. Предлагается просто запомнить указатель вручную, мы должны написать аналог vtable своими руками. Давайте когда создают объект function, мы запомним адрес метода call, запомним адрес метода копи конструктор, заппомним
адрес метода мув конструктор, запомним их всех и сохраним просто как указатели, и когда нас будут просить это сделать, мы будем делать call по этому указателю, скастив его обратно к типу, который нам нужен. Для примера покажем как будет
работать call:

private:
	static const size_t BUFFER_SIZE = 16;
	Base* fptr;
	alignas(std::max_align_t) char buffer[BUFFER_SIZE ];
	
	using invoke_ptr_t = Ret(*)(void*, Args...);
	invoke_ptr_t invoke_ptr;

И когда у нас создают функцию, мы запоминаем адрес по которому надо её вызывать. Нам нужно написать статические методы (invoke, copy, destroy ), которые мы будем вызывать, когда с хранящимся объектом мы будем делать соответствующее
действие. Мы храним указатель на тот самый оператор, который мы будем вызывать.

template <typename F>
static Ret invoker(F* fptr, Args... args) {
	return (*fptr)(std::forward<Args>(args)...);
}

Попробуем написать новый конструктор. invoke_ptr нужно проинициализировать адрессом статической функции, которая будет соответствовать данному типу. Т.е. по сути когда мы инициализируем invoke_ptr, мы просим его инстанцировать 
статический метод вот с таким f, с таким Args, и его адрес себе сохраняем. Также перепишем оператор круглые скобочки. Если sizeof func большой, то нужно сделать положить в динамическую память и сохранить указать в fptr, а если маленький,
то указатель fptr будет указывать на буффер. Однако теперь у нас неопределён деструктор. Раньше за счёт виртуальности delete правильно знал что ему удалять, а теперь delete от void* не понятно что удалить. Нам нужно отдельно завсести 
статическую функцию destroy. Теперь мы должны проинициализировать ещё и destroy_ptr, а чем? Нужно опять завести статическую функцию destroyer, в которой если sizeof func был маленьким, то нужно вызвать деструкор, а если был большим, то 
нам нужно ещё и освободить динамическую память.

template <typename T>
class function;

template <typename Ret, typename... Args>
class function<Ret(Args...)> {
private:
	static const size_t BUFFER_SIZE = 16;
	void* fptr;
	alignas(std::max_align_t) char buffer[BUFFER_SIZE ];
	
	using invoke_ptr_t = Ret(*)(void*, Args...);
	using destroy_ptr_t = void(*)(void*);

	invoke_ptr_t invoke_ptr;
	destroy_ptr_t destroy_ptr;

public:
	template <typename F>
	static Ret invoker(F* fptr, Args... args) {
		return (*fptr)(std::forward<Args>(args)...);
	}
	template <typename F>
	static void destroyer(F* fptr) {
		if constexpr (sizeof(F) > BUFFER_SIZE )
			delete fptr;
		else {
			fptr->~F();
		}
	}

	template <typename F>
	function(const F& func)
		: invoke_ptr(reinterpret_cast<invoke_ptr_t>(&invoker<F>))
		, destroy_ptr(reinterpret_cast<destroy_ptr_t>(&destroyer<F>))
	{
		if constexpr (sizeof(F) > BUFFER_SIZE ) {
			fptr = new F(func);
		} else {
			new (buffer) F(func);
			fptr = buffer;
		}
	}

	~function() {
		destroy_ptr(fptr);
	}

	Ret operator()(Args... args) const {
		return invoke_ptr(fptr, std::forward<Args>(args)...);
	}
};

int main() {
	function<int(int)> f = &square;
}

Тут нужно еще предусмотреть указатель на методы, поля, дальше нужно отдельно поддержать копирование и мув function, для всего этого нужны статические type erasure методы. По сути то что сейчас произошло, мы по сути создали таблицу 
виртуальных функций в каком то смысле. По сути набор статических методов, это и есть в каком то смылсе таблица виртуальных функций для типа F, ведь что такое vtable, это в статической памяти набор хранящихся указателей на методы. Мы по
сути это и сделали, мы опеределили статические методы и запомнили указатели на них, а когда мы подменили объект на объект другого типа, мы должны будем эти указатели все поменять на другие. Только есть проблема, если мы сейчас добавим
все эти указатели, то sizeof от объекта function будет очень большой. На самом деле мы хотим чтобы только invoke_ptr было быстрым, а все остальные указатели мы можем запрятать в динамическую область памяти. Мы можем создать нечто вроде
контрол блока и все остальные указатели запрятать туда, чтобы в нашем объекте они не лежали.

Нужно ли поддерживать кастомный аллокатор? Нет, начиная с С++17 поддержка кастомных аллокаторов была удалена, потому что разработчики компиляторов задолбались и компитет спустя 6 лет сдался и сказал окей не будем поддерживать 
нестандартные аллокаторы хахахах. 

Вы думаете на этом проблемы std::function закончились? Нет. Представим что у нас есть следующий функциональный объект. Он простой, но его смысл в том, что его нельзя копировать. Что будет если мы попробуем создать std::function от такого
объекта?

struct NotCopyable {
	std::unique_ptr<int> p{new int(5)};
	int operator()(int x) {
		return x + *p;
	}
};

int main() {
	std::function<int(int)> f = NotCopyable();
	f(5);
}

Будет CE, а почему? Объект, который мы кладём в std::function должен быть copy constructible, ведь мы же его нигде не копируем. Понятное дело если бы мы написали например auto f2 = f; было бы CE, ну нельзя скопировать, но почему мы даже
создать f от некопируемеого функтора не можем. Это не тривиально. В std::function хранятся в специальной обёртке хранятся указатели, и std::function при создании инстанцирует все эти статические функции invoker, destroyer, и т.д. в том
числе она инстаницрует и копирование и мувание. Т.е. даже не смотря на то, что мы не просим её ни разу копироваться, при создании объект function инстанцирует все эти статические методы и пытается сохранить указатели на них, но когда
он пытается инстанцировать статическую функцию копирования функцтора, он напарывается на CE, не смотря на то, что эту функцию мы не используем, инстанцировать её он пытается чтобы взять указатель на неё и сохранить, но не может, потому
что тамы вызывается копирующий оператор, а его нет. Отсюда следствие: std::function не поддерживает move-only типы и это печально, потому что это не такое уж и редкое свойство для функтора не быть копируемым. Комитет осознал проблему
и добавил класс std::move_only_function, который позволяет создавать функции и функциональные объекты от некопирующихся сущностей. 

После всех этих разговоров понятно почему std::function довольно нетривиальный класс.


_____________________________________________
std::bind и bind-objects

Существует ещё один вид callable - это bind expressions. Допустим у нас есть функция от двух аргументов, и мы хотим превратить её в функцию от одного аргумента с фиксированным первым или вторым аргументом например. Мы так уже делали с 
помощью лямьд, но есть другой способ это сделать - функция std::bind. В ней мы говорим название функции, а дальше мы можем перечислить какие аргументы мы в ней фиксируем, а в место каких, отдаём то, что нам передали в f:

int sum(int x, int y) {
	return x + y;
}

int main() {
	auto f = std::bind(sum, 5, std::placeholders::_1);

	std::cout << f(3);	// Выведет 8
}
std::bind это такая функция, которая берёт другую функцию или функциональный объект, а дальше зашивает аргументы по следующему правилу: те аргументы которые мы передали как константы, они фиксируются в вызове этой функции, а то что мы 
передали через std::placeholders::_1 _2 _3 и т.д. они становятся аргументами f, и подставляются на соответствующее место в sum. Т.е. в данном случае мы сказали что bind это функция одного аргумента (она всего один placeholder держит),
и вот тот аргумент который был первым передан в f, пойдёт вторым в sum.

Пример номер 2: 

int diff(int x, int y) {
	return x - y;
}

auto g = std::bind(diff, std::placeholders::_1, 5);

std::cout << g(3);

Здесь мы зафиксировали второй аргумент (т.е. в нашем случае 5), и вызвались от 3, результат получится -2. Как вы думаете во что превратилось auto, какой тип у g? Вот такой: std::_Bind<int (*(std::_Placeholder<1>, int))(int, int)>.
А что это за тип такой? Это указатель (* на функцию которая принимает (std::_Placeholder<1>, int) а возвращает функцию, которая принимает два инта (int, int) возвращающая инт <int. 

std::function умеет хранить в себе и std::bind тоже, потому что на выходе из std::bind мы получили функцию, которая принимает один int и возвращает один int, и вот такое мы можем сохранить в std::function int от int.

std::function<int(int)> g = std::bind(diff, std::placeholders::_1, 5);

А ещё можно с помощью std::bind менять порядок аргументов:

auto f = std::bind(sum, 5, std::placeholders::_1);
std::function<int(int)> h = std::bind(diff, std::placeholders::_2, std::placeholders::_1);
std::cout << h(4, 7);

Обычный diff дал бы нам -3, а сейчас выведется просто 3, потому что h это штука, которая вызывает f со свапнутными аргументами. 

Задача на дом: как реализован std::bind. Он реализуется стрёмно, через шаблонную магию. std::placeholders:: это некоторые именнованные константы, которых фиксированное кол-во, implementation defined [1, ..., N]. За счёт того, что их 
ограниченное число, в компайл тайме происходит подстановка на нужную позицию функции нужного по счёту аргумента. std::bind хранит в себе эти аргументы, а ещё он должен хранить указатель на функцию, которую он вызывает, с подставленными
этими аргументами.

Допустим мы хотим в std::bind зашить параметр, переданный по ссылке, а не скопированный, что нам тогда делать? Следующий фокус, как нам в std::bind (т.е. в создаваемый функциональный объект), сказать что мы хотим отдать не копию объекта, 
который мы хотим в него зашить, а ссылку? Чтобы изменение этого объекта из вне влияло на то, что подставляется в function. Если мы просто напишем x, то он просто сохранит этот int, и дальше когда мы меняем исходный int, это не влияет на
то что зашито в std::bind. Но что если мы хотим зашить в std::bind эту ссылку на x и её туда отдавать? Мы можем воспользоваться std::reference_wrapper:


int x = 5;
std::function<int(int)> g = std::bind(diff, std::placeholders::_1, std::ref(x));	// x передаём по ссылке с помощью std::reference_wrapper
std::cout << g(3) << '\n';								// Вывод -2
x = 1;											// Изменили x 
std::cout << g(3) << '\n';								// Вывод 2

Есть класс std::reference_wrapper, это такой объект, который является копируемой ссылкой, т.е. он хранит указатель на T, но умеет неявно каститься к ссылке на T. Мы можем в std::bind отдать не просто x, а std::reference_wrapper от x, и 
тогда по факту у нас сохранится указатель, но он будет неявно каститься к ссылке, поэтому когда мы будем от него вызываться, у нас будет всё нормально работать. А std::ref это просто функция, которая возвращает std::reference_wrapper на
данный тип. Есть ещё std::cref для константных ссылок.


_____________________________________________
Лирическое отступление std::string_view

Что такое std::string_view? Это просто using std::basic_string_view с параметром char. std::string_view это штука, которая представляет из себя строку, но не владеет строкой. т.е. это как бы наблюдение за строкой, сама память нам не 
принадлежит, мы через std::string_view можем смотреть что лежит в строке, т.е. это обёртка над строкой. Мы можем взять подстроку нашего std::string_view и получим опять std::string_view, и это всё работает за O(1). std::string_view
создаются от обычной строки. По сути std::string_view это просто пара указателей, указывающих на начало и конец строки, на которую мы можем смотреть. Если исходная строка поменялась, то мы тоже это увидим. Это простая штука, она 
появилась в C++17, а в C++20 появлась std::span - это тоже самое, только над произвольным T (span с англ. оболочка). std::span это штука, которая также позволяет наблюдать за диапазоном какого-то контейнера. Эта идея была развита в
C++20 в следующую мысль: мы вообще-то зачастую, когда хотим делать какие-то операции над диапазонами, мы не хотим менять исходные данные, мы просто хотим на них смотреть. Вот у нас есть обычный string_view, который нам позволяет 
посмотреть как выглядит строка, но мы могли бы например захотеть попросить reverse_view от строки, т.е. мы смотрим на кусочик строки только в обратную сторону, filter_view - смотрим на кусок строки, но с предикатом, например чтобы не
видить никаких символов, не удовлетворяющих условию, или sorted_view вообще. Т.е. строка она остаётся как была, а мы просто смотрим на неё через разные фильтры. Так мы приходим к идее views. У нас таких view много, но самое главное
что над ними определён оператор pipe (вертикальная черта |), который может из одного view передавать данные в другой. Это полезно для случая, когда нам нужно пропустит данные через несколько фильтров.


###################################
std::string_view — это фича C++17, которая представляет лёгкий, не-владеющий (non-owning) вид на последовательность символов. Простыми словами: это как const std::string&, но без overhead на копирование и без владения памятью.
Она делает работу со строками быстрее, безопаснее (меньше аллокаций) и удобнее. В современном коде почти все функции, которые только читают строку, должны принимать std::string_view.

Зачем это нужно?
До C++17 передача строки в функцию выглядела так:

void func(const std::string& s);  // может создать копию, если передать const char*
void func(std::string s);         // всегда копия — медленно!

Проблемы:
- Передача const char* или строки литерала в const std::string& могла вызвать выделение памяти (конструктор std::string).
- Передача подстроки (s.substr(0, 5)) создавала новую std::string с копированием данных.

std::string_view решает это: он просто хранит указатель на данные и длину, ничего не копирует и не владеет памятью.

Основные характеристики:
- Хранит const char* data() и size_t size().
- Не владеет памятью -> время жизни данных должен управлять вызывающий код.
- Очень дешёвый в копировании (как два указателя).
- Работает с любыми contiguous последовательностями char (std::string, char[], строковые литералы).


###
Примеры использования
#include <string_view>
#include <iostream>
#include <string>

void print(std::string_view sv) {  // лучший способ принимать "строку" на чтение
    std::cout << sv << '\n';
}

int main() {
    std::string s = "Очень длинная строка в куче";
    const char* c_str = "C-style строка";
    char arr[] = "массив символов";

    print(s);                			// не копирует, просто view на данные s
    print(c_str);            			// вид на строковый литерал
    print(arr);              			// вид на массив
    print("строковый литерал");  		// напрямую!

    // Подстрока без копирования
    std::string_view sub = s.substr(0, 6);  	// нет аллокации!
    print(sub);  				// выведет "Очень "

    // Удаление префикса/суффикса
    std::string_view sv = "   hello world   ";
    sv.remove_prefix(3);   			// "hello world   "
    sv.remove_suffix(3);   			// "hello world"
    print(sv);
}


###
Ключевые методы

std::string_view sv = "hello world";

sv.data()          				// const char* на начало
sv.size()          				// длина
sv.empty()         				// пустая?
sv.front() / sv.back()  			// первый/последний символ
sv.substr(pos, n)  				// новый string_view на подстроку (без копии!)
sv.starts_with("pre") / sv.ends_with("suf")  	// C++20
sv.contains("sub") 				// C++23


###
Когда использовать std::string_view
- Функция только читает строку:			std::string_view — идеально
- Нужно передать подстроку:			std::string_view — без копий
- "Парсинг, токенизация, логирование":		std::string_view везде!
- Нужно владеть данными или модифицировать:	std::string
- API возвращает строку на короткое время:	std::string_view (но осторожно с lifetime!)


###
Опасности: lifetime проблемы
Правило: время жизни данных, на которые смотрит string_view, должно быть не меньше времени жизни самого string_view.

std::string_view bad_func() {
    std::string s = "hello";
    return std::string_view(s);  // ОПАСНО! s уничтожается при выходе
}  // возвращаемый view висит в воздухе → UB при использовании

// Правильно:
std::string_view good_func(const std::string& s) {
    return std::string_view(s);  // ок, если s живёт дольше вызова
}


###
Преобразование в std::string

std::string_view sv = "hello";
std::string owned = sv;            	// явно: создаёт копию
std::string owned2(sv);            	// то же самое
std::string owned3 = sv.to_string();  	// C++20













