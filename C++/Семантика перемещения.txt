Move семантика

Move семантика - это механизм, который позволяет ресурсам быть "перемещёнными" из одного объекта в другой, вместо создания их копий. Это значительно уулучшает производительность 
программ, особенно когда работа идёт с большими данными или ресурсоемкими объектами. ВВедённая в C++11, move семантика использует два ключевых компонента: перемещающие конструкторы
и перемещающие операторы присваивания.


______________________________________________________________________________________
rvalue

В С++ используемые значения мы можем разделить на две группы: lvalue и rvalue. lvalue (locator value) представляет собой объект, который занимает идентифицируемое место в памяти
(например, имеет адрес), например, переменные, параметры, константы. С lvalue ассоциирован некоторый адрес в памяти, в котором на постоянной основе хранится некоторое значение,
и мы можем lvalue присвоить некоторое значение. 

А rvalue определено путём исключения, говоря, что любое выражение является либо lvalue, либо rvalue. Таким образом из определения lvalue следует, что rvalue — это выражение, 
которое не представляет собой объект, который занимает идентифицируемое место в памяти. rvalue - это то, что можно ТОЛЬКО присваивать, например литералы или результаты 
выражений.

int n = 5;

Здесь n представляет lvalue, а число 5 - rvalue. Подобные названия приняты, потому что n расположен слева от оператора присваивания (left value), а присваиваемое значение - 
число 5 справа от оператора присвоения (right value). Другой пример:

int n{5}
int k{n + 7};

Здесь n и k - lvalue, а 5 и выражение n + 7 - rvalue.

int var;
var = 4;

Оператор присваивания ожидает lvalue с левой стороны, и var является lvalue, потому что это объект с идентифицируемым местом в памяти. С другой стороны, следующие заклинания 
приведут к ошибкам:

4 = var;       // ERROR!
(var + 1) = 4; // ERROR!

Ни константа 4, ни выражение var + 1 не являются lvalue
(что автоматически их делает rvalue). Они не lvalue, потому что оба являются временным результатом выражений, которые не имеют определённого места в памяти (то есть они могут 
находится в каких-нибудь временных регистрах на время вычислений). Таким образом, присваивание в данном случае не несёт в себе никакого семантического смысла. Иными словами — 
некуда присваивать.


______________________________________________________________________________________
rvalue-ссылка

rvalue-ссылка может ссылаться на результат выражения, даже если этот результат представляет временное значение. Привязка к rvalue-ссылке продлевает время жизни такого временного
значения. Его память не будет удалена, пока rvalue-ссылка находится в области видимости.

Для установки ссылки rvalue применяются два амперсанда после имени типа:

int main()
{
    int n {5};
    int&& tempRef {n+3};                	// ссылка rvalue
    std::cout << tempRef << std::endl; 		// 8
}

В данном случае результат выражения n +3 сохраняется в памяти (в стеке), а ссылка tempRef будет представлять ссылку на это временное значение. Когда завершится функция main, 
соответственно завершится и область видимости переменной tempRef и будет удалено временное значение, на которое эта переменная ссылается. Стоит отметить, что tempRef, хоть и 
хранит ссылку на rvalue, само по себе также является lvalue.



______________________________________________________________________________________
Функция std::move

Основная задача этой функции преобразовать свои аргументы в rvalue (правое значение), которое м.б. использовано для перемещения, а не копирования объектов. Это полезно для 
оптимизации программ, особенно когда работа идёт с большими данными.Технически не перемещает ничего сама по себе. Она просто преобразует lvalue (левое значение, т.е. объект, имеющий
постоянный адресс в памяти) в rvalue, которое можно использовать для инициализации или присваивания другим объектам с помощью перемещающего конструктора или перемещающего оператора
присваивания.

#include <iostream>
#include <utility> // Для std::move()
#include <vector>

class HugeData {
public:
	std::vector<int> data; // Большой массив данных
	HugeData(int size) : data(size) {} // Конструктор
	
	//Перемещающий конструктор
	HugeData(HugeData&& other) noexcept : data(std::move(other.data)) {
		std::cout << "Перемещающий конструктор вызван" << std::endl;
	}	

	// Оператор перемещающего присваивания
	HugeData& operator=(HugeData&& other) noexcept {
		if(this != &other){
			data = std::move(other.data);
			std::cout << "Оператор перемещающего присваивания вызван" << std::endl;
		}
		return *this;
	}
	
	// Деструктор
	~HugeData() {}
};

int main() {
	HugeData resource1(10000); // Создаём большой объект

	HugeData resource2 = std::move(resource1); // Используем перемещающий конструктор
	return 0;
}

В этом примере, когда мы присваиваем resource1 к resource2 с использованием std::move(resource1), resource1 преобразуется в rvalue. Это позволяет компилятору использовать перемещающий 
конструктор HugeData, который передаёт внутренние данные из resource1 в resource2 без дорогостоящего процесса копирования. После перемещения resource1 остаётся в валидном, но 
неопределённом состоянии, что означает, что с ним можно безопасно работать, например присваивать новые значения или уничтожать объект. 

################

Второе объяснение:
Стоит отметить, что мы не можем установить ссылку rvalue на значение lvalue, например:

int n {5};
int&& tempRef = n;  // ! Так нельзя

Здесь n - lvalue, а ссылке rvalue мы можем только передать значение rvalue. Тем не менее в некоторых ситуациях может возникать необходимость преобразовать lvalue в rvalue. Для 
этого применяется встроенная функция std::move(), которая имеется по умолчанию в стандартной библиотеке C++:

int main()
{
    int n {5};
    int&& tempRef = std::move(n);   		// преобразуем int в int&&
    std::cout << tempRef << std::endl; 		// 5
}

Здесь значение переменной n преобразуется из типа int в тип int&& - rvalue-ссылку на int. В данном случае практического смысла в подобном преобразовании мало, но далее на 
примере конструктора перемещения мы посмотрим реальную пользу подобной функции.

Также стоит обратить внимание, что при преобразовании константного значения результатом является константная ссылка:

const int m{2};
const int&& mRef = std::move(m);    		// результат - константная ссылка



______________________________________________________________________________________
rvalue-ссылка как параметр функции

rvalue-ссылка может выступать в качестве параметра функции:

void print(std::string&& text)
{
    std::cout << text << std::endl;
}
 
int main()
{
    print("hello");
}


Чтобы указать, что параметр представляет rvalue-ссылку, после типа указываются два амперсанда &&. То есть здесь функция print принимает rvalue-ссылку на значение std::string. 
При вызове этой функции ей можно передать rvalue: 

print("hello");

Но нельзя передать lvalue, поэтому следующие строки НЕ скомпилируются:

std::string message = "hi world";
print(message);     // ! Ошибка - передаем lvalue

Однако мы могли бы применить опять же функцию std::move() и преобразовать переменную в rvalue:

print(std::move(message));



______________________________________________________________________________________
Возвращение rvalue из функции

При возвращении значения локальной переменной или параметра компилятор рассматривает значение как rvalue. Но если возвращаемое значение представляет переменную компилятор 
также может выполнять оптимизацию NRVO (named return value optimization):

void print(std::string&& text)
{
    std::cout << text << std::endl;
}
 
std::string defaultMessage()
{
    std::string message{"hello world"};
    return message;
}

int main()
{
    print(defaultMessage()); // передаем rvalue
}

Здесь функция defaultMessage возвращает rvalue, соответственно результат этой функции мы можем передать внутрь функции print. (Результат функции defaultMessage() передаётся в 
параметр функции print(std::string&& text). Вау! Применяемая оптимизация NRVO означает, что компилятор сохраняет объект результата непосредственно в памяти, предназначенной для 
хранения возвращаемого функцией значения. То есть после применения NRVO больше не выделяется память для отдельной автоматической переменной с именем message. То есть при 
выполнении этой программы создается только один объект std::string.

Аналогично происходит при сохранении во внешнюю переменную:

std::string defaultMessage()
{
    std::string message{"hello world"};
    return message;
}
int main()
{
    std::string text = defaultMessage();
    std::cout << text << std::endl;
}

Здесь также создается только один объект std::string.



______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________

Конструктор перемещения

Конструктор перемещения (move constructor) представляет альтернативу конструктору копирования в тех ситуациях, когда надо сделать копию объекта, но копирование данных 
нежелательно - вместо копирования данных они просто перемещаются из одной копии объекта в другую.

Пример проблемы:

#include <iostream>
  
class Message 										// класс сообщения
{
public:
    Message(const char* data, unsigned count) 						// обычный конструктор
    {
        size = count;
        text = new char[size];  							// выделяем память
        for(unsigned i{}; i < size; i++)    						// копируем данные
        {
            text[i] = data[i];
        }
 
        id = ++counter;
        std::cout << "Create Message " << id << std::endl;
    }
    // конструктор копирования
    Message(const Message& copy) : Message{copy.getText(), copy.size }  		// обращаемся к стандартному конструктору
    {
        std::cout << "Copy  Message " << copy.id << " to " << id << std::endl;
    }
     
    // деструктор
    ~Message()
    { 
        std::cout << "Delete Message "  << id << std::endl;
        delete[] text;  								// особождаем память
    }

    char* getText() const { return text; }
    unsigned getSize() const { return size; }
    unsigned getId() const {return id;}

private:
    char* text{};  									// текст сообщения
    unsigned size{};    								// размер сообщения
    unsigned id{};  									// номер сообщения
    static inline unsigned counter{};   						// статический счетчик для генерации номера объекта
};
//unsigned Message::counter = 0;
 

// класс мессенджера, который отправляет сообщение
class Messenger
{
public:
    Messenger(Message mes): message{mes}
    { }
    void sendMessage() const
    {
        std::cout << "Send message " <<  message.getId() << ": " << message.getText() << std::endl;
    }
private:
    Message message;
};


int main()
{
    Messenger telegram{Message{"Hello Word", 11}};
    telegram.sendMessage();
}


Здесь определен класс условного сообщения Message. Текст сообщения хранится в символьном указателе text. Также, чтобы был виден весь процесс создания/копирования/удаления 
данных в классе сообщения определена статическая переменная counter, которая будет увеличиваться с созданием каждого нового объекта. И текущее значение счетчика будет 
присваиваться переменной id, которая представляет номер сообщения. В конструкторе Message выделяем память для хранения текста сообщения, который передается через параметр - 
символьный массив, копируем данные в выделенную область памяти и устанавливаем номер сообщения. Для копирования данных в Message определен конструктор копирования. Также 
определен класс Messenger, который принимает в конструкторе сообщение и сохраняет его в переменную message. С помощью функции sendMessage мессенджер условно отправляет 
сообщение. В функции main создаем объект Messenger, передавая ему один объект сообщения, и затем вызываем функцию sendMessage. Обратите внимание, что в конструктор объекта 
Messenger здесь передается объект Message, который не привязан ни к какой переменной.

Вывод в консоль:
Create Message 1
Create Message 2
Copy  Message 1 to 2
Delete Message 1
Send message: Hello Word
Delete Message 2


Здесь мы видим, что в процессе работы программы создается два объекта Message, причем вовлекается конструктор копирования. Посмотрим по этапно.

1. Выполнение строки

Messenger telegram{Message{"Hello Word", 11}};

Приводит к выполнению конструктора Message, в котором строка "Hello Word" передается переменной text и устанавливает номер сообщения. Этот временный объект Message будет иметь 
номер 1. Соответственно на консоль выводится:

Create Message 1

2. Далее созданный объект Message передается в конструктор Messenger:

Messenger(Message mes): message{mes}

Обратите внимание на выражение message{mes}. Оно берет переданный в конструктор временный объект Message и с помощью конструктора копирования передает в переменную message его 
копию. Конструктор копирования Message в свою очередь обращается к стандартному конструктору:

Message(const Message& copy) : Message{copy.getText(), copy.size }

Создается объект Message номер 2. Стандартный конструктор выделяет память для строки. У нас получаются две копии, каждая из которых хранит указатели на разные участки памяти. 
То есть мы имеем две независимые копии, и на консоль будет выведено:

Create Message 2
Copy  Message 1 to 2
Delete Message 1

Теперь объект Messenger хранит второе сообщение. Первое, временное сообщение удаляется.

3. Далее вызывается функция sendMessage()

telegram.sendMessage();

Информация о хранимом в мессенджере сообщении выводится на консоль, и это сообщение по завершению работы функции main удаляется.

Send message: Hello Word
Delete Message 2



С точки зрения создания копий, выделения/управления/освобождения памяти вроде проблем никаких нет. Но мы видим, что выделенная память для первого сообщения в итоге все равно 
никак не использовалась. То есть мы по сути зря использовали эту память. Не было бы лучше, если бы вместо выделения нового участка памяти для второго сообщения, мы могли бы 
просто передать ему память, которая уже выделена для первого сообщения? Первое же сообщение все равно удаляется. И для решения этой проблемы как раз используются конструкторы 
перемещения.

Конструктор перемещения принимает один параметр, который должен представлять ссылку rvalue на объект текущего типа: Здесь параметр moved представляет перемещаемый объект.

MyClass(MyClass&& moved) 		// ссылка rvalue
{
    // код конструктора перемещения
}



Изменим выше приведенный код, применив конструктор перемещения в классе Message:

// класс сообщения
class Message
{
public:
    Message(const char* data, unsigned count) 						// обычный конструктор
    {
        size = count;
        text = new char[size];  							// выделяем память
        for(unsigned i{}; i < size; i++)    						// копируем данные
        {
            text[i] = data[i];
        }
 
        id = ++counter;
        std::cout << "Create Message " << id << std::endl;
    }
    // конструктор копирования
    Message(const Message& copy) : Message{copy.getText(), copy.size } 	 		// обращаемся к стандартному конструктору
    {
        std::cout << "Copy  Message " << copy.id << " to " << id << std::endl;
    }
    Message(Message&& moved)								// конструктор перемещения
    {
        id = ++counter;
        std::cout << "Create Message " << id << std::endl;
 
        text = moved.text;  								// перемещаем текст сообщения
        size = moved.size;  								// перемещаем размер сообщения
        moved.text = nullptr;
        std::cout << "Move Message " << moved.id << " to " << id << std::endl;
    }
    // деструктор
    ~Message()
    { 
        std::cout << "Delete Message "  << id << std::endl;
        delete[] text;  								// особождаем память
    }
    char* getText() const { return text; }
    unsigned getSize() const { return size; }
    unsigned getId() const {return id;}
private:
    char* text{};  									// текст сообщения
    unsigned size{};    								// размер сообщения
    unsigned id{};  									// номер сообщения
    static inline unsigned counter{};   						// статический счетчик для генерации номера объекта
};
//unsigned Message::counter = 0;
 
// класс мессенджера, который отправляет сообщение
class Messenger
{
public:
    Messenger(Message mes): message{std::move(mes)}
    { }
    void sendMessage() const
    {
        std::cout << "Send message " <<  message.getId() << ": " << message.getText() << std::endl;
    }
private:
    Message message;
};
int main()
{
    Messenger telegram{Message{"Hello Word", 11}};
    telegram.sendMessage();
}



По сравнению с предыдущим кодом здесь сделаны два изменения. Прежде всего в класс Message добавлен конструктор перемещения:

Message(Message&& moved)
{
    id = ++counter;
    std::cout << "Create Message " << id << std::endl;
 
    text = moved.text;  // перемещаем текст сообщения
    size = moved.size;  // перемещаем размер сообщения
    moved.text = nullptr;
    std::cout << "Move Message " << moved.id << " to " << id << std::endl;
}

Здесь параметр moved представляет перемещаемый объект. Мы не вызваем стандартный конструктор, как в случае с конструктором копирования, потому что нам не надо выделять память. 
Вместо этого мы просто передаем в переменную text значение указателя (адрес блока выделенной памяти) из перемещаемого объекта moved:

text = moved.text;

Таким образом мы избегаем ненужного дополнительного выделения памяти. И чтобы указатель text перемещаемого объекта moved перестал указывать на эту область памяти, и 
соответственно чтобы в деструкторе объекта moved не было ее освобождения, передаем указателю значение nullptr.

Другой важный момент - в конструкторе Messenger при копировании объекта используем встроенную функцию std::move(), которая имеется в стандартной библиотеке С++:

Messenger(Message mes): message{std::move(mes)}
    { }

Функция std::move() преобразует переданное значение в ссылку rvalue. Несмотря на свое название, эта функция ничего не перемещает.

Выражение message{std::move(mes)} фактически приведет к вызову конструктора перемещения, в который будет передан параметр mes. А результат конструктора перемещения будет 
присвоен переменной message. 


Если бы конструктор перемещения не был бы определен, то выражение message{std::move(mes)} вызывало бы конструктор копирования.Таким образом, также создается два объекта, но 
теперь мы уходим от ненужного выделения памяти и копирования значения. Как правило, перемещаются объекты, которые больше не нужны, как в примере выше. Стоит отметить, что
компилятор сам компилирует по умолчанию конструктор перемещения, который перемещает значения всех нестатических переменных. Однако если мы определяем деструктор или конструктор 
копирования или оператор присваивания с копированием или перемещением, то компилятор не генерирует стандартный конструктор перемещения.



______________________________________________________________________________________
Оператор присваивания с перемещением

Оператор присваивания с перемещением (move assignment operator) призван решать те же задачи, что и конструктор перемещения. Подобный оператор имеет следующую форму:

MyClass& operator=(MyClass&& moved)
{
    // код оператора
    return *this; // возвращаем текущий объект
}


В качестве параметра передаем перемещаемый объект в виде rvalue-ссылки. В коде оператора выполняем некоторые действия.


class Message 											// класс сообщения
{
public: 
    Message(const char* data, unsigned count) 							// обычный конструктор
    {
        size = count;
        text = new char[size];  								// выделяем память
        for(unsigned i{}; i < size; i++)    							// копируем данные
        {
            text[i] = data[i];
        }
 
        id = ++counter;
        std::cout << "Create Message " << id << std::endl;
    }
    
    Message& operator=(const Message& copy) 							// обычный оператор присваивания
    {
        std::cout << "Copy assign message " << copy.id << " to " << id << std::endl;
        if (&copy != this)  									// избегаем самоприсваивания
        {
            delete text;        								// освобождаем память текущего объекта
            // копируем данные по указателю из перемещаемого объекта в текущий
            size = copy.size;
            text = new char[size];  								// выделяем память
            for(unsigned i{}; i < size; i++)    						// копируем данные
            {
                text[i] = copy.text[i];
            }
        }
        return *this;	 									// возвращаем текущий объект
    }
    // опрератор присваивания с перемещением
    Message& operator=(Message&& moved)
    {
        std::cout << "Move assign message " << moved.id << " to " << id << std::endl;
        if (&moved != this)     								// избегаем самоприсваивания
        {
            delete text;        								// освобождаем память текущего объекта
            text = moved.text;  								// копируем указатель из перемещаемого объекта в текущий
            size = moved.size;
            moved.text = nullptr; 								// сбрасываем значение указателя в перемещаемом объекте
            moved.size = 0;
        }
        return *this; 										// возвращаем текущий объект
    }
    // деструктор
    ~Message()
    { 
        std::cout << "Delete Message "  << id << std::endl;
        delete[] text;  									// освобождаем память
    }
    char* getText() const { return text; }
    unsigned getSize() const { return size; }
    unsigned getId() const {return id;}
private:
    char* text{};  										// текст сообщения
    unsigned size{};    									// размер сообщения
    unsigned id{};  										// номер сообщения
    static inline unsigned counter{};   							// статический счетчик для генерации номера объекта
};
 
int main()
{
    char text1[] {"Hello Word"};
    Message hello{text1, std::size(text1)};
 
    char text2[] {"Hi World!"};
    hello = Message{text2, std::size(text2)};   						// присваивание объекта
    std::cout << "Message " <<  hello.getId() << ": " << hello.getText() << std::endl;
}



В операторе присваивания получаем перемещаемый объект Message, удаляем ранее выделенную память и копируем значение указателя из перемещаемого объекта:

Message& operator=(Message&& moved)
{
    std::cout << "Move assign message " << moved.id << " to " << id << std::endl;
    if (&moved != this)     // избегаем самоприсваивания
    {
        delete text;        // освобождаем память текущего объекта
        text = moved.text;  // копируем указатель из перемещаемого объекта в текущий
        size = moved.size;
        moved.text = nullptr; // сбрасываем значение указателя в перемещаемом объекте
        moved.size = 0;
    }
    return *this; // возвращаем текущий объект
}

В функции main присваиваем переменной hello объект Message:

char text2[] {"Hi World!"};
hello = Message{text2, std::size(text2)};

Стоит отметить, что, как и в случае с конструктором перемещения, присваиваемое значение представляет rvalue - временный объект в памяти (Message{text2, std::size(text2)};), 
который после выполнения операции (присовения) будет не нужен. И это как раз идеальный случай для применения оператора присваивания с перемещением. Консольный вывод данной 
программы:

Create Message 1
Create Message 2
Move assign message 2 to 1
Delete Message 2
Message 1: Hi World!
Delete Message 1

Как видно, переменная hello представляет объект Message с номером 1. Стоит отметить, что если в классе определено несколько операторов присваивания (стандартный и присваивание 
с перемещением), то по умолчанию для rvalue будет применяться оператор присваивания с перемещением. При присвоении lvalue будет применять стандартный оператор присвоения (без 
перемещения):

Message hello{"Hello Word", 11};
Message hi{"Hi World!", 10};
hello = hi; // присвоение lvalue - обычный оператор присваивания
hello = Message{"Hi World!", 10}; // присвоение rvalue - оператор присваивания с перемещением

Стоит отметить, что мы можем применить функцию std::move() для преобразования lvalue в rvalue:

Message hello{"Hello Word", 11};
Message hi{"Hi World!", 10};
hello = std::move(hi); // преобразование lvalue в rvalue - оператор присваивания с перемещением

Здесь переменная hi преобразуется в rvalue, поэтому при присвоении будет срабатывать оператор присвоения с перемещением. Стоит отметить, что компилятор сам компилирует оператор 
присваивания с перемещением по умолчанию, который перемещает значения всех нестатических переменных. Однако если мы определяем деструктор или конструктор копирования или 
конструктор перемещения или оператор присваивания, то компилятор не генерирует стандартный оператор присваивания с перемещением.



______________________________________________________________________________________
std::unique_ptr и перемещение значений

Поскольку smart-указатель std::unique_ptr уникально указывает на определенный адрес памяти, не может быть двух и более указателей std::unique_ptr, которые указывают на один и 
тот же участок памяти. Именно поэтому у типа unique_ptr нет конструктора копирования и оператора присваивания с копирования. Соотвественно при попытки их применить мы столкнемся
с ошибками компиляции:

#include <iostream> 
#include <memory>
 
int main()
{
    std::unique_ptr<int> one{ std::make_unique<int>(123) };
    std::unique_ptr<int> other;
    // other = one;             				// Ошибка! оператор присваивания с копированием отсутствует 
    // std::unique_ptr<int> another{ other }; 			// Ошибка! конструктор копированием отсутствует 
}

Однако unique_ptr имеет конструктор перемещения и оператор присвоения с перемещением, которые при необходимости перемещения данных из одного указателя в другой можно использовать

#include <iostream> 
#include <memory>
 
int main()
{
    std::unique_ptr<int> one{ std::make_unique<int>(123) };
    std::unique_ptr<int> other;
    other = std::move(one);         				// оператор копирования с перемещением
    // std::cout << *one << std::endl;  			// Данные из one перемещены в other
    std::cout << *other << std::endl;   			// 123
    std::unique_ptr<int> another{ std::move(other) }; 		// конструктор перемещения
    std::cout << *another << std::endl; 			// 123
}

Стоит отметить, что после того, как мы переместим значение из указателя, мы не сможем получить значения по данному указателю.



______________________________________________________________________________________

























