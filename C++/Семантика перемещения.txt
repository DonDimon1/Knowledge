Move semaintics and rvalue references (C++11) Лекция 38 46.00

###################################
Idea of move-semantics, Rule of five 

##################
Понимание проблемы:

Рассмотрим push_back в вектор:

vector<string> v;
v.push_back("abc");

Вопрос: сколько строк создаётся от такой операции? "abc" это const char[]*, мы кладём в вектор строк вещь такого типа. У нас push_back имеет следующую сигнатуру: void push_back(const T& value), 
здесь T это string, т.е. когда мы так пишем аргумент в функции это (const string&), и здесь получается константная ссылка на стринг, и мы её инициализируем сишной строкой "abc". В этот момент
создаётся временная строка (Сишная строка конвертируется в объект std::string), к которой привязывается эта константная ссылка как к временному объекту. Дальше в реализации push_back 
рано или поздно мы доходим до момента когда вызывается placement new: new(arr + n) T(value). Здесь создаётся T(value) от предыдущего const T& value в вызове push_back. T это string, value это 
тоже string, т.е. создаётся второй string из первого string. У нас был string который создался для того, чтобы быть переданным из сишной строки "abc" в аргумент push_back(const T& value), а потом 
из него создался второй string new(arr + n) T(value), который положился в вектор, а этот временный стринг в (const T& value) уничтожился. Это кажется не очень эффектнивно. 

Главная проблема в том что кажется что у нас нет способа избежать этого. Как нам научиться класть в вектор объекты так, чтобы не копировать второй раз? Это работает не только с вектором, а со 
всеми контейнерами при добавлении в них чего угодно не тривиального(для тривиальных это неактуально, например для int). Например если мы передаём не стринг а вектор векторов (кладём в 
ветктор ещё один вектор) всё тоже самое, у нас будет создаваться временный вектор чтобы привязаться к константной ссылке, а потом будет создаваться новый вектор из этого временного вектора,
который мы только что создали. В этом и вопрос нахрена мы создавали временный вектор, почему его нельзя сразу положить и сохранить? 

И даже если мы напишем так: v.push_back(string("abc")); - это не поможет, это будет всё тоже самое, потому что этот стринг также будет привязываться к константной ссылке const T& value, 
просто теперь конверсия станет явной, но ничего не изменилось, потому что на моменте new(arr + n) T(value) создастся ещё один стринг из нашего изначального стринга, и всё ровно будет два
создания стринга.


Есть такая функция emplace_back() (и её аналоги в других контейнерах), которая частично решает проблему. Эта функция принимает не объект T, а аргументы из которых создаёт T на месте. 

template <typename... Args>
void emplace_back(const Args&... args) {
	// Она делает всё тоже самое что и push_back, но когда дело доходит до создания объекта, она говорит не new T от другого T, а new T от этих Args.
	new (ptr) T(args...);	//Т.е. объект создаётся один раз.
}

И в случае если бы мы написали emplace_back("abc"), в (const Args&... args) принялся бы const char* и в new создалась бы string от этой const char*, т.е. реально объект string создался бы только один.
Однако глобально проблему это не решает, это заметание проблемы под ковёр а не её решение, мы просто спустили проблему на уровень глубже. Здесь это работает, а что если у нас вектор 
векторов векторов? Если у нас вектор стрингов, то это работает и мы не будем создавать промежуточные стринги, но если у нас вектор векторов стрингов, то мы не будем создвать промежуточный
вектор стрингов, но всё ровно будем создавать промежуточный стринг когда будем принимать их в аргументе void emplace_back(const Args&... args). 

Эта проблема существует не только при добавлении в контейнер, а при вообще любом сохранении данных. Если у нас есть класс, который в себе хранит какие либо данные, и мы пытаемся в него
эти данные передать и сохранить в нём, мы сталкиваемся с той же самой проблемой. Представим класс S в котором есть поле string, и мы хотим уметь создавать класс S от этой string. Для этого мы 
либо принимаем по значению и копируем сразу же, либо принимаем по ссылке или константной ссылке, но чтобы мы не сделали, сейчас мы не можем избавиться от промежуточной строки.
Сейчас мы не можем создать такой класс, чтобы он умел создаваться от строки const string& и сохранять её в себе и при этом не создавать промежуточную строку, т.е. проинициализировать строку
data строкой "abc". В данном случае у нас будет создана первая строка для того чтобы привязать константную ссылку const string& и только потом из неё будет создана вторая строка data. 

struct S {
	string data;
	S(const string& str): data(str) {}
};

int main() {
	S s("abc");
}


Ещё одна проблема это проблема с исключениями. Когда мы пишем:
string s("abc");
throw s;

мы создаём локальный объект и потом его пытаемся бросить, нам нужно его переложить в динамическую память, но для этого его нужно скопировать. Почему здесь нельзя сделать чтото более 
умное, нежели просто скопировать? Мы хотим чтобы в таких ситуациях можно было не копировать объекты, а делать нечто более умное. 


################
Решение проблемы:

Для своих классов можно определить не только копи конструктор, а ещё и мув конструктор. Семантика будет примерно такой же, у нас всё ещё будет создаваться промежуточная строка в 
(const string& str) и из неё будет создана строка data, но эта строка data будет создана не путём того, что мы полностью скопируем данные строки str, а путём того что мы заберём у str владение 
данными и отдадим владение этими данными строке data. Т.е. мы не будем концептуально менять порядок того, что из чего создаётся, мы просто хотим чтобы у нас была возможность создавать
объекты из других объектов не полностью копируя их, а забирая данные и оставляя их пустыми. Скопировать вектор занимет O(n), а мувнуть занимает O(1), потому что мувнуть это значит просто
забрать его поля себе, а у него оставить пустыми. Тоже самое и у строки, мы можем у string забрать себе его поинтер на массив, а сам string оставить пустым. Т.о. эта проблема решиться и мы 
сможем например в push_back() не создавать вторую полноценную строку, а просто создать первую строку, а при вызове оператора new, мувать эту строку а не копировать. Т.е. будет создано
также две строки, но вторая будет создана мувом а не копией. 


Введём мув операции для объекта. Для всех стандартных типов они уже определены и работают корректно и на самом деле в реализациях стандартных векторов и стандартных строк не создаются
копии а происходит мув. Напримере класса string определим мувающие операции. Мы берём другую строку, её поля зануляем, а себе забираем то что у неё лежало. Если научить компилятор в 
нужных моментах вызвать эту операцию вместо копирования, то мы победили и решили нашу проблему. Т.е. мы опишем для нашего класса как делать мувающие операции, и дальше нужно будет
разобраться когда компилятор должен их вызывать, а когда не должен.

Рассмотрим код ниже:
Новый вид конструктора - мув конструктор:
string(string&& other)

Мув конструктор принимает тип string&&. Пока что оставим это как есть, не будем объяснять что это. Поверим что если написать именно так, то будет как надо. 

Когда мы создали стринг из другого стринга, неважно путём мува или копирования, тот стринг всё ещё продолжает существовать и вызов его деструктора никто не отменял. Поэтому нам 
обязательно нужно сделать other.arr = nullptr, чтобы когда в той строке вызывался деструктор, у нас не случилось двойного удаления. Так же нам нужно сказать что other.sz = other.cap = 0, потому
что мы хотим оставить объект other в консистентном состоянии, он должен быть пустым, поскольку им можно будет пользоваться дальше. Когда мы забираем данные, мы хотим обнулить объект,
поскольку в объекте теперь нет данных, на вопрос, сколько байт в строке other, строка other должна отвечать правильно. Тот объект, который мувнули, не перестаёт быть валидным. 

В опереаторе перемещения удаляем свой массив чтобы небыло утечки памяти, а потом присваиваем всё как в обычном операторе присваивания, не забывая обнулять объект other. 

class string {
	char* arr;
	size_t sz;
	size_t cap;
	// Копи конструктор: string(const string& other)
	// Оператор присваивания (copy assigment operator)

	// Добавим в класс string move конструктор и move assigment operator. Это операции описывающие как забрать у другого объекта владение, оставив его пустым, а себе данные присвоить. 
	// Мув конструктор
	string (string&& other): arr(other.arr), sz(other.sz), cap(other.cap) {
		other.arr = nullptr;					// Чтобы не случилось двойного удаления в строке other
		other.sz = other.cap = 0;				// Оставляем остроку(объект) other в корректном состоянии. Данных там больше нет, поэтому sz и cap должны быть 0.
	}
	
	// Оператор перемещения (move assigment operator)
	string& operator=(string&& other) {	
		delete[] arr;						// Перед присваиванием чужого массива, свой массив нужно удалить, стобы небыло утечки памяти. 	
		arr = other.arr; other.arr = nullptr;			// Всё присваиваем как в обычном операторе присваивания. Забираем чужие поля себе, а у other обнуляем их.
		sz = other.sz; other.sz = 0;
		cap = other.cap; other.cap = 0;
		return *this;
	
		// Здесь мы забыли обработать ситуацию присваивания самому себе
	}
};

Если компилятор в нужные моменты будет вызывать мув конструктор а не копи конструктор и оператор перемещения вместо обычного оператора присваивания, то у нас всё будет хорошо и у нас
не будут создаваться лишние строки. Теперь нам нужно понять когда же вызывается этот конструктор, а когда вызывается обычный копи конструктор. Ответ на этот вопрос будет дан позднее. 


################
Rule of five 

У нас есть праивло 3: Если у нас в класс есть нетривиальный копи конструктор или копи оператор присваивания или нетривиальный деструктор, то значит нужно реализовать все эти три метода 
обязательно. К правилу трёх мы добавили ещё 2 новых метода: мув конструктор и оператор перемешения, которые подчиняются этому же правилу: если реализован один из этих методов, то нужно 
реализовать все эти 5 методов. 

Тривиальный мув конструктор так же как и все остальные можно сделать = default. Дефолтный мув конструктор просто поэлементно будет вызывать мув конструкторы полей, а в случае если поля
будут не классами а просто обычными типами, то это будет просто обычное присваивание. Для примитивных типов типа int, мув ничем не отличается от копирования, мув конструирование и 
мув присваивание примитивных типов это всё ровно что их копирование. При этом other он не зануляет! Но если у нас классовые типы в полях, то для них будут вызваны мув конструкторы. 

Соответственно если мы напишем для класса string мув конструктор дефолтным: string (string&& other) = default, то это будет работать так, что просто поэлментно будут муваться поля, а поскольку
все поля тривиальные, это значит что посути это будет просто копирование полей, и поэтому дефолтный мув конструктор для string будет работать некорректно потому что он будет работать
также как и дефолтный копи конструктор. При этом other не зануляется. Для указателей он просто копирует указатель(сам указатель а не данные на которые он ссылается), поэтому для строк,
векторов и вообще для любых типов у которых нетривиальное копирование не подходит дефолтный мув конструктор и оператор перемещения, потому что у нас может получиться ситуация, когда 
два указателя указывают на один и тот же объект. Если тип такой, что копирование для него будет нетривиальным, то и мув для него будет нетривиальным. 

Если вообще не писать мув конструктор и мув оператор присваивания(перемещения) и тогда мув будет работать как копирование. Это обратная совместимость с C++3. Если есть хоть один 
нетривиальный нами написанный копи конструктор, копи оператор присваивания и возможно даже нетривиальный деструктор, то компилятор не генерирует за нас дефолтный мув конструктор и
мув оператор перемещения. Если мы вообще ничего не написали из этих 5 методов, то тогда компилятор сам допределит стандартные мув операции. 


################
Бывают типы которые можно мувать, но копировать нельзя. Можно запретить своему типу копирующие операции и написать только мувающие операторы. Пример: std::unique_ptr. 


_____________________________________________
Mystic function std::move

Как компилятор понимает когда вызывать мувающую операцию а когда копирующую? Короткий ответ: Если компилятор видит что вы вызываетесь от rvalue, то он автоматически вызывает 
мувающую операцию если можно, а от lvalue вызывает копирующую операцию. Однако можно принудительно заставить вызвать мувающую операцию и для этого есть функция std::move().

Функция std::move() это штука, которая позволяет вызвать мувающую операцию, несмотря на то что объект был lvalue. С помощью этой функции мы решим все проблемы описанные в предыдущей
главе.

Вернёмся к предыдущему примеру:

struct S {
	string data;
	S(const string& data): data(std::move(data)) {}
};

Когда мы хотим чтобы строка data была не скопирована а перемещена,  мы говорим: проинициализируйся не от этой строки, а от std::move от этой строки. std::move заставляет компилятор выбрать
мувающую версию а не копирующую. Однако в этом случае это не сработает и здесь всё ровно будет копирования, потому что здесь написан const. Мувающая версия не подойдёт, поскольку
она принимает неконстантный тип, и даже несмотря на то, что мы компилятор попросим мувнуть явно, он не сможет, потому что он не сможет выбрать мувающую версию. Для того чтобы 
компилятор смог нужно в конструкторе тоже принять по специальной ссылке &&. По такой ссылке мы можем сначала принять rvalue, а уже потом мувнуть. 

struct S {
	string data;
	S(const string& data): data(data) {}			// Конструктор копирования, которую нельзя мувнуть из-за const 
	S(string&& data): data(std::move(data)) {}		// Конструктор перемещения 
};

int main() {
	string a = "abc";
	S s(a);			// Вызов от lvalue, будет вызван конструктор копирования.
	S s2("abc");		// Вызов от rvalue, будет вызван конструктор перемещения.
}

Если мы передаём обычную строку, т.е. lvalue, то всё будет работать как раньше и выберется первый конструктор (копирования). А если мы вызовемся от rvalue, т.е. от временной строки, мы 
попадём во второй конструктор (перемещения).  Для объектов lvalue мы будем их честно копировать, для объектов rvalue мы будем их мувать. Т.е. если мы принимаем в конструкторе тип string&&, 
то вызываясь от rvalue мы попадаем в этот конструктор (перемещения), и тогда будет выполнен мув data(std::move(data)). Когда мы делаем data(std::move(data)) мы в конструкторе уже самой строки
тоже попадаем в мувающую версию, и поле data в структуре S инициализируется мувом а не копированием. 

Вообщем роль std::move это перенаправить перегрузку функции по другому пути, по умолчанию, когда мы вызываемся от какого-то объекта, мы идём по пути копирования, а std::move это способ
перенаправить нас в перегрузку мува. std::move тоже возвращает тип с двумя амперсандами &&. Т.е. чтобы мы не дали в std::move, он вернёт такой тип, что перегрузка пойдёт по пути мува. 


################
Для решения проблемы с push_back() теперь нам нужно два push_back(): один для const T&, второй для T&&. В настоящей реализации STL так и есть:

void push_back(const T& value) {	// Здесь написано всё что было написано раньше
	// ...
	new (ptr) T value;		//  Так было раньше
}

void push_back(T&& value) {		// Дописываем второй push_back()
	// ...
	new (ptr) T (std::move(value));	// Единственное чем отличаются эти два push_back.
} 

В первый push_back мы будем попадать если делаем push_back обычной переменной, а во второй push_back мы будем попадать если мы делаем push_back временного объекта. 


################
Проблема с бросанием исключений решена автоматически сама собой. Начиная с C++11 когда мы пишем 

string s = "abc";
throw s;

по возможности вызывается move конструктор, а не копи конструктор. Для стандартных типов (в том числе и std::string), и для любого объекта, который поддерживает мув операции будет 
вызываться мув в этой ситуации, потому что понятно что нет смысла копировать временный объект "abc", потому что он сейчас будет уничтожен. В прошлых примерах с исключениями вызывалось 
копирование потому что, были написаны нетривиальный конструктор копирования, но не написали конструктор мувания, поэтому по умолчанию вызывался конструктор копирования. 


################
Очень важный пример: функция std::swap().

Очень плохая реализация функции swap:

template <typename T>
void swap(T& x, T& y) {
	T tmp = x;
	x = y;
	y = tmp;
}  

Плохая эта реализиция потому что, если T это хотябы std::string, то это работает за трижды линейное время, потому что в каждой строке есть операция полного копирования.  Используя мув 
семантику мы можем написать функцию std::swap() универсально для любого типа:

template <typename T>
void swap(T& x, T& y) {
	T tmp = std::move(x);
	x = std::move(y);
	y = std::move(tmp);
}  

Теперь это будет работать за константное время, при условии что тип T поддерживает move-семантику.


###########################
Реализация функции std::move которая работает правильно в 90% случаев:
Эти случаи покрывают всё то, что мы ранее обсудили. Для большинства практических приложений эта реализация сгодится.

Главные вопросы: что нам нужно принять, и что нам нужно вернуть?

template <typename T>
T&& move(T& x) {
	return  static_cast<T&&>(x);
}		

Чтобы получить из x тип T&&, нам нужно сделать явный static_cast. Роль move в том, чтобы принять обычную ссылку на x и вернуть ссылку с двумя амперсанДами (пишется через Д). Но из обычной
ссылки в ссылку с двумя амперсандами неявного каста небывает, и поэтому нам нужно сделать явный каст. И на самом деле вместо std::move можно везде писать static_cast<T&&> это будет
эквивалентно. Есть мнение что название move не очень удачно, оно вводит в заблуждение. std::move никого никуда не двигает, move это просто каст к rvalue. Возможно было бы лучше назвать
его rvalue_cast, потому что по сути это явный каст к rvalue.

Вопрос на понимание: Что если мы напишем так?

string s = "abc";
std::move(s);

Ответ: ничего не произойдёт. Если мы просто вызвали std::move от объекта и ничему это не присвоили то ничего не произойдёт и с объектом ничего не случится, потому что сама функция std::move
ничего не делает с объектом. Поскольку std::move это по сути static_cast, то эта функция не выполняет никаких инструкицй в рантайме, она имеет смысл только на этапе компиляции. В рантайме
это 0 действий, поэтому в рантайме std::move для процессора не означает никаких инструкций. 


Несколько упражнений:
1) Что было бы если бы мы в (T& x)  не поставили амперсанд?

template <typename T>
T&& move(T x) {					// Лишние копирование. В этой реализации вызыв move всегда бы требовал лишние копирование объекта. Так же он бы возвращал бы битую ссылку, потому 
	return  static_cast<T&&>(x);		// что мы бы возвращали ссылку на временный объект, который до этого зачем то скопировали. 
}	


2) Возврат без двух &&
template <typename T>
T move(T& x) {					// Мув возвращал бы rvalue, но уже на момент возврата из мува должен был быть вызван мув конструктор, потому что мы возвращаем новый объект T, 
	return  static_cast<T&&>(x);		// создавая его из rvalue типа T, это бы означало, что сам по себе вызов функции move уже бы означал вызов мув конструктора, потому что мы создаём новый
}						// T уже из мувнутого T в момент возврата. Но move сам не должен вызвать другой конструктор, он должен просто перенаправить в другой конструктор.



_____________________________________________
Формальное определение lvalue и rvalue (Formal definitions of lvalue and rvalue)

Самое главное что нужно знать про lvalue и rvalue! ! ! ! !
Lvalue and rvalue are categories of expressions, not type.
Lvalue и rvalue это категории выражений а не типов, т.е. это виды выражений. Некорректен вопрос каким value обладает какой нибудь тип. Типы сами по себе не обладают ни каким value, только
выражения обладают каким либо видом value. Каждое выражение обладает двумя независимыми свойствами: типом и видом value. Только для выражения имеет смысл спрашивать какой это вид value.

В частности например если спрашивают является ли int&& rvalue?. Это не какое value, потому что нельзя спрашивать про тип, только выражения бывают value. 
Философски lvalue это то что лежит в памяти, а rvalue то что не обязательно в памяти лежит.

Вид value должен быть известен в компайлтайме.

Выражение - это синтаксическая конструкция, которая состоит из индефикаторов(названий переменных) и литералов, соединенных операторами и скобочками. Все инструкции бывают либо экспрешинами, 
либо дикларейшинами, либо контрол стейтамоми.




Оффтоп: Что такое литерал в C++?
Литерал — это фиксированное значение, записанное прямо в коде. Оно представляет собой конкретные данные, которые компилятор интерпретирует как значения определенного типа.

Виды литералов в C++:
1. Целочисленные литералы (Integer literals): 
	42        // int
	0x2A      // 16-ричное число (42 в десятичной системе)
	0b101010  // двоичное число (42 в десятичной системе)
	052       // 8-ричное число (42 в десятичной системе)
	1'000'000 // Разделители для удобства чтения (равно 1000000)

2. Числа с плавающей запятой (Floating-point literals)
	3.14      // double
	2.5f      // float
	6.02e23   // 6.02 ? 10^23 (double)
	1.5L      // long double

3. Символьные литералы (Character literals)
	'A'       // char
	'\n'      // символ новой строки
	'\x41'    // символ 'A' (16-ричное значение)

4. Строковые литералы (String literals)
	"Hello, world!"    	// const char[]
	"Hello" " " "world!"  	// Конкатенация строковых литералов

5. Литералы булевых значений (Boolean literals)
	true   // 1
	false  // 0

6. Литерал типа nullptr
	nullptr  // Указатель на "ничто" (аналог NULL)

7. Литералы для std::string (C++11)
	using namespace std::string_literals;
	auto s = "Hello"s;  // std::string


Особенности строковых литералов:
Строковые литералы в C++ имеют тип const char[N], а не std::string. Это значит, что, например, такой код работать не будет:

std::string str = "Hello";  // Работает, потому что std::string может быть создан из const char*
std::string str2 = {'H', 'e', 'l', 'l', 'o'};  // Ошибка, нужна кавычка ""

Если нужен именно std::string, начиная с C++11 можно использовать суффикс s:

using namespace std::string_literals;
std::string s = "Hello"s;


Пользовательские литералы (C++11 и новее)
Можно определять свои литералы:

#include <iostream>

long double operator"" _km(long double x) { return x * 1000; } // переводит километры в метры

int main() {
    std::cout << 5.0_km << " meters\n";  // Выведет 5000 meters
}

Конец оффтопа.




Формальное определение:

					lvalue													rvalue
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1) id - индефикатор переменной (название). Если експрешен на верхнем уровне представляет из | Если наш экспрешен это литерал, то это rvalue. Пример литераторв: 5, 'a', 2.0f, true. Кроме случая 
себя просто имя переменной, то это lvalue. Т.е. любая переменная сама по себе это lvalue, и | когда это строковый литерал. Строковый литерал это lvalue: "abc".
не важно какого она типа. Индефикатор это частный случай экспрешена, и он всегда lvalue,    |
неважно какой это тип, даже если тип с двумя &&. 					    |
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2) = += -= *= /= %= <<= >>= &= |= ^= это всё lvalue (для фундаментальных типов)		    | Над стандартными (а точнее примитивными) типами:
											    | Арифметические операторы: + - * / % << >> & | ^ && || ! ~ 
											    | Сравнение: < > <= >= == !=
											    | Если выражение на верхнем уровне представляет собой чтото из этого, то это rvalue.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3) Префиксный инкремент и декремент это lvalue над фундаментальными типами: ++expr, --expr. | Постфиксный инкремент и декремент это rvalue над фундаментальными типами: expr++, expr--.
											    |
Почему некорректно следущее выражение?: (5 + 2)++; Потому что (5 + 2) это rvalue, а инкремент можно вызывать только у lvalue.

Присваивание для примитивных(фундаментальных) типов нельзя вызывать от rvalue. Для кастомных типов уже бывают варианты.

Теперь можно понять почему нельзя сказать что, то чему можно присваивать это lvalue, а то чему нельзя это rvalue, поскольку константа это lvalue, но ей присваивать нельзя. 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
4) *ptr; - унарная звёздочка, в случае если после разыменования указателя получается	    | &a - унарный амперсанд это rvalue.
фундаментальный тип. a[i]; - квадратные скобочки, в случае если получается фундаментальный  |
тип.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
5) 									Вид value запятой, это вид value её правой части. 
comma if rhs is lvalue. 	rhs - это right hand side				    | comma if rhs is rvalue. 

Запятую для своих типов можно перегрузить, поэтому это работает тоже только для фундаментальных типов.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
6) ?: 										   Тернарный оператор
true ? x++ : ++x; - это не компилируется, потому что вид value должен быть известен в компайлтайме. В данном случае вид value это синтаксическая вещь. Вид value у тернарного оператора такой же
как в худшем случае:  если обе его части это lvalue то тогда и он сам lvalue, если хоть одна его часть это rvalue, то он весь rvalue. Это логично, потому что, в компайл тайме мы должны решить
какой вид value у всего выражения, но вычислить тернарный оператор в компайл тайме мы не можем, поэтому это правило введено на уровне синтаксиса.
											    |
?: if both operands are lvalue								    | ?: if least one operand is rvalue 

Это работает для любых типов.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
7) Когда вызов функции считается lvalue, а когда rvalue?
Когда мы говорим о перегрузке операторов для своих типов, в том числе string, big integer, это тоже подходит под это седьмое правило вызыв функции. Все предыдущие правила, это правила на случай
стандартных операторов, если у нас операторы неперегружены. Но если мы говорим о своём, не вшитом в язык операторе или функции, то работает это седьмое правило: 
											   |
fanction call is lvalue if return type is T&						   | fanction call is rvalue if return type is T or T&&
Вызов функции это lvalue если возвращаемый тип это T&					   | Вызов функции это rvalue если возвращаемый тип это T или T&&
											   |
										           |
T&& это такая ссылка, что будучи возвращённой из функции, она считается rvalue. Если бы мы из функции возвращали обычную ссылку, то она считалась бы lvalue, и применялись бы другие правила. 
T&& ведёт себя как и обычная ссылка, но если её вернуть из функции, то этот экспрешен будет считаться rvalue. В этом и есть суть типа &&, а вовсе не в том, что переменная такого типа это 
rvalue.	НЕТ! Переменная такого типа это всё ровно lvalue, но вот будучи возвращённой из функции этот тип является rvalue. 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
8)cast expression имеет такое же правило как и вызов функции (правило 7). Любой каст как и любой вызов функции является lvalue если это каст к T&, и является rvalue, если это каст к T или T&&.
Это относится ко всем видам кастов, включая C стайл каст. 							
											   |
cast expression is lvalue if return type is T&						   | cast expression is rvalue if return type is T or T&&
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Это не всё определение lvalue rvalue, здесь указаны не все операторы. Например не указан оператор new который имеет вид rvalue. Главная суть этого опеределения в двух последних пунктах. 




###############################
Rvalue ссылки и их свойства (Что такое тип с двумя &&).

T&& - этот тип называется rvalue ссылкой. 

1) Главное свойство rvalue ссылки это то, что будучи возвращённой из функции, она является rvalue выражением, а не lvalue. 
2) Проинициализировать rvalue ссылку можно только rvalue выражением.

Это два единственных отличия rvalue ссылки от lvalue ссылки. rvalue ссылка так называется не потому что переменная такого типа T&& это rvalue (это в корне не верно!!!), а потому что смотри
два свойства выше.


Примеры:
Можно ли так написать?

int x = 5;
int&& y = x;

Так написать нельзя, потому что x это lvalue выражение, а rvalue ссылку мы можем проинициализировать только rvalue выражением. Это CE.


Можно ли написать так?

int&& y = 6;

Да так можно написать, это продление жизни, точно также как и в случае const int& y = 6; rvalue ссылки позволяют продливать жизнь объектов, так же как это делают константные ссылки если 
справа был временный объект. 


Можно ли написать после этого так?

int&& y = 6;
y = 7;

Да так можно написать, создастся временный объект, который будет соответствовать y, он будет жить пока жив сам y. Его можно менять потому что он не const. 


Можно ли написать так?

int&& y = 6;
y = 7;
int&& z = y;

Нет нельзя, имя переменной это всегда lvalue и не важно какой у неё тип. Проинициализировать rvalue ссылку (в нашем случае z) можно только rvalue выражением, но у нас в третей строке справа 
(= y;) это lvalue, поэтому это CE. Это нельзя делать, не смотря на то что тип y это int&&. Не важно какой у неё тип, важно то что вид value неподходящий, а значит rvalue ссылку z
проинициализировать y нельзя. Это главный пример. 

Но в данном случае мы можем написать вот так:

int&& y = 6;
y = 7;
int&& z = std::move(y);

Здесь std::move это функция, возвращаемый тип которой int&&. Если тип с двумя амперсандами возвращается из функции, то это выражение является rvalue, значит так написать можно.

Теперь можно понять в чём смысл std::move. Смысл в том, чтобы была функция, результат которой был бы rvalue выражением.

Также мы можем написать так:

int&& y = 6;
y = 7;
int&& z = static_cast<int&&>(y);

Мы можем сделать явный каст к int&& это тоже будет считаться rvalue выражением, а также можем сделать std::move, который под капотом на самом деле и это есть static_cast к int&&, и это тоже
будет rvalue (см. правило 8 в таблице).


Если мы напишем так:

int x = 5;
int&& y = x;
int&& z = static_cast<int&&>(y);
z = 1;

то теперь x станет равным 1, потому что мы поменяли ссылку. Ссылка z это просто другое название для x. 


Имя переменной это lvalue, для того, чтобы когда мы писали data от data: data(data), не важно каким типом было data, оно бы не мувалось. Чтобы когда нам нужно мувнуть, мы бы писали это явно,
чтобы оно не мувнулось неявно и не получилось случайно так, что мы написали так: data(data) и data в скобочках опустела. Т.е. чтобы пошло в копи конструктор, а не в мув конструктор. 



###############################
Интуитивное понимание std::move

Мы сталкивались с ситуациями, когда у нас есть какие то два разных типа, и в одну сторону неявный каст разрешён, а в другую запрещён, например, ситуация с обычной ссылкой type&  и с 
константной ссылкой const type&:

type&       <--------------------- type
	   	                     |
       //----------------------------/
       \/
const type& <--------------------- const type

Нам разрешён каст от обычного типа type к ссылке этого типа type&, а также разрешён каст от константного типа const type к константной ссылке const type&. Но при этом можно обычный тип type 
отдать по константной ссылке const type&. А вот если мы хотим по обычной ссылке type& отдать константный тип const type то эта вещь неявно запрещена, для этого нужно использовать const_cast:

	       
type&                 		   type 
    /\	      const_cast         
    \\---------------------------------\
            	             	       |
                                       |
const type& 		  	   const type



Также такая ситуация была когда мы изучали наследование: так работает неявно

Base&    <--------------------- Base
     /\	                  	      
     \\----------------------------\ 
                                   |
Derived& <--------------------  Derived

Но если нам нужно сделать так:

Base&                            Base
	     static_cast	   |
       //--------------------------/
       \/
Derived&                         Derived

это запрещённое действие и для этого нам нужен static_cast к ссылке.

У обычного типа по сравнению с его константным аналогом просто определено больше операций. Если мы хотим константный тип принять по обычной ссылке т.е. разрешить над ним операции,
которые по умолчанию над ним запрещены, мы должны явно писать каст. Тоже самое и с наследованием, Derived по отношению к Base это тип, у которого некоторые операции определены 
дополнительно, а Base по отношению к Derived это тип у которого часть операций вообще не определена. У Derived  мы можем вызвать все операции Base, но если мы хотим у Base вызвать операции
Derived, то нам нужно явно скастить если мы уверены что так можно сделать. 


std::move это в каком то смысле третий пример данной ситуации. У нас есть ссылка которая принимает как lvalue так и rvalue (const type&), а также есть ссылка которая принимает только rvalue 
(type&&).  И у нас есть выражения вида lvalue и выражения вида rvalue. Выражения вида rvalue мы можем отдать как и в lvalue ссылку (const type&) так и в rvalue ссылку (type&&).

const type& <-------------------  lvalue
     /\                                                    
     \\-----------------------------\      
                                    |
type&&      <-------------------  rvalue

Но если мы хотим выражение lvalue отдать в rvalue ссылку type&&, то нам нужна функция std::move.  std::move это в каком то смысле каст, но не между типами, а между видами value.

const type& 	 		  lvalue
                  std::move         |  
     //-----------------------------/      
     \/                                                  
type&&        			  rvalue


Над lvalue определены какие то операции, а над rvalue определено больше операций, потому что над rvalue оперделена операция перемещения, над lvalue такого делать нельзя. Над rvalue 
можно без проблем сделать как копирование так и перемещение оно от этого не пострадает, а над lvalue не принято делать перемещение, т.е. над rvalue можно делать больше чем над lvalue.
rvalue мы можем без проблем отдать как и в type&& так и в const type&, а lvalue по умолчанию мы можем отдать только в const type&, и если мы почему то над lvalue решил сделать операцию
нехарактерную для него, то мы его с помощью явного каста отдаём в type&&.



###############################
Взаимодействие rvalue-ссылок и const 

Правила константности действуют независимо от правил вида value. Правила константности и правила вида value соблюдаются независимо. 

В следующем примере всё корректно:
int x = 5;			
int&& y = std::move(x);	
int&& z = std::move(y);

Однако:

int x = 5;			
const int&& y = std::move(x);		// Навешиваем const, это можно
// int&& z = std::move(y);		// Снимаем const без конст каста, так уже нельзя, нарушение константности. 



В реализации std::move аргумент принимает только T&, а не const T&:

template <typename T>
T&& move(T& x) {
	return static_cast<T&&>(x);
}

Если бы мы в аргумент функции move принимали бы const T&, то вернуть T&& мы бы уже не смогли из-за нарушения константности, поскольку в аргументе тип константный, а возвращаемый тип
неконстантный, нельзя статик кастом от константного T скастовать к неконстантному. 

Если мы попытаемся мувнуть константный тип то будет как будто копирование. 

void f(const T& x) {
	g(std::move(x)); 
}

Если мы вызываем move а тип константный, то в функции move в аргументе (T& x) в тип T вшивается const: мы делаем std::move от x, где  x имеет константный тип const T&, то в аргумен функции 
std::move в тип T приходит константный тип (например будет T = const std::string, а не просто T = std::string). Тогда static_cast будет к const T&&, и вренём мы const T&&. И если у нас g определена
как от const T& так и от T&& (если у нас есть два конструктора), то мы попадём в const T&, потому что несмотря на то что у нас в первое определение принимается lvalue и rvalue а в другое только 
rvalue, мы отдаём rvalue, но во втором случае (T&&) нарушается константность, мы не можем отдать константное rvalue туда где ожидается неконстантное rvalue. Поэтому если мы муваем 
константный тип ничего плохого неслучится, мы всё ровно попадём в копирующую версию потому что константность защищает от изменений независимо от вида value. Мы не можем попасть в 
конструктор T&& потому что в этом случае слетает const, и мы не можем попасть в этот конструктор без явного каста. const независимо от вида value защищает нас от изменения объекта
(Лекция 40 14:40 и 27.30). 


############################
Несколько вопросов про lvalue и rvalue

Рассмотрим пример:

std::string x = "abc";
const std::string&& y = std::move(x);

После применения std::move x станет пустым или может нулём?
Конечно нет. 
1) Поскольку y это ссылка на x, то получается y это тоже самое что и x, одно и тоже, просто другое название для x, если x стал 0 то и y стал 0. Поскольку это одна и таже строка, то тогда она не может 
опустеть.
2) std::move не меняет исходный объект, move вообще ничего не делает над объектом. std::move только выбирает нужную версию перегрузки функций, а в случае примитивных типов это вообще 
ничего не значит, это просто костыль для компилятора для того чтобы он разрешил такую инициализацию. Мувание примитивных типов это всё ровно что копироватние примитивных типов.

Если бы мы написали без ссылки, тогда мы бы создали новую строку t , и теперь t = "abc", а x это пустая строка и y это тоже пустая строка:

std::string x = "abc";
const std::string&& y = std::move(x);
std::string t = std::move(x);

Это работает с std::string. Если бы мы использовали какой нибудь другой string в котором нет мув конструктора и оператора мув перемещения, то тогда бы t была бы копия x и x остался бы таким же 
а не пустым, потому что если у класса не упомянуты ни мув конструктор ни оператор перемещения, то move работает как копирование. Но если мы берём std::string, то в нём мув операции 
поддержаны, и тогда в третьей строке t станет = "abc", а x станет пустым (y естественно тоже). Т.е. std::move перенаправляет нас в мув конструктор, который уже в свою очередь забирает данные у 
старого объекта и присваивает их новому объекту. Если мув конструктор не реализован, то будет работать копи конструктор.

Константность запрещает нам перемещать данные. Если у нас стоит const, то мы ничего не мувнем, а скопируем: 

const std::string x = "abc";
std::string t = std::move(x);


Если мы напишем так:

std::string x = "abc";
const std::string&& y = std::move(x);
std::move(x);

то со строкой x ничего не произойдёт, поскольку сама по себе функция std::move ничего не делает, всё делают мув конструктор и оператор перемещения определённые в типе.


Следующее объяснение. Рассмотрим случай:

Мы делаем std::move от типа с двумя амперсандами:

std::string x = "abc";
std::string&& y = std::move(x);
std::string&& z = std::move(y);

В 3-ей строке мы делаем std::move(y), но у ссылки игрик типа с двумя амперсандами std::string&&, а std::move принимает тип с одинм амперсандом T&. Как так? Шаблон что делает конверсию из 
string&& string& ?

Начнём с того что это неправильная реализация move (она рабочая на 90% случаев), на самом деле std::move устроен по другому и он принимает и ввозвращает не такие типы. Но мы можем
рассмотреть и нашу неправильную реализацию. Когда мы передаём в шаблонную функцию чтото по ссылке, то при выяснении что такое тип T ссылка отбрасывается. В нашем случае когда мы 
передаём в std::move переменную типа string&&, то ссылка отбрасывается и T берётся без учёта ссылок. У нас в качестве T это string, поэтому в аргументе функции std::move у нас тип string&.
Это работает с любыми шаблонными функциями. Однако так не работает с константами, const не отбрасывается при передачи.  


_____________________________________________
Reference qualifiers (C++11)

У нас есть структура и в ней строка. Мы хотим написать метод который возвращает данные этой строки.

struct S {
	std::string str;

	std::string getData() const {
		return str;
	}
};

А теперь представим что у нас эта S это временный объект:

S{"abc"}.getData();

Что призойдёт в такой ситуации? Здесь опять происходит копирование. Сначала создастся строка str от временной строки "abc", а потом когда мы скжем getData() из этой строки создастся ещё одна
строка и вернётся из функции нам.

Иногда хотелось бы чтобы у нас можно было иначе работать с объектом, если this это rvalue. У нас же есть перегрузка между const и не const объектами, но можно ещё сделать перегрузку между 
lvalue и rvalue объектами. Было бы неплохо если бы когда мы вызывались у rvalue объекта то getData() мувала бы строку а не копировала. Для этого у нас есть reference qualifiers.


У нас есть const qualifiers, которые позволяют нам понять от константного объекта мы вызвались или от неконстантного объекта. Так же есть ещё reference qualifiers, которые позволяют понять
от lvaluer объекта мы вызвались или от value.

std::string getData() && {
	return std::move(str);
}

Этот метод теперь доступен только для rvalue объектов. Если объект от которого мы вызываемся это rvalue, то мы попадём в эту версию. Мы хотим забрать string из поля str, вернуть его наружу
и пусть str опустеет нам это не важно поскольку наш string это rvalue, он временный, и значит нам пофигу на то что он опустеет. В getData() мы возвращаем просто std::string, потому что сам объект S
это временный объект и он сейчас будет уничтожен и поэтому мы хотим из этого временного объекта вернуть строку, а не ссылку на строку. Если мы понимаем что объект временный то нам не нужно 
копировать строку, мы можем просто её мувнуть и вернуть себе. 


Если мы хотим вызывать методы только от lvalue мы можем использовать следующий квалификатор:

std::string getData() & {
	return str;
}

Однако константные ссылки в этой ситуации работают аналогично константным ссылкам в параметрах. Если мы напишем так:

std::string getData() const & {
	return str;
}

то мы сможем вызываться как от rvalue так и от lvalue. Такая запись означает что мы как будто приняли себя по константной ссылке. Если мы хотим сделать перегрузку между случаями когда мы себя
приняли по константной ссылке и когда мы себя приняли по rvalue ссылке, то мы делаем вот так:

std::string getData() const & {
	return str;
}

std::string getData() && {
	return std::move(str);
}

В первой перегрузке мы понимаем что себя менять нельзя и мы принимаем по обычной константной ссылке а во второй перегрузке мы себя принимаем по rvalue ссылке и тем самым можем из себя
достать данные и передать кому то. Сейчас первую перегрузку мы можем вызывать от любого value, но если мы уберём const в первой перегрузке, то её мы сможем вызывать только от lvalue, потому 
что неконстантная lvalue ссылка не может быть проинициализирована через rvalue. 


Теперь мы можем решитьпроблему с реализацией оператора присваиванием:

a + b = 5; 	// Это компилируется хотя a + b это rvalue, т.е. мы присваиваем 5 к rvalue. Однако компилятору никто не запрещал присваиваться от rvalue this.

Для того чтобы оператор присваивания можно было вызывать только к lvalue нужно будет поставить квалификатор & в определении оператора присваивания.



_____________________________________________
Forwarding references, std::forward

На данный момент мы всё ещё неправильно реализовали push_back(). Сейчас у нас есть два push_back(), 1-ый принимает const T&, 2-ой T&&:

void push_back(const T&) {
	// ...
	new (ptr) T (value);
}

void push_back(T&&) {
	// ...
	new (ptr) T (std::move(value));
}

Они отличаются тем, что где то там в 1-ой реализации написано new (ptr) T (value), а во второй new (ptr) T (std::move(value)). Но это на самом деле обман, ведь там написано allocator.construct(). В
allocator.construct() мы можем передать либо value либо std::move(value), но сама функция construct() принимает по константной ссылке:

void construct(U* ptr, const Args&... args) {
} 

Получается мы не можем мувать с такой ссылкой.

Или пример 2: У нас есть функция emplace_back(), которая принимает не T, а аргументы конструктора T и на месте конструирует T из них:

template <typename... Args>
void emplace_back(const Args&... args) {
}

Она принимает аргументы по константной ссылке. Получается функция emplace_back() не умеет мувать если ей передали rvalue. Если мы в emplace_back() будем принимать const Args&... args то 
получается мы этой функцией навредили а не помогли себе, потому что emplace_back() по идее должна мувать аргументы если они были rvalue в конструктор T, а если мы их принимаем по 
константной ссылке то это всё не будет муваться, а будет копироваться. 

Ровно та же проблема в функции construct(). У нас переменное число аргументов - это ключевой момент здесь. Что в функции construct() в аллокаторе, что в функции emplace_back у нас переменное 
число аргументов, и нас не спасёт написать две перегрузки одна от const Args& другая от Args&&, потому что аргументов много и некоторые из них могут быть lvalue, а некоторые rvalue. Т.е. нам нужно 
2^n перегрузок, где n это число аргументов. Мы не решили проблему глобально всё ещё. Мы научились копировать или мувать только пока это не передаётся дальше, т.е. если у нас стек вызовов 
функций состоит из одного вызова функции мы решили проблему, но если нам нужно пойти дальше и передать это в следуюущую функцию с сохранением вида value, то мы не решили проблему. Если
бы мы вызывали new то было бы всё нормально, но мы же вызываем construct или вызываем emplace_back, и вот здесь нам нужно как то, передавая дальше аргументы, сохранить вид value каждого
аргумента, чтобы те аргументы, которые нельзя было мувать скопировлись, а остальные мувнулись.


Вопрос: Как принять переменное число аргументов, с сохранив вид value каждого?
Нам нужно уметь передавать аргументы дальше в функции с сохранением вида value, который мы приняли на данный момент. Если нам в push_back часть аргументов отдали как lvalue, а часть как
rvalue, то мы должны и дальше в construct отдать соответствуюущие аргументы как lvalue, другие как rvalue, иначе мы всё зря придумали и мы будем попрежнему всё копировать. Это верно для всех
контейнеров и для всех вставок в них, и вообще для всех ситуаций, когда мы куда то передаём временный объект и хотим передать его дальше, при этом у нас функция может принимать сразу 
несколько объектов, часть из них временная, а часть невременная.



На самом деле во всех таких ситуациях мы принимаем два амперсанда&& а не один и никакого const. Сигнатура функции emplace_back() выглядит так:

template <typename... Args>
void emplace_back(Args&&... args) {
}

Точно также выглядит сигнатура функции construct в аллокаторе. Какже это работает? Есть ещё одна волшебная функция std::forward() которая позволяет обеспечить работоспособность данного 
феномена.

Правильная реализация функции construct:

allocator.construct(ptr, std::forward<Args>(args));	// Вызов функции construct

//...

template <typename U, typename... Args>
void construct(U* ptr, Args&&... args) {		// Правильная реализация
	new (ptr) U(std::forward<Args>(args)...);	// Правильная передача аргументов с сохранением вида value в следующую функцию выглядит так
} 

Это правильная передача аргументов с сохранением вида value в следующую функцию. Мы принимаем аргументы по ссылке с двумя амперсандами &&, но передаём дальше не с помощью move и не 
просто так, а с помощью std::forward. Утверждается что функция std::forward каким то чудесным образом, в зависимости о того приняли ли мы их как lvalue или как rvalue изначально, и дальше 
передаёт какждый из них как lvalue или rvalue соответственно, если мы их приняли по ссылке с двумя амперсандами &&. 


###########################
Почему вообще в аргументе функции у нас ссылка с двумя амперсандами Args&&... args, ведь сюда нельзя передать lvalue, поскольку такая ссылка должна инициализироваться только от rvalue. 
Это проблема и для этой проблемы нам нужно ввести новый костыль в стандарт. Всё то что мы говорили про тип && верно за одним исключением:  если ссылка с двумя амперсандами (rvalue ссылка) 
является шаблонным параметром функции, то правило неверно. 

Если rvalue ссылка является типом аргумента функции, для которой это является шаблонным параметром, то это работает по другим правилам, и здесь не применяется правило что эту ссылку можно
инициализировать только через rvalue. Это сделано для того чтобы таким синтаксисом можно было принимать как rvalue так и lvalue. 
Ещё раз: если функция принимает тип вида T&& где T это шаблонный параметр данной функции, то такая ссылка работает по другим правилам, нежели обычная rvalue ссылка.

template <typename... Args>		// Args это шаблонный параметр
void emplace_back(Args&&... args);	// Функция принимает тип Args с двумя &&, который является шаблонным параметром.

Только в таком случае работают иные правила. Например в void push_back(T&&) аргумент T&& не попадает под это исключение из правил, потому что здесь T это не шаблонный параметр функции, а 
шаблонный параметр класса: 

template <typename T, typename Alloc = std::allocator<T>>	// T - шаблонный параметр класса vector.
class vector {
	//...

	void push_back(T&&) {					// из-за этого T&& не попадает под это исключение из правил.
	}
};

Важно чтобы тип был шаблонным параметром самой этой функции, а не вышележащего класса. Т.е. тип в функции должен быть в точности равен шаблонному параметру и ещё должно быть два ампераснда &&.
При этом если бы аргумент функции был бы равен const Args&& это уже не попадает под исключение из правил:

template <typename... Args>
void emplace_back(const Args&&... args);	// Не попадает под исключенпие из правил

template <typename... Args>
void emplace_back(vector<Args>&&... args);	// Тоже не попадает под исключение из правил

В данном случае под исключение из правил попадает только аргумент Args&& и больше никакой. И только в этом случае такая ссылка умеет принимать как lvalue так и rvalue. Такие ссылки носят специальное
название: Forwarding references или ещё Universal references (Передаваемая или универсальная). Это не термин из стандарта. 


###########################
Оффтоп. Упражнение: создание вектора из переменного числа аргументов

Мы хотим чтобы у нас в структуре был конструктор от переменного кол-ва строк, а хранить мы хотим вектор строк, и строки мы хотим либо через lvalue или через rvalue инициализировать правильно
каждую. Нам нужно положить в вектор каждую из строк для этого мы сделаем резёрв вектора на нужный нам размер. В данном случае сколько у нас аргументов такой размер нам и нужен. Дальше пишем
push_back() который будет выполняться для каждой строки. 

strict S {
	vector<string> v;						// Контейнер, который будет хранить строки.

	template <typename... Args>
	S(Args&&... args) {						// Конструктор принимает переменное число аргументов (Args&&... args) через универсальные ссылки.
		//static.assert						// Тут нужен статик асёрт на то чтобы все типы были конвертируемы в стринг.
		v.reserve(sizeof...(args));				// Заранее резервирует место в векторе под количество переданных аргументов.
		(v.push_back(std::forward<Args>(args)), ...);		// При инициализации каждую из строк мы кладём в вектор либо муванием либо копированием
	}
};

Последняя строка (v.push_back(std::forward<Args>(args)), ...); — это fold-expression (Выражения свертки) из C++17. Она позволяет выполнить выражение для каждого аргумента из args.... В данном случае 
каждый аргумент перемещается (std::move) или копируется (std::string), в зависимости от его вида value, в вектор v.


###########################
Продолжаем про универсальные ссылки. (Лекция 40 1:10:40)

Forwarding references обладают ещё одним важным свойством: Если мы передаём туда lvalue, то меняются правила вывода типов шаблона.

Представим что у нас есть функция, которая принимает T по универсальной ссылке:

template<typename T>	// 1
void h(T&& x);

template<typename T>	// 2
void g(T& x);

template<typename T>	// 3
void f(T x);

Правила по которым компилятор решает чему равно T будут разными для случая 1 и одинаковыми для случая 2 и 3 (2 и 3 правила одинаковые, 1 от них отличается). И это опять исключение из правил,
добавленное специально для таких ссылок, благодаря ему у нас как раз получится реализовать std::forward().

Когда мы вызваем f или g от x, то T в этих случаях просто становится равно int. Однако Если мы вызовем h(x) где h принимает ссылку T&&, то тип T внезапно окажется не int, а int&.

int x = 0;	// Мы вызываемя от lvalue
f(x);		// T = int.     Тип x = int.     ( T = int x )
g(x);		// T = int.     Тип x = int&.  ( (T = int) + & x )
h(x);		// T = int&   Тип x = int&.  void h(T&& x), здесь ( (T = int& поскольку это lvalue) + навешивается ещё два && (& + && -> &), получаем, тип x = int&, почему так рассказано далее).

Тоже самое произойдёт если мы вызовемся от обычной ссылки. Если функция принимает универсальную ссылку T&& и мы вызываемся от lvalue, то старые правила вывода типа T не работают, а работают новые 
правила, что компилятор навешивает дополнительно амперсанд на T. Неважно вызываемся мы от int или int&, когда мы вызываемся от lvalue: 

int& y = x;
f(y);		// T = int.	
g(y);		// T = int.
h(y);		// T = int&


Сслыка & отбрасывается кроме случая когда мы вызываемся от универсальной ссылки T&&. В случае когда мы вызываемся от универсальной ссылке, берётся амперсанд.

int&& z = std::move(x);
f(z);		// T = int.
g(z);		// T = int.
h(z);		// T = int&.   

Таковы правила вывода типа шаблона. Почему 1 амперсанд а не 2 и почему это не зависит от типа выражения, от которого мы вызываемся. 

Однако если мы вызываемся от rvalue T оказывается без амперсандов даже в случае с универсальной ссылкой. Получается если для ссылки T&& мы вызываемся от lvalue, она его принимает, но T 
становится равным типу без ссылок с навешанным амперсандом, а если вызывается от rvalue, то она его принимает и T выводится как обычно.

// Передаём rvalue
h(1); 			// T = int
h(std::move(x));	// T = int.  T - это просто int, на него навешиваем ещё два &&, получаем тип T&&.

Т.е. если вид выражения lvalue то для функции с шаблонным типом T&&, сам тип T становится равен T&, а если мы вызываемся от выражения вида rvalue тип T остаётся обычным T.


А какой тип имеет x?
В языке C++ существует правило Reference collapsing rules: Если в момент вывода типа переменной в шаблоне у нас накладываются амперсанды один на другой, то они преобразовываются по следующему
правилу: 
Если у нас есть один амперсанд & и на него навешивается ещё один амперсанд & + &, то это один амперсанд & + & -> &.
Если на два амперсанда && навешивается один амперсанд & то это тоже один амперсанд && + & -> &.
Если на один амперсанд & навешиваются два амперсанда && то это тоже один амперсанд & + && -> &.
Если только если на два амперсанда && навешиваются два амперсанда && то это два амперсанда && + && -> &&.

Это правило очень простое – одиночный амперсанд (&) всегда побеждает.

Исходя из этих правил можно понять какой тип будет у x в каждом из случаев:

template<typename T>	// 3
void h(T&& x);

Если мы передаём в h lvalue, то T это будет тип с амперсандом, а на него ещё два амперсанда навешалось (T&& x), тогда получается & + && -> это будет один амперсанд &.

Если бы мы передали rvalue, то T это просто int и на него навесилось два амперсанда, и получалось просто два амперсанда T&&.

Т.о. благодаря этому костылю для универсальных ссылок они могут принимать как lvalue, так и rvalue, причем если они принимают lvalue, то компилятор компилятор искусственно добавляет амперсанд 
на T, и балгодаря этому если мы в функцию h примем lvalue, то мало того, что оно её примет, оно ещё тип будет иметь с одним амперсандом, а если мы приняли rvalue, то оно будет с двумя 
амперсандами и это подсказывает нам как работает forward - он понимает какой тип на самом деле, какой был value в зависимости от того что в шаблонном аргументе, там либо один амперсанд либо
нет амперсанда. Исходя из этого форвард понимает ему кастить к rvalue или нет.

Правила вывода типов не применяются если мы явно указали тип T при вызове шаблонной функции. 

П.с. я это понял но полюбому забуду. Впринципе это логично. Чтобы понять заново нужно прочитать и посмотреть лекцию 40 с 1:10:40.

Итог: универсальные ссылка это:
1) Ссылка должна обладать типом T&& и никаким другим.
2) Это должен быть шаблонный параметр данной функции а не класса.
3) Это должен быть аргумент функции.

Она умеет принимать как lvalue так и rvalue. Но если она принимает lvalue, то на тип T навешивается дополнительный амперсанд.


###########################
Пример с хабра: https://habr.com/ru/articles/242639/
Начнем с простого – сжатия ссылок (reference collapsing). Как известно, взятие ссылки на ссылку в С++ не допускается, но это иногда может происходить при реализации шаблонов:

template <typename T>
void baz(T t) {
  T& k = t;
}

int i = 4;
baz<int&>(i);		// Что случится, если вызвать эту функцию так?

При инстанцировании шаблона T установится равным int&. Какой же тип будет у переменной k внутри функции? Компилятор «увидит» int& & — а так как это запрещенная конструкция, компилятор просто преобразует 
это в обычную ссылку. Так появилось правило сжатия ссылок. Это правило очень простое – одиночный амперсанд (&) всегда побеждает. Таким образом – (& и &) это (&), также как и (&& и &), и (& и &&). Единственный 
случай, при котором в результате сжатия получается (&&) — это (&& и &&).

Другое дополнение С++, имеющее прямое отношение к рассматриваемой теме – это правила особого вывода типа (special type deduction rules) для rvalue-ссылок в различных случаях. Рассмотрим пример шаблонной 
функции:

template <class T>	// Пример шаблонной функции
void func(T&& t) {
}

Не позволяйте двойному амперсанду обмануть Вас – t здесь не является rvalue-ссылкой. При появлении в данной ситуации (когда необходим особый вывод типа), T&& принимает особое значение – когда func 
инстанцируется, T изменяется в зависимости от переданного типа. Если была передана lvalue типа U, то Т становится U&. Если же U это rvalue, то Т становится просто U. 
Пример:

func(4);            // 4 это rvalue: T становится int

double d = 3.14;
func(d);            // d это lvalue; T становится double&

float f() {...}
func(f());          // f() это rvalue; T становится float

int bar(int i) {
  func(i);          // i это lvalue; T становится int&
}




_____________________________________________
Implementation std::forward, std::move (Реализация)	Лекция 41 начало

Исправим функцию construct в аллокаторе:

template <typename U, typename... Args>
void construct(U* ptr, Args&&... args) {
	new (ptr) U(std::forward<Args>(args)...);
}

Теперь нам нужно реализовать std::forward для того чтобы это работало, с учётом того, что было сказано про универсальные ссылки. 

Попробуем понять что нам нужно какой тип должен принимать и возвращать forward, чтобы если нам на вход изначально передали lavlue, то мы и дальше его передали как lvalue, а если нам изначально передали
rvalue, то мы и дальше бы передали его как rvalue. 

На первый взгляд может показаться что форвард можно написать так:
 
template <typename T>
T&& forward(T&& value) {
	return value;
}

Однако это не будет правильно работать. У нас есть два случая:
1) Когда Args нам передали изначально как lvalue: 
Тогда в функции construct: Тип Args = int&, и тип args = int& (псевдокод: typeof(args) = int&). Далее мы в std::forward, с шаблонныйм параметром int&, отдаём args. 
Тогда в функции forward: Тип T = int& и тип value = int&. Получается мы приняли как int& и отдали как int&, всё работает правильно.

2) Когда нам Args передали изначально как rvalue:
Тогда в функции construct: Тип Args = int, а типа args = int&&. 
Тогда в функции forward: Тип T = int.

Мы явно указываем шаблонный параметр при вызове forward, а это значит что правила вывода типа не применяются, мы же явно указали шаблонный параметр, т.е. T это будет просто int. Здесь не работает 
правило и сейчас на T не навеситься амперсанд. Правила вывода типов не применяются если мы явно указали тип T при вызове шаблонной функции. Поэтому здесь принимаемый тип будет int&&, но вызываемся
то мы от lvalue, поэтому это будет CE. Если мы в данной реализации приняли args как rvalue, то попытка отдать его в такой forward это будет CE.

С одним амперсандом это тоже не сработает:

template <typename T>
T&& forward(T& value) {
	return value;
}

Если мы так будем принимать, то у нас будет таже проблема при возврате, если мы изначально приняли его как rvalue, у нас шаблонным параметром является просто T, и мы пытаемся вернуть T&&, т.е.
мы попытаемся инициализировать rvalue ссылку через lvalue на возврате. Так делать нельзя.


Для решения этой проблемы нам нужно написать static_cast:

template <typename T>
T&& forward(T& value) {
	return static_cast<T&&>(value);
}

Где-то мы уже это видели)) Кажется этот форвард ничем не отличается от мува, который мы реализовывали раньше. А может на самом деле это и есть правильная реализация форварда а вот мув должен 
работать иначе? 

Если у нас изначально было lvalue, то у нас будет шаблонный параметр с одним амперсандом, а возвращать мы будем lvalue. Т.е. мы примем value по одиночному амперсанду, а вернём тип с двумя амперсандами.
Но у нас же произошёл Reference collapsing, T был уже сам с амперсандом, мы скастили его к T&&, это значит что на самом деле результирующий тип не int&& а int&. Это значит для lvalue это будет правильно
работать. Т.е. если мы приняли lvalue то мы и отдадим lvalue, а значит всё правильно. Возвращаемый тип это lvalue ссылка а не rvalue ссылка потому что это шаблонный тип, как только мы подставляем T тип 
превращается в lavlue ссылку. То что в возвращаемом типе написано T&& это не важно, потому что при подстановке конкретного T, получается lvalue ссылка. 

Но если мы пробросим rvalue это тоже будет правильно работать, потому что если мы пробрасывали rvalue то у нас Args это int, мы вызываемся от lvalue с шаблонным параметром int, значит получается что T = int
тогда T&& это int&& и мы возвращаем rvalue. Получается что такая реализация std::forward правильно обрабатывает нам оба случая. Получается что мув который мы написали раньше это форвард а не мув.
Однако это ещё не правильная реализация не мува не форварда, один случай мы ещё не предусмотрели.


Попробуем понять тогда почему наш move реализован неправильно. Мув не должен работать как форвард. Мув должен возвращать только rvalue, мув никогда не должен возвращать lvalue, в этом его смысл, а в нашей 
реализации мув иногда всё ровно возвращает lvalue, если ему в качестве T подсунут одиночный амперсанд &. Так не должно быть. Если сейчас в качестве T муву подсунуть шаблонный аргумент с уже одиночным 
амперсандом, то мув вернёт lvalue (этот тип с одиночным амперсандом) из-за правила reference collapsing, однако мув никогда не должен возвращать lvalue. Поэтому в мув мы должны возвращать не T&&, а 
std::remove_reference_t<T>&&:

template <typename T>
std::remove_reference_t<T>&& move(T& value) {
	return static_cast<std::remove_reference_t<T>&&>(value);
}

std::remove_reference_t - удаляет ссылку (lvalue и rvalue) с переданного типа, т.о. мы получаем чистый тип.

Мы хотим чтобы у нас не работало reference collapsing на возвращаемый тип, когда мы возвращаем из мува, мы хотим чтобы мув всегда возвращал T&& и для этого в возвращаемом типе мув мы снимаем все амперсанды
с T, если они были, и потом навешиваем наверх два амперсанда &&. Потому возвращаемый тип мув вот такой и кастим мы именно к нему а не к T&&. Однако и принимаемый тип мув не такой. Принимаемый тип мув это
как раз T&&:

template <typename T>
std::remove_reference_t<T>&& move(T&& value) {
	return static_cast<std::remove_reference_t<T>&&>(value);
}

В мув можно отдавать как lvalue так и rvalue, и не важно что мы дали, на выходе будет всё ровно rvalue. Мув который мы написали до этого мог принимать только lvalue, но это неправильно. Вдруг мы захотим передать в
мув результат вызова какой нибудь функции, которая иногда возвращает lvalue а иногда rvalue, и мы на выходе всегда хотим видеть rvalue. Т.е. мув должен принимать и то и другое и всегда возвращать rvalue. Поэтому
мув принимает универсальную ссылку а возвращает всегда rvalue ссылку. Обращаем внимание на то, что принимаемый тип T&& это универсальная ссылка а не rvalue ссылка.


В противоположность ему std::forward иногда возвращает lvalue а иногда rvalue ссылку, в зависимости от того каким был принимаемый T. Но всё таки он тоже принимает не T&:

template <typename T>
T&& forward(std::remove_reference_t<T>& value) {
	return static_cast<T&&>(value);
}

Форвард принимает std::remove_reference_t<T> но с одним поверх навешанным амперсандом &. Обращаем внимание на то, что возвращаемый тип T&& это rvalue ссылка, а не универсальная ссылка, потому что она не 
является аргументом функции, она является возвращаемым типом, правила исключения работали если бы она была принимаемым аргументом, а она является возвращаемым типом. 

Почему в форвард мы принимаем не просто T& а std::remove_reference_t<T>&? Для этого есть две причины:
1) Мы хотим чтобы forward не умел выводить тип с шаблонного параметра неявно. Когда мы принимаем такой тип, мы добиваемся интересного эффекта: теперь forward мы не можем не передать явно шаблонный
аргумент. А этого мы и хотели, ведь если бы forward умел выводить его неявно, то мы бы неправильно пользовались бы форвардом, мы бы мували когда этого ненужно. Если бы в forward был бы реализован так как раньше
(принимал в аргументе просто T&), то я бы мог забыть при вызове forward забыть написать шаблонный параметр Args, и тогда компилятор вывел бы нам неявно шаблонный аргумент как T = просто типу без амперсандов. И тогда
бы мы его скаcтили к T&& потому что T же не имеет амперсандов, мы бы навесили два амперсанда и скастили. И тогда получалось бы что если мы форварду забыли явно указать шаблонный аргумент, то это будет 
компилироваться и мувать, хотя это не должно мувать. За счёт того что мы принимаемым типом написали std::remove_reference_t<T>&, мы попрежнему умеем принимать только lvalue, но теперь это CE если мы забыли явно
указать шаблонный аргумент. Компилятор не умеет подбирать T так чтобы std::remove_reference_t<T>& соответсвтовал нужному T поэтому это и работает, это метафункция.

2) Forward от rvalue иногда тоже осмысленен, но редко. У std::forward есть перегрузка:

template <typename T>
T&& forward(std::remove_reference_t<T>&& value) {		// Два амперсанда && а не один &
	static_assert(!std::is_lvalue_reference_v<T>);		// Защита от того что T это lvalue ссылка
	return static_cast<T&&>(value);
}

В теории могло бы быть так, что при вызове forward могла быть ещё функция: 

template <typename U, typename... Args>
void construct(U* ptr, Args&&... args) {
	new (ptr) U(std::forward<Args>(f<Args>(args))...);
}

Т.е. мы могли бы форвардить не напрямую аргументы, а тоже результат вызова какой либо функции от этих аргументов. И в теории могло бы получиться так, чтобы мы форвардили rvalue, т.е. мы пытаемся передать дальше то,
что уже является rvalue. В этом случае если в форвард уже пришло rvalue, то мы проходим проверку static_assert(!std::is_lvalue_reference_v<T>). Такой форвард не компилируется в случае если мы попытаемся форворднуть
с lvalue ссылкой rvalue: 

new (ptr) U(std::forward<Args>(f<Args&>(args))...); // Должно упасть, мы пытаемся по lvalue ссылке форворднуть rvalue.

Т.е. запрещает форвардит rvalue как lvalue. Затем форвард кастит к rvalue.


Оффтоп:
Реализация std::is_lvalue_reference_v:

template <typename T>
struct s_lvalue_reference_v: std::false_type {};

template <typename T>
struct s_lvalue_reference_v<T&>: std::true_type {};

Конец оффтопа.



###########################
Продолжаем пример с хабра: https://habr.com/ru/articles/242639/
Реализация идеальной передачи с использованием std::forward

Вот как реализован forward:

template<class T>
T&& forward(typename std::remove_reference<T>::type& t) noexcept {
  return static_cast<T&&>(t);
}

Рассмотрим следующий вызов:

template <typename T1, typename T2>
void wrapper(T1&& e1, T2&& e2) {
    func(forward<T1>(e1), forward<T2>(e2));
}

int ii ...;
float ff ...;
wrapper(ii, ff);

Рассмотрим первый аргумент (второй аналогичен): ii является lvalue, таким образом T1 становится int& в соответствии с правилом особого вывода типа. Получается вызов func(forward<int&>(e1), …). Таким образом, шаблон
forward инстанцирован типом int& и получаем следующую версию этой функции:

int& && forward(int& t) noexcept {
    return static_cast<int& &&>(t);
}

Время применить правило сжатия ссылок:

int& forward(int& t) noexcept {
    return static_cast<int&>(t);
}

Другими словами, аргумент передан по ссылке в func, как и требуется для lvalue.

Следующий пример:
wrapper(42, 3.14f);

Здесь аргументы являются rvalue, таким образом T1 становится int. Получаем вызов func(forward(e1), ...). Таким образом, шаблонная функция forward инстанцирована типом int и получаем следующую версию функции:

int&& forward(int& t) noexcept {
    return static_cast<int&&>(t);
}

Аргумент, полученный по ссылке, приводится к rvalue-ссылке, которую и требуется получить от forward.

Шаблонную функцию forward можно рассматривать как некоторую обертку над static_cast<T&&>(t), когда T может принять значение U& или U&&, в зависимости от типа входного аргумента (lvalue или rvalue). Теперь wrapper 
является одним шаблоном, который обрабатывает любые сочетания типов аргументов.

Еще один момент, который нужно отметить: использование std::remove_reference. На самом деле forward может быть реализован и без использования этой функции. Сжатие ссылок выполнит всю работу, таким образом, 
применение std::remove_reference для этого избыточно. Однако, эта функция позволяет вывести T& t в ситуации, когда этот тип не может быть выведен (согласно стандарту С++, 14.8.2.5), поэтому необходимо явно 
указывать параметры шаблона при вызове std::forward.


Примеры использования идеальной передачи:

Идеальная передача довольно полезна, потому что делает возможным программирование на более высоком уровне. Функции высшего порядка – это функции, которые могут принять другие функции в качестве аргументов 
или возвращать их. Без идеальной передачи, применение функций высшего порядка довольно обременительно, так как нет удобного способа передать аргументы в функцию внутри функции-обертки. Под термином «функция» я 
здесь кроме самих функций также имею в виду и классы, конструкторы которых фактически тоже являются функциями.

В начале данной статьи я описывал метод контейнеров emplace_back. Другой хороший пример – это стандартная шаблонная функция make_unique:

template<typename T, typename... Args>
unique_ptr<T> make_unique(Args&&... args)
{
    return unique_ptr<T>(new T(std::forward<Args>(args)...));
}



_____________________________________________
Исправление push_back() с учётом move-семантики

Какие проблемы у нас были в push_back? Во-первых мы говорили что нужно уметь принимать как lvalue ссылку так и rvalue ссылку. Исправляем это:
Сначала мы делаем reserve. Далее мы делаем construct:

void push_pack(const T& value) {			
	if(sz == cap_) {
		reserve(cap_ > 0 ? cap_ * 2 : 1); 	
	}
	AllocTraits::construct(alloc, arr_ + sz_, value);
	++sz_;
}

void push_pack(T&& value) {			
	if(sz == cap_) {
		reserve(cap_ > 0 ? cap_ * 2 : 1); 	
	}
	AllocTraits::construct(alloc, arr_ + sz_, std::move(value));
	++sz_;
}

Теперь у нас есть две версии push_back. На самом деле обе версии push_back() выражаются через emplace_back(), поэтому можно просто написать emplace_back. Эта функция делает всё тоже самое что и push_back(), но в construct
она использует std::forward:

template <typename... Args>
void emplace_back(Args&&... args) {
	if(sz == cap_) {
		reserve(cap_ > 0 ? cap_ * 2 : 1); 	
	}
	AllocTraits::construct(alloc_, arr_ + sz_, 
		std::forward<Args>(args)...);
	++sz_;
}

Поэтому теперь реализация push_back() будет выглядить так:

void push_pack(const T& value) {
	emplace_back(value);
}

void push_pack(T&& value) {
	emplace_back(std::move(value));
}

Т.е. по сути push_back() это просто emplace_back себя же, т.е. всё выражается через функцию emplace_back().


Однако есть ещё одна очень важная проблема, такая же важная как проблема передачи value. Это проблема реалокации. Эта проблема ещё не решена. Когда мы делем reserve (реалокацию старого массива), мы в строчке 

AllocTraits::construct(alloc, newarr + index, arr_[index]);	// Новая реализация с учётом allocator_traits 

создаём на новом массиве объекты из старых объектов. Сейчас это работает копированием. Представим если бы у нас был вектор строк, тогда наша текущая реализация будет пересоздавать все строки. Если у нас N строк которая
каждая размера M, то наша реалокация будет работать не за O(N), она будет работать за O(N*M), потому что каждую строку она пересоздаёт заново, вместо того чтобы просто переложить указатели. Мы хотим чтобы у нас не 
вызывался копи конструктор, мы хотим чтобы реалокация вектора мувала старые объекты в новый массив, а не копировала. Этого можно добиться написав std::move:

AllocTraits::construct(alloc, newarr + index, 		// Новая реализация с учётом allocator_traits 
			std::move(arr_[index]));	// Новая реализация с учётом move-семантики


Оданко тут возникает новая проблема о которой мы раньше не задумывались: Сам move() не может бросить исключение, однако move конструктор может бросить исключение. Здесь мы потеряли exception safety, после того как
мы сделали реалокацию мувающую а не копирующую. Она не только пропала, но и не совсем понятно как её вернуть обратно:

	
	|---|---|---|---|---|
	| 1 | 2 | 3 | 4 | 5 |	Старый массив
	|---|---|---|---|---|

	|---|---|---|---|---|
	|   |   |   |   |   |	Новый массив
	|---|---|---|---|---|

Мы начинаем перекладывать объекты,  и допустим на 3-ем элементе у нас возникло исключение:
 
	|---|---|---|---|---|
	| 0 | 0 | 3 | 4 | 5 |	Старый массив
	|---|---|---|---|---|
	  |   |   |
	  |   |   Исключение
	|---|---|---|---|---|
	| 1 | 2 |   |   |   |	Новый массив
	|---|---|---|---|---|

Что делать? Теперь в новом массиве у нас два объекта перемещены а остальные ещё нет, в старом массиве первые два объекта уже пустые, а остальные ещё непереложены, и мы даже не можем начать перекладывать обратно, 
потому что мув-конструктор может кидать исключения, и что нам тогда делать, мы не можем обратно их переложить. Как нам вернуть безопасность исключения в push_back() если мы решили мувать а не копировать?

Есть такая специальная функция, которая называется std::move_if_noexcept(). Эта функция работает так: если move-конструктор noexcept, то она возвращает rvalue, а иначе lvalue (не совсем но почти так). Предлагается следующее:
если move-конструктор не noexcept то мы не будем мувать, а будем копировать. Это означает то, что если мы написали например свой класс строк, определили копи и мув конструкторы но забыли написать noexcept для мув
конструктора, то при добавлении наших строк в вектор при реалокации он будет их копировать полностью а не мувать. Мораль: всегда нужно помечать свои мув конструктор и оператор перемещения словом noexcept. 

AllocTraits::construct(alloc, newarr + index, 			// Новая реализация с учётом allocator_traits 
			std::move_if_noexcept(arr_[index]));	// Новая реализация с учётом move-семантики

Т.о. что если у нас мув-конструктор noexcept то мы это муваем и мы считаем что это не кидает исключений, catch нам тут тоже не нужен, если же у  нас мув-конструктор не noexcept, то мы на самом деле копируем а не муваем, но и 
тогда те действия которые написаны после catch попржнему будут верными (см. реализацию вектора).


##################
Реализация функции std::move_if_noexcept().

Самое интересное в этой функции это возвращаемый тип, в нём нужен std::conditional_t. std::conditional_t это тернарный мета-оператор, если условие верно мы возвращаем первый тип T&&, иначе второй тип const T&. 

template <typename T>
constexpr typename std::conditional_t<
		std::is_nothrow_move_constructible_v<T> && !std::is_copy_constructible_v<T>,
		T&&,
		const T&>
move_if_noexcept(T& x) noexcept{
	return std::is_nothrow_move_constructible_v<T> && !std::is_copy_constructible_v<T>
		? std::move(x)
		: x;
}

(Код я взял из chatGPT, смысл тот же просто порядок поменялся).
std::is_nothrow_move_constructible_v это такая мета функция которая как раз проверяет является ли мув-конструктор noexcept. Если это не верно и при этом мы std::is_copy_constructible_v то тогда мы возвращаем lvalue, а иначе 
rvalue. 

Вторая часть условия std::is_copy_constructible_v нужна для того, что, например мы сделали вектор из uniqe_ptr или из других типов, которые нельзя копировать, т.е. вектор состоит из типов которые можно мувать но нельзя
копировать. И при этом мув конструктор у них не noexcept, что тогда делать вектору? Тогда вектор просто отказывается от exception safety. Если у нас тип таков, что его нельзя безопастно мувать, но при этом нельзя и копировать 
вообще, тогда мы его всё ровно муваем, потому что нам некуда деваться, но это не безопастно и мы просто не соблюдаем гарантию. Если же тип таков, что его нельзя безопастно мувать, но копировать можно, тогда мы копируем.

Эта функция принимает T&, потому что мы никогда не хотим туда принимать rvalue. И разумеется сама функция тоже должна быть noexcept. 


##################
Что если сделать push_back() в вектор другого элемента этого же вектора?

Представим что у нас есть вектор строк из пяти строк "abc". Стандартные строки умеют муваться, копироваться и всё noexcept.

std::vector<std::string> v(5, "abc");
v.push_back(v[3]);				// Что будет?

С учётом нашей реализации что будет? Будет UB, потому что сначала мы реалацируем вектор (в худшем случае), далее муваем все объекты, и теперь все объекты принадлежат новому вектору, в старом векторе у нас всё 
обнулилось (скорее всего там nullptr). И теперь мы в конец нового вектора хотим вставить 4 элемент старого вектора, но там уже ничего нет, у нас получается битая ссылка.

	|---|---|---|---|---|
	| 0 | 0 | 0 | 0 | 0 |		Старый вектор
	|---|---|---|---|---|
	  |   |   |   |   |    
	  |   |   |   |   |
	|---|---|---|---|---|---|
	| 1 | 2 | 3 | 4 | 5 |   |   		Новый вектор
	|---|---|---|---|---|---|

В push_back() мы принимаем объект по ссылке, но до того как мы его куда то положили, у нас то на что ссылалась ссылка стала невалидным, потому что мы сделали реалокацию и потом решили положить этот же объект на новое
место, но ссылка уже невалидная. Как решить эту проблему? 

На самом деле правильный push_back() сначала кладёт новый элемент в последную ячейку нового вектора а только потом занимается перекладыванием предшедствующих элементов т.е. реалокацией. Именно так он и сделан в 
STL.  Это всё загнано под один большой try. 


##################
Переосмысление принятия параметров в функцию	(Лекция 41 конец 55.00)

После того что мы изучили, почему бы нам не перестать вообще принимать параметры по ссылке, а делать по значению. Представим что мы отказались от принятия параметров по ссылке. Если у нас есть move-семантика то нам не 
нужны ссылки, мы можем просто делать так:

template <typename T>
void f (T x) {
}

Если мы принимаем lvalue, то это скопируется и мы x сможем менять, а если мы принимаем rvalue, то оно мувнеться. Почему бы например нам не написать один такой push_back() вместо двух перегрузок которые есть сейчас?
Зачем нам два разных push_back() если мы можем сделать один позначению, ведь если мы принимаем rvalue, то оно просто мувнется (уже на стадии попадания в аргумент функции оно будет смувлено). Если мы принимаем по 
lvalue то оно один раз скопируется, а дальше мы будем мувать всё ровно. Если мы не хотим никуда это не передавать или ничего не менять то это может быть неоптимально, или если объект не поддерживает мув семантику, но 
если принимать объект и отдвать его куда то или менять его то кажется что нам достаточно написать одну такую функцию, и нам не нужно делать перегрузку между T&& и const T&.  

Это не троллинг и современный кодстайл рекомендует делать так во многих местах. Начиная с C++11 есть смысл в некоторых случаях отказаться от перегрузки по видам разных ссылок. Если у нас объекты заведомо поддерживают
мув семантику то нам м.б. не нужно делать две перегрузки для lvalue и rvalue, нам можно просто сделать одну и по значению, и когда человек будет хотеть скопировать он будет передавать lvalue, а когда человек понимает
что он готов мувнуть, он будет передавать rvalue и мы будем мувать. Получается это обязанность вызывающего решить хочет он мувнуть или скопировать. Это не панацея но во многих случаях нам теперь не нужно писать 
перегрузку по видам ссылок. В современном коде на плюсах зачастую принято принимать значение чтобы не делать перегрузку по разным видам ссылок.

Так почему же push_back() реализован не так, почему там два разных push_back() а не один общий? Для обратной совместимости, а ещё потому что не все типы поддерживают мув семантику. Если бы с приходом C++11 убрали 
старый push_back() и сделали бы такой, то весь старый код теперь бы у нас лишний раз копировался, а ещё если бы мы хотели жить без мув семантики то мы бы не смогли, push_back() обязывал бы нас соблюдать move-семантику,
хотя он не должен этого делать, мы хотим уметь пользоваться push_back() по старинке, например если бы мы вообще не знали про мув семантику. До C++11 вектор занимался перекладыванием полностью. 


##################
Несколько примеров 

Пример с перегрузкой по универсальной ссылке.
Вопрос: что выведется?

template <typename T>
class Optional {
public:
	Optional() = default;

	Optional(const Optional&) {
		std::cout << "A" << std::endl;
	}

	template<typename U>
	Optional(Optional<U>&&) {
		std::cout << "B" << std::endl;
	}

	template <typename U>
	Optional(U&&) {
		std::cout << "C" << std::endl;
	}
};

int main() {
	Optional<int> a;
	Optional<int> b(a);
}

Правильный ответ C. (Ватафак??? я думал A). 

Сначала поймём почему можно было бы решить что B? Потому что точная подстановка всегда лучше чем приведение типов. В A мы принимаем const Optional, а у нас Optional неконстантный, поэтому подставить U в случае B 
казалось бы лучше чем навесить const, однако он не может так сделать, потому что в случае B там rvalue (а не универсальная ссылка, аргумент не соответствует шаблонному типу полностью). B мог бы быть выбран если было бы 
так: Optional(Optional<U>&), но там два амперсанда, поэтому не может быть B впринципе потому что rvalue, B отпадает из-за несоответствия вида value. Осталось понять почему C лучше чем A. Да по той же причине - точная 
подстановка лучше чем соответствие типа, потому что в C можно подставить просто Optional от int и будет lvalue ссылка на Optional от int и это лучше чем const Optional от int в случае A. Т.е. в C можно сделать такую шаблонную 
подстановку, что принимаемый тип будет точным соответствием, а в A у нас в любом случае навешан const. В C в качестве U будет Optional int& и принимаемый тип будет Optional int& и это лучше чем const Optional int& в случае
A потому что тут навешан const, поэтому здесь правильный ответ C.


Хорошо а если мы уберём в B один амперсанд?

	Optional(const Optional&) {
		std::cout << "A" << std::endl;
	}

	template<typename U>
	Optional(Optional<U>&) {			// Один амперсанд
		std::cout << "B" << std::endl;
	}

	template <typename U>
	Optional(U&&) {
		std::cout << "C" << std::endl;
	}

Случай A всё ровно не подходит из-за const, это неявный каст. Но что подходит лучше между B и C? Теперь лучше подходит случай B, потому что частное предпочтительней общего, в C подходит всё то что в B, но и ещё чтото, 
а B это частный случай C. 

А вот если бы мы поменяли main:

	template<typename U>
	Optional(Optional<U>&&) {			// Два амперсанда
		std::cout << "B" << std::endl;
	}

	template <typename U>
	Optional(U&&) {
		std::cout << "C" << std::endl;
	}
};

int main() {
	Optional<int> a;
	Optional<int> b(std::move(a));
}

То в этом случае наооборот подходил бы случай B, по той же самой причине: частное предпочтительней общего. Данную проблему можно встретить при реализации shared_ptr.


Пример 2:
Есть такая функиця std::exchange. Она эффективно заменяет значение obj на значение new_value, и возвращает старое значение obj. т.е. если можно мувнуть то она мувает, а иначе копирует. Как реализовать такую функцию? Допустим
у нас есть два объекта, и мы хотим второму объекту правильно присвоить первый объект.

template<class T, class U = T>
constexpr						// Since C++20
T exchange(T& obj, U&& new_value)			// Здесь U это универсальная ссылка
	noexcept (					// Since C++23
		std::is_nothrow_move_constructible<T>::value &&
		std::is_nothrow_assignable<T&, U>::value
	)
{
	T old_value = std::move(obj);			// Забираем старое значение из obj
	obj = std::forward<U>(new_value);		// obj присваиваем новое значение
	return old_value;				// Возвращаем старое значение. Копирование почти наверника не происходит в возвращаемое значение из-за RVO.
}



Пример 3:
class std::move_iterator
Это адаптер над итератором, который ведёт себя в точности как нижележащий итератор, с той лишь разницей, что разыменование даёт rvalue а не lvalue ссылку. Представим что мы хотим поместить в контейнер какой-то диапазон 
элементов. У нас есть функция insert от диапазона с итератором на начало и конец, и тогда нам в полне могли отдать такой диапазон, ограниченный такими мув-итераторами, и тогда у нас контейнер должен положить в себя эти 
элементы не копированием а муванием, потому что всё в этом итераторе (включая разыменование) такое же как и в обычном итераторе, но когда мы делаем разыменование, мы получаем не lvalue ссылку, а rvalue ссылку.

int main() {
	std::vector<std::string> p {"str1", "str2", "str3", "str4"};
	std::vector<std::string> q;

	for (std::move_iterator it{p.begin()}, end{p.end()}; it != end; ++it) {
		it->push_back('!');
		q.emplace_back(*it);
	}
}

Здесь у нас есть пустой вектор q и вектор строк p, и мы перебераем все эти строки. В цикле в конец каждой строки мы добавляем символ '!' с помощью push_back(), а затем перекладываем мувом все строки в пустой вектор q, т.е.
мы переместили все строки в новый вектор, а в исходном векторе все строки стали пустыми.  


Пример 4:
Теперь когда мы пишем аллокаторы мы должны поддерживать мув-семантику. В аллокаторе есть такая мета-функция: std::allocator_traits<allocator_type>::propagate_on_container_move_assignment. 
Теперь, когда мы реализовываем контейнер но уже с поддержкой мув-семантики, нам ещё нужно при муве контейнера (при мув конструкторе и при операторе перемещения) тоже правильно работать с аллокатором. И тут есть 
печальный случай: У нас есть оператор присваивания вектора (он копирующий), и теперь мы можем написать мувающий оператор перемещения вектора. Но что если при этом у нас алокаторы разные, они находятся на разных пулах. 
В этому случае никакого мува не получится, нам придётся полноценно скопировать, потому что если мы одному вектору присваиваем другой а при этом у них разные аллокаторы (в смысле того что они на разных пулах висят) то мы 
не сможем это мувнуть за O(1). Т.е. иногда если аллокатор нетривиальный и аллокаторы не равны и propagate_on_container_move_assignment = false, т.е. нам нужно ставить свой аллокатор и подменить элементы, но мы не сможем 
этого сделать, нам нужно аллокатор оставить такой же котрый у нас и был, т.е. висеть на том же пуле, и если нам скажут мув то нам придётся копировать, т.е. пересоздавать элементы поштучно. Мы можем каждый отдельный элемент
мувнуть, но в целом мы не можем мувнуть просто весь массив, мы должны поштучно пувать элементы. Т.о. если мы реализовываем мув конструктор и оператор перемещения у контейнера, они не всегда работают за O(1), а только в 
том случае, если с аллокаторами всё хорошо. 


_____________________________________________
Expired values. RVO and copy elision. C++11.

До C++11 существовало только 2 вида value, но с наступлением C++11 классификация была расширена, и добавлены промежуточные или обощённые категории. 
На самом деле в современном C++ категорий value не две а пять. До сих пор мы считали что бывают только lvalue и rvalue, но на самом деле бывают: lvalue, rvalue, glvalue, prvalue, xvalue. 

		glvalue	        rvalue
		/      \       /     \
	       /        \     /       \
	      /          \   /         \
	    lvalue       xvalue       prvalue

lvalue является частным случаем glvalue (g-generalaized т.е. обобщённое lvalue). 
prvalue (p-pure т.е. истинное или настоящее rvalue) является частным случаем rvalue.
Есть нечто, что является одновременно частным случаем glvalue и rvalue - это xvalue (x - expired т.е. просроченное)
Но всё это частные случаи выражений. 

Всё, о чём мы раньше говорили, используя термины lvalue и rvalue это всё правда, просто теперь нужно понимать, что понятия lvalue и rvalue более широкие. Так же нам нужно понять что rvalue подразделяется ещё на два вида и 
понять чем xvalue отличается от prvalue, и почему lvalue и xvalue тоже являются некоторой обобщённой категорией value (glvalue). 

Что из rvalue относится к xvalue, а что к prvalue. Есть настоящее или истинное rvalue (prvalue), а есть какое то другое value (xvalue), и всё это частный случай rvalue. 

xvalue - это те rvalue, которые формально: 
1) результат вызова функции (function call), если возвращаемый тип это rvalue ссылка.
2) касты к rvalue ссылке (cast exp)
3) У нас есть rvalue объект а мы написали точку (или стрелочку) и обратились к какому то полю этого объекта. 
4) Если у нас был rvalue массив и мы обратились к нему квадратными скобочками []. 
5) Ещё технические пункты типо запятой или тернарного оператора. 

Зачем в стандарт добавили ещё такой костыль? Зачем xvalue выделили в отдельную категорию? Зачастую люди ошибочно думают что категории xvalue, prvalue, glvalue это вещи которые нужно понимать чтобы понять 
move-семантику. Это ошибочно. Эти категории они не для мув-семантики вообще то, т.е. мув семантика и без них работать будет. То что мы описали с std::move и std::forward оно всё и без этих видов value нормально объясняется.
Тем не менее кое для чего нужно всё таки из rvalue выделить отдельную подкатегорию (xvalue), и про неё сказать, что с такими объектами чуть-чуть другие правила кое-где. Но это не относиться к std::move или std::forward.
А нужно это для такой штуки как copy elision.


Представим код:

std::string s = std::string("abc");

Вопрос: сколько и какие вызовутся конструкторы? Если формально следовать тем правилам, которые мы изучали, то как будто бы должно вызваться два конструктора: сначала конструктор std::string("abc"), затем мув конструктор s, 
поскольку std::string("abc") это rvalue, затем std::string("abc") должно уничтожится, ну т.е. вообщем 2 конструктора. Но на самом деле сразу вызовется один конструктор s от std::string("abc") и всё, потому что есть такое являние,
называемое copy elision. Стандарт говорит, что если у нас объект инициализируется по средствам prvalue, то промежуточный объект можно впринципе не создавать. Если мы берём какую то переменную, и инициализируем её 
выражением, которое является prvalue, то компилятор имеет право вообще не создавать промежуточный объект. Не будет создана вторая строка, сразу будет создана строка s, которая будет равна "abc", т.е. не будет ещё одной 
строки из которой потом создаётся другая строка, потому что компилятор видит что мы создаём строку из prvalue, а это значит что можно не делать промежуточную строку вообще. 

Но если бы мы здесь написали 

std::string s = std::move(std::string("abc"));

то это уже будет xvalue, и тогда это правило не действует. 


Как можно понимать lvalue и rvalue одной фразой? Чем lvalue отличается от rvalue? lvalue это то чему можно присваивать - это чушь, потому что rvalue тоже можно присваивать. lvalue это не временный объект, rvalue - это 
временный объект - это определение тоже не понятно, что значит временный объект? 

Наиболее бизкое определение что такое lvalue и rvalue: lvalue - это то, чему соответствует какая то ячейка памяти, а rvalue это то, чему необязательно соответсвтует. Это понимание лучше чем два предыдущих, однако это понимание
было верным до C++11, до ввода move-семантики. lvalue - это то, чему соответствует некоторая ячейка памяти, ну грубо говоря то, у чего можно взять адрес, то что лежит реально где-то. А rvalue это то, что нигде не лежит, вообще 
говоря оно может и не лежать в памяти, оно может где-то в промежуточных вычислениях компилятора фигурировать, но в память так и не будет положено. Однако с приходом C++11 это стало несовсем верно, потому что xvalue это
как раз та особая категория которой обязательно что-то в памяти должно соответсвтовать, но при этом оно ведёт себя как rvalue. Так вот glvalue это как раз старое понимание lvalue, это то, чему соответсвтует какая то ячейка памяти,
а rvalue необязательно. Но при этом xvalue, несмотря на то что оно где-то лежит, ведёт себя как rvalue по поведению, xvalue это то что обязано где-то храниться, обязано быть созданно и куда то положено, но по свойствам как rvalue.
Вот поэтому если мы std::string s инициализируем std::move(от чего то там), то сам результат std::move говорит - раз это xvalue, то оно должно где-то быть создано и положено в память поэтому этот код гарантирует, что сначала
создастся промежуточная строка, потом из неё мувнется новая строка. Но если мы prvalue напишем std::string s = std::string("abc"), то компилятор имеет право просто никуда не класть промежуточную строку, а начиная с C++17 
компилятор обязан несоздать промежуточную строку. Это называется garanted copy elision (гарантировання copy elision). 

Тоже самое происходит если мы возвращаем из функции, допустим у нас есть функция которая возвращает строку:

string f() {
	return string("abc");
}

Начиная с C++17 компилятор обязан не создавать промежуточную строку string("abc"), чтобы с помощью её инициализировать строку в которую возвращается значение функции,  а сразу создать эту новую строку как строку 
от "abc". Но если мы здесь напишем:

string f() {
	return std::move(string("abc"));
}

мы сломаем себе copy elision, потому что мы обяжем компилятор эту строку string("abc") всё-таки создать отдельно, мы её превратили в xvalue, тем самым заставили компилятор её куда то положить, только потом из неё создать 
новую строку на возврат. 



Примеры copy elision:
У нас есть класс который выводит что с ним произошло.

struct S {
	int x = 0;
	S(int x): x(x) {
		std::cout << "Created" << std::endl;
	}
	S(const S& s): x(s.x) {
		std::cout << "Copy" << std::endl;
	}
	S(S&& s): x(s.x) {
		std::cout << "Move" << std::endl;
	}
	~S() {
		std::cout << "Destroyed" << std::endl;
	}
};

int main() {
	S s = S(0);	
}

Вывод в терминал:
Created
Destroyed

В данном случае мы видим что создался только один объект.

Хорошо, как вы думаете сколько конструкторов будет создано в этом случае: 

int main() {
	S s = S(S(S(S(S(1)))));	
}

Вывод в терминал:
Created
Destroyed

Создаётся снова один объект. 


Но если мы сделаем std::move

int main() {
	S s = std::move(S(S(S(S(S(1))))));	
}

Вывод в терминал:
Created
Move
Destroyed
Destroyed

то уже будет вызвано два конструктора, а не один. Как это работает под капотом? Почему если мы делаем std::move от prvalue, вдруг это заставляет его вызвать конструктор, хотя так бы он не стал этого делать, он бы мог просто это 
проглотить и не создавать промежуточный объект, но вот мы вызвали std::move от него и внезапно из-за этого он решил создать объект. В какой момент решается что конструктор нужно вызвать, что именно заставляет его решить
что тут нужно добавить вызов конструтора? 

Есть такой термин в стандарте: temporary materialization. Это неявное преобразование из prvalue в xvalue, которое происходит в ограниченном наборе случаев, и вот один из них это когда мы инициализируем rvalue ссылку через своё
prvalue. Компилятор оперирует видами value, и умеет одни виды value неявно преобразовывать в другие виды value, и вот неявное преобразование между prvalue и xvalue называется temporary materialization. Когда оно происходит, 
это значит что компилятор должен создать этот объект в памяти, пока он был prvalue и пока мы его из одного prvalue передавали в другое prvalue ничего страшного не происходит, всё это можно было проглатить и ничего не 
создавать, но когда мы создали xvalue из какого то prvalue, компилятор тут делает эту temporary materialization. В этом словосочетании главное слово это materialization - т.е. материализация временного объекта. Можно так это 
представить: компилятор как бы в уме считает и если мы сделали в какой то момент xvalue из этого, то мы как бы говорим компилятору "а вот это ты запиши пожалуйста в память". 

CppReference:
Если у нас есть prvalue любого полного типа T, оно может быть сконвертировано к xvalue такого же типа, и эта конверсия приводит к тому что временный объект типа T создаётся в памяти.

Список случаев когда происходит temporary materialization:
1) Если мы инициализируем ссылку через prvalue.
2) Если мы к prvalue обращаемся через точку.
3) Если мы делаем array-to-pointer conversion.
4) Если мы инициализируем объект типа std::initializer_list<T> от braced-init-list.
5) Применяем typeid
6) Применяем sizeof
7) Или если мы используем prvalue как discarded-value. discarded-value это когда мы просто игнорируем и не используем результат например функции.

temporary materialization не происходит когда мы просто создаём объект из prvalue ТАКОГО ЖЕ типа путём прямой или копи инициализации, т.е. если мы пишем что std::string s = std::string("abc") то материализация временного 
объекта не происходит, просто создаётся std::string s. Если типы разные то материализация всё таки происходит. То есть:

struct T {				// Другой тип
	T(S) {}
};

int main() {
	T t = S(S(S(S(S(1)))));		// Инициализируем другой тип
}

Вывод в консоль:
Created
Destroyed

Т.е. один объект класса S всё ровно был создан потому что типы разные. Гарантия работает только если у нас одинаковые типы.


Пояснение про 7 пункт. Если мы напишем так:

int main() {
	S(S(S(S(S(1)))));	
}

то компилятор всё ровно не может проигнорировать эту строчку целиком, он всё таки вызовет конструктор но всего один. 

Также временная материализация происходит когда мы делаем так:

int main() {
	int x = S(0).x;	
}

Здесь prvalue обязан превратиться в xvalue. Как только когда мы обращаемся к нему точкой или стрелочкой, создаётся временный объект из этого. 


###########################
lvalue-to-rvalue conversion (неявная конверсия от lvalue к rvalue)

Что такое неявная конверсия от lvalue к rvalue? Мы же не можем неявно rvalue ссылку проинициализировать через lvalue. Мало того что компилятор умеет неявно конвертировать prvalue к xvalue, ещё он умеет неявно 
конвертировать glvalue к prvalue и делает он это когда мы читаем из памяти (неформально lvalue-to-rvalue conversion это чтение из памяти). У нас есть переменная в памяти, а есть регистр процессора с которым мы взаимодействуем,
и когда нам нужно считать переменную из памяти, фактически мы превращаем lvalue в rvalue, т.е. в данном случае lvalue это то что записано в памяти, а rvalue это временная штука с которой мы будем делать вычисления. Получается
lvalue-to-rvalue conversion это когда мы например из под указателя считали значение, у нас выражение *p это lvalue, но считав из него значение мы его превратили в rvalue. 

*p = *q;

*p - это настоящее lvalue мы туда записали, а *q мы от туда считали, взяли из памяти значение и в терминах ассемблера положили его как бы в регистр чтобы потом записать в *p, так вот это и есть lvalue-to-rvalue conversion, 
считывание из памяти и помещение в регистр процессора это как бы lvalue-to-rvalue conversion - из того что записано в памяти взять на руки и прочитать. 

И наоборот prvalue-to-xvalue conversion это у нас на руках было какое то значение и мы решили его записать, чтобы потом уже с ним что-то делать. Вот так предлагаем воспринимать lvalue и rvalue, однако формально это очень
сложно. Хоть lvalue-to-rvalue conversion неявно разрешены, всё ровно в prvalue ссылки нельзя принять lvalue без явной конверсии.  И не нужно путать lvalue-to-rvalue conversion с инициализацией rvalue ссылки посредством lvalue, 
первое можно а второе нельзя.


###########################
RVO (Return value optimization) Non-mandatory copy/move elision

Настало время поговорить про RVO с более глубоким пониманием.

Иногда (это не гарантируется стандартом, но скорее всего все компиляторы так делают) у нас copy elision может происходить на возврате из функции:

string f() {				
	return string("abc");
}

Пример RVO. Это частный случай copy elision. Но если мы напишем return std::move(string("abc")) мы испортим себе RVO, вынудив компилятор создать промежуточную строку и мувнуть:

string f() {
	return std::move(string("abc"));
}

Мораль: когда мы возвращаем что-то из функций по значению обычно move писать не нужно. Если мы напишем move скорее всего мы здесь сами себе навредим а не поможем. 

RVO мощнее чем просто copy elision. Есть ещё named return value optimization (NRVO)

Пример:

std::string f() {
	// return std::string("abc");			// Так нормально. Это обычная copy elision
	
	// return std::move(std::string("abc"));	// Так ненормально, мы добавили дополнительный мув конструктор

	// Пример RVO
	std::string str = "abc";			// Создаём локальную переменную
	return str;					// Возвращаем локальную переменную
}

В момент возврата строки нам может захотется написать return std::move(str), но так тоже не нужно делать, это тоже неправильно, потому что RVO работает даже над lvalue, если это просто имя переменной. Когда мы из функции
что-то возвращаем по значению, если это просто имя переменной, которая была локальной переменной данной функции, причём мы всегда возвращаем только её, т.е. НЕТ такого:

if(условие)
	return x1;					// В обоих случаях RVO не сработает, return должен быть один.
else
	return x2;

тогда компилятор умеет эту переменную создать сразу на том месте, где мы ожидаем возврат из функции и не будет ни копи ни мува здесь. 

Пример: S будет создано только один раз:

S f() {
	S s = 1;
	return s;
}

int main(){
	S s = f();
}

Вывод в терминал:
Created
Destroyed

Конструктор S был вызван только один раз, потому что в месте = f() сработала copy elision, мы инициализируем s через prvalue, а в месте return s сработала named RVO имменого значения (NRVO), компилятор увидил что мы
возвращаем из функции локальный объект для этой же функции, и он его сразу создал на месте возврата. Но если мы в возврате напишем std::move(s), то RVO не будет, будет мув конструктор:

S f() {
	S s = 1;
	return std::move(s);
}

int main(){
	S s = f();
}

Вывод в терминал:
Created
Move
Destroyed
Destroyed

Потому что RVO не работает если мы возвращаем не s, а какой то експрешен от s. Здесь результат вызова f() это prvalue (если бы мы возвращали из функции T&& - rvalue ссылку, то результат вызова функции был бы xvalue, 
получается xvalue это rvalue-ссылки как раз). Если мы возвращаем копи то это prvalue, в этом и смысл вводить xvalue. 

RVO работает только для локальных переменных функции. Если бы мы приняли что-то в функцию и потом это же вернули то RVO работать не будет:

S f(S a) {
	return a;		// RVO не работает в этом случае потому что a это не локальная переменная.
}

int main() {
	S t(0);
	S s = f(t);
}

Считаем вызовы конструкторов:
Здесь мы создаём объект t с помощью обычного конструктора (1), затем вызываем функцию f и передаём в неё наш объект t копированием (здесь создалась локальная копия t (2)), затем возвращаем его для создания другого объекта
s (3). В момент когда мы инициализировали s с помощью возврата из функции f(): S s = f(t) небыло вызвано никакого конструктора, поскольку был copy elision. При возврате copy elision сработает, поскольку объекты одинакового типа,
однако RVO не будет работать. В итоге поэтому у нас вызвалось 3 конструктора:

Вывод в терминал:
Created		(Создание t)
Copy		(Копирование в функцию f)
Move		(Возврат из функции f)
Destroyed
Destroyed
Destroyed

Почему в третий раз вызвался мув конструктор, а не копи конструктор? При возврате из f() почему то вызвался мув конструктор а не копи конструктор? Потому что есть ещё одно правило в стандарте: даже если компилятору не 
удаётся сделать RVO при возврате из функции, но переменная локальная, он её мувает, а не копирует на возврат. Т.е. написав std::move мы точно не выиграем, если мы думем что избавимся от копии, то мы от неё не избавимся, 
компилятор не обязан делать RVO при возврате из функции, если мы возвращаем имя локальной переменной, но он обязан как минимум мувнуть её, а в лучшем случае избавиться от вызова конструктора вообще. 

Ещё раз: если мы из функции возвращаем локальную переменную, причём это может быть как аргумент функции так и просто её локальная переменная внутри функции (и чтобы это была не ссылка, а локальный объект), компилятор
попытается сделать RVO (т.е. не вызвать никакой конструктор для возврата), но даже если не получится, он обязан по крайней мере вызвать мув конструктор. Поэтому объект t в функцию f() мы приняли через копи конструктор, 
и он стал локальной переменной (копией), а на выходе мы вызвали мув конструктор. Если бы мы написали std::move то мы бы ничего не выиграли, а потенциально проиграли, потому что тогда компилятор точно бы не сделал RVO. RVO 
можно только для локальных переменных, а для аргументов функций нельзя (Этот вопрос задают на собесах). 


###########################
Пример когда std::move после return нужно писать:

Иногда return std::move всё-таки осмысленен, когда у нас была изначально rvalue-ссылка:

S f(S&& a) {				// rvalue ссылка в аргументе 
	return std::move(a);		// Сейчас нужно написать std::move, иначе будет копирование	
}

int main() {
	S t(0):
	S s = f(std::move(t));		// Принимаем в функцию по rvalue ссылке 
}

Если бы мы НАПИСАЛИ return std::move(a): 
Вывод в терминал:
Created		
Move		
Destroyed
Destroyed

Здесь мы делаем мув вместо копирования на возврате.


Если бы мы НЕ написали return std::move(a), а просто return a: 
Вывод в терминал:
Created		
Copy		
Destroyed
Destroyed

Объект t сначала создастся, затем скопировался. В таком сценарии у нас вызывается сначала конструктор, потом копи конструктор. Копи конструктор вызывается при возврате из функции. a это нелокальный объект, а ссылка на 
какой то внешний объект, но сама переменная a при этом lvalue. Если бы компилятор знал что a это мой локальный объект, то он бы его мог мувнуть, потому что он понимает что всё ровно сейчас он его уничтожит при выходе из этой
функции, но так компилятор не может сделать потому что a это ссылка, а сам объект где то в другом месте живёт. И вот в такой ситуации написать std::move осмысленно и рекомендуется, если мы приняли по rvalue ссылке и 
возвращаем это же ссылку. 

Однако RVO  в обоих случаях не работает, поскольку a это не локальный объект, а ссылка на другой объект.



Реализация оператора + в BigInteger:

BigInteger operator+(const BigInteger& a, const BigInteger& b) {
	BigInteger sum = a;
	sum += b;
	return sum;
}

При такой реализации у нас только один раз создатся новый BigInteger, потому что мы создали локальный объект, затем его вернули, произойдёт RVO и поэтому копия не создастся на возврате. Если бы мы решили повыпендриваться и
написали бы вот так:

BigInteger operator+(const BigInteger& a, const BigInteger& b) {
	BigInteger sum = a;
	return sum += b;
}

то мы проиграли, потому что теперь мы делаем return не переменной, а експрешена который lvalue, и теперь компилятор не умеет делать RVO, т.о. мы создали лишную копию. (Скорее всего копия а не мув, потому что аргументы 
переданы через ссылку).

Если бы мы приняли BigInteger по значению и написали бы так:

BigInteger operator+(BigInteger a, BigInteger b) {
	a += b;
	return a;
}

Здесь мы бы создали уже два объекта, RVO для аргумента функции нельзя сделать, но второй объект создался бы мувом а не копированием, потому что a по значению т.е. является локальной копией, и если компилятор не может сделать
RVO, то должн сделать мув. Эта реализация хуже чем первая потому что создаётся второй объект, но он хотябы создаётся муванием а не копированием. 

И если бы у нас оператор + от первого аргумента был бы rvalue, мы бы могли написать так:

BigInteger operator+(BigInteger&& a, const BigInteger& b) {
	a += b;
	return std::move(a);
}

В этому случае мы не создали ни одной копии, мы приняли rvalue, и затем мувнули её на return. В такой реализации у нас будет 0 копий. Если бы мы не сделали мув, мы бы скопировали. 



______________________________________________________________________________________
Теория: Существуют случаи когда передача принимаемого значения в функции по значению лучше чем передача по ссылки:

Например если это переменные примитивных типов: int, char и т.д. (Т.е. Не string и не vector)

Передавая их по ссылке мы ничего не эконимим: сама ссылка при передачи в функцию передаётся как указатель. Т.е. на стек кладётся указатель который весит 8 байт, но и сами 
примитивные переменные весят не больше 8 байт. 

А по эффективности даже проигрываем, потому что разыминовывание указателя это более долгая операция, чем обращение к переменной непосредственно.

























