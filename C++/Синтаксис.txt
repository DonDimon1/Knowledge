Функции:
void f(); - объявление функции

void f(){}; - определение функции. Любое определение также является объявлением.

Переменные:
int x; - определение переменной. (определение а не объявление, поскольку там сейчас храниться мусор, но он храниться, т.е. переменная не пустая)

x = 10; - инициализация переменной (инициализация когда есть знак =)

extern int y; - переменная объявлена, но не определена. (extern означает что переменная определена, где то в другом месте)


x; - неквалифицированный
N::x; - квалифицированный



______________________________________________________________________________________
Атрибуты (Attribute) С++11

Начиная с C++11 мы можем иногда помечать функции переменные и аргументы функций атрибутами. Атрибуты это элемент синтаксиса в двойных квадратных скобочках перед типом. Это
влияет на компилятор, например атрибут no_unique_address (since C++20) означает что можно этому объекту не заводить отдельный адрес:

struct Empty {};

struct Y {
	int i;
	[[no_unique_address]] Empty e;	
};

Раньше была EBO (Empty base optimization) для того чтобы аллокатор в векторе не занимал отдельные 8 байт, несмотря на то что он пустой, приходилось от него наследоваться приватно. Начиная с 
C++20 можно так не делать, а можно просто писать этот атрибут про некоторые поля класса и у них не будет своих адресов. Однако если у нас есть несколько таких полей, то они не могут иметь
один адрес: 

struct Z {
	char c;
	[[no_unique_address]] Empty e1, e2;	
};

e1 и e2 не могут быть одинакового адреса, потому что у них одинаковый тип, несмотря на то что они помечены [[no_unique_address]], но любой из них может шарить свой адрес с переменно c.

Самый частовстречающийся атрибут: nodiscard. Это атрибут который ставится перед функциями и говорит компилятору что нужно выдать ворнинг если результат этой функции дискардится - 
т.е. результат этой функции неиспользуется (результат этой функции вычисляется, но с её значением ничего не делается). Это важно для функций, результат которых точно нужно сохранить или 
опасно игнорировать, например operator_new или метод allocate, в стандарте они помечены этим атрибутом.

Также например проверка контейнера на пустату, функция: empty также помечена атрибутом nodiscard, но зачем? Например size и capacity непомечены этим тэгом, но empty помечен, почему?
Потому что название функции empty можно воспринять как глагол, т.е. можно подумать что это функция чистит контейнер а не проверяет его на пустоту.  Т.е. название этой функции может 
ввести в заблуждение, поэтому если мы не будем использовать возвращаемое значение компилятор нам кинет ворнинг и мы можем понять что делаем чтото не так.

Атрибут deprecated - устаревшая функция, её не нужно больше использовать. 

Атрибут maybe_unused (C++17) - это атрибут, который ставится перед аргументами функций. Он говорит что этот аргумент может не использоваться в теле функции и компилятор не должен 
жаловаться. Вопрос, зачем нужен этот атрибут, если просто можно не дать имя переменной. Ответ: этот атрибут крайне полезен для шаблонного кода, например у нас может быть шаблонная 
функция с компайлтайм условием при котором этот аргумент используется, а при остальных нет, и при некоторых T у нас будет unused аргумент, а при некоторых T будет used. 

Атрибуты likely и unlikely (since C++20). likely это штука которую мы можем ставить после if, подсказывая компилятору что эта ветка if более вероятна, чем альтернативная. Это помогает 
компилятору лучше оптимизировать код, лучше делать бренч предикшен. 

Атрибут assume (since C++23). Штука которая позволяет оптимизировать. Например у нас функция принимает беззнаковый int и мы знаем что этот int всегда меньше и мы можем компилятору 
об этом сказать используя этот атрибут: assume(x < 100). 