https://y2kot.gitbook.io/untitled
______________________________________________________________________________________
Введение в паттерны

Главная идея: Разделяй и властвуй.


# Что такое паттерны проектирования?
Паттерны проектирования - это набор общепринятых подходов, предназначенных для решения проблем, возникающих в процессе проектирования и разработки программного обеспечения. Паттерны описывают 
определенные способы организации классов и связей между ними.
Используются для достижения таких целей, как улучшение декомпозиции задачи и легкой модификации кода. Паттерны обеспечивают возможность повторного использования кода.


# Основная идея
Основная идея паттернов проектирования заключается в предоставлении типовых решений для проблем, с которыми сталкиваются разработчики. Вместо того, чтобы каждый раз "изобретать велосипед" 
и декомпозировать задачу с нуля, можно использовать проверенные проектные подходы.


# Преимущества
Готовое решение
Упрощение модификации кода
Облегчение взаимодействия между программистами
Повышение скорости разработки
Увеличение надежности кода
Повышение читаемости кода


# Недостатки
Увеличение объема кода
Увеличение времени выполнения
Высокие требования к памяти
Увеличение времени компиляции
Может привести к уменьшению скорости разработки

Структура паттернов:
1) Порождающие паттерны
2) Структурные паттерны
3) Поведенческие паттерны



______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Порождающие паттерны

# Общее описание
Полиморфизм – это очень мощный механизм, который позволяет модифицировать программу «не изменяя» написанный код, за счет добавления новых классов. Дословный перевод полиморфизма - много форм. 
Синоним полиморфизма – безразличие, когда один и тот же код может работать с объектами разных классов (типов).


# Проблема
При модификации программы происходит подмена объектов одних классов на объекты других классов. Как правило, в объектно-ориентированных языках это реализуется за счет передачи в методы ссылок 
(указателей) на базовые полиморфные классы или за счет интерфейсов. При использовании обобщений (шаблонов) подстановка типов осуществляется на этапе компиляции.
При использовании полиморфизма рано или поздно возникает необходимость создания конкретного объекта (сущности) конкретного типа. Для расширения, модификации или подмены сущности будет необходимо найти 
все места, где создается объект, и изменить код. Такая модификация программы увеличивает время разработки, понижает надежность программы, приводит к проблемам с версионностью.

# Порождающие паттерны
Порождающие паттерны – группа паттернов проектирования, которые:
1) берут на себя ответственность за логику создания объектов,
2) позволяют нам не создавать в методах объекты конкретных классов,
3) дают возможность принимать решение объекты каких классов нужно создавать при выполнении программы,
4) дают возможность повторно использовать уже созданный объект.


# Текущий список порождающих паттернов 
1) Фабричный метод
2) Абстрактная фабрика
3) Прототип
4) Строитель
5) Одиночка
6) Пул объектов

______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Фабричный метод (Factory method)

# Проблема
При использовании полиморфизма появляется возможность подмены объекта одного класса на объект другого класса с использованием ссылки (указателя) на базовый абстрактный класс. При создании объекта 
конкретного класса может возникнуть необходимость подмены одной сущности на другую, в результате чего придется искать, где создается объект, и менять написанный код. В попытках решить эту проблему, 
сформировалась идея передачи ответственности создания конкретного объекта другому классу.

# Назначение
Фабричный метод (Factory method) - порождающий паттерн проектирования, определяющий единый интерфейс создания объектов и позволяющий менять класс создаваемого объекта.

# Решаемые задачи
1) Подмена создания объекта одного класса на объект другого класса
Появляется возможность создавать объекты, являющиеся наследниками одного базового класса, без привязки к конкретным классам. Это позволяет легко расширять, модифицировать программу, добавляя новые 
классы, без изменения клиентского кода, который создает объекты классов.

2) Отделение принятия решения, какой объект нужно создать, от самого процесса создания объекта
После принятия решения о выборе конкретного типа создаваемого объекта создается объект (Creator) конкретного фабричного метода. Фактическое создание объекта происходит при непосредственном вызове 
метода createProduct() фабричного метода (Creator).

3) Повторное использование объектов
Появляется возможность повторного использования уже созданного объекта в разных местах программы.

# UML диаграмма паттерна "Фабричный метод"

			/------------\				 /------------------\		  /-----------\
			|  Product   |				 |      Creator	    |		  | Solution  |
			|------------| <------------------------ |------------------| <-----------|-----------|
			|+operation()|				 | +createProduct() |		  | +create() |
			\------------/				 \------------------/		  \-----------/
			      /\					   /\				/\
			      ||					   ||				||
			      ||					   ||				||
		    /---------/\----------\				   ||				||
		    |			  |			   /---------------\	       /------------------\
		    |			  |			   |ConcreteCreator|	       | ConcreteSolution |
	 /----------------\	  /----------------\		   |---------------|	       |------------------|
	 |ConcreteProduct1|	  |ConcreteProductN|		   |	 -//- 	   |	       |       -//- 	  |
	 |----------------|  ...  |----------------|		   \---------------/	       \------------------/
	 | 	-//-	  |	  |	 -//-      |
	 \----------------/	  \----------------/


Product - интерфейс объектов, которые создаются подклассами Creator.
Creator - абстрактный класс, который предоставляет интерфейс для создания объектов подклассов конкретного продукта (Product).
Solution - абстрактный класс, который предоставляет интерфейс для подклассов, принимающих решения, объект какого подкласса продуктов (Product) надо создавать и возвращающий объект подкласса 
	конкретного Creator.


# Преимущества
1) Избавление методов от создания объектов конкретных классов, что решает проблему подмены объекта одного класса на объект другого класса.
2) Упрощение добавления новых классов без изменения написанного кода.
3) Возможность разделения принятия решения о создании объекта и собственно создание объекта в разных местах программы.
4) Возможность принимать решение, объект какого класса необходимо создавать, не во время компиляции, а во время выполнения программы.
5) Возможность во время выполнения программы подменять создание объекта одного класса на объект другого класса.

# Недостатки
1) Увеличивается объем кода.
2) Увеличивается время компиляции.
3) Увеличивается время выполнения программы из-за использования полиморфизма.
4) Увеличивается количество требуемой памяти.
5) Требуется создание параллельных иерархий классов.
6) Необходимость перекомпилировать один и тот же код при добавлении новых типов объектов.
7) Необходимость в передаче ссылки (указателя) на абстрактный создатель (Creator) в методы клиентского кода, где необходимо создавать объекты.

# Связь с другими паттернами
Фабричный метод может быть использован внутри Абстрактной фабрики для создания конкретных объектов. Вместо того, чтобы создавать объекты напрямую, абстрактная фабрика может использовать 
фабричный метод для создания экземпляров объектов определенного типа.


______________________________________________________________________________________
Общая реализации Фабричного метода на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/factory-method/realizacii-na-s++ (Удобнее смотреть)

### Файл Car:

class Car							// Абстрактный базовый класс
{
public:
    virtual ~Car() = default;
    virtual void drive() = 0;
};


class Sedan : public Car					// Наследник Car
{
public:
    Sedan() 
    { 
        cout << "Sedan constructor called" << endl; 
    }
    
    ~Sedan() override 
    { 
        cout << "Sedan destructor called" << endl; 
    }

    void drive() override 
    { 
        cout << "Driving sedan" << endl; 
    }
};

class SUV : public Car 						// Наследник Car
{
public:
    SUV() 
    {
        cout << "Calling the SUV constructor;" << endl;
    }
    
    ~SUV() override 
    { 
        cout << "Calling the SUV destructor;" << endl; 
    }

    void drive() override 
    { 
        cout << "Driving SUV;" << endl; 
    }
};


### Файл Concepts
// Здесь определяются два концепта, который позволяют уточнять, какие требования должны быть выполнены для типов, используемых в шаблонах. 

template <typename Derived, typename Base>
concept Derivative = is_abstract_v<Base> && is_base_of_v<Base, Derived>;  // Этот концепт проверяет, что тип Derived является потомком (унаследованным типом) от Base, где Base должен быть абстрактным классом.

template <typename Type>
concept NotAbstract = !is_abstract_v<Type>;				  // Этот концепт проверяет, что тип Type не является абстрактным классом.


### Файл CarCreator
// Этот код использует концепты для создания иерархии классов и гарантирует, что конкретные реализации фабричного метода соответствуют определённым условиям.

class CarCreator						// Абстрактный базовый класс, который определяет интерфейс для создания объектов типа Car
{
public:
    virtual ~CarCreator() = default;
    virtual unique_ptr<Car> createCar() const = 0;
};


template <Derivative<Car> TCar>				// Проверяет, что тип TCar является производным от Car.
requires NotAbstract<TCar>				// (Условие) Проверяет, что тип TCar не является абстрактным классом.
class ConcreteCarCreator : public CarCreator		// Принимает в качестве шаблонного параметра тип TCar, который должен быть производным от Car и не должен быть абстрактным. Это гарантируется через концепты.
{
public:
    unique_ptr<Car> createCar() const override 		// Создаёт объект типа TCar с помощью функции make_unique и возвращает уникальный указатель на этот объект
    {
        return make_unique<TCar>();
    }
};


### Файл CarCreatorMaker
// CarCreatorMaker реализует фабрику фабрик (Factory of Factories), то есть это метафабрика, которая создает объекты CarCreator, специализирующиеся на создании конкретных типов Car. 

class CarCreatorMaker
{
public:
    template <Derivative<Car> TCar>	// Шаблонный параметр TCar: Тип машины, который должен быть производным от Car и не должен быть абстрактным классом. Это обеспечивается концептами Derivative<Car> и NotAbstract<TCar>.
    NotAbstract<TCar>
    static unique_ptr<CarCreator> createCarCreator() 	// Возвращает указатель на объект CarCreator, который будет использоваться для создания объектов типа TCar.
    {
        return make_unique<ConcreteCarCreator<TCar>>();	// Метод создает и возвращает объект ConcreteCarCreator<TCar>, который знает, как создавать конкретные экземпляры типа TCar.
    }
};


### Файл User
// Представляет собой клиентский код, который использует объекты типа CarCreator для создания и использования объектов типа Car.

class User
{
public:
    void use(const shared_ptr<CarCreator>& creator)	// Метод принимает в качестве аргумента shared_ptr<CarCreator>, который указывает на объект, способный создавать экземпляры Car.
    {
        if (!creator) throw runtime_error("The creator is missing!");	// проверяется, что указатель creator не является nullptr

        shared_ptr<Car> car = creator->createCar();			// вызывает creator->createCar(), чтобы создать объект Car. Использование shared_ptr вместо unique_ptr здесь предполагает, что объект Car может быть использован в других местах программы после вызова метода use.
        car->drive();							// выполняет какое-то действие, связанное с конкретной реализацией автомобиля.
    }
};



#######
Класс Solution выполняет роль посредника между клиентским кодом и классами создателей продуктов. Он отвечает за регистрацию методов создания объектов для каждого типа продукта и предоставляет методы 
для создания объектов по их идентификаторам.


### Файл VehicleSolution
class VehicleSolution								// используется для регистрации и создания объектов CarCreator на основе идентификаторов. 
{
public:
    using CreateCarMaker = unique_ptr<CarCreator>(&)();				// CreateCarMaker - это тип, представляющий собой указатель на функцию, которая возвращает unique_ptr<CarCreator>. Это будет функция-фабрика, создающая объекты CarCreator.
    using CallBackMap = map<size_t, CreateCarCreator>;				// CallBackMap  - это тип, представляющий ассоциативный контейнер (карта), где ключ (size_t) — это идентификатор, а значение — это функция CreateCarCreator, которая создает объект CarCreator.

public:
    VehicleSolution() = default;
    VehicleSolution(initializer_list<pair<size_t, CreateCarCreator>> list);	// Конструктор, принимающий список инициализации (initializer_list), который позволяет инициализировать объект VehicleSolution с заранее определенным набором пар идентификаторов и функций создания.

    bool registrate(size_t id, CreateCarCreator createfun);			// Метод для регистрации новой функции создания объекта CarCreator в карте callbacks с определенным идентификатором id.
    bool check(size_t id) 							// Метод для удаления функции создания по заданному идентификатору id. Возвращает true, если элемент был удален (т.е. если такой идентификатор был в карте).
    { 
        return callbacks.erase(id) == 1; 
    }

    unique_ptr<CarCreator> create(size_t id);					// Метод для создания объекта CarCreator на основе зарегистрированной функции для указанного идентификатора id. Возвращает unique_ptr<CarCreator>.

private:
    CallBackMap callbacks;							// Карта, которая хранит ассоциации между идентификаторами и функциями создания объектов CarCreator.
};


### Файл Methods
// Реализация методов файла VehicleSolution

# pragma region Solution
VehicleSolution::VehicleSolution(initializer_list<pair<size_t, CreateCarCreator>> list) // Конструктор принимает список инициализации пар size_t (идентификатор) и CreateCarCreator (функция, создающая объект CarCreator).
{
    for (auto&& elem : list)								// В цикле проходит по каждой паре в списке и регистрирует ее, вызывая метод registrate.
        this->registrate(elem.first, elem.second);					// Вызываем registrate 
}

bool VehicleSolution::registrate(size_t id, CreateCarCreator createfun)			// Метод регистрирует новую функцию создания объекта CarCreator в карте callbacks с определенным идентификатором id.
{
    return callbacks.insert(CallBackMap::value_type(id, createfun)).second;
}

unique_ptr<CarCreator> VehicleSolution::create(size_t id)				// Метод ищет функцию создания CarCreator по переданному идентификатору id.
{
    CallBackMap::const_iterator it = callbacks.find(id);				// Если такая функция найдена, она вызывается для создания объекта CarCreator, и результат оборачивается в unique_ptr<CarCreator>.

    return it != callbacks.end() ? unique_ptr<CarCreator>(it->second()) : nullptr;
}

shared_ptr<VehicleSolution> make_solution(						// Эта функция служит фабрикой для создания объектов VehicleSolution, инициализируя их списком пар идентификаторов и функций создания.
    initializer_list<pair<size_t, 
    VehicleSolution::CreateCarCreator>> list
)
{
    return shared_ptr<VehicleSolution>(new VehicleSolution(list));
}
# pragma endregion



### Файл main

# include <iostream>
# include <initializer_list>
# include <memory>
# include <map>
# include <exception>

using namespace std;

int main()
{
    try
    {
        shared_ptr<VehicleSolution> solution
        = make_solution({ {1, CarCreatorMaker::createCarCreator<Sedan>} });		// создает экземпляр VehicleSolution. Внутри него регистрируется фабрика, ассоциированная с идентификатором 1, которая будет создавать машины типа Sedan.

        if (!solution->registrate(2, CarCreatorMaker::createCarCreator<SUV>))		// добавляет еще одну фабрику, ассоциированную с идентификатором 2, для создания машин типа SUV.
        {
            throw runtime_error("Error registration!");
        }
        shared_ptr<CarCreator> cr(solution->create(2));					// Создается объект CarCreator на основе идентификатора 2 (для SUV) и передается в метод User::use.

        User{}.use(cr);									// Метод use создает объект Car с помощью переданного CarCreator и вызывает метод drive.
    }
    catch (runtime_error& err)
    {
        cout << err.what() << endl;
    }
}


# Пример вывода:
Driving an SUV.


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/factory-method/concrete-implementation



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Абстрактная фабрика (Abstract factory)

# Проблема
В процессе разработки программы может возникнуть необходимость создания иерархии разных классов, объекты которых должны использоваться совместно. Таким примером может являться система графики, в 
которой происходит взаимодействие множества компонентов: кистей, ручек, форм, канвасов.

Фабричный метод не поддерживает связь между иерархиями классов. Например, нет возможности подменить одну графическую систему на другую. В таком случае возможным решением является объединение методов 
создания иерархий объектов разных классов в один класс.

# Назначение
Абстрактная фабрика(Abstract factory) — порождающий паттерн проектирования, определяющий единый интерфейс создания иерархий классов и позволяющий менять одно семейство связанных объектов на другое.
Семейством связанных объектов могут быть, например, объекты конкретной графической подсистемы (brush, pen, marker, canvas).

# Решаемые задачи
1) Возможность создавать и подменять одно семейство объектов на другое
Появляется возможность создавать семейства связанных объектов. При необходимости можно легко заменять или добавлять новые семейства объектов, не изменяя другие части кода, которые используют 
эти объекты.

2) Отделение принятия решения о том, какое семейство объектов нужно создать, от самого процесса создания объектов семейства
Решение о выборе конкретного семейства принимается в части кода, который использует абстрактную фабрику. Во время выполнения этот код определяет, какое семейство связанных объектов требуется 
создать, и создает соответствующую фабрику. В коде через абстрактную фабрику вызываются методы создания объектов конкретных иерархий классов.

3) Повторное использование объектов
Появляется возможность повторного использования уже созданных семейств объектов.

# UML диаграмма паттерна "Абстрактная фабрика"

			/-----------\				 /------------------\				 /-----------\
			|  BasePen  |				 |  AbstractFactory |		  		 | BaseBrush |
			|-----------| <------------------------  |------------------|  ------------------------> |-----------|
			|    ...    |				 |   +createPen()   |				 |    ...    |
			\-----------/				 |  +createBrush()  |				 \-----------/
								 \------------------/		
			      /\					  /\					       /\
			      ||					  ||					       ||
			      ||					  ||					       ||
			      ||					  ||					       ||
		      /---------------\				 /------------------\   		      	  /----------\   
		      |	    QtPen     |	 			 | QtGraphicFactory |  			      	  |  QtBrush |
	 	      |---------------|	       			 |------------------|			      	  |----------|
		      |	    -//-      |	       			 |	 -//-       |			      	  |   -//-   |
                      \---------------/	     			 \------------------/			      	  \----------/


# Преимущества
1) Избавление методов от привязки к конкретным классам, что решает проблему подмены объекта одного семейства класса на объект другого семейства классов.
2) Упрощение добавления новых семейств объектов без изменения написанного кода.
3) Возможность принимать решение, объект какого семейства создавать, и создавать объекты в разных местах программы.
4) Возможность принимать решение, объект какого семейства необходимо создавать, не во время компиляции, а во время выполнения программы.
5) Возможность во время выполнения программы подменять создание объекта одного семейства класса на объект другого класса.

# Недостатки
1) Увеличивается объем кода.
2) Увеличивается время компиляции.
3) Увеличивается время выполнения программы из-за использования полиморфизма.
4) Увеличивается количество требуемой памяти.
5) Требуется создание параллельных иерархий классов.
6) Необходимость перекомпилировать один и тот же код при добавлении новых типов объектов.
7) Семейства объектов должны быть однородны по своей структуре, иначе выделить базовую абстракцию в абстрактной фабрике будет невозможно.
8) Возможность наличия неполных семейств объектов.

# Связь с другими паттернами
1) Абстрактная фабрика может использовать Фабричный метод для создания конкретных объектов. Вместо того, чтобы иметь только один метод для создания объектов, абстрактная фабрика может использовать 
фабричный метод в своей реализации.
2) Абстрактная фабрика может быть комбинирована с паттерном Строитель для создания сложных объектов.



______________________________________________________________________________________
Общая реализация на языке С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/abstract-factory/realizacii-na-s++

### Файл BaseGraphics:

class BaseGraphics 						// Базовый абстрактный класс графики
{
public:
    virtual ~BaseGraphics() = 0;
};

BaseGraphics::~BaseGraphics() {}


class QtGraphics : public BaseGraphics				// Наследуемый класс
{
public:
	QtGraphics(shared_ptr<Image> im) 
	{
		cout << "Calling the QtGraphics constructor;" << endl; 
	}
	
	~QtGraphics() override 
	{ 
		cout << "Calling the QtGraphics destructor;" << endl; 
	}
};


### Файл AbstractGraphFactory:

class AbstractGraphFactory 					// это абстрактный класс, который объявляет методы для создания различных графических объектов: Graphics, Pen и Brush.
{			
public:
	virtual ~AbstractGraphFactory() = default;

	virtual unique_ptr<BaseGraphics> createGraphics(shared_ptr<Image> im) = 0; // Каждый метод возвращает указатель (unique_ptr) на базовый класс (BaseGraphics, BasePen, BaseBrush), что позволяет скрыть детали конкретных реализаций.
	virtual unique_ptr<BasePen> createPen(shared_ptr<Color> cl) = 0;
	virtual unique_ptr<BaseBrush> createBrush(shared_ptr<Color> cl) = 0;
};


class QtGraphFactory : public AbstractGraphFactory	// QtGraphFactory — это конкретная реализация абстрактной фабрики. Она создает объекты, специфичные для Qt.
{
public:
	unique_ptr<BaseGraphics> createGraphics(shared_ptr<Image> im) override	// Метод createGraphics создает и возвращает объект типа QtGraphics, используя переданный объект Image.
	{
		return make_unique<QtGraphics>(im);
	}

	unique_ptr<BasePen> createPen(shared_ptr<Color> cl) override
	{
		return make_unique<QtPen>();
	}

	unique_ptr<BaseBrush> createBrush(shared_ptr<Color> cl) override
	{
		return make_unique<QtBrush>();
	}
};


Абстрактная фабрика позволяет создать целое семейство связанных или зависимых объектов (в данном случае, объекты Graphics, Pen, и Brush) без необходимости привязываться к конкретным классам этих 
объектов. Клиентский код (тот, который будет использовать эту фабрику) будет работать с объектами через их базовые интерфейсы, не зная о том, какие именно конкретные классы используются. Это позволяет 
легко заменить, например, QtGraphFactory на другую фабрику (например, GDIPlusGraphFactory), которая будет создавать объекты для другой графической системы, без изменений в клиентском коде.


### Файл User
class User 			// класс User взаимодействует с объектами, создаваемыми с помощью фабрики AbstractGraphFactory
{
public:
	void use(shared_ptr<AbstractGraphFactory>& cr) // Метод use принимает объект cr, который является shared_ptr на объект типа AbstractGraphFactory. Этот объект AbstractGraphFactory может быть любой конкретной фабрикой, которая наследует AbstractGraphFactory, например, QtGraphFactory.
	{
		shared_ptr<Image> image = make_shared<Image>(); // Внутри метода use создается объект Image с помощью make_shared<Image>. Это изображение будет использоваться при создании объекта Graphics.
		auto graphics = cr->createGraphics(image); // Вызов cr->createGraphics(image) использует фабрику, чтобы создать объект графики (Graphics) на основе переданного изображения. Конкретный тип объекта Graphics зависит от того, какая конкретная фабрика передана в use (например, если это QtGraphFactory, то будет создан объект QtGraphics).
	}
};

Как это связано с Абстрактной фабрикой:
Абстракция: Пользователь (User) не знает и не интересуется, какой конкретный тип объекта Graphics будет создан. Он просто использует метод createGraphics фабрики.
Гибкость: В зависимости от того, какая фабрика была передана в use, могут создаваться разные объекты Graphics. Например, это может быть объект QtGraphics или объект, относящийся к другой графической 
системе.
Расширяемость: Если в будущем понадобится поддержка другой графической системы, вам нужно будет лишь создать новую фабрику (например, DirectXGraphFactory) и передать ее в use, не изменяя сам метод use.


### Файл Pen:
class BasePen {}; // это базовый класс, который может служить общим интерфейсом или основой для различных типов "ручек" (инструментов рисования линий, контуров и т.д.).

class QtPen : public BasePen {}; // конкретный тип "ручки". 

Когда вы создаете такие классы в контексте паттерна Абстрактная фабрика, вы позволяете фабрике создавать объекты определенных типов, не завися от их конкретной реализации.


### Файл Brush:
class BaseBrush {};

class QtBrush : public BaseBrush {};


### Файл Image:
class Image {};


### Файл Color:
class Color {};


### Файл Main:
# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<AbstractGraphFactory> grfactory = make_shared<QtGraphFactory>(); 	// Создаем фабрику для Qt. Этот код создает объект QtGraphFactory, который является конкретной реализацией абстрактной фабрики AbstractGraphFactory. Указатель grfactory типа shared_ptr<AbstractGraphFactory> позволяет работать с фабрикой через абстрактный интерфейс, но на самом деле это конкретная фабрика QtGraphFactory.

	unique_ptr<User> us = make_unique<User>();					// Создаем пользователя. Создается объект User, который будет использовать графическую фабрику для создания и работы с графическими объектами.

	us->use(grfactory);								// Пользователь использует фабрику для создания и использования графических объектов. Внутри метода use User будет использовать фабрику для создания графических объектов, например, Graphics, Pen, Brush (зависит от того, как именно определен метод use).
}


# Что происходит на высоком уровне:
1) Инкапсуляция создания объектов: User не знает о том, какой конкретный тип графической системы используется (в данном случае это Qt), он просто получает фабрику через абстрактный интерфейс и 
использует ее для создания нужных объектов.
2) Гибкость и расширяемость: Если в будущем нужно будет поддерживать другую графическую систему (например, DirectX), можно создать новый класс фабрики (например, DirectXGraphFactory), который наследует 
AbstractGraphFactory. Весь остальной код останется неизменным — нужно будет только передать новую фабрику в метод use.


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++

https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/abstract-factory/vozmozhnye-realizacii-dlya-resheniya-konkretnykh-zadach-na-s++



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Прототип (Prototype)

# Проблемы
Представим, что вам потребовалось создать каркасную модель сферы из полигонов. Обычно таких полигонов очень много и при их создании необходимо вычислять координаты. Кроме того, в методы для создания 
объектов требуется передавать объект класса Creator (зачем он нужен? см. Фабричный метод). В данном случае более простым способом создания объекта может быть его копирование из существующего.

В итоге:
Необходимость передачи объекта класса Creator в методы для создания объектов
Необходимость большого количества информации и времени для создания нового объекта


# Назначение
Прототип (Prototype) — это порождающий паттерн проектирования, который поручает создание копий объектов самим копируемым объектам. Для этого в базовый класс добавляется метод для копирования, который 
создает новый объект на основе существующего. Паттерн вводит общий интерфейс для всех объектов, поддерживающих копирование. Это позволяет копировать объекты, не привязываясь к их классам.


# Решаемые задачи
1) Копирование объектов
Дает возможность создавать копии объектов на основе других объектов.

2) Создание сложных объектов
Паттерн прототип предоставляет альтернативу созданию подклассов для конструирования сложных объектов. Вместо того, чтобы создавать множество подклассов для каждой вариации объекта, можно использовать 
прототипы и копирование, чтобы создавать новые объекты с нужными параметрами и состоянием.


# UML диаграмма паттерна "Прототип"

	/--------------\			/-----------\
	|    Client    |			| Prototype |
	|--------------| ---------------------->|-----------|
	| +operation() |			|  +clone() |
	\--------------/			\-----------/
						      /\
						      ||
						      ||
			         /--------------------/\--------------------\
				 |					    |
				 |					    |
			/--------------------\			  /--------------------\
			| ConcretePrototype1 |			  | ConcretePrototypeN |
			|--------------------|        ...	  |--------------------| 
			|      +clone()	     |			  |      +clone()      |
			\--------------------/			  \--------------------/


# Преимущества
1) Возможность создавать новые объекты, используя уже существующие объекты в качестве прототипов.
2) Увеличение скорости создания сложных объектов.
3) Нет необходимости в передаче объекта класса Creator в методы для создания объектов.


# Недостатки
1) Необходимо убедиться в добавлении метода копирования в каждый класс, объект которого может быть скопирован.
2) Копируется внутреннее состояние объекта, в том числе значения приватных полей.
		

# Связь с другими паттернами
Паттерн Строитель может использовать прототипы для создания копий подобъектов.


______________________________________________________________________________________
Общая реализация на языке С++

### Файл Car:

class Car									// Абстрактный базовый класс машин
{
public:
	virtual ~Car() = default;
	virtual unique_ptr<Car> clone() = 0;					// Метод предназначен для создания копии объекта, используя паттерн Прототип.
};


class Sedan : public Car							// Класс седан
{
public:
	Sedan() 
	{ 
		cout << "Calling the default constructor;" << endl; 
	}
	
	Sedan(const Sedan& car) 						// Конструктор копирования. Этот конструктор вызывается, когда объект Sedan копируется.
	{ 
		cout << "Calling the Copy constructor;" << endl; 
	}
	
	~Sedan() override 
	{ 
		cout << "Calling the destructor;" << endl; 
	}

	unique_ptr<Car> clone() override					// Метод clone() реализует паттерн Прототип, позволяя создавать копию объекта Sedan. 
	{									// Внутри метода создается новая копия текущего объекта Sedan, вызывая конструктор копирования, и возвращается unique_ptr на этот новый объект.
		return make_unique<Sedan>(*this);
	}
};


Паттерн Прототип позволяет создавать объекты путем копирования существующего экземпляра (прототипа), вместо создания нового с нуля. 


### Файл User:
class User
{
public:
	void use(shared_ptr<Car> &car) // Метод use принимает объект car по ссылке типа shared_ptr<Car>. Это означает, что car является указателем с подсчетом ссылок на объект типа Car (или его наследника). Копирование shared_ptr увеличивает счетчик ссылок, что гарантирует, что объект не будет уничтожен, пока существует хотя бы один указатель на него.
	{
		auto newCar = car->clone(); 	// Метод clone() вызывается для объекта car. Этот метод реализован в конкретных классах, наследующих Car, и возвращает копию объекта, заключенную в unique_ptr<Car>.
	}					// Результатом вызова car->clone() является новый объект, который хранится в newCar. Поскольку clone() возвращает unique_ptr, newCar будет уникальным указателем на новый объект.
};


User использует метод clone() для создания новой копии автомобиля, что может быть полезно, если User хочет работать с копией, не изменяя исходный объект car. 


### Файл Main:
# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<Car> sedan = make_shared<Sedan>(); // Создаем объект Sedan
	User{}.use(sedan); // Создается временный объект User, который сразу же вызывает метод use. Внутри метода use, переданный объект sedan (типа shared_ptr<Car>) используется для создания его клона. Вызов car->clone() приводит к вызову метода clone() у объекта sedan, который вызывает конструктор копирования для создания нового объекта Sedan. 
}				// Новый объект Sedan, созданный методом clone, временно хранится в unique_ptr<Car> newCar, который будет автоматически уничтожен, когда метод use завершится. После завершения метода use временный объект User будет уничтожен.





Управление ресурсами. Идиома RAII

Объекты классов могут на протяжении всего своего существования использовать различные ресурсы - динамически выделенная память, файлы, сетевые подключения и т.д. В этом случае в 
C++ применяется так называемый принцип/идиома RAII (resource acquisition is initialization). RAII предполагает, что получение ресурса производится при инициализации объекта. А
освобождение ресурса производится в деструкторе объекта. Например, получение динамической памяти происходит в конструкторе объекта, а освобождение в деструкторе. При этом важно, 
чтобы ресурс (в данном случае динамическая память) освобождался только один раз. Для этой цели в классе удалены конструктор копирования и оператор присваивания, что позволяет 
избежать ситуации, когда два объекта хранят указатель на одну и ту же область динамической памяти и соответственно потом в деструкторе будут пытаться освободить эту память.



______________________________________________________________________________________
Идиома копирования и замены

Когда нужно изменить состояние одного или нескольких объектов, и на любом этапе модификации может возникнуть ошибка, для создания кода, устойчиваого к ошибкам, может применяться
идиома копирования и замены (copy-and-swap idiom). Суть данной идиомы состоит в следующей последовательности действий:

1. Создаем копию объекта(ов)

2. Изменяем копию. При этом оригинальные объекты остаются нетронутыми

3. Если все изменения прошли успешно, заменяем оригинальный объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то оригинальный объект 
не заменяется.

Обычно эта идиома применяется в функциях и частным, хотя и распространенным, случаем ее применения является оператор присваивания. В общем случаем это выглядит так:

// оператор присвоения некоторого класса Copyable
Copyable& operator=(const Copyable& obj) {
    Copyable copy{obj}; 				// создаем копию через конструктор копирования
    swap(copy);         				// обмениваем значения копии и оригинального объекта
    return *this;
}
// некоторая функция для обмена значениями
void swap(Copyable& copy) noexcept;

В функции оператора присваивания сначала создается временная копия присваиваемого объекта. И в случае успешного создания копиии текущий объект (this) и копия обмениваются 
содержимым через некоторую функцию swap().

Функция swap может быть реализована как внешняя функция или как функция-член класса (в примере выше предполагается, что она реализована внутри класса). При этом функция swap 
определяется как не генерирующая исключения (с ключевым словом noexcept). Поэтому единственной точкой, где может возникнуть исключение, функция копирования (конструктор 
копирования) объекта. Если копирование не удается, то управление не доходит до выполнения функции swap.

Устойчивость к исключениям заключается в том, что в операторе присваивания нет точки, где генерация исключения могла бы привести к утечке памяти. Приведённая выше реализация 
также устойчива к присваиваниям объекта самому себе (a=a), однако содержит издержки, связанные с тем, что временная копия в этом случае тоже будет создаваться. Исключить 
издержки можно дополнительной проверкой:

// оператор присвоения некоторого класса Copyable
Copyable& operator=(const Copyable& obj) {
    Copyable copy{obj};     				// создаем копию через конструктор копирования
    if(this != &obj)        				// если не текущий объект
        swap(copy);         				// обмениваем значения копии и оригинального объекта
    return *this;
}
// некоторая функция для обмена значениями
void swap(Copyable& copy) noexcept;

Хотя часто подобный способ применяется именно в операторах присвоения, но также он может применяться в других ситуациях, где необходимо выполнить устойчивую к исключениям 
модификацию объекта. И всегда принцип будет тот же. Сначала копируем объект, который надо изменить. Далее выполняем над объектом-копией изменения. И если все пройдет удачно, 
обмениваем значениями целевой объект и объект-копию.



______________________________________________________________________________________
Идиома Move-and-Swap / Перемещение с обменом

Идиома move-and-swap или перемещение с обменом применяется в операторах присвоения с перемещением. Она позволяет избежать дублирования кода деструктора и конструктора 
копирования. Суть данной идиомы состоит в следующей последовательности действий:

1. Для перемещаемого объекта создаем копию с помощью конструктора перемещения

2.Заменяем текущий объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то текущий объект не заменяется.

Общая форма move-and-swap выглядит следующим образом:

MyClass& MyClass::operator=(MyClass&& rhs) noexcept
{
    MyClass moved(std::move(rhs)); // получаем перемещаемый объект
    swap(moved);                  // выполняем обмен значениями
    return *this; // возвращаем текущий объект
}



______________________________________________________________________________________
Паттерн swap delete

Когда удалил ту память на которую ссылаешься, и потом указатель ты занулил



______________________________________________________________________________________
















