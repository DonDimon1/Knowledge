https://y2kot.gitbook.io/untitled
______________________________________________________________________________________
Введение в паттерны

Главная идея: Разделяй и властвуй.


# Что такое паттерны проектирования?
Паттерны проектирования - это набор общепринятых подходов, предназначенных для решения проблем, возникающих в процессе проектирования и разработки программного обеспечения. Паттерны описывают 
определенные способы организации классов и связей между ними.
Используются для достижения таких целей, как улучшение декомпозиции задачи и легкой модификации кода. Паттерны обеспечивают возможность повторного использования кода.


# Основная идея
Основная идея паттернов проектирования заключается в предоставлении типовых решений для проблем, с которыми сталкиваются разработчики. Вместо того, чтобы каждый раз "изобретать велосипед" 
и декомпозировать задачу с нуля, можно использовать проверенные проектные подходы.


# Преимущества
Готовое решение
Упрощение модификации кода
Облегчение взаимодействия между программистами
Повышение скорости разработки
Увеличение надежности кода
Повышение читаемости кода


# Недостатки
Увеличение объема кода
Увеличение времени выполнения
Высокие требования к памяти
Увеличение времени компиляции
Может привести к уменьшению скорости разработки

Структура паттернов:
1) Порождающие паттерны
2) Структурные паттерны
3) Поведенческие паттерны



______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Порождающие паттерны

# Общее описание
Полиморфизм – это очень мощный механизм, который позволяет модифицировать программу «не изменяя» написанный код, за счет добавления новых классов. Дословный перевод полиморфизма - много форм. 
Синоним полиморфизма – безразличие, когда один и тот же код может работать с объектами разных классов (типов).


# Проблема
При модификации программы происходит подмена объектов одних классов на объекты других классов. Как правило, в объектно-ориентированных языках это реализуется за счет передачи в методы ссылок 
(указателей) на базовые полиморфные классы или за счет интерфейсов. При использовании обобщений (шаблонов) подстановка типов осуществляется на этапе компиляции.
При использовании полиморфизма рано или поздно возникает необходимость создания конкретного объекта (сущности) конкретного типа. Для расширения, модификации или подмены сущности будет необходимо найти 
все места, где создается объект, и изменить код. Такая модификация программы увеличивает время разработки, понижает надежность программы, приводит к проблемам с версионностью.

# Порождающие паттерны
Порождающие паттерны – группа паттернов проектирования, которые:
1) берут на себя ответственность за логику создания объектов,
2) позволяют нам не создавать в методах объекты конкретных классов,
3) дают возможность принимать решение объекты каких классов нужно создавать при выполнении программы,
4) дают возможность повторно использовать уже созданный объект.


______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Фабричный метод (Factory method)

# Проблема
При использовании полиморфизма появляется возможность подмены объекта одного класса на объект другого класса с использованием ссылки (указателя) на базовый абстрактный класс. При создании объекта 
конкретного класса может возникнуть необходимость подмены одной сущности на другую, в результате чего придется искать, где создается объект, и менять написанный код. В попытках решить эту проблему, 
сформировалась идея передачи ответственности создания конкретного объекта другому классу.

# Назначение
Фабричный метод (Factory method) - порождающий паттерн проектирования, определяющий единый интерфейс создания объектов и позволяющий менять класс создаваемого объекта.

# Решаемые задачи
1) Подмена создания объекта одного класса на объект другого класса
Появляется возможность создавать объекты, являющиеся наследниками одного базового класса, без привязки к конкретным классам. Это позволяет легко расширять, модифицировать программу, добавляя новые 
классы, без изменения клиентского кода, который создает объекты классов.

2) Отделение принятия решения, какой объект нужно создать, от самого процесса создания объекта
После принятия решения о выборе конкретного типа создаваемого объекта создается объект (Creator) конкретного фабричного метода. Фактическое создание объекта происходит при непосредственном вызове 
метода createProduct() фабричного метода (Creator).

3) Повторное использование объектов
Появляется возможность повторного использования уже созданного объекта в разных местах программы.

# UML диаграмма паттерна "Фабричный метод"

			/------------\				 /------------------\		  /-----------\
			|  Product   |				 |      Creator	    |		  | Solution  |
			|------------| <------------------------ |------------------| <-----------|-----------|
			|+operation()|				 | +createProduct() |		  | +create() |
			\------------/				 \------------------/		  \-----------/
			      /\					   /\				/\
			      ||					   ||				||
			      ||					   ||				||
		    /---------/\----------\				   ||				||
		    |			  |			   /---------------\	       /------------------\
		    |			  |			   |ConcreteCreator|	       | ConcreteSolution |
	 /----------------\	  /----------------\		   |---------------|	       |------------------|
	 |ConcreteProduct1|	  |ConcreteProductN|		   |	 -//- 	   |	       |       -//- 	  |
	 |----------------|  ...  |----------------|		   \---------------/	       \------------------/
	 | 	-//-	  |	  |	 -//-      |
	 \----------------/	  \----------------/


Product - интерфейс объектов, которые создаются подклассами Creator.
Creator - абстрактный класс, который предоставляет интерфейс для создания объектов подклассов конкретного продукта (Product).
Solution - абстрактный класс, который предоставляет интерфейс для подклассов, принимающих решения, объект какого подкласса продуктов (Product) надо создавать и возвращающий объект подкласса 
	конкретного Creator.


# Преимущества
1) Избавление методов от создания объектов конкретных классов, что решает проблему подмены объекта одного класса на объект другого класса.
2) Упрощение добавления новых классов без изменения написанного кода.
3) Возможность разделения принятия решения о создании объекта и собственно создание объекта в разных местах программы.
4) Возможность принимать решение, объект какого класса необходимо создавать, не во время компиляции, а во время выполнения программы.
5) Возможность во время выполнения программы подменять создание объекта одного класса на объект другого класса.

# Недостатки
1) Увеличивается объем кода.
2) Увеличивается время компиляции.
3) Увеличивается время выполнения программы из-за использования полиморфизма.
4) Увеличивается количество требуемой памяти.
5) Требуется создание параллельных иерархий классов.
6) Необходимость перекомпилировать один и тот же код при добавлении новых типов объектов.
7) Необходимость в передаче ссылки (указателя) на абстрактный создатель (Creator) в методы клиентского кода, где необходимо создавать объекты.

# Связь с другими паттернами
Фабричный метод может быть использован внутри Абстрактной фабрики для создания конкретных объектов. Вместо того, чтобы создавать объекты напрямую, абстрактная фабрика может использовать 
фабричный метод для создания экземпляров объектов определенного типа.


______________________________________________________________________________________
Реализации Фабричного метода на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/factory-method/realizacii-na-s++ (Удобнее смотреть)

### Файл Car:

class Car							// Абстрактный базовый класс
{
public:
    virtual ~Car() = default;
    virtual void drive() = 0;
};


class Sedan : public Car					// Наследник Car
{
public:
    Sedan() 
    { 
        cout << "Sedan constructor called" << endl; 
    }
    
    ~Sedan() override 
    { 
        cout << "Sedan destructor called" << endl; 
    }

    void drive() override 
    { 
        cout << "Driving sedan" << endl; 
    }
};

class SUV : public Car 						// Наследник Car
{
public:
    SUV() 
    {
        cout << "Calling the SUV constructor;" << endl;
    }
    
    ~SUV() override 
    { 
        cout << "Calling the SUV destructor;" << endl; 
    }

    void drive() override 
    { 
        cout << "Driving SUV;" << endl; 
    }
};


### Файл Concepts
// Здесь определяются два концепта, который позволяют уточнять, какие требования должны быть выполнены для типов, используемых в шаблонах. 

template <typename Derived, typename Base>
concept Derivative = is_abstract_v<Base> && is_base_of_v<Base, Derived>;  // Этот концепт проверяет, что тип Derived является потомком (унаследованным типом) от Base, где Base должен быть абстрактным классом.

template <typename Type>
concept NotAbstract = !is_abstract_v<Type>;				  // Этот концепт проверяет, что тип Type не является абстрактным классом.


### Файл CarCreator
// Этот код использует концепты для создания иерархии классов и гарантирует, что конкретные реализации фабричного метода соответствуют определённым условиям.

class CarCreator						// Абстрактный базовый класс, который определяет интерфейс для создания объектов типа Car
{
public:
    virtual ~CarCreator() = default;
    virtual unique_ptr<Car> createCar() const = 0;
};


template <Derivative<Car> TCar>				// Проверяет, что тип TCar является производным от Car.
requires NotAbstract<TCar>				// (Условие) Проверяет, что тип TCar не является абстрактным классом.
class ConcreteCarCreator : public CarCreator		// Принимает в качестве шаблонного параметра тип TCar, который должен быть производным от Car и не должен быть абстрактным. Это гарантируется через концепты.
{
public:
    unique_ptr<Car> createCar() const override 		// Создаёт объект типа TCar с помощью функции make_unique и возвращает уникальный указатель на этот объект
    {
        return make_unique<TCar>();
    }
};


### Файл CarCreatorMaker
// CarCreatorMaker реализует фабрику фабрик (Factory of Factories), то есть это метафабрика, которая создает объекты CarCreator, специализирующиеся на создании конкретных типов Car. 

class CarCreatorMaker
{
public:
    template <Derivative<Car> TCar>	// Шаблонный параметр TCar: Тип машины, который должен быть производным от Car и не должен быть абстрактным классом. Это обеспечивается концептами Derivative<Car> и NotAbstract<TCar>.
    NotAbstract<TCar>
    static unique_ptr<CarCreator> createCarCreator() 	// Возвращает указатель на объект CarCreator, который будет использоваться для создания объектов типа TCar.
    {
        return make_unique<ConcreteCarCreator<TCar>>();	// Метод создает и возвращает объект ConcreteCarCreator<TCar>, который знает, как создавать конкретные экземпляры типа TCar.
    }
};


### Файл User
// Представляет собой клиентский код, который использует объекты типа CarCreator для создания и использования объектов типа Car.

class User
{
public:
    void use(const shared_ptr<CarCreator>& creator)	// Метод принимает в качестве аргумента shared_ptr<CarCreator>, который указывает на объект, способный создавать экземпляры Car.
    {
        if (!creator) throw runtime_error("The creator is missing!");	// проверяется, что указатель creator не является nullptr

        shared_ptr<Car> car = creator->createCar();			// вызывает creator->createCar(), чтобы создать объект Car. Использование shared_ptr вместо unique_ptr здесь предполагает, что объект Car может быть использован в других местах программы после вызова метода use.
        car->drive();							// выполняет какое-то действие, связанное с конкретной реализацией автомобиля.
    }
};



#######
Класс Solution выполняет роль посредника между клиентским кодом и классами создателей продуктов. Он отвечает за регистрацию методов создания объектов для каждого типа продукта и предоставляет методы 
для создания объектов по их идентификаторам.


### Файл VehicleSolution
class VehicleSolution								// используется для регистрации и создания объектов CarCreator на основе идентификаторов. 
{
public:
    using CreateCarMaker = unique_ptr<CarCreator>(&)();				// CreateCarMaker - это тип, представляющий собой указатель на функцию, которая возвращает unique_ptr<CarCreator>. Это будет функция-фабрика, создающая объекты CarCreator.
    using CallBackMap = map<size_t, CreateCarCreator>;				// CallBackMap  - это тип, представляющий ассоциативный контейнер (карта), где ключ (size_t) — это идентификатор, а значение — это функция CreateCarCreator, которая создает объект CarCreator.

public:
    VehicleSolution() = default;
    VehicleSolution(initializer_list<pair<size_t, CreateCarCreator>> list);	// Конструктор, принимающий список инициализации (initializer_list), который позволяет инициализировать объект VehicleSolution с заранее определенным набором пар идентификаторов и функций создания.

    bool registrate(size_t id, CreateCarCreator createfun);			// Метод для регистрации новой функции создания объекта CarCreator в карте callbacks с определенным идентификатором id.
    bool check(size_t id) 							// Метод для удаления функции создания по заданному идентификатору id. Возвращает true, если элемент был удален (т.е. если такой идентификатор был в карте).
    { 
        return callbacks.erase(id) == 1; 
    }

    unique_ptr<CarCreator> create(size_t id);					// Метод для создания объекта CarCreator на основе зарегистрированной функции для указанного идентификатора id. Возвращает unique_ptr<CarCreator>.

private:
    CallBackMap callbacks;							// Карта, которая хранит ассоциации между идентификаторами и функциями создания объектов CarCreator.
};


### Файл Methods
// Реализация методов файла VehicleSolution

# pragma region Solution
VehicleSolution::VehicleSolution(initializer_list<pair<size_t, CreateCarCreator>> list) // Конструктор принимает список инициализации пар size_t (идентификатор) и CreateCarCreator (функция, создающая объект CarCreator).
{
    for (auto&& elem : list)								// В цикле проходит по каждой паре в списке и регистрирует ее, вызывая метод registrate.
        this->registrate(elem.first, elem.second);					// Вызываем registrate 
}

bool VehicleSolution::registrate(size_t id, CreateCarCreator createfun)			// Метод регистрирует новую функцию создания объекта CarCreator в карте callbacks с определенным идентификатором id.
{
    return callbacks.insert(CallBackMap::value_type(id, createfun)).second;
}

unique_ptr<CarCreator> VehicleSolution::create(size_t id)				// Метод ищет функцию создания CarCreator по переданному идентификатору id.
{
    CallBackMap::const_iterator it = callbacks.find(id);				// Если такая функция найдена, она вызывается для создания объекта CarCreator, и результат оборачивается в unique_ptr<CarCreator>.

    return it != callbacks.end() ? unique_ptr<CarCreator>(it->second()) : nullptr;
}

shared_ptr<VehicleSolution> make_solution(						// Эта функция служит фабрикой для создания объектов VehicleSolution, инициализируя их списком пар идентификаторов и функций создания.
    initializer_list<pair<size_t, 
    VehicleSolution::CreateCarCreator>> list
)
{
    return shared_ptr<VehicleSolution>(new VehicleSolution(list));
}
# pragma endregion



### Файл main

# include <iostream>
# include <initializer_list>
# include <memory>
# include <map>
# include <exception>

using namespace std;

int main()
{
    try
    {
        shared_ptr<VehicleSolution> solution
        = make_solution({ {1, CarCreatorMaker::createCarCreator<Sedan>} });		// создает экземпляр VehicleSolution. Внутри него регистрируется фабрика, ассоциированная с идентификатором 1, которая будет создавать машины типа Sedan.

        if (!solution->registrate(2, CarCreatorMaker::createCarCreator<SUV>))		// добавляет еще одну фабрику, ассоциированную с идентификатором 2, для создания машин типа SUV.
        {
            throw runtime_error("Error registration!");
        }
        shared_ptr<CarCreator> cr(solution->create(2));					// Создается объект CarCreator на основе идентификатора 2 (для SUV) и передается в метод User::use.

        User{}.use(cr);									// Метод use создает объект Car с помощью переданного CarCreator и вызывает метод drive.
    }
    catch (runtime_error& err)
    {
        cout << err.what() << endl;
    }
}


# Пример вывода:
Driving an SUV.


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/factory-method/concrete-implementation




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Абстрактная фабрика










Управление ресурсами. Идиома RAII

Объекты классов могут на протяжении всего своего существования использовать различные ресурсы - динамически выделенная память, файлы, сетевые подключения и т.д. В этом случае в 
C++ применяется так называемый принцип/идиома RAII (resource acquisition is initialization). RAII предполагает, что получение ресурса производится при инициализации объекта. А
освобождение ресурса производится в деструкторе объекта. Например, получение динамической памяти происходит в конструкторе объекта, а освобождение в деструкторе. При этом важно, 
чтобы ресурс (в данном случае динамическая память) освобождался только один раз. Для этой цели в классе удалены конструктор копирования и оператор присваивания, что позволяет 
избежать ситуации, когда два объекта хранят указатель на одну и ту же область динамической памяти и соответственно потом в деструкторе будут пытаться освободить эту память.



______________________________________________________________________________________
Идиома копирования и замены

Когда нужно изменить состояние одного или нескольких объектов, и на любом этапе модификации может возникнуть ошибка, для создания кода, устойчиваого к ошибкам, может применяться
идиома копирования и замены (copy-and-swap idiom). Суть данной идиомы состоит в следующей последовательности действий:

1. Создаем копию объекта(ов)

2. Изменяем копию. При этом оригинальные объекты остаются нетронутыми

3. Если все изменения прошли успешно, заменяем оригинальный объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то оригинальный объект 
не заменяется.

Обычно эта идиома применяется в функциях и частным, хотя и распространенным, случаем ее применения является оператор присваивания. В общем случаем это выглядит так:

// оператор присвоения некоторого класса Copyable
Copyable& operator=(const Copyable& obj) {
    Copyable copy{obj}; 				// создаем копию через конструктор копирования
    swap(copy);         				// обмениваем значения копии и оригинального объекта
    return *this;
}
// некоторая функция для обмена значениями
void swap(Copyable& copy) noexcept;

В функции оператора присваивания сначала создается временная копия присваиваемого объекта. И в случае успешного создания копиии текущий объект (this) и копия обмениваются 
содержимым через некоторую функцию swap().

Функция swap может быть реализована как внешняя функция или как функция-член класса (в примере выше предполагается, что она реализована внутри класса). При этом функция swap 
определяется как не генерирующая исключения (с ключевым словом noexcept). Поэтому единственной точкой, где может возникнуть исключение, функция копирования (конструктор 
копирования) объекта. Если копирование не удается, то управление не доходит до выполнения функции swap.

Устойчивость к исключениям заключается в том, что в операторе присваивания нет точки, где генерация исключения могла бы привести к утечке памяти. Приведённая выше реализация 
также устойчива к присваиваниям объекта самому себе (a=a), однако содержит издержки, связанные с тем, что временная копия в этом случае тоже будет создаваться. Исключить 
издержки можно дополнительной проверкой:

// оператор присвоения некоторого класса Copyable
Copyable& operator=(const Copyable& obj) {
    Copyable copy{obj};     				// создаем копию через конструктор копирования
    if(this != &obj)        				// если не текущий объект
        swap(copy);         				// обмениваем значения копии и оригинального объекта
    return *this;
}
// некоторая функция для обмена значениями
void swap(Copyable& copy) noexcept;

Хотя часто подобный способ применяется именно в операторах присвоения, но также он может применяться в других ситуациях, где необходимо выполнить устойчивую к исключениям 
модификацию объекта. И всегда принцип будет тот же. Сначала копируем объект, который надо изменить. Далее выполняем над объектом-копией изменения. И если все пройдет удачно, 
обмениваем значениями целевой объект и объект-копию.



______________________________________________________________________________________
Идиома Move-and-Swap / Перемещение с обменом

Идиома move-and-swap или перемещение с обменом применяется в операторах присвоения с перемещением. Она позволяет избежать дублирования кода деструктора и конструктора 
копирования. Суть данной идиомы состоит в следующей последовательности действий:

1. Для перемещаемого объекта создаем копию с помощью конструктора перемещения

2.Заменяем текущий объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то текущий объект не заменяется.

Общая форма move-and-swap выглядит следующим образом:

MyClass& MyClass::operator=(MyClass&& rhs) noexcept
{
    MyClass moved(std::move(rhs)); // получаем перемещаемый объект
    swap(moved);                  // выполняем обмен значениями
    return *this; // возвращаем текущий объект
}



______________________________________________________________________________________
Паттерн swap delete

Когда удалил ту память на которую ссылаешься, и потом указатель ты занулил



______________________________________________________________________________________
















