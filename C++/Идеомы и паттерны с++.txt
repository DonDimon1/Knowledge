https://y2kot.gitbook.io/untitled
______________________________________________________________________________________
Введение в паттерны

Главная идея: Разделяй и властвуй.


# Что такое паттерны проектирования?
Паттерны проектирования - это набор общепринятых подходов, предназначенных для решения проблем, возникающих в процессе проектирования и разработки программного обеспечения. Паттерны описывают 
определенные способы организации классов и связей между ними.
Используются для достижения таких целей, как улучшение декомпозиции задачи и легкой модификации кода. Паттерны обеспечивают возможность повторного использования кода.


# Основная идея
Основная идея паттернов проектирования заключается в предоставлении типовых решений для проблем, с которыми сталкиваются разработчики. Вместо того, чтобы каждый раз "изобретать велосипед" 
и декомпозировать задачу с нуля, можно использовать проверенные проектные подходы.


# Преимущества
Готовое решение
Упрощение модификации кода
Облегчение взаимодействия между программистами
Повышение скорости разработки
Увеличение надежности кода
Повышение читаемости кода


# Недостатки
Увеличение объема кода
Увеличение времени выполнения
Высокие требования к памяти
Увеличение времени компиляции
Может привести к уменьшению скорости разработки

Структура паттернов:
1) Порождающие паттерны
2) Структурные паттерны
3) Поведенческие паттерны



______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Порождающие паттерны

# Общее описание
Полиморфизм – это очень мощный механизм, который позволяет модифицировать программу «не изменяя» написанный код, за счет добавления новых классов. Дословный перевод полиморфизма - много форм. 
Синоним полиморфизма – безразличие, когда один и тот же код может работать с объектами разных классов (типов).


# Проблема
При модификации программы происходит подмена объектов одних классов на объекты других классов. Как правило, в объектно-ориентированных языках это реализуется за счет передачи в методы ссылок 
(указателей) на базовые полиморфные классы или за счет интерфейсов. При использовании обобщений (шаблонов) подстановка типов осуществляется на этапе компиляции.
При использовании полиморфизма рано или поздно возникает необходимость создания конкретного объекта (сущности) конкретного типа. Для расширения, модификации или подмены сущности будет необходимо найти 
все места, где создается объект, и изменить код. Такая модификация программы увеличивает время разработки, понижает надежность программы, приводит к проблемам с версионностью.

# Порождающие паттерны
Порождающие паттерны – группа паттернов проектирования, которые:
1) берут на себя ответственность за логику создания объектов,
2) позволяют нам не создавать в методах объекты конкретных классов,
3) дают возможность принимать решение объекты каких классов нужно создавать при выполнении программы,
4) дают возможность повторно использовать уже созданный объект.


# Текущий список порождающих паттернов 
1) Фабричный метод
2) Абстрактная фабрика
3) Прототип
4) Строитель
5) Одиночка
6) Пул объектов

______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Фабричный метод (Factory method)

# Проблема
При использовании полиморфизма появляется возможность подмены объекта одного класса на объект другого класса с использованием ссылки (указателя) на базовый абстрактный класс. При создании объекта 
конкретного класса может возникнуть необходимость подмены одной сущности на другую, в результате чего придется искать, где создается объект, и менять написанный код. В попытках решить эту проблему, 
сформировалась идея передачи ответственности создания конкретного объекта другому классу.

# Назначение
Фабричный метод (Factory method) - порождающий паттерн проектирования, определяющий единый интерфейс создания объектов и позволяющий менять класс создаваемого объекта.

# Решаемые задачи
1) Подмена создания объекта одного класса на объект другого класса
Появляется возможность создавать объекты, являющиеся наследниками одного базового класса, без привязки к конкретным классам. Это позволяет легко расширять, модифицировать программу, добавляя новые 
классы, без изменения клиентского кода, который создает объекты классов.

2) Отделение принятия решения, какой объект нужно создать, от самого процесса создания объекта
После принятия решения о выборе конкретного типа создаваемого объекта создается объект (Creator) конкретного фабричного метода. Фактическое создание объекта происходит при непосредственном вызове 
метода createProduct() фабричного метода (Creator).

3) Повторное использование объектов
Появляется возможность повторного использования уже созданного объекта в разных местах программы.

# UML диаграмма паттерна "Фабричный метод"

			/------------\				 /------------------\		  /-----------\
			|  Product   |				 |      Creator	    |		  | Solution  |
			|------------| <------------------------ |------------------| <-----------|-----------|
			|+operation()|				 | +createProduct() |		  | +create() |
			\------------/				 \------------------/		  \-----------/
			      /\					   /\				/\
			      ||					   ||				||
			      ||					   ||				||
		    /---------/\----------\				   ||				||
		    |			  |			   /---------------\	       /------------------\
		    |			  |			   |ConcreteCreator|	       | ConcreteSolution |
	 /----------------\	  /----------------\		   |---------------|	       |------------------|
	 |ConcreteProduct1|	  |ConcreteProductN|		   |	 -//- 	   |	       |       -//- 	  |
	 |----------------|  ...  |----------------|		   \---------------/	       \------------------/
	 | 	-//-	  |	  |	 -//-      |
	 \----------------/	  \----------------/


Product - интерфейс объектов, которые создаются подклассами Creator.
Creator - абстрактный класс, который предоставляет интерфейс для создания объектов подклассов конкретного продукта (Product).
Solution - абстрактный класс, который предоставляет интерфейс для подклассов, принимающих решения, объект какого подкласса продуктов (Product) надо создавать и возвращающий объект подкласса 
	конкретного Creator.


# Преимущества
1) Избавление методов от создания объектов конкретных классов, что решает проблему подмены объекта одного класса на объект другого класса.
2) Упрощение добавления новых классов без изменения написанного кода.
3) Возможность разделения принятия решения о создании объекта и собственно создание объекта в разных местах программы.
4) Возможность принимать решение, объект какого класса необходимо создавать, не во время компиляции, а во время выполнения программы.
5) Возможность во время выполнения программы подменять создание объекта одного класса на объект другого класса.

# Недостатки
1) Увеличивается объем кода.
2) Увеличивается время компиляции.
3) Увеличивается время выполнения программы из-за использования полиморфизма.
4) Увеличивается количество требуемой памяти.
5) Требуется создание параллельных иерархий классов.
6) Необходимость перекомпилировать один и тот же код при добавлении новых типов объектов.
7) Необходимость в передаче ссылки (указателя) на абстрактный создатель (Creator) в методы клиентского кода, где необходимо создавать объекты.

# Связь с другими паттернами
Фабричный метод может быть использован внутри Абстрактной фабрики для создания конкретных объектов. Вместо того, чтобы создавать объекты напрямую, абстрактная фабрика может использовать 
фабричный метод для создания экземпляров объектов определенного типа.


______________________________________________________________________________________
Объяснение от ChatGPT

Представьте, что вы работаете в кафе, где есть разные виды напитков: кофе, чай, какао и т.д. Если бариста (ваш код) должен готовить каждый напиток вручную, он будет тратить много времени на изучение 
рецептов и следование им. Но если в кафе есть автомат (фабрика), который умеет готовить разные напитки по запросу, то бариста просто нажимает кнопку (вызов фабричного метода) и получает готовый напиток.
Таким образом, бариста может фокусироваться на обслуживании клиентов, не думая о том, как именно готовятся напитки. Автомат (фабрика) берет на себя всю сложную работу по созданию напитков.


______________________________________________________________________________________
Очень упрощённая реализация от ChatGPT

#include <iostream>
#include <memory>
#include <string>

using namespace std;

class Transport { // Базовый класс для транспорта
public:
    virtual ~Transport() = default;
    virtual void drive() const = 0;
};

class Car : public Transport { // Класс для автомобиля
public:
    void drive() const override {
        cout << "Driving a car!" << endl;
    }
};

class Bike : public Transport { // Класс для велосипеда
public:
    void drive() const override {
        cout << "Riding a bike!" << endl;
    }
};

class TransportFactory { // Фабрика для создания транспорта
public:
    // Фабричный метод для создания объекта транспорта
    static unique_ptr<Transport> createTransport(const string& type) {
        if (type == "car") {
            return make_unique<Car>();
        } else if (type == "bike") {
            return make_unique<Bike>();
        } else {
            return nullptr;
        }
    }
};

int main() {
    // Создание автомобиля с помощью фабричного метода
    unique_ptr<Transport> myCar = TransportFactory::createTransport("car");
    if (myCar) {
        myCar->drive();  // Вывод: Driving a car!
    }

    // Создание велосипеда с помощью фабричного метода
    unique_ptr<Transport> myBike = TransportFactory::createTransport("bike");
    if (myBike) {
        myBike->drive();  // Вывод: Riding a bike!
    }

    return 0;
}



______________________________________________________________________________________
Общая реализации Фабричного метода на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/factory-method/realizacii-na-s++ (Удобнее смотреть)

### Файл Car:

class Car							// Абстрактный базовый класс
{
public:
    virtual ~Car() = default;
    virtual void drive() = 0;
};


class Sedan : public Car					// Наследник Car
{
public:
    Sedan() 
    { 
        cout << "Sedan constructor called" << endl; 
    }
    
    ~Sedan() override 
    { 
        cout << "Sedan destructor called" << endl; 
    }

    void drive() override 
    { 
        cout << "Driving sedan" << endl; 
    }
};

class SUV : public Car 						// Наследник Car
{
public:
    SUV() 
    {
        cout << "Calling the SUV constructor;" << endl;
    }
    
    ~SUV() override 
    { 
        cout << "Calling the SUV destructor;" << endl; 
    }

    void drive() override 
    { 
        cout << "Driving SUV;" << endl; 
    }
};


### Файл Concepts
// Здесь определяются два концепта, который позволяют уточнять, какие требования должны быть выполнены для типов, используемых в шаблонах. 

template <typename Derived, typename Base>
concept Derivative = is_abstract_v<Base> && is_base_of_v<Base, Derived>;  // Этот концепт проверяет, что тип Derived является потомком (унаследованным типом) от Base, где Base должен быть абстрактным классом.

template <typename Type>
concept NotAbstract = !is_abstract_v<Type>;				  // Этот концепт проверяет, что тип Type не является абстрактным классом.


### Файл CarCreator
// Этот код использует концепты для создания иерархии классов и гарантирует, что конкретные реализации фабричного метода соответствуют определённым условиям.

class CarCreator						// Абстрактный базовый класс, который определяет интерфейс для создания объектов типа Car
{
public:
    virtual ~CarCreator() = default;
    virtual unique_ptr<Car> createCar() const = 0;
};


template <Derivative<Car> TCar>				// Проверяет, что тип TCar является производным от Car.
requires NotAbstract<TCar>				// (Условие) Проверяет, что тип TCar не является абстрактным классом.
class ConcreteCarCreator : public CarCreator		// Принимает в качестве шаблонного параметра тип TCar, который должен быть производным от Car и не должен быть абстрактным. Это гарантируется через концепты.
{
public:
    unique_ptr<Car> createCar() const override 		// Создаёт объект типа TCar с помощью функции make_unique и возвращает уникальный указатель на этот объект
    {
        return make_unique<TCar>();
    }
};


### Файл CarCreatorMaker
// CarCreatorMaker реализует фабрику фабрик (Factory of Factories), то есть это метафабрика, которая создает объекты CarCreator, специализирующиеся на создании конкретных типов Car. 

class CarCreatorMaker
{
public:
    template <Derivative<Car> TCar>	// Шаблонный параметр TCar: Тип машины, который должен быть производным от Car и не должен быть абстрактным классом. Это обеспечивается концептами Derivative<Car> и NotAbstract<TCar>.
    NotAbstract<TCar>
    static unique_ptr<CarCreator> createCarCreator() 	// Возвращает указатель на объект CarCreator, который будет использоваться для создания объектов типа TCar.
    {
        return make_unique<ConcreteCarCreator<TCar>>();	// Метод создает и возвращает объект ConcreteCarCreator<TCar>, который знает, как создавать конкретные экземпляры типа TCar.
    }
};


### Файл User
// Представляет собой клиентский код, который использует объекты типа CarCreator для создания и использования объектов типа Car.

class User
{
public:
    void use(const shared_ptr<CarCreator>& creator)	// Метод принимает в качестве аргумента shared_ptr<CarCreator>, который указывает на объект, способный создавать экземпляры Car.
    {
        if (!creator) throw runtime_error("The creator is missing!");	// проверяется, что указатель creator не является nullptr

        shared_ptr<Car> car = creator->createCar();			// вызывает creator->createCar(), чтобы создать объект Car. Использование shared_ptr вместо unique_ptr здесь предполагает, что объект Car может быть использован в других местах программы после вызова метода use.
        car->drive();							// выполняет какое-то действие, связанное с конкретной реализацией автомобиля.
    }
};



#######
Класс Solution выполняет роль посредника между клиентским кодом и классами создателей продуктов. Он отвечает за регистрацию методов создания объектов для каждого типа продукта и предоставляет методы 
для создания объектов по их идентификаторам.


### Файл VehicleSolution
class VehicleSolution								// используется для регистрации и создания объектов CarCreator на основе идентификаторов. 
{
public:
    using CreateCarMaker = unique_ptr<CarCreator>(&)();				// CreateCarMaker - это тип, представляющий собой указатель на функцию, которая возвращает unique_ptr<CarCreator>. Это будет функция-фабрика, создающая объекты CarCreator.
    using CallBackMap = map<size_t, CreateCarCreator>;				// CallBackMap  - это тип, представляющий ассоциативный контейнер (карта), где ключ (size_t) — это идентификатор, а значение — это функция CreateCarCreator, которая создает объект CarCreator.

public:
    VehicleSolution() = default;
    VehicleSolution(initializer_list<pair<size_t, CreateCarCreator>> list);	// Конструктор, принимающий список инициализации (initializer_list), который позволяет инициализировать объект VehicleSolution с заранее определенным набором пар идентификаторов и функций создания.

    bool registrate(size_t id, CreateCarCreator createfun);			// Метод для регистрации новой функции создания объекта CarCreator в карте callbacks с определенным идентификатором id.
    bool check(size_t id) 							// Метод для удаления функции создания по заданному идентификатору id. Возвращает true, если элемент был удален (т.е. если такой идентификатор был в карте).
    { 
        return callbacks.erase(id) == 1; 
    }

    unique_ptr<CarCreator> create(size_t id);					// Метод для создания объекта CarCreator на основе зарегистрированной функции для указанного идентификатора id. Возвращает unique_ptr<CarCreator>.

private:
    CallBackMap callbacks;							// Карта, которая хранит ассоциации между идентификаторами и функциями создания объектов CarCreator.
};


### Файл Methods
// Реализация методов файла VehicleSolution

# pragma region Solution
VehicleSolution::VehicleSolution(initializer_list<pair<size_t, CreateCarCreator>> list) // Конструктор принимает список инициализации пар size_t (идентификатор) и CreateCarCreator (функция, создающая объект CarCreator).
{
    for (auto&& elem : list)								// В цикле проходит по каждой паре в списке и регистрирует ее, вызывая метод registrate.
        this->registrate(elem.first, elem.second);					// Вызываем registrate 
}

bool VehicleSolution::registrate(size_t id, CreateCarCreator createfun)			// Метод регистрирует новую функцию создания объекта CarCreator в карте callbacks с определенным идентификатором id.
{
    return callbacks.insert(CallBackMap::value_type(id, createfun)).second;
}

unique_ptr<CarCreator> VehicleSolution::create(size_t id)				// Метод ищет функцию создания CarCreator по переданному идентификатору id.
{
    CallBackMap::const_iterator it = callbacks.find(id);				// Если такая функция найдена, она вызывается для создания объекта CarCreator, и результат оборачивается в unique_ptr<CarCreator>.

    return it != callbacks.end() ? unique_ptr<CarCreator>(it->second()) : nullptr;
}

shared_ptr<VehicleSolution> make_solution(						// Эта функция служит фабрикой для создания объектов VehicleSolution, инициализируя их списком пар идентификаторов и функций создания.
    initializer_list<pair<size_t, 
    VehicleSolution::CreateCarCreator>> list
)
{
    return shared_ptr<VehicleSolution>(new VehicleSolution(list));
}
# pragma endregion



### Файл main

# include <iostream>
# include <initializer_list>
# include <memory>
# include <map>
# include <exception>

using namespace std;

int main()
{
    try
    {
        shared_ptr<VehicleSolution> solution
        = make_solution({ {1, CarCreatorMaker::createCarCreator<Sedan>} });		// создает экземпляр VehicleSolution. Внутри него регистрируется фабрика, ассоциированная с идентификатором 1, которая будет создавать машины типа Sedan.

        if (!solution->registrate(2, CarCreatorMaker::createCarCreator<SUV>))		// добавляет еще одну фабрику, ассоциированную с идентификатором 2, для создания машин типа SUV.
        {
            throw runtime_error("Error registration!");
        }
        shared_ptr<CarCreator> cr(solution->create(2));					// Создается объект CarCreator на основе идентификатора 2 (для SUV) и передается в метод User::use.

        User{}.use(cr);									// Метод use создает объект Car с помощью переданного CarCreator и вызывает метод drive.
    }
    catch (runtime_error& err)
    {
        cout << err.what() << endl;
    }
}


# Пример вывода:
Driving an SUV.


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/factory-method/concrete-implementation



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Абстрактная фабрика (Abstract factory)

# Проблема
В процессе разработки программы может возникнуть необходимость создания иерархии разных классов, объекты которых должны использоваться совместно. Таким примером может являться система графики, в 
которой происходит взаимодействие множества компонентов: кистей, ручек, форм, канвасов.

Фабричный метод не поддерживает связь между иерархиями классов. Например, нет возможности подменить одну графическую систему на другую. В таком случае возможным решением является объединение методов 
создания иерархий объектов разных классов в один класс.

# Назначение
Абстрактная фабрика(Abstract factory) — порождающий паттерн проектирования, определяющий единый интерфейс создания иерархий классов и позволяющий менять одно семейство связанных объектов на другое.
Семейством связанных объектов могут быть, например, объекты конкретной графической подсистемы (brush, pen, marker, canvas).

# Решаемые задачи
1) Возможность создавать и подменять одно семейство объектов на другое
Появляется возможность создавать семейства связанных объектов. При необходимости можно легко заменять или добавлять новые семейства объектов, не изменяя другие части кода, которые используют 
эти объекты.

2) Отделение принятия решения о том, какое семейство объектов нужно создать, от самого процесса создания объектов семейства
Решение о выборе конкретного семейства принимается в части кода, который использует абстрактную фабрику. Во время выполнения этот код определяет, какое семейство связанных объектов требуется 
создать, и создает соответствующую фабрику. В коде через абстрактную фабрику вызываются методы создания объектов конкретных иерархий классов.

3) Повторное использование объектов
Появляется возможность повторного использования уже созданных семейств объектов.

# UML диаграмма паттерна "Абстрактная фабрика"

			/-----------\				 /------------------\				 /-----------\
			|  BasePen  |				 |  AbstractFactory |		  		 | BaseBrush |
			|-----------| <------------------------  |------------------|  ------------------------> |-----------|
			|    ...    |				 |   +createPen()   |				 |    ...    |
			\-----------/				 |  +createBrush()  |				 \-----------/
								 \------------------/		
			      /\					  /\					       /\
			      ||					  ||					       ||
			      ||					  ||					       ||
			      ||					  ||					       ||
		      /---------------\				 /------------------\   		      	  /----------\   
		      |	    QtPen     |	 			 | QtGraphicFactory |  			      	  |  QtBrush |
	 	      |---------------|	       			 |------------------|			      	  |----------|
		      |	    -//-      |	       			 |	 -//-       |			      	  |   -//-   |
                      \---------------/	     			 \------------------/			      	  \----------/


# Преимущества
1) Избавление методов от привязки к конкретным классам, что решает проблему подмены объекта одного семейства класса на объект другого семейства классов.
2) Упрощение добавления новых семейств объектов без изменения написанного кода.
3) Возможность принимать решение, объект какого семейства создавать, и создавать объекты в разных местах программы.
4) Возможность принимать решение, объект какого семейства необходимо создавать, не во время компиляции, а во время выполнения программы.
5) Возможность во время выполнения программы подменять создание объекта одного семейства класса на объект другого класса.

# Недостатки
1) Увеличивается объем кода.
2) Увеличивается время компиляции.
3) Увеличивается время выполнения программы из-за использования полиморфизма.
4) Увеличивается количество требуемой памяти.
5) Требуется создание параллельных иерархий классов.
6) Необходимость перекомпилировать один и тот же код при добавлении новых типов объектов.
7) Семейства объектов должны быть однородны по своей структуре, иначе выделить базовую абстракцию в абстрактной фабрике будет невозможно.
8) Возможность наличия неполных семейств объектов.

# Связь с другими паттернами
1) Абстрактная фабрика может использовать Фабричный метод для создания конкретных объектов. Вместо того, чтобы иметь только один метод для создания объектов, абстрактная фабрика может использовать 
фабричный метод в своей реализации.
2) Абстрактная фабрика может быть комбинирована с паттерном Строитель для создания сложных объектов.



______________________________________________________________________________________
Объяснение от ChatGPT

Представьте, что вы владелец мебельного магазина. В вашем магазине есть разные коллекции мебели: например, "Современная" и "Викторианская". В каждой коллекции есть столы, стулья и диваны, которые 
соответствуют стилю этой коллекции.
Абстрактная фабрика в этом случае — это ваш заказ на мебель, который может быть оформлен для любой из коллекций, но вам не нужно думать о том, как именно создается каждый предмет мебели.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <memory>

using namespace std;

// Абстрактный интерфейс для стула
class Chair {
public:
    virtual ~Chair() = default;
    virtual void sit() const = 0;
};

// Абстрактный интерфейс для стола
class Table {
public:
    virtual ~Table() = default;
    virtual void use() const = 0;
};

// Конкретный стул в современном стиле
class ModernChair : public Chair {
public:
    void sit() const override {
        cout << "Sitting on a modern chair." << endl;
    }
};

// Конкретный стол в современном стиле
class ModernTable : public Table {
public:
    void use() const override {
        cout << "Using a modern table." << endl;
    }
};

// Конкретный стул в викторианском стиле
class VictorianChair : public Chair {
public:
    void sit() const override {
        cout << "Sitting on a Victorian chair." << endl;
    }
};

// Конкретный стол в викторианском стиле
class VictorianTable : public Table {
public:
    void use() const override {
        cout << "Using a Victorian table." << endl;
    }
};

// Абстрактная фабрика для создания мебели
class FurnitureFactory {
public:
    virtual ~FurnitureFactory() = default;
    virtual unique_ptr<Chair> createChair() const = 0;
    virtual unique_ptr<Table> createTable() const = 0;
};

// Фабрика для создания современной мебели
class ModernFurnitureFactory : public FurnitureFactory {
public:
    unique_ptr<Chair> createChair() const override {
        return make_unique<ModernChair>();
    }
    unique_ptr<Table> createTable() const override {
        return make_unique<ModernTable>();
    }
};

// Фабрика для создания викторианской мебели
class VictorianFurnitureFactory : public FurnitureFactory {
public:
    unique_ptr<Chair> createChair() const override {
        return make_unique<VictorianChair>();
    }
    unique_ptr<Table> createTable() const override {
        return make_unique<VictorianTable>();
    }
};

int main() {
    // Создаем фабрику для викторианской мебели
    unique_ptr<FurnitureFactory> factory = make_unique<VictorianFurnitureFactory>();

    // Создаем викторианский стул и стол через фабрику
    unique_ptr<Chair> chair = factory->createChair();
    unique_ptr<Table> table = factory->createTable();

    chair->sit(); // Вывод: Sitting on a Victorian chair.
    table->use(); // Вывод: Using a Victorian table.

    // Теперь можем легко сменить фабрику на современную
    factory = make_unique<ModernFurnitureFactory>();

    chair = factory->createChair();
    table = factory->createTable();

    chair->sit(); // Вывод: Sitting on a modern chair.
    table->use(); // Вывод: Using a modern table.

    return 0;
}



______________________________________________________________________________________
Общая реализация на языке С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/abstract-factory/realizacii-na-s++

### Файл BaseGraphics:

class BaseGraphics 						// Базовый абстрактный класс графики
{
public:
    virtual ~BaseGraphics() = 0;
};

BaseGraphics::~BaseGraphics() {}


class QtGraphics : public BaseGraphics				// Наследуемый класс
{
public:
	QtGraphics(shared_ptr<Image> im) 
	{
		cout << "Calling the QtGraphics constructor;" << endl; 
	}
	
	~QtGraphics() override 
	{ 
		cout << "Calling the QtGraphics destructor;" << endl; 
	}
};


### Файл AbstractGraphFactory:

class AbstractGraphFactory 					// это абстрактный класс, который объявляет методы для создания различных графических объектов: Graphics, Pen и Brush.
{			
public:
	virtual ~AbstractGraphFactory() = default;

	virtual unique_ptr<BaseGraphics> createGraphics(shared_ptr<Image> im) = 0; // Каждый метод возвращает указатель (unique_ptr) на базовый класс (BaseGraphics, BasePen, BaseBrush), что позволяет скрыть детали конкретных реализаций.
	virtual unique_ptr<BasePen> createPen(shared_ptr<Color> cl) = 0;
	virtual unique_ptr<BaseBrush> createBrush(shared_ptr<Color> cl) = 0;
};


class QtGraphFactory : public AbstractGraphFactory	// QtGraphFactory — это конкретная реализация абстрактной фабрики. Она создает объекты, специфичные для Qt.
{
public:
	unique_ptr<BaseGraphics> createGraphics(shared_ptr<Image> im) override	// Метод createGraphics создает и возвращает объект типа QtGraphics, используя переданный объект Image.
	{
		return make_unique<QtGraphics>(im);
	}

	unique_ptr<BasePen> createPen(shared_ptr<Color> cl) override
	{
		return make_unique<QtPen>();
	}

	unique_ptr<BaseBrush> createBrush(shared_ptr<Color> cl) override
	{
		return make_unique<QtBrush>();
	}
};


Абстрактная фабрика позволяет создать целое семейство связанных или зависимых объектов (в данном случае, объекты Graphics, Pen, и Brush) без необходимости привязываться к конкретным классам этих 
объектов. Клиентский код (тот, который будет использовать эту фабрику) будет работать с объектами через их базовые интерфейсы, не зная о том, какие именно конкретные классы используются. Это позволяет 
легко заменить, например, QtGraphFactory на другую фабрику (например, GDIPlusGraphFactory), которая будет создавать объекты для другой графической системы, без изменений в клиентском коде.


### Файл User
class User 			// класс User взаимодействует с объектами, создаваемыми с помощью фабрики AbstractGraphFactory
{
public:
	void use(shared_ptr<AbstractGraphFactory>& cr) // Метод use принимает объект cr, который является shared_ptr на объект типа AbstractGraphFactory. Этот объект AbstractGraphFactory может быть любой конкретной фабрикой, которая наследует AbstractGraphFactory, например, QtGraphFactory.
	{
		shared_ptr<Image> image = make_shared<Image>(); // Внутри метода use создается объект Image с помощью make_shared<Image>. Это изображение будет использоваться при создании объекта Graphics.
		auto graphics = cr->createGraphics(image); // Вызов cr->createGraphics(image) использует фабрику, чтобы создать объект графики (Graphics) на основе переданного изображения. Конкретный тип объекта Graphics зависит от того, какая конкретная фабрика передана в use (например, если это QtGraphFactory, то будет создан объект QtGraphics).
	}
};

Как это связано с Абстрактной фабрикой:
Абстракция: Пользователь (User) не знает и не интересуется, какой конкретный тип объекта Graphics будет создан. Он просто использует метод createGraphics фабрики.
Гибкость: В зависимости от того, какая фабрика была передана в use, могут создаваться разные объекты Graphics. Например, это может быть объект QtGraphics или объект, относящийся к другой графической 
системе.
Расширяемость: Если в будущем понадобится поддержка другой графической системы, вам нужно будет лишь создать новую фабрику (например, DirectXGraphFactory) и передать ее в use, не изменяя сам метод use.


### Файл Pen:
class BasePen {}; // это базовый класс, который может служить общим интерфейсом или основой для различных типов "ручек" (инструментов рисования линий, контуров и т.д.).

class QtPen : public BasePen {}; // конкретный тип "ручки". 

Когда вы создаете такие классы в контексте паттерна Абстрактная фабрика, вы позволяете фабрике создавать объекты определенных типов, не завися от их конкретной реализации.


### Файл Brush:
class BaseBrush {};

class QtBrush : public BaseBrush {};


### Файл Image:
class Image {};


### Файл Color:
class Color {};


### Файл Main:
# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<AbstractGraphFactory> grfactory = make_shared<QtGraphFactory>(); 	// Создаем фабрику для Qt. Этот код создает объект QtGraphFactory, который является конкретной реализацией абстрактной фабрики AbstractGraphFactory. Указатель grfactory типа shared_ptr<AbstractGraphFactory> позволяет работать с фабрикой через абстрактный интерфейс, но на самом деле это конкретная фабрика QtGraphFactory.

	unique_ptr<User> us = make_unique<User>();					// Создаем пользователя. Создается объект User, который будет использовать графическую фабрику для создания и работы с графическими объектами.

	us->use(grfactory);								// Пользователь использует фабрику для создания и использования графических объектов. Внутри метода use User будет использовать фабрику для создания графических объектов, например, Graphics, Pen, Brush (зависит от того, как именно определен метод use).
}


# Что происходит на высоком уровне:
1) Инкапсуляция создания объектов: User не знает о том, какой конкретный тип графической системы используется (в данном случае это Qt), он просто получает фабрику через абстрактный интерфейс и 
использует ее для создания нужных объектов.
2) Гибкость и расширяемость: Если в будущем нужно будет поддерживать другую графическую систему (например, DirectX), можно создать новый класс фабрики (например, DirectXGraphFactory), который наследует 
AbstractGraphFactory. Весь остальной код останется неизменным — нужно будет только передать новую фабрику в метод use.


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++

https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/abstract-factory/vozmozhnye-realizacii-dlya-resheniya-konkretnykh-zadach-na-s++



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Прототип (Prototype)

# Проблемы
Представим, что вам потребовалось создать каркасную модель сферы из полигонов. Обычно таких полигонов очень много и при их создании необходимо вычислять координаты. Кроме того, в методы для создания 
объектов требуется передавать объект класса Creator (зачем он нужен? см. Фабричный метод). В данном случае более простым способом создания объекта может быть его копирование из существующего.

В итоге:
Необходимость передачи объекта класса Creator в методы для создания объектов
Необходимость большого количества информации и времени для создания нового объекта


# Назначение
Прототип (Prototype) — это порождающий паттерн проектирования, который поручает создание копий объектов самим копируемым объектам. Для этого в базовый класс добавляется метод для копирования, который 
создает новый объект на основе существующего. Паттерн вводит общий интерфейс для всех объектов, поддерживающих копирование. Это позволяет копировать объекты, не привязываясь к их классам.


# Решаемые задачи
1) Копирование объектов
Дает возможность создавать копии объектов на основе других объектов.

2) Создание сложных объектов
Паттерн прототип предоставляет альтернативу созданию подклассов для конструирования сложных объектов. Вместо того, чтобы создавать множество подклассов для каждой вариации объекта, можно использовать 
прототипы и копирование, чтобы создавать новые объекты с нужными параметрами и состоянием.


# UML диаграмма паттерна "Прототип"

	/--------------\			/-----------\
	|    Client    |			| Prototype |
	|--------------| ---------------------->|-----------|
	| +operation() |			|  +clone() |
	\--------------/			\-----------/
						      /\
						      ||
						      ||
			         /--------------------/\--------------------\
				 |					    |
				 |					    |
			/--------------------\			  /--------------------\
			| ConcretePrototype1 |			  | ConcretePrototypeN |
			|--------------------|        ...	  |--------------------| 
			|      +clone()	     |			  |      +clone()      |
			\--------------------/			  \--------------------/


# Преимущества
1) Возможность создавать новые объекты, используя уже существующие объекты в качестве прототипов.
2) Увеличение скорости создания сложных объектов.
3) Нет необходимости в передаче объекта класса Creator в методы для создания объектов.


# Недостатки
1) Необходимо убедиться в добавлении метода копирования в каждый класс, объект которого может быть скопирован.
2) Копируется внутреннее состояние объекта, в том числе значения приватных полей.
		

# Связь с другими паттернами
Паттерн Строитель может использовать прототипы для создания копий подобъектов.


______________________________________________________________________________________
Объяснение от ChatGPT

Представьте, что вы архитектор, и у вас есть чертеж здания. Если вам нужно спроектировать похожее здание, вы можете начать с нуля, но это займет много времени. Вместо этого вы берете копию уже 
существующего чертежа и изменяете его под новые требования. Это и есть суть Прототипа — создание копии с последующим изменением.

______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <memory>
#include <string>

using namespace std;

// Базовый класс Shape с виртуальным методом клонирования
class Shape {
public:
    virtual ~Shape() = default;
    
    // Виртуальный метод клонирования, который будет реализован в подклассах
    virtual unique_ptr<Shape> clone() const = 0;

    virtual void draw() const = 0;
};

// Конкретный класс Circle, который наследует Shape
class Circle : public Shape {
public:
    Circle(int radius) : radius(radius) {}
    
    // Реализация метода клонирования для Circle
    unique_ptr<Shape> clone() const override {
        return make_unique<Circle>(*this);
    }

    void draw() const override {
        cout << "Drawing a Circle with radius " << radius << endl;
    }

private:
    int radius;
};

// Конкретный класс Square, который наследует Shape
class Square : public Shape {
public:
    Square(int side) : side(side) {}
    
    // Реализация метода клонирования для Square
    unique_ptr<Shape> clone() const override {
        return make_unique<Square>(*this);
    }

    void draw() const override {
        cout << "Drawing a Square with side " << side << endl;
    }

private:
    int side;
};

int main() {
    // Создаем круг с радиусом 10
    unique_ptr<Shape> originalCircle = make_unique<Circle>(10);
    originalCircle->draw(); // Рисуем круг

    // Создаем копию круга с помощью метода clone
    unique_ptr<Shape> clonedCircle = originalCircle->clone();
    clonedCircle->draw(); // Рисуем клонированный круг

    // Создаем квадрат со стороной 20
    unique_ptr<Shape> originalSquare = make_unique<Square>(20);
    originalSquare->draw(); // Рисуем квадрат

    // Создаем копию квадрата с помощью метода clone
    unique_ptr<Shape> clonedSquare = originalSquare->clone();
    clonedSquare->draw(); // Рисуем клонированный квадрат

    return 0;
}



______________________________________________________________________________________
Общая реализация на языке С++

### Файл Car:

class Car									// Абстрактный базовый класс машин
{
public:
	virtual ~Car() = default;
	virtual unique_ptr<Car> clone() = 0;					// Метод предназначен для создания копии объекта, используя паттерн Прототип.
};


class Sedan : public Car							// Класс седан
{
public:
	Sedan() 
	{ 
		cout << "Calling the default constructor;" << endl; 
	}
	
	Sedan(const Sedan& car) 						// Конструктор копирования. Этот конструктор вызывается, когда объект Sedan копируется.
	{ 
		cout << "Calling the Copy constructor;" << endl; 
	}
	
	~Sedan() override 
	{ 
		cout << "Calling the destructor;" << endl; 
	}

	unique_ptr<Car> clone() override					// Метод clone() реализует паттерн Прототип, позволяя создавать копию объекта Sedan. 
	{									// Внутри метода создается новая копия текущего объекта Sedan, вызывая конструктор копирования, и возвращается unique_ptr на этот новый объект.
		return make_unique<Sedan>(*this);
	}
};


Паттерн Прототип позволяет создавать объекты путем копирования существующего экземпляра (прототипа), вместо создания нового с нуля. 


### Файл User:
class User
{
public:
	void use(shared_ptr<Car> &car) // Метод use принимает объект car по ссылке типа shared_ptr<Car>. Это означает, что car является указателем с подсчетом ссылок на объект типа Car (или его наследника). Копирование shared_ptr увеличивает счетчик ссылок, что гарантирует, что объект не будет уничтожен, пока существует хотя бы один указатель на него.
	{
		auto newCar = car->clone(); 	// Метод clone() вызывается для объекта car. Этот метод реализован в конкретных классах, наследующих Car, и возвращает копию объекта, заключенную в unique_ptr<Car>.
	}					// Результатом вызова car->clone() является новый объект, который хранится в newCar. Поскольку clone() возвращает unique_ptr, newCar будет уникальным указателем на новый объект.
};


User использует метод clone() для создания новой копии автомобиля, что может быть полезно, если User хочет работать с копией, не изменяя исходный объект car. 


### Файл Main:
# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<Car> sedan = make_shared<Sedan>(); // Создаем объект Sedan
	User{}.use(sedan); // Создается временный объект User, который сразу же вызывает метод use. Внутри метода use, переданный объект sedan (типа shared_ptr<Car>) используется для создания его клона. Вызов car->clone() приводит к вызову метода clone() у объекта sedan, который вызывает конструктор копирования для создания нового объекта Sedan. 
}				// Новый объект Sedan, созданный методом clone, временно хранится в unique_ptr<Car> newCar, который будет автоматически уничтожен, когда метод use завершится. После завершения метода use временный объект User будет уничтожен.


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/prototype/vozmozhnye-realizacii-dlya-resheniya-konkretnykh-zadach-na-s++




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Строитель (Builder)

# Проблема
Требуется создавать в одном месте сложный объект, состоящий из множества подобъектов.

Примером сложного объекта может служить объект почтового сообщения Email. У этого объекта может быть множество параметров, таких как отправитель, получатель, тема, текст, вложения. Используя паттерн 
Строитель, можно поэтапно создать объект почтового сообщения с различными параметрами.

# Назначение
Строитель (Builder) — это порождающий паттерн проектирования, который позволяет создавать сложные объекты, разбив процесс конструирования сложного объекта на отдельные шаги.

# Решаемые задачи
1) Поэтапное создание сложного объекта
Появляется возможность создавать сложные объекты пошагово. Каждый шаг строителя определяет значения и настройки для соответствующей части объекта.
2) Отделение процесса контроля за созданием объекта от самого процесса создания объекта.
Одна сущность (строитель) определяет шаги конструирования объекта, в то время как другая сущность (директор) управляет последовательностью этих шагов, обеспечивая создание объекта с нужной 
конфигурацией.

# UML диаграмма паттерна "Строитель"

		/-----------\			   /---------------\
		| Director  | 			   |    Builder    |
		|-----------| /\-----------------> |---------------|
		| +create() | \/		   | +buildPart1() |
		\-----------/ 			   |      ...      |
		      /\			   | +buildPartN() |
		      ||			   \---------------/
		      ||				   /\
		      ||				   ||
	     /------------------\			   ||
	     | ConcreteDirector |			   ||
	     |------------------|		  /------------------\
	     |       -//-       |		  | ConcreteBuilder  |
	     \------------------/		  |------------------|
						  |       -//-       |
						  \------------------/


# Преимущества
1) Упрощение процесса создания сложных объектов.
2) Разделение процесса создания объекта и контроля за созданием объекта.

# Недостатки
1) Усложнение кода из-за введения дополнительных иерархий классов.
2) Избыточность кода для создания простых объектов/

# Связь с другими паттернами
Паттерн Строитель может использоваться вместе с Фабричным методом для создания сложных объектов. "Фабричный метод" определяет интерфейс для создания взаимосвязанных объектов, а "Строитель" отвечает за 
создание отдельных частей сложного объекта.


______________________________________________________________________________________
Объяснение от ChatGPT

Представьте, что вы заказываете пиццу. Вы можете выбрать разные ингредиенты — тесто, соус, начинку, сыр и т.д. Процесс сборки пиццы состоит из нескольких шагов, и в зависимости от ваших предпочтений, 
вы можете выбрать разные комбинации. Шеф-повар (Строитель) выполняет каждый шаг, чтобы собрать вашу пиццу (объект).


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <memory>
#include <string>

using namespace std;

// Класс Car, представляющий сложный объект — автомобиль. У него есть методы для установки различных частей, таких как двигатель и шасси.
class Car {
public:
    void setEngine(const string& engine) { this->engine = engine; }
    void setChassis(const string& chassis) { this->chassis = chassis; }

    void show() const {
        cout << "Car with " << engine << " engine and " << chassis << " chassis." << endl;
    }

private:
    string engine;
    string chassis;
};

// Это интерфейс, который описывает шаги для создания автомобиля. Конкретные строители, такие как SedanBuilder, реализуют эти шаги по-своему.
class CarBuilder {
public:
    virtual ~CarBuilder() = default;

    virtual void buildEngine() = 0;
    virtual void buildChassis() = 0;

    shared_ptr<Car> getCar() { return car; }

protected:
    shared_ptr<Car> car = make_shared<Car>();
};

// Конкретный строитель для создания седана
class SedanBuilder : public CarBuilder {
public:
    void buildEngine() override {
        car->setEngine("Sedan Engine");
        cout << "Building engine for Sedan." << endl;
    }

    void buildChassis() override {
        car->setChassis("Sedan Chassis");
        cout << "Building chassis for Sedan." << endl;
    }
};

// Директор управляет процессом создания автомобиля. Он знает, в каком порядке вызывать методы строителя для получения готового объекта.
class CarDirector {
public:
    CarDirector(shared_ptr<CarBuilder> builder) : builder(builder) {}

    shared_ptr<Car> buildCar() {
        builder->buildEngine();
        builder->buildChassis();
        return builder->getCar();
    }

private:
    shared_ptr<CarBuilder> builder;
};

int main() {
    // Создаем строителя для седана
    shared_ptr<CarBuilder> sedanBuilder = make_shared<SedanBuilder>();

    // Создаем директора и строим автомобиль
    CarDirector director(sedanBuilder);
    shared_ptr<Car> sedan = director.buildCar();

    // Выводим информацию о созданном автомобиле
    sedan->show();

    return 0;
}


______________________________________________________________________________________
Общая реализация на языке С++


### Файл Car:

class Car									// Абстрактный класс Car
{
public:
	virtual ~Car() = default;
	virtual void drive() = 0;
};


class Sedan : public Car							// Наследуемый класс 
{
public:
	Sedan() 
	{ 
		cout << "Calling the Sedan constructor;" << endl; 
	}
	
	~Sedan() override 
	{ 
		cout << "Calling the Sedan destructor;" << endl; 
	}

	void drive() override 
	{ 
		cout << "Calling the drive method;" << endl; 
	}
};


### Файл CarBuilder:

class CarBuilder							// CarBuilder — это абстрактный класс, который определяет интерфейс для построения автомобиля (Car).
{
public:
	virtual ~CarBuilder() = default;

	virtual bool buildEngine() = 0;					// Он включает в себя методы для поэтапного создания машины (buildEngine, buildChassis)
	virtual bool buildChassis() = 0;

	shared_ptr<Car> getCar();					// И метод для получения готового объекта (getCar).

protected:
	virtual shared_ptr<Car> create() = 0;				// Предназначен для создания нового объекта Car. Он также является абстрактным и должен быть реализован в классах-наследниках.

	shared_ptr<Car> car{ nullptr };
	size_t part{ 0 };
};


class SedanBuilder : public CarBuilder					// реализует методы для поэтапного создания седана.
{
public:
	bool buildEngine() override					// проверяет текущий этап сборки (part) и, если это первый этап, строит двигатель для седана, увеличивая счетчик part.
	{
		if (!part)
			++part;

		if (part != 1) return false;
		
		cout << "Building part 1: Engine for Sedan;" << endl;
		return true;
	}
	
	bool buildChassis() override					// выполняет аналогичную функцию, но для второго этапа сборки, строя шасси для седана.
	{
		if (part == 1)
			++part;

		if (part != 2) return false;

		cout << "Building part 2: Chassis for Sedan;" << endl;
	}

protected:
	shared_ptr<Car> create() override;
};



### Файл Methods:

shared_ptr<Car> CarBuilder::getCar()					// Эти два метода отвечают за создание и возврат объекта автомобиля, если все необходимые этапы строительства завершены.
{
	if (!car) { car = create(); }

	return car;
}

shared_ptr<Car> SedanBuilder::create()
{
	if (part == 2) { car = make_shared<Sedan>(); }

	return car;
}


### Файл CarCreator:		

class CarCreator							// Абстрактным классом, который определяет интерфейс для создания объектов типа Car.
{									// CarCreator служит базой для всех классов, которые хотят создать объекты Car, предоставляя единый интерфейс для создания автомобилей.
public:
	virtual ~CarCreator() = default;
	virtual shared_ptr<Car> create() = 0;
};


class CarDirector : public CarCreator					// CarDirector наследует CarCreator и реализует метод create(), который отвечает за создание объекта Car.
{
public:
	CarDirector(shared_ptr<CarBuilder> builder) : br(builder) {} 	// В конструкторе CarDirector принимает shared_ptr<CarBuilder> в качестве параметра и сохраняет его в приватном поле br. Этот объект строителя (CarBuilder) отвечает за поэтапное создание автомобиля.

	shared_ptr<Car> create() override				// Метод create() в CarDirector использует объект строителя для поэтапного создания автомобиля:
	{
		if (br->buildEngine() && br->buildChassis()) return br->getCar();	// Сначала вызывается метод buildEngine() строителя.
											// Затем вызывается метод buildChassis() строителя. Если оба этапа строительства выполнены успешно, метод getCar() возвращает готовый объект Car.
		return nullptr;								// Если на каком-то этапе строительство не удалось, метод возвращает nullptr.
	}

private:
	shared_ptr<CarBuilder> br;
};


Этот код объединяет два паттерна: Строитель (Builder) и Фабричный метод (Factory Method). В результате мы получаем гибкую и модульную структуру для создания объектов типа Car через поэтапное 
строительство.


### Файл User:

class User
{
public:
	void use(shared_ptr<CarCreator>& creator)
	{
		shared_ptr<Car> car = creator->create();		// Использует фабрику для создания автомобиля

		if (car)						// Проверка, успешно ли создан автомобиль
			car->drive();					// Если автомобиль создан, вызывается метод drive()
	}
};

Класс User, представленный в вашем коде, показывает, как объект пользовательского класса может взаимодействовать с фабрикой для создания объектов Car и затем использовать их. 


### Файл Main:

# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<CarBuilder> builder = make_shared<SedanBuilder>(); 		// создается объект SedanBuilder, который является конкретной реализацией абстрактного класса CarBuilder. SedanBuilder отвечает за поэтапное создание автомобиля типа Sedan.
	shared_ptr<CarCreator> creator = make_shared<CarDirector>(builder);	// CarDirector является конкретной реализацией абстрактного класса CarCreator. В конструктор CarDirector передается builder, который будет использоваться для создания автомобиля.
										// CarDirector управляет процессом создания автомобиля, используя методы строителя (buildEngine() и buildChassis()), а затем возвращает готовый объект Car.
	User{}.use(creator);							// Создается временный объект класса User, который сразу же вызывает метод use() с переданным объектом CarCreator.
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Одиночка (Singleton)

# Проблема
Необходимость в создании одного экземпляра конкретного объекта.

Примером такого объекта может являться объект базы данных. Такие объекты нельзя клонировать или копировать, объект должен быть один во всей системе. Это необходимо для того, чтобы избежать проблем с 
целостностью и согласованностью данных.


# Назначение
Одиночка (Singleton) – это порождающий паттерн проектирования, который гарантирует, что будет создан только один экземпляр класса, и предоставляет к нему глобальную точку доступа.


# Решаемые задачи
1) Контроль за объектом.
Паттерн гарантирует, что у класса есть только один экземпляр


# Преимущества
1) Гарантия наличия единственного экземпляра объекта.
2) Предоставление глобальной точки доступа к объекту.
3) Оптимизация использования ресурсов.

# Недостатки
1) Создает проблемы с модификацией, расширением и управлением объектом.
2) Решение о том, какой объект создавать, не может приниматься при выполнении программы.
3) Создается глобальный объект и теряется контроль над его жизненным циклом.



______________________________________________________________________________________
Общая реализация на языке С++

### Файл Sun:
// Конструктор помечается модификатором private, чтобы объект класса нельзя было создать извне

class Sun
{
public:
	static shared_ptr<Sun> instance()
	{
		class SunProxy : public Sun {};					// SunProxy: Это вложенный класс-прокси, который наследуется от Sun. Этот подход используется для создания объекта Sun через закрытый конструктор.

		static shared_ptr<Sun> myInstance = make_shared<SunProxy>();	// Создается один статический экземпляр SunProxy через make_shared. Так как myInstance статический, он создается один раз и будет доступен при каждом вызове instance().

		return myInstance;						// возвращает shared_ptr, обеспечивая глобальную точку доступа к единственному экземпляру Sun.
	}
	
	~Sun() 
	{ 
		cout << "Calling the destructor;" << endl; 
	}

	void shine() 
	{ 
		cout << "The sun is shining;" << endl; 
	}

	Sun(const Sun&) = delete;					// Удаленные конструктор копирования и оператор присваивания:
	Sun& operator =(const Sun&) = delete;				// Эти операторы удалены, чтобы предотвратить копирование и присваивание объектов Sun. Singleton должен существовать в единственном экземпляре, и запрет на копирование помогает это обеспечить.

private:
	Sun() 								// Закрытый конструктор: делает невозможным создание объектов Sun извне класса. Это характерная черта паттерна Singleton, которая 
	{ 								// 	гарантирует, что экземпляр класса может быть создан только через статический метод instance().
		cout << "Calling the default constructor;" << endl; 
	}
};



### Файл Main:

# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<Sun> sun(Sun::instance());

	sun->shine();
}


Sun::instance() возвращает shared_ptr<Sun> на единственный экземпляр Sun. Поскольку instance() метод возвращает shared_ptr<Sun>, создаётся новый shared_ptr<Sun>, который управляет тем же объектом Sun.
Важно отметить, что, так как возвращаемое значение из instance() уже является shared_ptr<Sun>, использование конструкции shared_ptr<Sun> sun(Sun::instance()); избыточно. Более правильно использовать 
присваивание: shared_ptr<Sun> sun = Sun::instance(); (Подсказка от ChatGPT)


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/singleton/vozmozhnye-realizacii-dlya-resheniya-konkretnykh-zadach-na-s++




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Пул объектов (Object pool)

# Проблема
1) Требуется ограниченное количество объектов одного класса.
2) Переиспользование сложных объектов

Представь, что у тебя есть домашний Wi-Fi роутер. Вместо того чтобы каждый раз, когда устройство в доме нуждается в подключении к Интернету, создавать новое подключение к провайдеру интернета и 
разрывать его после использования, ты можешь использовать пул подключений.


# Назначение
Пул объектов (Object pool) – это порождающий паттерн проектирования, который предоставляет ограниченный набор инициализированных, по мере необходимости, и готовых для использования объектов. 
Используется для повышения производительности и управления ресурсами путем повторного использования предварительно созданных объектов вместо создания новых. Это полезно в случаях, когда создание 
объектов требует значительных ресурсов, таких как соединения с базой данных.


# Решаемые задачи
1) Централизованное управление доступом.
Обеспечивает централизованное управление доступом к объектам пула

2) Контроль и ограничение доступа.
Позволяет контролировать и ограничивать количество одновременно используемых объектов.

3) Повышение производительности.
Повторное использование объектов позволяет избежать увеличение затрачиваемых ресурсов на создание и уничтожение объектов.

4) Управление жизненным циклом объектов.
Упрощает управление жизненным циклом объектов, так как клиенту не нужно явно создавать и уничтожать объекты, а просто получать и возвращать их в пул.

# Преимущества
1) Повышается производительность за счет минимизации создания и уничтожения множества объектов.
2) Возможность ограничивать и контролировать число используемых объектов.
3) Возможность переиспользовать объект.


# Недостатки
1) Функция очистки, создания, удаления объекта. Возможность утечки информации. Если объект не очищается или его состояние не сбрасывается перед возвращением в пул, может возникнуть утечка информации. 
Например, если объект содержит конфиденциальные данные или ссылки на другие объекты, эта информация может остаться в объекте после его возврата в пул.
2) Увеличение объема кода. Внедрение паттерна требует создания дополнительной логики для управления пулом объектов, обработки доступа к объектам, контроля их состояния.
3) Усложнение архитектуры приложения.
4) В некоторых ситуациях сложная логика управления пулом.


______________________________________________________________________________________
Объяснение от ChatGPT

Представьте себе библиотеку, где книги можно брать на время, а затем возвращать обратно. Вместо того чтобы каждый раз печатать новую книгу для каждого читателя, библиотека хранит ограниченное количество
экземпляров, которые читатели могут брать и возвращать. Это и есть идея пула объектов: повторное использование ограниченного числа ресурсов.


______________________________________________________________________________________
Общая реализация на языке С++

### Файл EmployeePoolObject:

template <typename T>
concept EmployeePoolObject = requires(T t) 		// Концепция EmployeePoolObject задает контракт (или набор требований), которому должен соответствовать тип T для того, чтобы считаться допустимым для этого концепта.
{
	t.clockIn();					// Требование t.clockIn() внутри requires(T t) означает, что для любого типа T, который будет использоваться с этой концепцией, должен быть определен метод clockIn(), который может быть вызван у объекта типа T.
};



### Файл Employee:

class Employee						// Класс, который отслеживает количество созданных и уничтоженных объектов. 
{
private:
	static size_t count;

public:
	Employee() 
	{ 
		cout << "Constructor(" << ++count << ");" << endl; 
	}
	
	~Employee() 
	{ 
		cout << "Destructor(" << count-- << ");" << endl; 
	}

	void clockIn() 					// Выводит сообщение о том, что сотрудник "отметился" (clocked in), и отображает адрес текущего объекта (this) в памяти.
	{ 
		cout << "Employee clocked in: 0x" << this << endl; 
	}
};

size_t Employee::count = 0;				// хранит количество созданных объектов Employee



### Файл EmployeePool:

template <EmployeePoolObject Type>							// Шаблонный класс для управления пулом сотрудников.
class EmployeePool						
{
public:
	static shared_ptr<EmployeePool<Type>> instance();				// Статический метод возвращает shared_ptr на единственный экземпляр EmployeePool. Это обеспечивает реализацию паттерна Singleton для пула сотрудников.

	shared_ptr<Type> hireEmployee();						// Этот метод предназначен для "нанятия" нового сотрудника, т.е., добавления нового сотрудника в пул и возвращения умного указателя на этот сотрудник.
	bool fireEmployee(shared_ptr<Type>& employee);					// Этот метод предназначен для "увольнения" сотрудника из пула. Он принимает умный указатель на сотрудника и удаляет его из пула.
	size_t count() const { return pool.size(); }					// count(): Возвращает количество сотрудников в пуле.
		
	EmployeePool(const EmployeePool&) = delete;					// Удаленные конструктор копирования и оператор присваивания: Запрещает копирование и присваивание экземпляра EmployeePool, что также является частью паттерна Singleton.
	EmployeePool& operator =(const EmployeePool&) = delete;				

private:
	vector<pair<bool, shared_ptr<Type>>> pool;					// Хранит информацию о сотрудниках. vector содержит пары, где первый элемент bool может указывать на состояние (например, занято/свободно), а второй элемент — умный указатель на сотрудника.

	EmployeePool() {}								// Закрытый конструктор для предотвращения создания экземпляров EmployeePool извне. Это свойственно паттерну Singleton.

	pair<bool, shared_ptr<Type>> createEmployee();					// Создает нового сотрудника и возвращает его в виде пары с состоянием.

	template <typename Type>							// operator <<: Дружественная функция, которая позволяет выводить содержимое пула сотрудников в поток вывода (например, в cout).
	friend ostream& operator << (ostream& os, const EmployeePool<Type>& pl);
};


### Файл instance():

template <EmployeePoolObject Type>							// реализует паттерн Singleton с использованием shared_ptr. 
shared_ptr<EmployeePool<Type>> EmployeePool<Type>::instance()
{
	static shared_ptr<EmployeePool<Type>> myInstance(new EmployeePool<Type>());	// Создается новый объект EmployeePool<Type>, и shared_ptr на этот объект присваивается переменной myInstance. Это гарантирует, что myInstance будет управлять единственным экземпляром EmployeePool<Type>, создавая его при первом вызове instance().

	return myInstance;
}


### Файл hireEmployee():

template <EmployeePoolObject Type>				// отвечает за предоставление доступного сотрудника из пула или создание нового сотрудника, если все существующие сотрудники заняты. 
shared_ptr<Type> EmployeePool<Type>::hireEmployee()
{
	size_t i;
	for (i = 0; i < pool.size() && pool[i].first; ++i);	// Цикл for проходит по всем элементам в pool до тех пор, пока не найдет свободного сотрудника

	if (i < pool.size())
	{
		pool[i].first = true;				// Если в пуле есть свободное место (т.е., i < pool.size()), то сотрудник становится доступным
	}
	else
	{
		pool.push_back(createEmployee());		// Если все сотрудники заняты (т.е., i >= pool.size()), создается новый сотрудник с помощью метода createEmployee() и добавляется в пул.
	}

	return pool[i].second;					// Возвращается умный указатель на сотрудника, который был найден или только что создан. 
}


### Файл fireEmployee():

template <EmployeePoolObject Type>				// Метод fireEmployee в классе EmployeePool предназначен для "увольнения" сотрудника из пула. Этот метод помечает сотрудника как освобожденного и выполняет определенные действия, связанные с его увольнением.
bool EmployeePool<Type>::fireEmployee(shared_ptr<Type>& employee)
{
	size_t i;
	for (i = 0; pool[i].second != employee && i < pool.size(); ++i); 	// Цикл for используется для поиска сотрудника в пуле.

	if (i == pool.size()) return false;					// Если после завершения цикла переменная i равна pool.size(), это означает, что сотрудник не был найден в пуле. В таком случае метод возвращает false.

	employee.reset();							// "Увольнение" сотрудника: Сбрасывает умный указатель employee, что освобождает его и обнуляет.
	pool[i].first = false;							// Помечает сотрудника как освобожденного, установив соответствующий флаг bool в false.
	pool[i].second->clockIn();						// Вызывает метод clockIn() у сотрудника, возможно для выполнения каких-то действий, связанных с "увольнением" или освобождением.

	return true;
}


### Файл createEmployee():

template <EmployeePoolObject Type>						// Метод createEmployee для класса EmployeePool предназначен для создания нового сотрудника и возвращения его вместе с флагом, указывающим на его доступность.
pair<bool, shared_ptr<Type>> EmployeePool<Type>::createEmployee()
{
	return { true, make_shared<Type>() };					// Создает новый объект типа Type (где Type должен быть классом, удовлетворяющим концепции EmployeePoolObject) и возвращает умный указатель shared_ptr<Type> на этот объект.
}


### Файл operator <<:

template <typename Type>							// Шаблонный оператор вывода operator<< для класса EmployeePool предназначен для вывода состояния пула сотрудников на поток, например, на консоль.
ostream& operator << (ostream& os, const EmployeePool<Type>& pl)
{
	for (auto elem : pl.pool)						// Цикл for используется для перебора всех элементов в pl.pool. 
		os << "{" << elem.first << ", 0x" << elem.second << "} ";	// elem.first: Выводит булевый флаг, показывающий состояние сотрудника (доступен или занят). elem.second: Выводит адрес объекта в памяти в шестнадцатеричном формате. 

	return os;
}


### Файл Main:

# include <iostream>
# include <memory>
# include <iterator>
# include <vector>

using namespace std;

int main()
{
	shared_ptr<EmployeePool<Employee>> pool = EmployeePool<Employee>::instance();	// Получаем экземпляр пула сотрудников

	vector<shared_ptr<Employee>> vec(4);						// Создаем вектор из 4 умных указателей на сотрудников

	for (auto& elem : vec)								// Заполняем вектор сотрудниками из пула
		elem = pool->hireEmployee();

	pool->fireEmployee(vec[1]);							// Увольняем второго сотрудника из вектора

	cout << *pool << endl;								// Выводим текущее состояние пула сотрудников

	shared_ptr<Employee> ptr = pool->hireEmployee();				// Нанимаем нового сотрудника и заменяем свободное место во векторе
	vec[1] = pool->hireEmployee();

	cout << *pool << endl;								// Выводим текущее состояние пула сотрудников после изменений
}





______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Структурные паттерны

# Общее описание
Структурные паттерны - это группа шаблонов проектирования, которая решает задачи, связанные с организацией классов и объектов в более крупные структуры.
1) Структурные паттерны уровня класса используют наследование для составления композиций из интерфейсов и реализаций.
Или
2) Вместо композиции интерфейсов или реализаций структурные паттерны уровня объекта компонуют объекты для получения новой функциональности.

Дополнительная гибкость в последнем случае связана с возможностью изменить композицию объектов во время выполнения, что недопустимо для статической композиции классов.

К структурным паттернам уровня класса можно отнести: адаптер и мост.

К структурным паттернам уровня объекта можно отнести: декоратор, компоновщик, заместитель, фасад.


# Используются следующие механизмы:
1) Наследование - это концепция, позволяющая описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом. Базовый класс определяет интерфейс, а подклассы - 
реализацию. Структуры на основе наследования получаются статичными.

2) Композиция - построение структуры путем объединения объектов некоторых классов.
Композиция позволяет получать структуры, которые можно изменять во время выполнения.


______________________________________________________________________________________
Адаптер (Adapter)

# Назначение
Паттерн адаптер (Adapter) преобразует интерфейс одного класса в интерфейс другого, который ожидают клиенты. Адаптер обеспечивает совместную работу классов с несовместимыми интерфейсами, которая 
без него была бы невозможна.

Например: контейнеры queue, priority_queue и stack библиотеки стандартных шаблонов STL реализованы на базе последовательных контейнеров list, deque и vector, адаптируя их интерфейсы к нужному виду. 
Именно поэтому эти контейнеры называют контейнерами-адаптерами.

# Решаемые задачи
1) Разделение ответственностей
Согласно принципу единственной ответственности (Single Responsibility) один класс должен иметь одну область ответственности. Когда существует сущность на которую возложены 2 или более ответственностей, 
они разделяются посредством вынесения каждой в адаптер. Ответственности делаются независимыми друг от друга.

2) Подмена одного интерфейса на другой
Позволяет преобразовывать интерфейс одного класса в интерфейс другого, который ожидают клиенты.

Интерфейс является абстракцией, которая определяет, как объект может быть использован, независимо от его конкретной реализации. Он представляет из себя набор методов и свойств класса.

3) Использование сторонних библиотек
Использовать класс из нестандартной библиотеки следует через адаптер. Делается это для решения проблем совместимости интерфейсов библиотеки и рабочей среды, адаптации кода к новым версиям библиотеки, 
устранения сильной зависимости кода от библиотеки. Возможность контролировать и модифицировать адаптер делает код более гибким и легким в сопровождении.

4) Расширение базового интерфейса
Интерфейс базового класса в общем случае плохо расширять, так как нарушаются принципы инкапсуляции и единственной ответственности (Single Responsibility). Код становится тяжелее поддерживать и 
модифицировать. Появляется потребность в дополнительных проверках и приведениях типов при работе с указателями на базовый класс.

При использовании адаптера расширение может относиться не к одному классу, а к целой иерархии классов.


# UML диаграмма паттерна "Адаптер"

		
		/-------------\			/----------------\			/-------------\		
		|   AdapterA  |			|     Adaptee    |			|   AdapterB  |
		|-------------|			|----------------|			|-------------|	
		| +requestA() |			| +specRequest() |			| +requestB() |
		\-------------/			\----------------/			\-------------/
		      /\		          /\	/\   /\					/\
		      ||		          ||	||   ||					||
		      ||   //=====================//	||   \\============================\\	||
		      ||   ||				||				   ||	||
		      ||   /\				||				   /\	||
		      ||   \/				||				   \/	||
	     /------------------\		/------------------\		      /------------------\
	     | ConcreteAdapterA |		| ConcreteAdaptee  |		      | ConcreteAdapterB |
	     |------------------|		|------------------|	              |------------------|
	     |	     -//-	|		|	-//-	   |		      |	      -//-	 |
	     \------------------/		\------------------/		      \------------------/



# Преимущества
1) отделяет и скрывает от клиента подробности преобразования различных интерфейсов
2) позволяет адаптировать интерфейс к требуемому
3) позволяет разделить роли сущности
4) дает возможность независимо развивать различные ответственности сущности
5) расширение интерфейса


# Недостатки
1) необходимость плодить много классов приводит к увеличению количества времени и памяти,необходимых для исполнения программы
2) дублирование кода (в различных конкретных адаптерах может требоваться одна и та же реализация методов)
3) часто адаптер должен иметь доступ к реализации класса


# Связь с другими паттернами
1) Мост: структура паттерна мост аналогична структуре адаптера, но у моста иное назначение. Он отделяет интерфейс от реализации, чтобы то и другое можно было изменять независимо. Адаптер же призван 
изменить интерфейс существующего объекта.
2) Фасад: адаптер может использоваться внутри фасада для обеспечения совместимости между подсистемами, имеющими несовместимые интерфейсы.
3) Заместитель: адаптер может служить в качестве простого заместителя для объекта, предоставляя тот же интерфейс, но с другой реализацией.
4) Декоратор: оба паттерна имеют схожую структуру, но разные цели. Адаптер изменяет интерфейс объекта, в то время как декоратор расширяет функциональность объекта, не изменяя его интерфейса


______________________________________________________________________________________
Объяснение от ChatGPT

Адаптер — это паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. Он как "переходник" между двумя вещами, которые сами по себе не могут взаимодействовать 
напрямую.

Представьте, что у вас есть розетка с европейским стандартом (две круглые вилки), а зарядное устройство от вашего телефона имеет американскую вилку (две плоские вилки). Чтобы подключить зарядное 
устройство к розетке, вам нужен переходник, который позволит подключить несовместимые устройства друг к другу. Этот переходник и есть адаптер.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

Допустим, у нас есть старый класс, который измеряет температуру в градусах Цельсия, но мы работаем с новой системой, которая ожидает температуру в Фаренгейтах. Вместо того чтобы переписывать старый 
класс, мы создаём адаптер.

#include <iostream>

// Старый класс, который измеряет температуру в Цельсиях
class CelsiusThermometer {
public:
    double getTemperature() {
        return 25.0; // Просто пример, возвращает 25 градусов Цельсия
    }
};

// Интерфейс для новой системы, которая ожидает температуру в Фаренгейтах
class FahrenheitThermometer {
public:
    virtual double getTemperature() = 0; // Абстрактный метод
};

// Адаптер, который позволяет использовать старый класс в новой системе
class CelsiusToFahrenheitAdapter : public FahrenheitThermometer {
public:
    CelsiusToFahrenheitAdapter(CelsiusThermometer* celsiusThermometer)
        : celsiusThermometer(celsiusThermometer) {}

    // Преобразуем температуру из Цельсия в Фаренгейт
    double getTemperature() override {
        double celsius = celsiusThermometer->getTemperature();
        return (celsius * 9.0 / 5.0) + 32.0;
    }

private:
    CelsiusThermometer* celsiusThermometer;
};

int main() {
    // Старый термометр, который измеряет в Цельсиях
    CelsiusThermometer oldThermometer;

    // Адаптер, который преобразует данные в Фаренгейты
    CelsiusToFahrenheitAdapter adapter(&oldThermometer);

    // Используем адаптер для получения температуры в Фаренгейтах
    std::cout << "Temperature in Fahrenheit: " << adapter.getTemperature() << std::endl;

    return 0;
}



______________________________________________________________________________________
Общая реализация на языке С++


### Файл includes:

// подключаем нужные для работы программы библиотеки
# include <iostream>
# include <memory>

// подключаем пространство имен std
using namespace std;


### Файл BaseAdaptee:

// класс BaseAdaptee является базовым описанием интерфейса, 
// который нуждается в адаптации
 
class BaseAdaptee
{
public:
    virtual ~BaseAdaptee() = default;
    virtual void specificRequest() = 0;
};


### Файл ConcreteAdaptee:

// класс ConcreteAdaptee определяет существующий интерфейс, 
// который нуждается в адаптации
// (реализует адаптируемый интерфейс) 

class ConcreteAdaptee : public BaseAdaptee
{
public:
    virtual void specificRequest() override 
    { 
        cout << "Method ConcreteAdaptee;" << endl; 
    }
};


### Файл Adapter:

// Adapter - базовый абстрактный класс для адапетров

// Adapter адаптирует интерфейс Adaptee к зависящему от 
// предметной области интерфейсу, которым пользуется Client

// Client - сущность, которая вступает во взаимоотношения с объектами, 
// удовлетворяющими интерфейсу
 
class Adapter
{
public:
    virtual ~Adapter() = default;
    virtual void request() = 0;
};


### Файл ConcreteAdapter:

// конкретная реализация экзмпляра BaseAdapter

// ConcreteAdapter адаптирует интерфейс BaseAdaptee к интерфейсу Adapter,
// чтобы клиентский код мог использовать адаптируемый класс через адаптер

class ConcreteAdapter : public Adapter
{
private:
    shared_ptr<BaseAdaptee>  adaptee;
public:
    ConcreteAdapter(shared_ptr<BaseAdaptee> ad) : adaptee(ad) {}
    void request() override;
};


### Файл Methods:

# pragma region Methods
void ConcreteAdapter::request()
{
    cout << "Adapter: ";
    if (adaptee)
    {
        adaptee->specificRequest();
    }
    else
    {
        cout << "Empty!" << endl;
    }
}


### Файл Main:

int main()
{
    shared_ptr<BaseAdaptee> adaptee = make_shared<ConcreteAdaptee>();
    shared_ptr<Adapter> adapter = make_shared<ConcreteAdapter>(adaptee);

    adapter->request();
}



______________________________________________________________________________________
Возможные реализации для решения конкретных задач
https://y2kot.gitbook.io/untitled/patterns/structural-patterns/adapter/vozmozhnye-realizacii-dlya-resheniya-konkretnykh-zadach



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Декоратор (Decorator)

# Назначение
1) Паттерн декоратор (Decorator) позволяет динамически добавлять новые обязанности объекту. Декораторы являются гибкой альтернативой порождению подклассов для расширения функциональности.

2) Рекурсивно декорирует основной объект.
Предполагает возможность применять несколько декораторов последовательно, оборачивая один декоратор в другой. Каждый декоратор добавляет свою функциональность к объекту, а затем передает управление 
следующему декоратору в цепочке, пока не достигнет последнего.

3) Паттерн декоратор использует схему "обертываем подарок, кладем его в коробку, обертываем коробку".

# Решаемые задачи
1) динамическое, прозрачное для клиентов добавление обязанностей объектам
2) реализация обязанностей, которые могут быть сняты с объекта
3) применяется, когда расширение путем наследования по каким-то причинам неудобно или невозможно
Наследование от некоторых классов может быть запрещено.

# UML диаграмма паттерна "Декоратор"

		
			/--------------\
			|   Component  |
			|--------------| <==============================================\\
			| +operation() |						||
			\--------------/						||
			       /\							||
			       ||							||
			       ||							||
			       /\							||
		  //============================================================\\      ||
		  ||			       ||				||      ||
		  ||			       ||				||      /\
		  ||			       ||				||      \/
	/--------------------\	     /--------------------\		    /--------------\
	| ConcreteComponent1 |	     | ConcreteComponentN |		    |   Decorator  |
	|--------------------|	...  |--------------------|		    |--------------|
	|	 -//-	     |	     |	      -//-	  |		    | +operation() |
	\--------------------/	     \--------------------/		    \--------------/
		  /\				/\				   /\
		  ||				||				   ||
		  ||				||			 	   /\
		  ||				||		        //================================\\
	/--------------------\	     /--------------------\		||		      		  ||
	|		     |	     |		          |		||		      		  ||
	|--------------------|	     |--------------------|	/--------------------\		/--------------------\
	|		     |       |		          |	| ConcreteDecorator1 |		| ConcreteDecoratorN |
	\--------------------/       \--------------------/	|--------------------|		|--------------------|
								|	-//-	     |		|	 -//-	     |
								\--------------------/		\--------------------/




# Преимущества
1) Гибкость: возможность добавлять желаемую реализацию к любому классу. Появлется возможность "декорировать" декораторы.
2) Отсутсвие разрастания иерархии.
3) Позволяет избежать перегруженных функциями классов на верхних уровнях иерархии.
4) Возможность обращаться с декорированным объектом так же как и с исходной сущностью.
5) Отсутствие дублирования кода, данный код просто уходит в конкретный декоратор.


# Недостатки
1) Снижение производительности программы.
Не используя декораторы можно напрямую пользоваться методом класса. Декоратор же может долго полиморфно совершать цепочку вызовов, что сказывается на времени выполнения программы.

2) Вся ответственность за декорирование "ложится на плечи" программиста
Нет сущности, которая бы полностью отвечала за последовательность декорирования: за порядок вызова и оборачивания декораторов.

3) В случае если в цепочке вызовов декоратора появляется необходимость изменить какую-либо обертку или удалить ее, то приходится заново оборачивать исходный объект.

4) Необходимость в создании сущности, отвечающей за декорирование.

# Связь с другими паттернами
1) Компоновщик: декоратор можно рассматривать как вырожденный случай компоновщика с единственным компонентом. Однако Decorator добавляет новые обязанности и не предназначен для агрегирования объектов.
2) Стратегия: декоратор хорошо совмещается с паттерном стратегия. Декоратор позволяет изменить внешний облик объекта, стратегия – его внутреннее содержание. Это два взаимодополняющих способа изменения 
объекта.
3) Адаптер: если декоратор изменяет только обязанности объекта, но не его интерфейс, то адаптер придает объекту совершенно новый интерфейс.



______________________________________________________________________________________
Объяснение от ChatGPT

Декоратор — это паттерн проектирования, который позволяет динамически добавлять новую функциональность объектам, не изменяя их исходный код. Это как обёртка, которая добавляет что-то новое к 
существующему объекту.

Представьте, что вы покупаете подарок, например, книгу. Вы можете просто купить книгу и подарить её, но чтобы сделать подарок более особенным, вы можете упаковать его в красивую обёртку, добавить 
бантик или даже положить его в подарочную коробку. Каждое из этих действий — это своего рода декорирование вашего подарка.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <string>
using namespace std;

// Базовый класс для человека в обычной одежде
class Person {
public:
    virtual string getOutfit() const {
        return "Basic outfit";
    }
};

// Декоратор для добавления шляпы
class HatDecorator : public Person {
private:
    const Person& person;
public:
    HatDecorator(const Person& person) : person(person) {}

    string getOutfit() const override {
        return person.getOutfit() + " + hat";
    }
};

// Декоратор для добавления куртки
class JacketDecorator : public Person {
private:
    const Person& person;
public:
    JacketDecorator(const Person& person) : person(person) {}

    string getOutfit() const override {
        return person.getOutfit() + " + jacket";
    }
};

int main() {
    // Базовый наряд
    Person basicPerson;

    // Наряд с шляпой
    HatDecorator personWithHat(basicPerson);
    cout << "Outfit 1: " << personWithHat.getOutfit() << endl;

    // Наряд с шляпой и курткой
    JacketDecorator personWithHatAndJacket(personWithHat);
    cout << "Outfit 2: " << personWithHatAndJacket.getOutfit() << endl;

    return 0;
}


______________________________________________________________________________________
Общая реализация на языке С++

### Файл includes:

# include <iostream>
# include <memory>

using namespace std;


### Файл Component:

class Component
{
public:
    virtual ~Component() = default;
    virtual void operation() = 0;
};


### Файл ConcreteComponent:

class ConcreteComponent : public Component
{
public:
    void operation() override 
    { 
        cout << "ConcreteComponent; "; 
    }
};


### Файл Decorator:

class Decorator : public Component
{
protected:
    shared_ptr<Component> component;
public:
    Decorator(shared_ptr<Component> comp) : component(comp) {}
};


### Файл ConcreteDecorator:

class ConcreteDecorator : public Decorator
{
public:
    using Decorator::Decorator;
    void operation() override;
};

# pragma region Method
void ConcreteDecorator::operation()
{
    if (component)
    {
        component->operation();
        cout << "ConDecorator; ";
    }
}
# pragma endregion


### Файл Main:

int main()
{
    shared_ptr<Component> component = make_shared<ConcreteComponent>();
    shared_ptr<Component> decorator1 = make_shared<ConcreteDecorator>(component);

    decorator1->operation();
    cout << endl;

    shared_ptr<Component> decorator2 = make_shared<ConcreteDecorator>(decorator1);

    decorator2->operation();
    cout << endl;
}


______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Компоновщик (Composite)

# Назначение
Компоновщик (Composite) - структурный паттерн проектирования, который позволяет сгруппировать объекты в древовидные структуры для представления иерархий "часть-целое". Позволяет клиентам единообразно 
трактовать индивидуальные и составные объекты.

# Используется в случаях, когда:
1) Объекты могут быть как примитивными (элементарными), так и составными (сложными). 

2) Составной объект может включать в себя коллекции других объектов, образуя сложные древовидные структуры.
Пример: директория файловой системы состоит из элементов, каждый их которых также может быть директорией.

3) Код клиента работает с примитивными и составными объектами единообразно.

# Решаемые задачи
1) композиция объектов
Дает возможность представления иерархии объектов вида часть-целое. С помощью композиции можно создавать древовидные структуры объектов, группировать объекты в контейнеры и управлять ими единообразно.

2) предоставление единообразного интерфейса
Единообразная трактовка клиентами составных и индивидуальных объектов, то есть паттерн компоновщик позволяет клиентам взаимодействовать с отдельными объектами и группами объектов (составными объектами) 
через единый интерфейс.

В качестве клиентов может выступать пользовательский код или другие классы, взаимодействующие с объектами иерархии Composite.

3) создание рекурсивных операций
Паттерн компоновщик позволяет выполнять операции на составных объектах рекурсивно. Когда операция вызывается на составном объекте, он автоматически распространяет операцию на все объекты в иерархии, 
включая объекты, содержащие другие объекты. Происходит рекурсивный проход по иерархии. Таким образом, можно легко применять операции как к отдельным объектам, так и ко всему дереву объектов.

# UML диаграмма паттерна "Компоновщик"


		/-------------------\
		|     Component	    |
		|-------------------|	1..*
		| +operation()      | <=======================================\\
		| +add(Component)   |					      ||
		| +remove(Iterator) |					      ||
		| +begin()	    |					      ||
		| +end()	    |		       //===========\\	      ||
		| +isComposite()    | 		       ||	    ||	      /\
		\-------------------/		       ||	    ||	      \/
			/\			       ||	/-------------------\
			||			       ||	|     Composite     |
			||			       ||	|-------------------|
			/\			       ||	| +operation()      |
	     //========================================//	| +add(Component)   |
	     ||				   ||			| +remove(Iterator) |
	     ||				   ||			| +begin()	    |
	     ||				   ||			| +end()	    |
    /--------------------\	 /--------------------\		| +isComposite()    |
    | ConcreteComponent1 |	 | ConcreteComponentN |		\-------------------/
    |--------------------|  ...  |--------------------|
    | 	     -//-        |	 | 	  -//-        |
    \--------------------/	 \--------------------/



# Преимущества
1) упрощение архитектуры клиентского кода
Предоставление клиентскому коду удобного и единого интерфейса для работы как с отдельными, так и с составными объектами позволяет ему работать с иерархией объектов без необходимости проверять их типы и 
выбирать разные пути обработки.

2) повышение гибкости и расширяемости системы за счет добавления новых компонентов в иерархию без изменения существующего кода
3) возможность выполнения рекурсивных операций на составных объектах
4) предоставление удобных методов для добавления, удаления и обхода компонентов в иерархии объектов

# Недостатки
1) потребность в создании сущности, отвечающей за за логику сборки компоновщика, которая может оказаться нетривиальной
2) нетривиальная логика обхода и работы с сущностью как с контейнером, если в компоновщике содержатся другие компоновщики
3) потеря типизации

Использование общего интерфейса может привести к потере типизации и нарушению статической проверки типов. Появляется необходимость решать проблему типизации вынесением всех методов из компоновщика в 
класс компонента. В свою очередь, это приводит к следующей проблеме

4) появление нелогичных операций
Максимизация интерфейса класса компонент, приводит к тому, что у подклассов появляются нелогичные операции

# Связь с другими паттернами
1) Цепочка обязанностей: отношение компонент-родитель используется в паттерне цепочка обязанностей.
2) Декоратор: паттерн декоратор часто применяется совместно с компоновщиком. Когда декораторы и компоновщики используются вместе, у них обычно бывает общий родительский класс. Поэтому декораторам 
придется поддержать интерфейс компонента такими операциями, как Add, Remove.
3) Приспособленец: паттерн приспособленец позволяет разделять компоненты, но ссылаться на своих родителей они уже не могут.
4) Итератор: итератор можно использовать для обхода составных объектов.
5) Посетитель: посетитель локализует операции и поведение, которые в противном случае пришлось бы распределять между классами Composite и Leaf

Leaf – лист:
– представляет листовые узлы композиции и не имеет потомков;
– определяет поведение примитивных объектов в композиции;

Composite – составной объект:
– определяет поведение компонентов, у которых есть потомки;
– хранит компоненты-потомки;
– реализует относящиеся к управлению потомками операции в интерфейсе класса Component;

Component – компонент:
– объявляет интерфейс для компонуемых объектов;
– предоставляет подходящую реализацию операций по умолчанию, общую для всех классов;
– объявляет интерфейс для доступа к потомкам и управления ими;



______________________________________________________________________________________
Объяснение от ChatGPT

Паттерн "Компоновщик" (или "Composite") позволяет работать с группами объектов так же, как и с отдельными объектами. Это особенно полезно, когда у вас есть иерархия объектов, например, структура, где 
есть контейнеры, которые могут содержать как простые элементы, так и другие контейнеры.

Представьте, что у вас есть компания, где есть сотрудники и отделы. Отделы могут включать в себя как отдельных сотрудников, так и другие отделы. Вам нужно обрабатывать их одинаково — например, 
посчитать количество сотрудников во всей компании.

Простой объект: Это обычный сотрудник.
Контейнер: Это отдел, который может содержать как сотрудников, так и другие отделы.
С помощью паттерна "Компоновщик" вы можете создать такую структуру, где каждый элемент (будь то сотрудник или отдел) будет обрабатываться одинаково.

Пример из жизни:
Давайте представим дерево каталогов и файлов в компьютере:

Файл: Это простой элемент, который содержит данные.
Папка: Это контейнер, который может содержать как файлы, так и другие папки.
Используя "Компоновщик", вы можете создавать структуры, где папка может содержать файлы и другие папки, и вы можете обращаться с папками и файлами одинаково — например, узнать их размер.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

class FileSystemItem {
public:
    virtual ~FileSystemItem() = default;
    virtual void showDetails() const = 0;
};

class File : public FileSystemItem {
private:
    string name;
public:
    File(const string& name) : name(name) {}

    void showDetails() const override {
        cout << "File: " << name << endl;
    }
};

class Folder : public FileSystemItem {
private:
    string name;
    vector<shared_ptr<FileSystemItem>> items;
public:
    Folder(const string& name) : name(name) {}

    void add(const shared_ptr<FileSystemItem>& item) {
        items.push_back(item);
    }

    void showDetails() const override {
        cout << "Folder: " << name << endl;
        for (const auto& item : items) {
            item->showDetails();
        }
    }
};

int main() {
    // Создаем файлы
    shared_ptr<File> file1 = make_shared<File>("File1.txt");
    shared_ptr<File> file2 = make_shared<File>("File2.txt");

    // Создаем папку и добавляем в нее файлы
    shared_ptr<Folder> folder1 = make_shared<Folder>("Folder1");
    folder1->add(file1);
    folder1->add(file2);

    // Создаем еще одну папку и добавляем в нее папку и файл
    shared_ptr<Folder> folder2 = make_shared<Folder>("Folder2");
    folder2->add(folder1);
    folder2->add(make_shared<File>("File3.txt"));

    // Показать детали всех элементов в folder2
    folder2->showDetails();

    return 0;
}



______________________________________________________________________________________
Общая реализация на языке С++

### Файл includes:

# include <iostream>
# include <initializer_list>
# include <memory>
# include <vector>


### Файл using:

using namespace std;

class Component

using PtrComponent = shared_ptr<Component>;
using VectorComponent = vector<PtrComponent>;


### Файл Component:

class Component
{
public:
    using value_type = Component;
    using size_type = size_t;
    using iterator = VectorComponent::const_iterator;
    using const_iterator = VectorComponent::const_iterator;

    virtual ~Component() = default;

    virtual void operation() = 0;

    virtual bool isComposite() const 
    { 
        return false; 
    }
    virtual bool add(initializer_list<PtrComponent> comp) 
    { 
        return false; 
    }
    virtual bool remove(const iterator& it) 
    { 
        return false; 
    }
    virtual iterator begin() const 
    { 
        return iterator(); 
    }
    virtual iterator end() const 
    { 
        return iterator(); 
    }
};


### Файл Figure:

class Figure : public Component
{
public:
    virtual void operation() override 
    { 
        cout << "Figure method;" << endl; 
    }
};


### Файл Camera:

class Camera : public Component
{
public:
    virtual void operation() override 
    { 
        cout << "Camera method;" << endl; 
    }
};


### Файл Composite:

class Composite : public Component
{
private:
    VectorComponent vec;
public:
    Composite() = default;
    Composite(PtrComponent first, ...);

    void operation() override;

    bool isComposite() const override 
    { 
        return true; 
    }
    bool add(initializer_list<PtrComponent> list) override;
    bool remove(const iterator& it) override 
    { 
        vec.erase(it); return true; 
    }
    iterator begin() const override 
    { 
        return vec.begin(); 
    }
    iterator end() const override 
    { 
        return vec.end(); 
    }
};


### Файл CompositeMethods:

# pragma region Methods
Composite::Composite(PtrComponent first, ...)
{
    for (shared_ptr<Component>* ptr = &first; *ptr; ++ptr)
        vec.push_back(*ptr);
}

void Composite::operation()
{
    cout << "Composite method:" << endl;
    for (auto elem : vec)
        elem->operation();
}

bool Composite::add(initializer_list<PtrComponent> list)
{
    for (auto elem : list)
        vec.push_back(elem);
return true;
}
# pragma endregion


### Файл Main:

int main()
{
    using Default = shared_ptr<Component>;
    PtrComponent fig = make_shared<Figure>(), cam = make_shared<Camera>();
    auto composite1 = make_shared<Composite>(fig, cam, Default{});

    composite1->add({ make_shared<Figure>(), make_shared<Camera>() });
    composite1->operation();
    cout << endl;

    auto it = composite1->begin();

    composite1->remove(++it);
    composite1->operation();
    cout << endl;

    auto composite2 = make_shared<Composite>(make_shared<Figure>(), composite1, Default());

    composite2->operation();
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Мост (Bridge)

# Назначение
Мост (Bridge) - структурный паттерн, предназначенный для отделения абстракции от ее реализации так, чтобы была возможность изменять их независимо друг от друга.

# Решаемые задачи
1) возможность выбирать реализацию во время выполнения программы
Мост позволяет избежать постоянной привязки абстракции к реализации.

2) комбинирование разных абстракций и реализаций и изменение их независимо
3) избежание перекомпиляции клиентского кода при изменениях в реализации абстракции
4) полное сокрытие от клиентов реализации абстракции
5) разделение одной реализации между несколькими объектами и сокрытие деталей разделения от клиента
6) декомпозиция иерархии: позволяет управлять ростом и сложностью иерархии

Зачастую иерархию разделяют на две части: абстракцию и реализацию.
В некоторых случаях может потребоваться более чем две части для разделения иерархии на более гибкие и независимые компоненты. Количество частей зависит от конкретных требований и особенностей системы.


# UML диаграмма паттерна "Мост"


		/--------------\			/-----------------\
		| Abstraction  |			|   Implementor   |
		|--------------|/\===================>  |-----------------|
		| +operation() |\/			| +impOperation() |
		\--------------/			\-----------------/
		       /\					/\
		       ||					||
		       ||					||
		       ||					||		
		/--------------\			  /--------------\
		|	       |			  |	         |	
		|--------------| <======================= |--------------|
		|     -//-     |			  |     -//-     |
		\--------------/			  \--------------/



# Преимущества
1) избавление от дублирования кода
Дублирование кода может возникать в случае, когда несколько реализаций содержат одинаковые методы. Данную проблему можно решить вынесением одинаковых методов на более высокий уровень абстракции. 
Однако такой подход вынуждает реализовывать вынесенные методы во всех остальных экземплярах реализации

2) позволяет иерархии не разрастаться
3) сокрытие деталей реализации от клиентов
4) возможность изменять реализацию во время выполнения программы

# Недостатки
1) увеличение времени выполнения
2) тяжелый процесс реализации паттерна: введение дополнительного уровня абстракции между "реализацией" и "абстракцией"
Из-за дополнительных затрат на разработку паттерна и усложнения структуры кода появляется необходимость закладывать реализацию моста в систему на этапе проектирования

3) связь между абстрактными понятиями не всегда может быть выделена

# Связь с другими паттернами
1) Абстрактная фабрика: паттерн абстрактная фабрика может создать и сконфигурировать мост
2) Адаптер: для обеспечения совместной работы не связанных между собой классов прежде всего предназначен паттерн адаптер. Обычно он применяется в уже готовых системах. Мост же участвует в проекте с 
самого начала и призван поддерживать возможность независимого изменения абстракций и их реализаций.
3) Компоновщик: мост и компоновщик могут совместно использоваться для создания сложных структур, состоящих из связанных объектов.
4) Декоратор: мост может быть комбинирован с декоратором для добавления дополнительной функциональности к объектам абстракции и реализации.
5) Стратегия: мост может быть реализован с использованием стратегии. В этом случае, абстракция содержит ссылку на объект стратегии, который предоставляет конкретную реализацию. Стратегия может быть 
легко заменена другой, не нарушая интерфейса абстракции.



______________________________________________________________________________________
Объяснение от ChatGPT

Представь себе, что ты разрабатываешь программу для работы с разными формами (например, круги и квадраты), которые можно рисовать в различных стилях (например, синим цветом или красным). Вместо того 
чтобы создавать класс для каждой комбинации форм и стилей (например, СинийКруг, КрасныйКвадрат и т.д.), паттерн "Мост" предлагает разделить формы и стили на два независимых набора классов:

Форма: это абстракция, которая определяет общие методы для всех форм (например, нарисовать).
Стиль рисования: это реализация, которая определяет, как конкретно форма будет нарисована (например, цвет).
С помощью "Моста" ты можешь создавать новые формы и стили независимо друг от друга и комбинировать их по мере необходимости.

Пример из жизни:
Представь себе пульт дистанционного управления для телевизора.
Пульт: это абстракция, которая определяет основные действия, такие как включение, выключение, изменение канала.
Телевизор: это реализация, которая определяет, как эти действия будут выполнены. У тебя может быть пульт, который работает с разными моделями телевизоров.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

// Абстракция - форма
class Shape {
protected:
    shared_ptr<DrawStyle> style;  // Мост к реализации
public:
    Shape(shared_ptr<DrawStyle> style) : style(style) {}

    virtual void draw() = 0;
};

// Реализация - стиль рисования
class DrawStyle {
public:
    virtual void drawShape(const string& shape) = 0;
};

class Circle : public Shape {
public:
    Circle(shared_ptr<DrawStyle> style) : Shape(style) {}

    void draw() override {
        style->drawShape("Circle");
    }
};

class Square : public Shape {
public:
    Square(shared_ptr<DrawStyle> style) : Shape(style) {}

    void draw() override {
        style->drawShape("Square");
    }
};

// Конкретная реализация стиля рисования
class RedStyle : public DrawStyle {
public:
    void drawShape(const string& shape) override {
        cout << "Drawing " << shape << " in red color." << endl;
    }
};

class BlueStyle : public DrawStyle {
public:
    void drawShape(const string& shape) override {
        cout << "Drawing " << shape << " in blue color." << endl;
    }
};


int main() {
    shared_ptr<DrawStyle> redStyle = make_shared<RedStyle>();
    shared_ptr<DrawStyle> blueStyle = make_shared<BlueStyle>();

    unique_ptr<Shape> redCircle = make_unique<Circle>(redStyle);
    unique_ptr<Shape> blueSquare = make_unique<Square>(blueStyle);

    redCircle->draw();   // Вывод: Drawing Circle in red color.
    blueSquare->draw();  // Вывод: Drawing Square in blue color.

    return 0;
}


______________________________________________________________________________________
Общая реализация на языке С++

### Файл includes

# include <iostream>
# include <memory>

using namespace std;


### Файл implementor

class Implementor
{
public:
    virtual ~Implementor() = default;
    virtual void operationImp() = 0;
};


### Файл Abstraction

class Abstraction
{
protected:
    shared_ptr<Implementor> implementor;
public:
    Abstraction(shared_ptr<Implementor> imp) : implementor(imp) {}
    virtual ~Abstraction() = default;
    virtual void operation() = 0;
};



### Файл Concretelmplementor

class ConcreteImplementor : public Implementor
{
public:
    virtual void operationImp() override 
    { 
        cout << "Implementor;" << endl; 
    }
};


### Файл Entity

class Entity : public Abstraction
{
public:
    using Abstraction::Abstraction;
    virtual void operation() override 
    {     
        cout << "Entity: "; 
        implementor->operationImp(); 
    }
};


### Файл Main

int main()
{
    shared_ptr<Implementor> implementor = make_shared<ConcreteImplementor>();
    shared_ptr<Abstraction> abstraction = make_shared<Entity>(implementor);

    abstraction->operation();
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Заместитель (Proxy)

# Назначение
Паттерн проектирования заместитель (Proxy) имитирует интерфейс и поведение оригинального объекта и контролирует доступ к нему.
Заместитель (Proxy) обычно создается для того, чтобы предоставить дополнительные функции или управлять доступом к оригинальному объекту без изменения его основной логики или структуры.

Назначение паттерна заместитель заключается в добавлении дополнительного уровня абстракции между клиентом и реальным объектом.

# Решаемые задачи
1) предоставление локального объекта, который работает с удаленным объектом, скрывая детали удаленного взаимодействия [удаленный заместитель (Remote Proxy)]
2) создание заглушки для ресурсоемкого объекта, позволяющей откладывать его создание или загрузку до момента реального использования [виртуальный прокси (Virtual Proxy)]
3) контроль доступа к объекту, ограничение различных операций в зависимости от прав доступа [защищающий заместитель (Protection Proxy)]
4) выполнение дополнительных действий при доступе к объекту, например, подсчет ссылок на объект или отслеживание изменений ["умная" ссылка (Smart Reference)]
5) кэширование результатов операций объекта для избегания повторных вычислений или загрузки [кэширующий заместитель (Caching Proxy)]

# UML диаграмма паттерна "Заместитель"


			/------------\
			|    Base    |
			|------------|
			| +request() |
			\------------/
			      /\
			      ||
			      ||
			      /\
	    //===================================\\
	    ||					 ||
	    ||					 ||
    /------------\			    /------------\
    |   Object   |			    |    Proxy   |
    |------------|  1			  /\|------------|
    | +request() | <======================\/| +request() |
    \------------/			    \------------/


# Преимущества
1) контроль доступа к объекту
Позволяет реализовать механизмы безопасности, аутентификации и авторизации в системе.

2) возможность работы при отсутствии самого объекта
В этом случае поведение заместителя может быть неоднозначным. Необходимо предупреждение о возможной недостоверности ответа

3) упрощение работы с ресурсоемкими объектами, "разгрузка" тяжелого оригинального объекта
4) добавление дополнительного функционала перед или после обращения к оригинальному объекту
5) возможность отвечать за жизненный цикл объекта
6) кэширование: возможность хранить результаты операций и предоставлять их повторно без обращения к оригинальному объекту

# Недостатки
1) увеличение накладных расходов: увеличение времени выполнения операций
2) усложнение кода: необходимость в добавлении дополнительных классов и методов

# Связь с другими паттернами
1) Адаптер: предоставляет другой интерфейс к адаптируемому объекту. Напротив, заместитель в точности повторяет интерфейс своего субъекта.
Интерфейс заместителя может быть и подмножеством интерфейса субъекта.

2) Декоратор: реализация паттерна декоратор похожа на реализацию заместителя, но назначение совершенно иное. Декоратор добавляет объекту новые обязанности, а заместитель контролирует доступ к объекту.
3) Фабричный метод: заместитель может быть создан с помощью фабричного метода. Фабричный метод позволяет инкапсулировать процесс создания заместителя и предоставляет гибкость в выборе типа заместителя, 
который будет создан.

4) Одиночка: заместитель может быть реализован как одиночка, гарантируя, что будет создан только один объект заместителя для доступа к оригинальному объекту
5) Стратегия: заместитель может использоваться для введения различных стратегий доступа к объекту.



______________________________________________________________________________________
Объяснение от ChatGPT

Простое объяснение:
Представь, что у тебя есть дорогая (в плане ресурсов) операция, например, загрузка большого изображения с сервера. Если ты каждый раз загружаешь изображение напрямую, это может быть неэффективно. 
Вместо этого ты можешь создать объект-заместитель, который будет притворяться этим изображением. Когда изображение нужно будет действительно загрузить и показать, заместитель выполнит эту задачу, но 
только тогда, когда это действительно необходимо.

Пример из жизни:
Представь, что ты хочешь купить билет в кино. Ты не идёшь сразу в зал, а сначала идёшь в кассу. Кассир — это "заместитель", который проверяет, есть ли места, продаёт тебе билет и только потом пропускает
тебя в зал. Кассир контролирует доступ к кинозалу.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

// Интерфейс, который реализует и реальное изображение, и его заместитель
class Image {
public:
    virtual void display() = 0;
};

// Реальный класс изображения, который загружает изображение с сервера
class RealImage : public Image {
private:
    string filename;

public:
    RealImage(const string& filename) : filename(filename) {
        loadImageFromDisk();
    }

    void display() override {
        cout << "Displaying " << filename << endl;
    }

private:
    void loadImageFromDisk() {
        cout << "Loading " << filename << " from disk..." << endl;
    }
};

// Заместитель изображения, который загружает изображение только при необходимости
class ProxyImage : public Image {
private:
    string filename;
    unique_ptr<RealImage> realImage;

public:
    ProxyImage(const string& filename) : filename(filename) {}

    void display() override {
        if (!realImage) {
            realImage = make_unique<RealImage>(filename);
        }
        realImage->display();
    }
};


int main() {
    unique_ptr<Image> image = make_unique<ProxyImage>("test_image.jpg");

    // Изображение будет загружено и показано только при первом вызове display()
    image->display();
    cout << "Calling display again...\n";
    image->display();  // В этот раз изображение не будет загружаться заново

    return 0;
}



______________________________________________________________________________________
Общая реализация на языке С++

### Файл Includes:

# include <iostream>
# include <memory>
# include <map>
# include <random>

using namespace std;


### Файл Subject:

class Subject
{
public:
    virtual ~Subject() = default;

    virtual pair<bool, double> request(size_t index) = 0;
    virtual bool changed() 
    { 
        return true; 
    }
};


### Файл RealSubject:

class RealSubject : public Subject
{
private:
    bool flag{ false };
    size_t counter{ 0 };
public:
    virtual pair<bool, double> request(size_t index) override;
    virtual bool changed() override;
};


### Файл Proxy:

class Proxy : public Subject
{
protected:
    shared_ptr<RealSubject> realsubject;
public:
    Proxy(shared_ptr<RealSubject> real) : realsubject(real) {}
};


### Файл ConcreteProxy:

class ConcreteProxy : public Proxy
{
private:
    map<size_t, double> cache;
public:
    using Proxy::Proxy;
    virtual pair<bool, double> request(size_t index) override;
};


### Файл RealSubjectMethods:

bool RealSubject::changed()
{
    if (counter == 0)
    {
        flag = true;
    }
    if (++counter == 7)
    {
        counter = 0;
        flag = false;
    }
    return flag;
}

pair<bool, double> RealSubject::request(size_t index)
{
    random_device rd;
    mt19937 gen(rd());

    return pair<bool, double>(true, generate_canonical<double, 10>(gen));
}


### Файл ConcreteProxyMethods:

pair<bool, double> ConcreteProxy::request(size_t index)
{
    pair<bool, double> result;

    if (!realsubject)
    {
        cache.clear();
        result = pair<bool, double>(false, 0.);
    }
    else if (!realsubject->changed())
    {
        cache.clear();
        result = realsubject->request(index);
        cache.insert(map<size_t, double>::value_type(index, result.second));
    }
    else
    {
        map<size_t, double>::const_iterator it = cache.find(index);
        if (it != cache.end())
        {
            result = pair<bool, double>(true, it->second);
        }
        else
        {
            result = realsubject->request(index);
            cache.insert(map<size_t, double>::value_type(index, result.second));
        }
    }
    return result;
}


### Файл Main:
int main()
{
    shared_ptr<RealSubject> subject = make_shared<RealSubject>();
    shared_ptr<Subject> proxy = make_shared<ConcreteProxy>(subject);

    for (size_t i = 0; i < 21; ++i)
    {
        cout << "( " << i + 1 << ", " << proxy->request(i % 3).second << " )" << endl;
    if ((i + 1) % 3 == 0)
        cout << endl;
    }
}




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Фасад (Facade)

# Назначение
Паттерн фасад (Facade) относится к структурным шаблонам проектирования и предоставляет унифицированный интерфейс вместо набора интерфейсов некоторой подсистемы. Он определяет интерфейс более высокого 
уровня, который упрощает использование подсистемы.

# Решаемые задачи
1) предоставление простого интерфейса к сложной подсистеме
2) ослабление связей между компонентами системы

# UML диаграмма паттерна "Фасад"

			
				/--------\
				| Facade |
				\--------/				  /---------\
				    ||					  |         |
			//=====================================\\	  \---------/      
			||	    ||		 ||	       ||	      /\
			\/	    ||		 ||	       ||	      ||
		   /---------\	    ||		 ||	       ||    //=================\\
		   |	     |	    ||		 ||	       ||    ||  		||
		   \---------/	    ||		 ||	       \/    ||			||
				    \/ 		 ||	     /---------\	    /---------\
    /---------\			/---------\	 ||	     |         |	    |         |
    |	      |=================|	  |	 ||	     \---------/	    \---------/
    \---------/			\---------/	 ||
	/\					 ||
	||					 ||
	||	/----------\			 ||
	\\======|	   |<====================//
		\----------/



# Преимущества
1) упрощение взаимодействия: предоставление простого интерфейса к сложной подсистеме
2) снижение зависимости клиентского кода от подсистемы: работа происходит с одним объектом

# Недостатки
1) увеличение сложности и сопровождаемости фасада
Если подсистема имеет большое количество компонентов или сложную структуру, фасад рискует стать сложным, перегруженным объектом, что приведет к укреплению связей между компонентами вместо их ослабления.

# Связь с другими паттернами
1) Абстрактная фабрика: допустимо использовать вместе с фасадом, чтобы предоставить интерфейс для создания объектов подсистем способом, не зависимым от этих подсистем. Абстрактная фабрика может 
выступать и как альтернатива фасаду, чтобы скрыть платформенно-зависимые классы.
2) Посредник: аналогичен фасаду в том смысле, что абстрагирует функциональность существующих классов.
3) Одиночка: обычно требуется только один фасад. Поэтому объекты фасадов часто бывают одиночками.
4) Подписчик-издатель: фасад может применять паттерн наблюдатель для уведомления клиентов о событиях, происходящих в подсистеме.
5) Компоновщик: фасад может использовать компоновщик для предоставления единого интерфейса к группе объектов внутри подсистемы.
6) Адаптер: фасад может использовать адаптеры для преобразования интерфейсов подсистемы в интерфейс, ожидаемый клиентом



______________________________________________________________________________________
Объяснение от ChatGPT

Простое объяснение:
Представь, что у тебя есть современный дом с множеством умных устройств: умные светильники, системы отопления, музыкальные колонки и т.д. Каждый из этих устройств можно управлять через отдельное 
приложение на телефоне, но это сложно и неудобно. Вместо этого у тебя есть единое приложение, которое позволяет одним нажатием кнопки настроить всю систему — включить свет, нагреть дом, включить музыку.
Это приложение — фасад. Оно скрывает сложность взаимодействия с каждым устройством и предлагает тебе простой и удобный интерфейс.

Допустим, у тебя есть сложный набор процессов при приготовлении кофе: нужно нагреть воду, измельчить зерна, заварить кофе и налить его в чашку. Фасад в этом случае будет машиной для приготовления кофе. 
Вместо того чтобы управлять каждым процессом по отдельности, ты просто нажимаешь кнопку "Сделать кофе", и машина делает всё за тебя.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

// Классы, представляющие различные компоненты домашнего кинотеатра

class Amplifier {
public:
    // Включение усилителя
    void on() { cout << "Amplifier is on" << endl; }

    // Установка громкости
    void setVolume(int level) { cout << "Volume set to " << level << endl; }

    // Выключение усилителя
    void off() { cout << "Amplifier is off" << endl; }
};

class DvdPlayer {
public:
    // Включение DVD-плеера
    void on() { cout << "DVD Player is on" << endl; }

    // Проигрывание фильма
    void play(string movie) { cout << "Playing " << movie << endl; }

    // Выключение DVD-плеера
    void off() { cout << "DVD Player is off" << endl; }
};

class Projector {
public:
    // Включение проектора
    void on() { cout << "Projector is on" << endl; }

    // Установка широкоформатного режима
    void wideScreenMode() { cout << "Projector in widescreen mode" << endl; }

    // Выключение проектора
    void off() { cout << "Projector is off" << endl; }
};

// Класс-фасад, который упрощает взаимодействие с системой домашнего кинотеатра
class HomeTheaterFacade {
private:
    Amplifier amp;      // Усилитель
    DvdPlayer dvd;      // DVD-плеер
    Projector projector; // Проектор

public:
    // Конструктор, принимающий ссылки на компоненты системы
    HomeTheaterFacade(Amplifier a, DvdPlayer d, Projector p) : amp(a), dvd(d), projector(p) {}

    // Метод для подготовки к просмотру фильма
    void watchMovie(string movie) {
        cout << "Get ready to watch a movie..." << endl;
        amp.on();                       // Включаем усилитель
        amp.setVolume(5);               // Устанавливаем громкость
        dvd.on();                       // Включаем DVD-плеер
        dvd.play(movie);                // Проигрываем фильм
        projector.on();                 // Включаем проектор
        projector.wideScreenMode();     // Переключаем проектор в широкоформатный режим
    }

    // Метод для завершения просмотра фильма и выключения системы
    void endMovie() {
        cout << "Shutting down movie theater..." << endl;
        projector.off();    // Выключаем проектор
        dvd.off();          // Выключаем DVD-плеер
        amp.off();          // Выключаем усилитель
    }
};

int main() {
    // Создаем объекты компонентов системы
    Amplifier amp;
    DvdPlayer dvd;
    Projector projector;

    // Создаем фасад для домашнего кинотеатра
    HomeTheaterFacade homeTheater(amp, dvd, projector);

    // Используем фасад для начала просмотра фильма
    homeTheater.watchMovie("Inception");

    // Используем фасад для завершения просмотра фильма
    homeTheater.endMovie();
}


Комментарии к классам компонентов: Каждому классу (Amplifier, DvdPlayer, Projector) добавлены комментарии, поясняющие методы, которые они выполняют (включение, выключение, настройка).

Комментарии к классу HomeTheaterFacade: Здесь поясняется роль фасада как посредника, который упрощает управление сложной системой. Также описаны действия, которые выполняет каждый метод фасада 
(watchMovie, endMovie).

Комментарии в функции main: Поясняют процесс создания объектов компонентов системы и использования фасада для упрощенного управления этими компонентами.



______________________________________________________________________________________
Пример реализации паттерна фасад для подсистемы компиляции на языке С++

### Файл Scanner:

class Scanner 
{
public:
    Scanner(istream&);
    virtual ~Scanner();
    virtual Token& Scan();
private:
    istream& _inputStream;
};


### Файл Parser:

class Parser 
{
public:
    Parser();
    virtual ~Parser();
    virtual void Parse(Scanner&, ProgramNodeBuilder&);
};


### Файл ProgramNodeBuilder:

class ProgramNodeBuilder 
{
public:
    ProgramNodeBuilder();
    virtual ProgramNode* NewVariable(const char* variableName) const;
    virtual ProgramNode* NewAssignment(ProgramNode* variable, ProgramNode* expression) const;
    virtual ProgramNode* NewReturnStatement(ProgramNode* value) const;
    virtual ProgramNode* NewCondition(ProgramNode* condition,ProgramNode* truePart, ProgramNode* falsePart) const;
    ProgramNode* GetRootNode();
private:
    ProgramNode* _node;
};


### Файл ProgramNode:

class ProgramNode
{
public:
    virtual void GetSourcePosition(int& line, int& index);
    virtual void Add(ProgramNode*);
    virtual void Remove(ProgramNode*);
    virtual void Traverse(CodeGenerator&);
protected:
    ProgramNode();
};


### Файл CodeGenerator:

class CodeGenerator 
{
public:
    virtual void Visit(StatementNode*);
    virtual void Visit(ExpressionNode*);
protected:
    CodeGenerator(BytecodeStream&);
protected:
    BytecodeStream& _output;
};


### Файл Compiler:

// класс Compiler, который будет служить фасадом, позволяющим 
// собрать приведенные классы подсистемы компиляции 

class Compiler 
{
public:
    Compiler();
    virtual void Compile(istream&, BytecodeStream&);
};
void Compiler::Compile (istream& input, BytecodeStream& output) 
{
    Scanner scanner(input);
    ProgramNodeBuilder builder;
    Parser parser;
    parser.Parse(scanner, builder);
    RISCCodeGenerator generator(output);
    ProgramNode* parseTree = builder.GetRootNode();
    parseTree->Traverse(generator);
}


Управление ресурсами. Идиома RAII

Объекты классов могут на протяжении всего своего существования использовать различные ресурсы - динамически выделенная память, файлы, сетевые подключения и т.д. В этом случае в 
C++ применяется так называемый принцип/идиома RAII (resource acquisition is initialization). RAII предполагает, что получение ресурса производится при инициализации объекта. А
освобождение ресурса производится в деструкторе объекта. Например, получение динамической памяти происходит в конструкторе объекта, а освобождение в деструкторе. При этом важно, 
чтобы ресурс (в данном случае динамическая память) освобождался только один раз. Для этой цели в классе удалены конструктор копирования и оператор присваивания, что позволяет 
избежать ситуации, когда два объекта хранят указатель на одну и ту же область динамической памяти и соответственно потом в деструкторе будут пытаться освободить эту память.



______________________________________________________________________________________
Идиома копирования и замены

Когда нужно изменить состояние одного или нескольких объектов, и на любом этапе модификации может возникнуть ошибка, для создания кода, устойчиваого к ошибкам, может применяться
идиома копирования и замены (copy-and-swap idiom). Суть данной идиомы состоит в следующей последовательности действий:

1. Создаем копию объекта(ов)

2. Изменяем копию. При этом оригинальные объекты остаются нетронутыми

3. Если все изменения прошли успешно, заменяем оригинальный объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то оригинальный объект 
не заменяется.

Обычно эта идиома применяется в функциях и частным, хотя и распространенным, случаем ее применения является оператор присваивания. В общем случаем это выглядит так:

// оператор присвоения некоторого класса Copyable
Copyable& operator=(const Copyable& obj) {
    Copyable copy{obj}; 				// создаем копию через конструктор копирования
    swap(copy);         				// обмениваем значения копии и оригинального объекта
    return *this;
}
// некоторая функция для обмена значениями
void swap(Copyable& copy) noexcept;

В функции оператора присваивания сначала создается временная копия присваиваемого объекта. И в случае успешного создания копиии текущий объект (this) и копия обмениваются 
содержимым через некоторую функцию swap().

Функция swap может быть реализована как внешняя функция или как функция-член класса (в примере выше предполагается, что она реализована внутри класса). При этом функция swap 
определяется как не генерирующая исключения (с ключевым словом noexcept). Поэтому единственной точкой, где может возникнуть исключение, функция копирования (конструктор 
копирования) объекта. Если копирование не удается, то управление не доходит до выполнения функции swap.

Устойчивость к исключениям заключается в том, что в операторе присваивания нет точки, где генерация исключения могла бы привести к утечке памяти. Приведённая выше реализация 
также устойчива к присваиваниям объекта самому себе (a=a), однако содержит издержки, связанные с тем, что временная копия в этом случае тоже будет создаваться. Исключить 
издержки можно дополнительной проверкой:

// оператор присвоения некоторого класса Copyable
Copyable& operator=(const Copyable& obj) {
    Copyable copy{obj};     				// создаем копию через конструктор копирования
    if(this != &obj)        				// если не текущий объект
        swap(copy);         				// обмениваем значения копии и оригинального объекта
    return *this;
}
// некоторая функция для обмена значениями
void swap(Copyable& copy) noexcept;

Хотя часто подобный способ применяется именно в операторах присвоения, но также он может применяться в других ситуациях, где необходимо выполнить устойчивую к исключениям 
модификацию объекта. И всегда принцип будет тот же. Сначала копируем объект, который надо изменить. Далее выполняем над объектом-копией изменения. И если все пройдет удачно, 
обмениваем значениями целевой объект и объект-копию.



______________________________________________________________________________________
Идиома Move-and-Swap / Перемещение с обменом

Идиома move-and-swap или перемещение с обменом применяется в операторах присвоения с перемещением. Она позволяет избежать дублирования кода деструктора и конструктора 
копирования. Суть данной идиомы состоит в следующей последовательности действий:

1. Для перемещаемого объекта создаем копию с помощью конструктора перемещения

2.Заменяем текущий объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то текущий объект не заменяется.

Общая форма move-and-swap выглядит следующим образом:

MyClass& MyClass::operator=(MyClass&& rhs) noexcept
{
    MyClass moved(std::move(rhs)); // получаем перемещаемый объект
    swap(moved);                  // выполняем обмен значениями
    return *this; // возвращаем текущий объект
}



______________________________________________________________________________________
Паттерн swap delete

Когда удалил ту память на которую ссылаешься, и потом указатель ты занулил



______________________________________________________________________________________
















