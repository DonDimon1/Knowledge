https://y2kot.gitbook.io/untitled
______________________________________________________________________________________
Введение в паттерны

Главная идея: Разделяй и властвуй.


# Что такое паттерны проектирования?
Паттерны проектирования - это набор общепринятых подходов, предназначенных для решения проблем, возникающих в процессе проектирования и разработки программного обеспечения. Паттерны описывают 
определенные способы организации классов и связей между ними.
Используются для достижения таких целей, как улучшение декомпозиции задачи и легкой модификации кода. Паттерны обеспечивают возможность повторного использования кода.


# Основная идея
Основная идея паттернов проектирования заключается в предоставлении типовых решений для проблем, с которыми сталкиваются разработчики. Вместо того, чтобы каждый раз "изобретать велосипед" 
и декомпозировать задачу с нуля, можно использовать проверенные проектные подходы.


# Преимущества
Готовое решение
Упрощение модификации кода
Облегчение взаимодействия между программистами
Повышение скорости разработки
Увеличение надежности кода
Повышение читаемости кода


# Недостатки
Увеличение объема кода
Увеличение времени выполнения
Высокие требования к памяти
Увеличение времени компиляции
Может привести к уменьшению скорости разработки

Структура паттернов:
1) Порождающие паттерны
2) Структурные паттерны
3) Поведенческие паттерны



______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Порождающие паттерны

# Общее описание
Полиморфизм – это очень мощный механизм, который позволяет модифицировать программу «не изменяя» написанный код, за счет добавления новых классов. Дословный перевод полиморфизма - много форм. 
Синоним полиморфизма – безразличие, когда один и тот же код может работать с объектами разных классов (типов).


# Проблема
При модификации программы происходит подмена объектов одних классов на объекты других классов. Как правило, в объектно-ориентированных языках это реализуется за счет передачи в методы ссылок 
(указателей) на базовые полиморфные классы или за счет интерфейсов. При использовании обобщений (шаблонов) подстановка типов осуществляется на этапе компиляции.
При использовании полиморфизма рано или поздно возникает необходимость создания конкретного объекта (сущности) конкретного типа. Для расширения, модификации или подмены сущности будет необходимо найти 
все места, где создается объект, и изменить код. Такая модификация программы увеличивает время разработки, понижает надежность программы, приводит к проблемам с версионностью.

# Порождающие паттерны
Порождающие паттерны – группа паттернов проектирования, которые:
1) берут на себя ответственность за логику создания объектов,
2) позволяют нам не создавать в методах объекты конкретных классов,
3) дают возможность принимать решение объекты каких классов нужно создавать при выполнении программы,
4) дают возможность повторно использовать уже созданный объект.


# Текущий список порождающих паттернов 
1) Фабричный метод
2) Абстрактная фабрика
3) Прототип
4) Строитель
5) Одиночка
6) Пул объектов

______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Фабричный метод (Factory method)

# Проблема
При использовании полиморфизма появляется возможность подмены объекта одного класса на объект другого класса с использованием ссылки (указателя) на базовый абстрактный класс. При создании объекта 
конкретного класса может возникнуть необходимость подмены одной сущности на другую, в результате чего придется искать, где создается объект, и менять написанный код. В попытках решить эту проблему, 
сформировалась идея передачи ответственности создания конкретного объекта другому классу.

# Назначение
Фабричный метод (Factory method) - порождающий паттерн проектирования, определяющий единый интерфейс создания объектов и позволяющий менять класс создаваемого объекта.

# Решаемые задачи
1) Подмена создания объекта одного класса на объект другого класса
Появляется возможность создавать объекты, являющиеся наследниками одного базового класса, без привязки к конкретным классам. Это позволяет легко расширять, модифицировать программу, добавляя новые 
классы, без изменения клиентского кода, который создает объекты классов.

2) Отделение принятия решения, какой объект нужно создать, от самого процесса создания объекта
После принятия решения о выборе конкретного типа создаваемого объекта создается объект (Creator) конкретного фабричного метода. Фактическое создание объекта происходит при непосредственном вызове 
метода createProduct() фабричного метода (Creator).

3) Повторное использование объектов
Появляется возможность повторного использования уже созданного объекта в разных местах программы.

# UML диаграмма паттерна "Фабричный метод"

			/------------\				 /------------------\		  /-----------\
			|  Product   |				 |      Creator	    |		  | Solution  |
			|------------| <------------------------ |------------------| <-----------|-----------|
			|+operation()|				 | +createProduct() |		  | +create() |
			\------------/				 \------------------/		  \-----------/
			      /\					   /\				/\
			      ||					   ||				||
			      ||					   ||				||
		    /---------/\----------\				   ||				||
		    |			  |			   /---------------\	       /------------------\
		    |			  |			   |ConcreteCreator|	       | ConcreteSolution |
	 /----------------\	  /----------------\		   |---------------|	       |------------------|
	 |ConcreteProduct1|	  |ConcreteProductN|		   |	 -//- 	   |	       |       -//- 	  |
	 |----------------|  ...  |----------------|		   \---------------/	       \------------------/
	 | 	-//-	  |	  |	 -//-      |
	 \----------------/	  \----------------/


Product - интерфейс объектов, которые создаются подклассами Creator.
Creator - абстрактный класс, который предоставляет интерфейс для создания объектов подклассов конкретного продукта (Product).
Solution - абстрактный класс, который предоставляет интерфейс для подклассов, принимающих решения, объект какого подкласса продуктов (Product) надо создавать и возвращающий объект подкласса 
	конкретного Creator.


# Преимущества
1) Избавление методов от создания объектов конкретных классов, что решает проблему подмены объекта одного класса на объект другого класса.
2) Упрощение добавления новых классов без изменения написанного кода.
3) Возможность разделения принятия решения о создании объекта и собственно создание объекта в разных местах программы.
4) Возможность принимать решение, объект какого класса необходимо создавать, не во время компиляции, а во время выполнения программы.
5) Возможность во время выполнения программы подменять создание объекта одного класса на объект другого класса.

# Недостатки
1) Увеличивается объем кода.
2) Увеличивается время компиляции.
3) Увеличивается время выполнения программы из-за использования полиморфизма.
4) Увеличивается количество требуемой памяти.
5) Требуется создание параллельных иерархий классов.
6) Необходимость перекомпилировать один и тот же код при добавлении новых типов объектов.
7) Необходимость в передаче ссылки (указателя) на абстрактный создатель (Creator) в методы клиентского кода, где необходимо создавать объекты.

# Связь с другими паттернами
Фабричный метод может быть использован внутри Абстрактной фабрики для создания конкретных объектов. Вместо того, чтобы создавать объекты напрямую, абстрактная фабрика может использовать 
фабричный метод для создания экземпляров объектов определенного типа.


______________________________________________________________________________________
Общая реализации Фабричного метода на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/factory-method/realizacii-na-s++ (Удобнее смотреть)

### Файл Car:

class Car							// Абстрактный базовый класс
{
public:
    virtual ~Car() = default;
    virtual void drive() = 0;
};


class Sedan : public Car					// Наследник Car
{
public:
    Sedan() 
    { 
        cout << "Sedan constructor called" << endl; 
    }
    
    ~Sedan() override 
    { 
        cout << "Sedan destructor called" << endl; 
    }

    void drive() override 
    { 
        cout << "Driving sedan" << endl; 
    }
};

class SUV : public Car 						// Наследник Car
{
public:
    SUV() 
    {
        cout << "Calling the SUV constructor;" << endl;
    }
    
    ~SUV() override 
    { 
        cout << "Calling the SUV destructor;" << endl; 
    }

    void drive() override 
    { 
        cout << "Driving SUV;" << endl; 
    }
};


### Файл Concepts
// Здесь определяются два концепта, который позволяют уточнять, какие требования должны быть выполнены для типов, используемых в шаблонах. 

template <typename Derived, typename Base>
concept Derivative = is_abstract_v<Base> && is_base_of_v<Base, Derived>;  // Этот концепт проверяет, что тип Derived является потомком (унаследованным типом) от Base, где Base должен быть абстрактным классом.

template <typename Type>
concept NotAbstract = !is_abstract_v<Type>;				  // Этот концепт проверяет, что тип Type не является абстрактным классом.


### Файл CarCreator
// Этот код использует концепты для создания иерархии классов и гарантирует, что конкретные реализации фабричного метода соответствуют определённым условиям.

class CarCreator						// Абстрактный базовый класс, который определяет интерфейс для создания объектов типа Car
{
public:
    virtual ~CarCreator() = default;
    virtual unique_ptr<Car> createCar() const = 0;
};


template <Derivative<Car> TCar>				// Проверяет, что тип TCar является производным от Car.
requires NotAbstract<TCar>				// (Условие) Проверяет, что тип TCar не является абстрактным классом.
class ConcreteCarCreator : public CarCreator		// Принимает в качестве шаблонного параметра тип TCar, который должен быть производным от Car и не должен быть абстрактным. Это гарантируется через концепты.
{
public:
    unique_ptr<Car> createCar() const override 		// Создаёт объект типа TCar с помощью функции make_unique и возвращает уникальный указатель на этот объект
    {
        return make_unique<TCar>();
    }
};


### Файл CarCreatorMaker
// CarCreatorMaker реализует фабрику фабрик (Factory of Factories), то есть это метафабрика, которая создает объекты CarCreator, специализирующиеся на создании конкретных типов Car. 

class CarCreatorMaker
{
public:
    template <Derivative<Car> TCar>	// Шаблонный параметр TCar: Тип машины, который должен быть производным от Car и не должен быть абстрактным классом. Это обеспечивается концептами Derivative<Car> и NotAbstract<TCar>.
    NotAbstract<TCar>
    static unique_ptr<CarCreator> createCarCreator() 	// Возвращает указатель на объект CarCreator, который будет использоваться для создания объектов типа TCar.
    {
        return make_unique<ConcreteCarCreator<TCar>>();	// Метод создает и возвращает объект ConcreteCarCreator<TCar>, который знает, как создавать конкретные экземпляры типа TCar.
    }
};


### Файл User
// Представляет собой клиентский код, который использует объекты типа CarCreator для создания и использования объектов типа Car.

class User
{
public:
    void use(const shared_ptr<CarCreator>& creator)	// Метод принимает в качестве аргумента shared_ptr<CarCreator>, который указывает на объект, способный создавать экземпляры Car.
    {
        if (!creator) throw runtime_error("The creator is missing!");	// проверяется, что указатель creator не является nullptr

        shared_ptr<Car> car = creator->createCar();			// вызывает creator->createCar(), чтобы создать объект Car. Использование shared_ptr вместо unique_ptr здесь предполагает, что объект Car может быть использован в других местах программы после вызова метода use.
        car->drive();							// выполняет какое-то действие, связанное с конкретной реализацией автомобиля.
    }
};



#######
Класс Solution выполняет роль посредника между клиентским кодом и классами создателей продуктов. Он отвечает за регистрацию методов создания объектов для каждого типа продукта и предоставляет методы 
для создания объектов по их идентификаторам.


### Файл VehicleSolution
class VehicleSolution								// используется для регистрации и создания объектов CarCreator на основе идентификаторов. 
{
public:
    using CreateCarMaker = unique_ptr<CarCreator>(&)();				// CreateCarMaker - это тип, представляющий собой указатель на функцию, которая возвращает unique_ptr<CarCreator>. Это будет функция-фабрика, создающая объекты CarCreator.
    using CallBackMap = map<size_t, CreateCarCreator>;				// CallBackMap  - это тип, представляющий ассоциативный контейнер (карта), где ключ (size_t) — это идентификатор, а значение — это функция CreateCarCreator, которая создает объект CarCreator.

public:
    VehicleSolution() = default;
    VehicleSolution(initializer_list<pair<size_t, CreateCarCreator>> list);	// Конструктор, принимающий список инициализации (initializer_list), который позволяет инициализировать объект VehicleSolution с заранее определенным набором пар идентификаторов и функций создания.

    bool registrate(size_t id, CreateCarCreator createfun);			// Метод для регистрации новой функции создания объекта CarCreator в карте callbacks с определенным идентификатором id.
    bool check(size_t id) 							// Метод для удаления функции создания по заданному идентификатору id. Возвращает true, если элемент был удален (т.е. если такой идентификатор был в карте).
    { 
        return callbacks.erase(id) == 1; 
    }

    unique_ptr<CarCreator> create(size_t id);					// Метод для создания объекта CarCreator на основе зарегистрированной функции для указанного идентификатора id. Возвращает unique_ptr<CarCreator>.

private:
    CallBackMap callbacks;							// Карта, которая хранит ассоциации между идентификаторами и функциями создания объектов CarCreator.
};


### Файл Methods
// Реализация методов файла VehicleSolution

# pragma region Solution
VehicleSolution::VehicleSolution(initializer_list<pair<size_t, CreateCarCreator>> list) // Конструктор принимает список инициализации пар size_t (идентификатор) и CreateCarCreator (функция, создающая объект CarCreator).
{
    for (auto&& elem : list)								// В цикле проходит по каждой паре в списке и регистрирует ее, вызывая метод registrate.
        this->registrate(elem.first, elem.second);					// Вызываем registrate 
}

bool VehicleSolution::registrate(size_t id, CreateCarCreator createfun)			// Метод регистрирует новую функцию создания объекта CarCreator в карте callbacks с определенным идентификатором id.
{
    return callbacks.insert(CallBackMap::value_type(id, createfun)).second;
}

unique_ptr<CarCreator> VehicleSolution::create(size_t id)				// Метод ищет функцию создания CarCreator по переданному идентификатору id.
{
    CallBackMap::const_iterator it = callbacks.find(id);				// Если такая функция найдена, она вызывается для создания объекта CarCreator, и результат оборачивается в unique_ptr<CarCreator>.

    return it != callbacks.end() ? unique_ptr<CarCreator>(it->second()) : nullptr;
}

shared_ptr<VehicleSolution> make_solution(						// Эта функция служит фабрикой для создания объектов VehicleSolution, инициализируя их списком пар идентификаторов и функций создания.
    initializer_list<pair<size_t, 
    VehicleSolution::CreateCarCreator>> list
)
{
    return shared_ptr<VehicleSolution>(new VehicleSolution(list));
}
# pragma endregion



### Файл main

# include <iostream>
# include <initializer_list>
# include <memory>
# include <map>
# include <exception>

using namespace std;

int main()
{
    try
    {
        shared_ptr<VehicleSolution> solution
        = make_solution({ {1, CarCreatorMaker::createCarCreator<Sedan>} });		// создает экземпляр VehicleSolution. Внутри него регистрируется фабрика, ассоциированная с идентификатором 1, которая будет создавать машины типа Sedan.

        if (!solution->registrate(2, CarCreatorMaker::createCarCreator<SUV>))		// добавляет еще одну фабрику, ассоциированную с идентификатором 2, для создания машин типа SUV.
        {
            throw runtime_error("Error registration!");
        }
        shared_ptr<CarCreator> cr(solution->create(2));					// Создается объект CarCreator на основе идентификатора 2 (для SUV) и передается в метод User::use.

        User{}.use(cr);									// Метод use создает объект Car с помощью переданного CarCreator и вызывает метод drive.
    }
    catch (runtime_error& err)
    {
        cout << err.what() << endl;
    }
}


# Пример вывода:
Driving an SUV.


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/factory-method/concrete-implementation



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Абстрактная фабрика (Abstract factory)

# Проблема
В процессе разработки программы может возникнуть необходимость создания иерархии разных классов, объекты которых должны использоваться совместно. Таким примером может являться система графики, в 
которой происходит взаимодействие множества компонентов: кистей, ручек, форм, канвасов.

Фабричный метод не поддерживает связь между иерархиями классов. Например, нет возможности подменить одну графическую систему на другую. В таком случае возможным решением является объединение методов 
создания иерархий объектов разных классов в один класс.

# Назначение
Абстрактная фабрика(Abstract factory) — порождающий паттерн проектирования, определяющий единый интерфейс создания иерархий классов и позволяющий менять одно семейство связанных объектов на другое.
Семейством связанных объектов могут быть, например, объекты конкретной графической подсистемы (brush, pen, marker, canvas).

# Решаемые задачи
1) Возможность создавать и подменять одно семейство объектов на другое
Появляется возможность создавать семейства связанных объектов. При необходимости можно легко заменять или добавлять новые семейства объектов, не изменяя другие части кода, которые используют 
эти объекты.

2) Отделение принятия решения о том, какое семейство объектов нужно создать, от самого процесса создания объектов семейства
Решение о выборе конкретного семейства принимается в части кода, который использует абстрактную фабрику. Во время выполнения этот код определяет, какое семейство связанных объектов требуется 
создать, и создает соответствующую фабрику. В коде через абстрактную фабрику вызываются методы создания объектов конкретных иерархий классов.

3) Повторное использование объектов
Появляется возможность повторного использования уже созданных семейств объектов.

# UML диаграмма паттерна "Абстрактная фабрика"

			/-----------\				 /------------------\				 /-----------\
			|  BasePen  |				 |  AbstractFactory |		  		 | BaseBrush |
			|-----------| <------------------------  |------------------|  ------------------------> |-----------|
			|    ...    |				 |   +createPen()   |				 |    ...    |
			\-----------/				 |  +createBrush()  |				 \-----------/
								 \------------------/		
			      /\					  /\					       /\
			      ||					  ||					       ||
			      ||					  ||					       ||
			      ||					  ||					       ||
		      /---------------\				 /------------------\   		      	  /----------\   
		      |	    QtPen     |	 			 | QtGraphicFactory |  			      	  |  QtBrush |
	 	      |---------------|	       			 |------------------|			      	  |----------|
		      |	    -//-      |	       			 |	 -//-       |			      	  |   -//-   |
                      \---------------/	     			 \------------------/			      	  \----------/


# Преимущества
1) Избавление методов от привязки к конкретным классам, что решает проблему подмены объекта одного семейства класса на объект другого семейства классов.
2) Упрощение добавления новых семейств объектов без изменения написанного кода.
3) Возможность принимать решение, объект какого семейства создавать, и создавать объекты в разных местах программы.
4) Возможность принимать решение, объект какого семейства необходимо создавать, не во время компиляции, а во время выполнения программы.
5) Возможность во время выполнения программы подменять создание объекта одного семейства класса на объект другого класса.

# Недостатки
1) Увеличивается объем кода.
2) Увеличивается время компиляции.
3) Увеличивается время выполнения программы из-за использования полиморфизма.
4) Увеличивается количество требуемой памяти.
5) Требуется создание параллельных иерархий классов.
6) Необходимость перекомпилировать один и тот же код при добавлении новых типов объектов.
7) Семейства объектов должны быть однородны по своей структуре, иначе выделить базовую абстракцию в абстрактной фабрике будет невозможно.
8) Возможность наличия неполных семейств объектов.

# Связь с другими паттернами
1) Абстрактная фабрика может использовать Фабричный метод для создания конкретных объектов. Вместо того, чтобы иметь только один метод для создания объектов, абстрактная фабрика может использовать 
фабричный метод в своей реализации.
2) Абстрактная фабрика может быть комбинирована с паттерном Строитель для создания сложных объектов.



______________________________________________________________________________________
Общая реализация на языке С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/abstract-factory/realizacii-na-s++

### Файл BaseGraphics:

class BaseGraphics 						// Базовый абстрактный класс графики
{
public:
    virtual ~BaseGraphics() = 0;
};

BaseGraphics::~BaseGraphics() {}


class QtGraphics : public BaseGraphics				// Наследуемый класс
{
public:
	QtGraphics(shared_ptr<Image> im) 
	{
		cout << "Calling the QtGraphics constructor;" << endl; 
	}
	
	~QtGraphics() override 
	{ 
		cout << "Calling the QtGraphics destructor;" << endl; 
	}
};


### Файл AbstractGraphFactory:

class AbstractGraphFactory 					// это абстрактный класс, который объявляет методы для создания различных графических объектов: Graphics, Pen и Brush.
{			
public:
	virtual ~AbstractGraphFactory() = default;

	virtual unique_ptr<BaseGraphics> createGraphics(shared_ptr<Image> im) = 0; // Каждый метод возвращает указатель (unique_ptr) на базовый класс (BaseGraphics, BasePen, BaseBrush), что позволяет скрыть детали конкретных реализаций.
	virtual unique_ptr<BasePen> createPen(shared_ptr<Color> cl) = 0;
	virtual unique_ptr<BaseBrush> createBrush(shared_ptr<Color> cl) = 0;
};


class QtGraphFactory : public AbstractGraphFactory	// QtGraphFactory — это конкретная реализация абстрактной фабрики. Она создает объекты, специфичные для Qt.
{
public:
	unique_ptr<BaseGraphics> createGraphics(shared_ptr<Image> im) override	// Метод createGraphics создает и возвращает объект типа QtGraphics, используя переданный объект Image.
	{
		return make_unique<QtGraphics>(im);
	}

	unique_ptr<BasePen> createPen(shared_ptr<Color> cl) override
	{
		return make_unique<QtPen>();
	}

	unique_ptr<BaseBrush> createBrush(shared_ptr<Color> cl) override
	{
		return make_unique<QtBrush>();
	}
};


Абстрактная фабрика позволяет создать целое семейство связанных или зависимых объектов (в данном случае, объекты Graphics, Pen, и Brush) без необходимости привязываться к конкретным классам этих 
объектов. Клиентский код (тот, который будет использовать эту фабрику) будет работать с объектами через их базовые интерфейсы, не зная о том, какие именно конкретные классы используются. Это позволяет 
легко заменить, например, QtGraphFactory на другую фабрику (например, GDIPlusGraphFactory), которая будет создавать объекты для другой графической системы, без изменений в клиентском коде.


### Файл User
class User 			// класс User взаимодействует с объектами, создаваемыми с помощью фабрики AbstractGraphFactory
{
public:
	void use(shared_ptr<AbstractGraphFactory>& cr) // Метод use принимает объект cr, который является shared_ptr на объект типа AbstractGraphFactory. Этот объект AbstractGraphFactory может быть любой конкретной фабрикой, которая наследует AbstractGraphFactory, например, QtGraphFactory.
	{
		shared_ptr<Image> image = make_shared<Image>(); // Внутри метода use создается объект Image с помощью make_shared<Image>. Это изображение будет использоваться при создании объекта Graphics.
		auto graphics = cr->createGraphics(image); // Вызов cr->createGraphics(image) использует фабрику, чтобы создать объект графики (Graphics) на основе переданного изображения. Конкретный тип объекта Graphics зависит от того, какая конкретная фабрика передана в use (например, если это QtGraphFactory, то будет создан объект QtGraphics).
	}
};

Как это связано с Абстрактной фабрикой:
Абстракция: Пользователь (User) не знает и не интересуется, какой конкретный тип объекта Graphics будет создан. Он просто использует метод createGraphics фабрики.
Гибкость: В зависимости от того, какая фабрика была передана в use, могут создаваться разные объекты Graphics. Например, это может быть объект QtGraphics или объект, относящийся к другой графической 
системе.
Расширяемость: Если в будущем понадобится поддержка другой графической системы, вам нужно будет лишь создать новую фабрику (например, DirectXGraphFactory) и передать ее в use, не изменяя сам метод use.


### Файл Pen:
class BasePen {}; // это базовый класс, который может служить общим интерфейсом или основой для различных типов "ручек" (инструментов рисования линий, контуров и т.д.).

class QtPen : public BasePen {}; // конкретный тип "ручки". 

Когда вы создаете такие классы в контексте паттерна Абстрактная фабрика, вы позволяете фабрике создавать объекты определенных типов, не завися от их конкретной реализации.


### Файл Brush:
class BaseBrush {};

class QtBrush : public BaseBrush {};


### Файл Image:
class Image {};


### Файл Color:
class Color {};


### Файл Main:
# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<AbstractGraphFactory> grfactory = make_shared<QtGraphFactory>(); 	// Создаем фабрику для Qt. Этот код создает объект QtGraphFactory, который является конкретной реализацией абстрактной фабрики AbstractGraphFactory. Указатель grfactory типа shared_ptr<AbstractGraphFactory> позволяет работать с фабрикой через абстрактный интерфейс, но на самом деле это конкретная фабрика QtGraphFactory.

	unique_ptr<User> us = make_unique<User>();					// Создаем пользователя. Создается объект User, который будет использовать графическую фабрику для создания и работы с графическими объектами.

	us->use(grfactory);								// Пользователь использует фабрику для создания и использования графических объектов. Внутри метода use User будет использовать фабрику для создания графических объектов, например, Graphics, Pen, Brush (зависит от того, как именно определен метод use).
}


# Что происходит на высоком уровне:
1) Инкапсуляция создания объектов: User не знает о том, какой конкретный тип графической системы используется (в данном случае это Qt), он просто получает фабрику через абстрактный интерфейс и 
использует ее для создания нужных объектов.
2) Гибкость и расширяемость: Если в будущем нужно будет поддерживать другую графическую систему (например, DirectX), можно создать новый класс фабрики (например, DirectXGraphFactory), который наследует 
AbstractGraphFactory. Весь остальной код останется неизменным — нужно будет только передать новую фабрику в метод use.


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++

https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/abstract-factory/vozmozhnye-realizacii-dlya-resheniya-konkretnykh-zadach-na-s++



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Прототип (Prototype)

# Проблемы
Представим, что вам потребовалось создать каркасную модель сферы из полигонов. Обычно таких полигонов очень много и при их создании необходимо вычислять координаты. Кроме того, в методы для создания 
объектов требуется передавать объект класса Creator (зачем он нужен? см. Фабричный метод). В данном случае более простым способом создания объекта может быть его копирование из существующего.

В итоге:
Необходимость передачи объекта класса Creator в методы для создания объектов
Необходимость большого количества информации и времени для создания нового объекта


# Назначение
Прототип (Prototype) — это порождающий паттерн проектирования, который поручает создание копий объектов самим копируемым объектам. Для этого в базовый класс добавляется метод для копирования, который 
создает новый объект на основе существующего. Паттерн вводит общий интерфейс для всех объектов, поддерживающих копирование. Это позволяет копировать объекты, не привязываясь к их классам.


# Решаемые задачи
1) Копирование объектов
Дает возможность создавать копии объектов на основе других объектов.

2) Создание сложных объектов
Паттерн прототип предоставляет альтернативу созданию подклассов для конструирования сложных объектов. Вместо того, чтобы создавать множество подклассов для каждой вариации объекта, можно использовать 
прототипы и копирование, чтобы создавать новые объекты с нужными параметрами и состоянием.


# UML диаграмма паттерна "Прототип"

	/--------------\			/-----------\
	|    Client    |			| Prototype |
	|--------------| ---------------------->|-----------|
	| +operation() |			|  +clone() |
	\--------------/			\-----------/
						      /\
						      ||
						      ||
			         /--------------------/\--------------------\
				 |					    |
				 |					    |
			/--------------------\			  /--------------------\
			| ConcretePrototype1 |			  | ConcretePrototypeN |
			|--------------------|        ...	  |--------------------| 
			|      +clone()	     |			  |      +clone()      |
			\--------------------/			  \--------------------/


# Преимущества
1) Возможность создавать новые объекты, используя уже существующие объекты в качестве прототипов.
2) Увеличение скорости создания сложных объектов.
3) Нет необходимости в передаче объекта класса Creator в методы для создания объектов.


# Недостатки
1) Необходимо убедиться в добавлении метода копирования в каждый класс, объект которого может быть скопирован.
2) Копируется внутреннее состояние объекта, в том числе значения приватных полей.
		

# Связь с другими паттернами
Паттерн Строитель может использовать прототипы для создания копий подобъектов.


______________________________________________________________________________________
Общая реализация на языке С++

### Файл Car:

class Car									// Абстрактный базовый класс машин
{
public:
	virtual ~Car() = default;
	virtual unique_ptr<Car> clone() = 0;					// Метод предназначен для создания копии объекта, используя паттерн Прототип.
};


class Sedan : public Car							// Класс седан
{
public:
	Sedan() 
	{ 
		cout << "Calling the default constructor;" << endl; 
	}
	
	Sedan(const Sedan& car) 						// Конструктор копирования. Этот конструктор вызывается, когда объект Sedan копируется.
	{ 
		cout << "Calling the Copy constructor;" << endl; 
	}
	
	~Sedan() override 
	{ 
		cout << "Calling the destructor;" << endl; 
	}

	unique_ptr<Car> clone() override					// Метод clone() реализует паттерн Прототип, позволяя создавать копию объекта Sedan. 
	{									// Внутри метода создается новая копия текущего объекта Sedan, вызывая конструктор копирования, и возвращается unique_ptr на этот новый объект.
		return make_unique<Sedan>(*this);
	}
};


Паттерн Прототип позволяет создавать объекты путем копирования существующего экземпляра (прототипа), вместо создания нового с нуля. 


### Файл User:
class User
{
public:
	void use(shared_ptr<Car> &car) // Метод use принимает объект car по ссылке типа shared_ptr<Car>. Это означает, что car является указателем с подсчетом ссылок на объект типа Car (или его наследника). Копирование shared_ptr увеличивает счетчик ссылок, что гарантирует, что объект не будет уничтожен, пока существует хотя бы один указатель на него.
	{
		auto newCar = car->clone(); 	// Метод clone() вызывается для объекта car. Этот метод реализован в конкретных классах, наследующих Car, и возвращает копию объекта, заключенную в unique_ptr<Car>.
	}					// Результатом вызова car->clone() является новый объект, который хранится в newCar. Поскольку clone() возвращает unique_ptr, newCar будет уникальным указателем на новый объект.
};


User использует метод clone() для создания новой копии автомобиля, что может быть полезно, если User хочет работать с копией, не изменяя исходный объект car. 


### Файл Main:
# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<Car> sedan = make_shared<Sedan>(); // Создаем объект Sedan
	User{}.use(sedan); // Создается временный объект User, который сразу же вызывает метод use. Внутри метода use, переданный объект sedan (типа shared_ptr<Car>) используется для создания его клона. Вызов car->clone() приводит к вызову метода clone() у объекта sedan, который вызывает конструктор копирования для создания нового объекта Sedan. 
}				// Новый объект Sedan, созданный методом clone, временно хранится в unique_ptr<Car> newCar, который будет автоматически уничтожен, когда метод use завершится. После завершения метода use временный объект User будет уничтожен.


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/prototype/vozmozhnye-realizacii-dlya-resheniya-konkretnykh-zadach-na-s++




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Строитель (Builder)

# Проблема
Требуется создавать в одном месте сложный объект, состоящий из множества подобъектов.

Примером сложного объекта может служить объект почтового сообщения Email. У этого объекта может быть множество параметров, таких как отправитель, получатель, тема, текст, вложения. Используя паттерн 
Строитель, можно поэтапно создать объект почтового сообщения с различными параметрами.

# Назначение
Строитель (Builder) — это порождающий паттерн проектирования, который позволяет создавать сложные объекты, разбив процесс конструирования сложного объекта на отдельные шаги.

# Решаемые задачи
1) Поэтапное создание сложного объекта
Появляется возможность создавать сложные объекты пошагово. Каждый шаг строителя определяет значения и настройки для соответствующей части объекта.
2) Отделение процесса контроля за созданием объекта от самого процесса создания объекта.
Одна сущность (строитель) определяет шаги конструирования объекта, в то время как другая сущность (директор) управляет последовательностью этих шагов, обеспечивая создание объекта с нужной 
конфигурацией.

# UML диаграмма паттерна "Строитель"

		/-----------\			   /---------------\
		| Director  | 			   |    Builder    |
		|-----------| /\-----------------> |---------------|
		| +create() | \/		   | +buildPart1() |
		\-----------/ 			   |      ...      |
		      /\			   | +buildPartN() |
		      ||			   \---------------/
		      ||				   /\
		      ||				   ||
	     /------------------\			   ||
	     | ConcreteDirector |			   ||
	     |------------------|		  /------------------\
	     |       -//-       |		  | ConcreteBuilder  |
	     \------------------/		  |------------------|
						  |       -//-       |
						  \------------------/


# Преимущества
1) Упрощение процесса создания сложных объектов.
2) Разделение процесса создания объекта и контроля за созданием объекта.

# Недостатки
1) Усложнение кода из-за введения дополнительных иерархий классов.
2) Избыточность кода для создания простых объектов/

# Связь с другими паттернами
Паттерн Строитель может использоваться вместе с Фабричным методом для создания сложных объектов. "Фабричный метод" определяет интерфейс для создания взаимосвязанных объектов, а "Строитель" отвечает за 
создание отдельных частей сложного объекта.



______________________________________________________________________________________
Общая реализация на языке С++


### Файл Car:

class Car									// Абстрактный класс Car
{
public:
	virtual ~Car() = default;
	virtual void drive() = 0;
};


class Sedan : public Car							// Наследуемый класс 
{
public:
	Sedan() 
	{ 
		cout << "Calling the Sedan constructor;" << endl; 
	}
	
	~Sedan() override 
	{ 
		cout << "Calling the Sedan destructor;" << endl; 
	}

	void drive() override 
	{ 
		cout << "Calling the drive method;" << endl; 
	}
};


### Файл CarBuilder:

class CarBuilder							// CarBuilder — это абстрактный класс, который определяет интерфейс для построения автомобиля (Car).
{
public:
	virtual ~CarBuilder() = default;

	virtual bool buildEngine() = 0;					// Он включает в себя методы для поэтапного создания машины (buildEngine, buildChassis)
	virtual bool buildChassis() = 0;

	shared_ptr<Car> getCar();					// И метод для получения готового объекта (getCar).

protected:
	virtual shared_ptr<Car> create() = 0;				// Предназначен для создания нового объекта Car. Он также является абстрактным и должен быть реализован в классах-наследниках.

	shared_ptr<Car> car{ nullptr };
	size_t part{ 0 };
};


class SedanBuilder : public CarBuilder					// реализует методы для поэтапного создания седана.
{
public:
	bool buildEngine() override					// проверяет текущий этап сборки (part) и, если это первый этап, строит двигатель для седана, увеличивая счетчик part.
	{
		if (!part)
			++part;

		if (part != 1) return false;
		
		cout << "Building part 1: Engine for Sedan;" << endl;
		return true;
	}
	
	bool buildChassis() override					// выполняет аналогичную функцию, но для второго этапа сборки, строя шасси для седана.
	{
		if (part == 1)
			++part;

		if (part != 2) return false;

		cout << "Building part 2: Chassis for Sedan;" << endl;
	}

protected:
	shared_ptr<Car> create() override;
};



### Файл Methods:

shared_ptr<Car> CarBuilder::getCar()					// Эти два метода отвечают за создание и возврат объекта автомобиля, если все необходимые этапы строительства завершены.
{
	if (!car) { car = create(); }

	return car;
}

shared_ptr<Car> SedanBuilder::create()
{
	if (part == 2) { car = make_shared<Sedan>(); }

	return car;
}


### Файл CarCreator:		

class CarCreator							// Абстрактным классом, который определяет интерфейс для создания объектов типа Car.
{									// CarCreator служит базой для всех классов, которые хотят создать объекты Car, предоставляя единый интерфейс для создания автомобилей.
public:
	virtual ~CarCreator() = default;
	virtual shared_ptr<Car> create() = 0;
};


class CarDirector : public CarCreator					// CarDirector наследует CarCreator и реализует метод create(), который отвечает за создание объекта Car.
{
public:
	CarDirector(shared_ptr<CarBuilder> builder) : br(builder) {} 	// В конструкторе CarDirector принимает shared_ptr<CarBuilder> в качестве параметра и сохраняет его в приватном поле br. Этот объект строителя (CarBuilder) отвечает за поэтапное создание автомобиля.

	shared_ptr<Car> create() override				// Метод create() в CarDirector использует объект строителя для поэтапного создания автомобиля:
	{
		if (br->buildEngine() && br->buildChassis()) return br->getCar();	// Сначала вызывается метод buildEngine() строителя.
											// Затем вызывается метод buildChassis() строителя. Если оба этапа строительства выполнены успешно, метод getCar() возвращает готовый объект Car.
		return nullptr;								// Если на каком-то этапе строительство не удалось, метод возвращает nullptr.
	}

private:
	shared_ptr<CarBuilder> br;
};


Этот код объединяет два паттерна: Строитель (Builder) и Фабричный метод (Factory Method). В результате мы получаем гибкую и модульную структуру для создания объектов типа Car через поэтапное 
строительство.


### Файл User:

class User
{
public:
	void use(shared_ptr<CarCreator>& creator)
	{
		shared_ptr<Car> car = creator->create();		// Использует фабрику для создания автомобиля

		if (car)						// Проверка, успешно ли создан автомобиль
			car->drive();					// Если автомобиль создан, вызывается метод drive()
	}
};

Класс User, представленный в вашем коде, показывает, как объект пользовательского класса может взаимодействовать с фабрикой для создания объектов Car и затем использовать их. 


### Файл Main:

# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<CarBuilder> builder = make_shared<SedanBuilder>(); 		// создается объект SedanBuilder, который является конкретной реализацией абстрактного класса CarBuilder. SedanBuilder отвечает за поэтапное создание автомобиля типа Sedan.
	shared_ptr<CarCreator> creator = make_shared<CarDirector>(builder);	// CarDirector является конкретной реализацией абстрактного класса CarCreator. В конструктор CarDirector передается builder, который будет использоваться для создания автомобиля.
										// CarDirector управляет процессом создания автомобиля, используя методы строителя (buildEngine() и buildChassis()), а затем возвращает готовый объект Car.
	User{}.use(creator);							// Создается временный объект класса User, который сразу же вызывает метод use() с переданным объектом CarCreator.
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Одиночка (Singleton)

# Проблема
Необходимость в создании одного экземпляра конкретного объекта.

Примером такого объекта может являться объект базы данных. Такие объекты нельзя клонировать или копировать, объект должен быть один во всей системе. Это необходимо для того, чтобы избежать проблем с 
целостностью и согласованностью данных.


# Назначение
Одиночка (Singleton) – это порождающий паттерн проектирования, который гарантирует, что будет создан только один экземпляр класса, и предоставляет к нему глобальную точку доступа.


# Решаемые задачи
1) Контроль за объектом.
Паттерн гарантирует, что у класса есть только один экземпляр


# Преимущества
1) Гарантия наличия единственного экземпляра объекта.
2) Предоставление глобальной точки доступа к объекту.
3) Оптимизация использования ресурсов.

# Недостатки
1) Создает проблемы с модификацией, расширением и управлением объектом.
2) Решение о том, какой объект создавать, не может приниматься при выполнении программы.
3) Создается глобальный объект и теряется контроль над его жизненным циклом.



______________________________________________________________________________________
Общая реализация на языке С++

### Файл Sun:
// Конструктор помечается модификатором private, чтобы объект класса нельзя было создать извне

class Sun
{
public:
	static shared_ptr<Sun> instance()
	{
		class SunProxy : public Sun {};					// SunProxy: Это вложенный класс-прокси, который наследуется от Sun. Этот подход используется для создания объекта Sun через закрытый конструктор.

		static shared_ptr<Sun> myInstance = make_shared<SunProxy>();	// Создается один статический экземпляр SunProxy через make_shared. Так как myInstance статический, он создается один раз и будет доступен при каждом вызове instance().

		return myInstance;						// возвращает shared_ptr, обеспечивая глобальную точку доступа к единственному экземпляру Sun.
	}
	
	~Sun() 
	{ 
		cout << "Calling the destructor;" << endl; 
	}

	void shine() 
	{ 
		cout << "The sun is shining;" << endl; 
	}

	Sun(const Sun&) = delete;					// Удаленные конструктор копирования и оператор присваивания:
	Sun& operator =(const Sun&) = delete;				// Эти операторы удалены, чтобы предотвратить копирование и присваивание объектов Sun. Singleton должен существовать в единственном экземпляре, и запрет на копирование помогает это обеспечить.

private:
	Sun() 								// Закрытый конструктор: делает невозможным создание объектов Sun извне класса. Это характерная черта паттерна Singleton, которая 
	{ 								// 	гарантирует, что экземпляр класса может быть создан только через статический метод instance().
		cout << "Calling the default constructor;" << endl; 
	}
};



### Файл Main:

# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<Sun> sun(Sun::instance());

	sun->shine();
}


Sun::instance() возвращает shared_ptr<Sun> на единственный экземпляр Sun. Поскольку instance() метод возвращает shared_ptr<Sun>, создаётся новый shared_ptr<Sun>, который управляет тем же объектом Sun.
Важно отметить, что, так как возвращаемое значение из instance() уже является shared_ptr<Sun>, использование конструкции shared_ptr<Sun> sun(Sun::instance()); избыточно. Более правильно использовать 
присваивание: shared_ptr<Sun> sun = Sun::instance(); (Подсказка от ChatGPT)


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/singleton/vozmozhnye-realizacii-dlya-resheniya-konkretnykh-zadach-na-s++




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Пул объектов (Object pool)

# Проблема
1) Требуется ограниченное количество объектов одного класса.
2) Переиспользование сложных объектов

Представь, что у тебя есть домашний Wi-Fi роутер. Вместо того чтобы каждый раз, когда устройство в доме нуждается в подключении к Интернету, создавать новое подключение к провайдеру интернета и 
разрывать его после использования, ты можешь использовать пул подключений.


# Назначение
Пул объектов (Object pool) – это порождающий паттерн проектирования, который предоставляет ограниченный набор инициализированных, по мере необходимости, и готовых для использования объектов. 
Используется для повышения производительности и управления ресурсами путем повторного использования предварительно созданных объектов вместо создания новых. Это полезно в случаях, когда создание 
объектов требует значительных ресурсов, таких как соединения с базой данных.


# Решаемые задачи
1) Централизованное управление доступом.
Обеспечивает централизованное управление доступом к объектам пула

2) Контроль и ограничение доступа.
Позволяет контролировать и ограничивать количество одновременно используемых объектов.

3) Повышение производительности.
Повторное использование объектов позволяет избежать увеличение затрачиваемых ресурсов на создание и уничтожение объектов.

4) Управление жизненным циклом объектов.
Упрощает управление жизненным циклом объектов, так как клиенту не нужно явно создавать и уничтожать объекты, а просто получать и возвращать их в пул.

# Преимущества
1) Повышается производительность за счет минимизации создания и уничтожения множества объектов.
2) Возможность ограничивать и контролировать число используемых объектов.
3) Возможность переиспользовать объект.


# Недостатки
1) Функция очистки, создания, удаления объекта. Возможность утечки информации. Если объект не очищается или его состояние не сбрасывается перед возвращением в пул, может возникнуть утечка информации. 
Например, если объект содержит конфиденциальные данные или ссылки на другие объекты, эта информация может остаться в объекте после его возврата в пул.
2) Увеличение объема кода. Внедрение паттерна требует создания дополнительной логики для управления пулом объектов, обработки доступа к объектам, контроля их состояния.
3) Усложнение архитектуры приложения.
4) В некоторых ситуациях сложная логика управления пулом.



______________________________________________________________________________________
Общая реализация на языке С++

### Файл EmployeePoolObject:

template <typename T>
concept EmployeePoolObject = requires(T t) 		// Концепция EmployeePoolObject задает контракт (или набор требований), которому должен соответствовать тип T для того, чтобы считаться допустимым для этого концепта.
{
	t.clockIn();					// Требование t.clockIn() внутри requires(T t) означает, что для любого типа T, который будет использоваться с этой концепцией, должен быть определен метод clockIn(), который может быть вызван у объекта типа T.
};



### Файл Employee:

class Employee						// Класс, который отслеживает количество созданных и уничтоженных объектов. 
{
private:
	static size_t count;

public:
	Employee() 
	{ 
		cout << "Constructor(" << ++count << ");" << endl; 
	}
	
	~Employee() 
	{ 
		cout << "Destructor(" << count-- << ");" << endl; 
	}

	void clockIn() 					// Выводит сообщение о том, что сотрудник "отметился" (clocked in), и отображает адрес текущего объекта (this) в памяти.
	{ 
		cout << "Employee clocked in: 0x" << this << endl; 
	}
};

size_t Employee::count = 0;				// хранит количество созданных объектов Employee



### Файл EmployeePool:

template <EmployeePoolObject Type>							// Шаблонный класс для управления пулом сотрудников.
class EmployeePool						
{
public:
	static shared_ptr<EmployeePool<Type>> instance();				// Статический метод возвращает shared_ptr на единственный экземпляр EmployeePool. Это обеспечивает реализацию паттерна Singleton для пула сотрудников.

	shared_ptr<Type> hireEmployee();						// Этот метод предназначен для "нанятия" нового сотрудника, т.е., добавления нового сотрудника в пул и возвращения умного указателя на этот сотрудник.
	bool fireEmployee(shared_ptr<Type>& employee);					// Этот метод предназначен для "увольнения" сотрудника из пула. Он принимает умный указатель на сотрудника и удаляет его из пула.
	size_t count() const { return pool.size(); }					// count(): Возвращает количество сотрудников в пуле.
		
	EmployeePool(const EmployeePool&) = delete;					// Удаленные конструктор копирования и оператор присваивания: Запрещает копирование и присваивание экземпляра EmployeePool, что также является частью паттерна Singleton.
	EmployeePool& operator =(const EmployeePool&) = delete;				

private:
	vector<pair<bool, shared_ptr<Type>>> pool;					// Хранит информацию о сотрудниках. vector содержит пары, где первый элемент bool может указывать на состояние (например, занято/свободно), а второй элемент — умный указатель на сотрудника.

	EmployeePool() {}								// Закрытый конструктор для предотвращения создания экземпляров EmployeePool извне. Это свойственно паттерну Singleton.

	pair<bool, shared_ptr<Type>> createEmployee();					// Создает нового сотрудника и возвращает его в виде пары с состоянием.

	template <typename Type>							// operator <<: Дружественная функция, которая позволяет выводить содержимое пула сотрудников в поток вывода (например, в cout).
	friend ostream& operator << (ostream& os, const EmployeePool<Type>& pl);
};


### Файл instance():

template <EmployeePoolObject Type>							// реализует паттерн Singleton с использованием shared_ptr. 
shared_ptr<EmployeePool<Type>> EmployeePool<Type>::instance()
{
	static shared_ptr<EmployeePool<Type>> myInstance(new EmployeePool<Type>());	// Создается новый объект EmployeePool<Type>, и shared_ptr на этот объект присваивается переменной myInstance. Это гарантирует, что myInstance будет управлять единственным экземпляром EmployeePool<Type>, создавая его при первом вызове instance().

	return myInstance;
}


### Файл hireEmployee():

template <EmployeePoolObject Type>				// отвечает за предоставление доступного сотрудника из пула или создание нового сотрудника, если все существующие сотрудники заняты. 
shared_ptr<Type> EmployeePool<Type>::hireEmployee()
{
	size_t i;
	for (i = 0; i < pool.size() && pool[i].first; ++i);	// Цикл for проходит по всем элементам в pool до тех пор, пока не найдет свободного сотрудника

	if (i < pool.size())
	{
		pool[i].first = true;				// Если в пуле есть свободное место (т.е., i < pool.size()), то сотрудник становится доступным
	}
	else
	{
		pool.push_back(createEmployee());		// Если все сотрудники заняты (т.е., i >= pool.size()), создается новый сотрудник с помощью метода createEmployee() и добавляется в пул.
	}

	return pool[i].second;					// Возвращается умный указатель на сотрудника, который был найден или только что создан. 
}


### Файл fireEmployee():

template <EmployeePoolObject Type>				// Метод fireEmployee в классе EmployeePool предназначен для "увольнения" сотрудника из пула. Этот метод помечает сотрудника как освобожденного и выполняет определенные действия, связанные с его увольнением.
bool EmployeePool<Type>::fireEmployee(shared_ptr<Type>& employee)
{
	size_t i;
	for (i = 0; pool[i].second != employee && i < pool.size(); ++i); 	// Цикл for используется для поиска сотрудника в пуле.

	if (i == pool.size()) return false;					// Если после завершения цикла переменная i равна pool.size(), это означает, что сотрудник не был найден в пуле. В таком случае метод возвращает false.

	employee.reset();							// "Увольнение" сотрудника: Сбрасывает умный указатель employee, что освобождает его и обнуляет.
	pool[i].first = false;							// Помечает сотрудника как освобожденного, установив соответствующий флаг bool в false.
	pool[i].second->clockIn();						// Вызывает метод clockIn() у сотрудника, возможно для выполнения каких-то действий, связанных с "увольнением" или освобождением.

	return true;
}


### Файл createEmployee():

template <EmployeePoolObject Type>						// Метод createEmployee для класса EmployeePool предназначен для создания нового сотрудника и возвращения его вместе с флагом, указывающим на его доступность.
pair<bool, shared_ptr<Type>> EmployeePool<Type>::createEmployee()
{
	return { true, make_shared<Type>() };					// Создает новый объект типа Type (где Type должен быть классом, удовлетворяющим концепции EmployeePoolObject) и возвращает умный указатель shared_ptr<Type> на этот объект.
}


### Файл operator <<:

template <typename Type>							// Шаблонный оператор вывода operator<< для класса EmployeePool предназначен для вывода состояния пула сотрудников на поток, например, на консоль.
ostream& operator << (ostream& os, const EmployeePool<Type>& pl)
{
	for (auto elem : pl.pool)						// Цикл for используется для перебора всех элементов в pl.pool. 
		os << "{" << elem.first << ", 0x" << elem.second << "} ";	// elem.first: Выводит булевый флаг, показывающий состояние сотрудника (доступен или занят). elem.second: Выводит адрес объекта в памяти в шестнадцатеричном формате. 

	return os;
}


### Файл Main:

# include <iostream>
# include <memory>
# include <iterator>
# include <vector>

using namespace std;

int main()
{
	shared_ptr<EmployeePool<Employee>> pool = EmployeePool<Employee>::instance();	// Получаем экземпляр пула сотрудников

	vector<shared_ptr<Employee>> vec(4);						// Создаем вектор из 4 умных указателей на сотрудников

	for (auto& elem : vec)								// Заполняем вектор сотрудниками из пула
		elem = pool->hireEmployee();

	pool->fireEmployee(vec[1]);							// Увольняем второго сотрудника из вектора

	cout << *pool << endl;								// Выводим текущее состояние пула сотрудников

	shared_ptr<Employee> ptr = pool->hireEmployee();				// Нанимаем нового сотрудника и заменяем свободное место во векторе
	vec[1] = pool->hireEmployee();

	cout << *pool << endl;								// Выводим текущее состояние пула сотрудников после изменений
}





______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Структурные паттерны






Управление ресурсами. Идиома RAII

Объекты классов могут на протяжении всего своего существования использовать различные ресурсы - динамически выделенная память, файлы, сетевые подключения и т.д. В этом случае в 
C++ применяется так называемый принцип/идиома RAII (resource acquisition is initialization). RAII предполагает, что получение ресурса производится при инициализации объекта. А
освобождение ресурса производится в деструкторе объекта. Например, получение динамической памяти происходит в конструкторе объекта, а освобождение в деструкторе. При этом важно, 
чтобы ресурс (в данном случае динамическая память) освобождался только один раз. Для этой цели в классе удалены конструктор копирования и оператор присваивания, что позволяет 
избежать ситуации, когда два объекта хранят указатель на одну и ту же область динамической памяти и соответственно потом в деструкторе будут пытаться освободить эту память.



______________________________________________________________________________________
Идиома копирования и замены

Когда нужно изменить состояние одного или нескольких объектов, и на любом этапе модификации может возникнуть ошибка, для создания кода, устойчиваого к ошибкам, может применяться
идиома копирования и замены (copy-and-swap idiom). Суть данной идиомы состоит в следующей последовательности действий:

1. Создаем копию объекта(ов)

2. Изменяем копию. При этом оригинальные объекты остаются нетронутыми

3. Если все изменения прошли успешно, заменяем оригинальный объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то оригинальный объект 
не заменяется.

Обычно эта идиома применяется в функциях и частным, хотя и распространенным, случаем ее применения является оператор присваивания. В общем случаем это выглядит так:

// оператор присвоения некоторого класса Copyable
Copyable& operator=(const Copyable& obj) {
    Copyable copy{obj}; 				// создаем копию через конструктор копирования
    swap(copy);         				// обмениваем значения копии и оригинального объекта
    return *this;
}
// некоторая функция для обмена значениями
void swap(Copyable& copy) noexcept;

В функции оператора присваивания сначала создается временная копия присваиваемого объекта. И в случае успешного создания копиии текущий объект (this) и копия обмениваются 
содержимым через некоторую функцию swap().

Функция swap может быть реализована как внешняя функция или как функция-член класса (в примере выше предполагается, что она реализована внутри класса). При этом функция swap 
определяется как не генерирующая исключения (с ключевым словом noexcept). Поэтому единственной точкой, где может возникнуть исключение, функция копирования (конструктор 
копирования) объекта. Если копирование не удается, то управление не доходит до выполнения функции swap.

Устойчивость к исключениям заключается в том, что в операторе присваивания нет точки, где генерация исключения могла бы привести к утечке памяти. Приведённая выше реализация 
также устойчива к присваиваниям объекта самому себе (a=a), однако содержит издержки, связанные с тем, что временная копия в этом случае тоже будет создаваться. Исключить 
издержки можно дополнительной проверкой:

// оператор присвоения некоторого класса Copyable
Copyable& operator=(const Copyable& obj) {
    Copyable copy{obj};     				// создаем копию через конструктор копирования
    if(this != &obj)        				// если не текущий объект
        swap(copy);         				// обмениваем значения копии и оригинального объекта
    return *this;
}
// некоторая функция для обмена значениями
void swap(Copyable& copy) noexcept;

Хотя часто подобный способ применяется именно в операторах присвоения, но также он может применяться в других ситуациях, где необходимо выполнить устойчивую к исключениям 
модификацию объекта. И всегда принцип будет тот же. Сначала копируем объект, который надо изменить. Далее выполняем над объектом-копией изменения. И если все пройдет удачно, 
обмениваем значениями целевой объект и объект-копию.



______________________________________________________________________________________
Идиома Move-and-Swap / Перемещение с обменом

Идиома move-and-swap или перемещение с обменом применяется в операторах присвоения с перемещением. Она позволяет избежать дублирования кода деструктора и конструктора 
копирования. Суть данной идиомы состоит в следующей последовательности действий:

1. Для перемещаемого объекта создаем копию с помощью конструктора перемещения

2.Заменяем текущий объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то текущий объект не заменяется.

Общая форма move-and-swap выглядит следующим образом:

MyClass& MyClass::operator=(MyClass&& rhs) noexcept
{
    MyClass moved(std::move(rhs)); // получаем перемещаемый объект
    swap(moved);                  // выполняем обмен значениями
    return *this; // возвращаем текущий объект
}



______________________________________________________________________________________
Паттерн swap delete

Когда удалил ту память на которую ссылаешься, и потом указатель ты занулил



______________________________________________________________________________________
















