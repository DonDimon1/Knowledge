https://y2kot.gitbook.io/untitled
______________________________________________________________________________________
Введение в паттерны

Главная идея: Разделяй и властвуй.


# Что такое паттерны проектирования?
Паттерны проектирования - это набор общепринятых подходов, предназначенных для решения проблем, возникающих в процессе проектирования и разработки программного обеспечения. Паттерны описывают 
определенные способы организации классов и связей между ними.
Используются для достижения таких целей, как улучшение декомпозиции задачи и легкой модификации кода. Паттерны обеспечивают возможность повторного использования кода.


# Основная идея
Основная идея паттернов проектирования заключается в предоставлении типовых решений для проблем, с которыми сталкиваются разработчики. Вместо того, чтобы каждый раз "изобретать велосипед" 
и декомпозировать задачу с нуля, можно использовать проверенные проектные подходы.


# Преимущества
Готовое решение
Упрощение модификации кода
Облегчение взаимодействия между программистами
Повышение скорости разработки
Увеличение надежности кода
Повышение читаемости кода


# Недостатки
Увеличение объема кода
Увеличение времени выполнения
Высокие требования к памяти
Увеличение времени компиляции
Может привести к уменьшению скорости разработки

Структура паттернов:
1) Порождающие паттерны
2) Структурные паттерны
3) Поведенческие паттерны



______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Порождающие паттерны

# Общее описание
Полиморфизм – это очень мощный механизм, который позволяет модифицировать программу «не изменяя» написанный код, за счет добавления новых классов. Дословный перевод полиморфизма - много форм. 
Синоним полиморфизма – безразличие, когда один и тот же код может работать с объектами разных классов (типов).


# Проблема
При модификации программы происходит подмена объектов одних классов на объекты других классов. Как правило, в объектно-ориентированных языках это реализуется за счет передачи в методы ссылок 
(указателей) на базовые полиморфные классы или за счет интерфейсов. При использовании обобщений (шаблонов) подстановка типов осуществляется на этапе компиляции.
При использовании полиморфизма рано или поздно возникает необходимость создания конкретного объекта (сущности) конкретного типа. Для расширения, модификации или подмены сущности будет необходимо найти 
все места, где создается объект, и изменить код. Такая модификация программы увеличивает время разработки, понижает надежность программы, приводит к проблемам с версионностью.

# Порождающие паттерны
Порождающие паттерны – группа паттернов проектирования, которые:
1) берут на себя ответственность за логику создания объектов,
2) позволяют нам не создавать в методах объекты конкретных классов,
3) дают возможность принимать решение объекты каких классов нужно создавать при выполнении программы,
4) дают возможность повторно использовать уже созданный объект.


# Текущий список порождающих паттернов 
1) Фабричный метод
2) Абстрактная фабрика
3) Прототип
4) Строитель
5) Одиночка
6) Пул объектов

______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Фабричный метод (Factory method)

# Проблема
При использовании полиморфизма появляется возможность подмены объекта одного класса на объект другого класса с использованием ссылки (указателя) на базовый абстрактный класс. При создании объекта 
конкретного класса может возникнуть необходимость подмены одной сущности на другую, в результате чего придется искать, где создается объект, и менять написанный код. В попытках решить эту проблему, 
сформировалась идея передачи ответственности создания конкретного объекта другому классу.

# Назначение
Фабричный метод (Factory method) - порождающий паттерн проектирования, определяющий единый интерфейс создания объектов и позволяющий менять класс создаваемого объекта.

# Решаемые задачи
1) Подмена создания объекта одного класса на объект другого класса
Появляется возможность создавать объекты, являющиеся наследниками одного базового класса, без привязки к конкретным классам. Это позволяет легко расширять, модифицировать программу, добавляя новые 
классы, без изменения клиентского кода, который создает объекты классов.

2) Отделение принятия решения, какой объект нужно создать, от самого процесса создания объекта
После принятия решения о выборе конкретного типа создаваемого объекта создается объект (Creator) конкретного фабричного метода. Фактическое создание объекта происходит при непосредственном вызове 
метода createProduct() фабричного метода (Creator).

3) Повторное использование объектов
Появляется возможность повторного использования уже созданного объекта в разных местах программы.

# UML диаграмма паттерна "Фабричный метод"

			/------------\				 /------------------\		  /-----------\
			|  Product   |				 |      Creator	    |		  | Solution  |
			|------------| <------------------------ |------------------| <-----------|-----------|
			|+operation()|				 | +createProduct() |		  | +create() |
			\------------/				 \------------------/		  \-----------/
			      /\					   /\				/\
			      ||					   ||				||
			      ||					   ||				||
		    /---------/\----------\				   ||				||
		    |			  |			   /---------------\	       /------------------\
		    |			  |			   |ConcreteCreator|	       | ConcreteSolution |
	 /----------------\	  /----------------\		   |---------------|	       |------------------|
	 |ConcreteProduct1|	  |ConcreteProductN|		   |	 -//- 	   |	       |       -//- 	  |
	 |----------------|  ...  |----------------|		   \---------------/	       \------------------/
	 | 	-//-	  |	  |	 -//-      |
	 \----------------/	  \----------------/


Product - интерфейс объектов, которые создаются подклассами Creator.
Creator - абстрактный класс, который предоставляет интерфейс для создания объектов подклассов конкретного продукта (Product).
Solution - абстрактный класс, который предоставляет интерфейс для подклассов, принимающих решения, объект какого подкласса продуктов (Product) надо создавать и возвращающий объект подкласса 
	конкретного Creator.


# Преимущества
1) Избавление методов от создания объектов конкретных классов, что решает проблему подмены объекта одного класса на объект другого класса.
2) Упрощение добавления новых классов без изменения написанного кода.
3) Возможность разделения принятия решения о создании объекта и собственно создание объекта в разных местах программы.
4) Возможность принимать решение, объект какого класса необходимо создавать, не во время компиляции, а во время выполнения программы.
5) Возможность во время выполнения программы подменять создание объекта одного класса на объект другого класса.

# Недостатки
1) Увеличивается объем кода.
2) Увеличивается время компиляции.
3) Увеличивается время выполнения программы из-за использования полиморфизма.
4) Увеличивается количество требуемой памяти.
5) Требуется создание параллельных иерархий классов.
6) Необходимость перекомпилировать один и тот же код при добавлении новых типов объектов.
7) Необходимость в передаче ссылки (указателя) на абстрактный создатель (Creator) в методы клиентского кода, где необходимо создавать объекты.

# Связь с другими паттернами
Фабричный метод может быть использован внутри Абстрактной фабрики для создания конкретных объектов. Вместо того, чтобы создавать объекты напрямую, абстрактная фабрика может использовать 
фабричный метод для создания экземпляров объектов определенного типа.


______________________________________________________________________________________
Объяснение от ChatGPT

Представьте, что вы работаете в кафе, где есть разные виды напитков: кофе, чай, какао и т.д. Если бариста (ваш код) должен готовить каждый напиток вручную, он будет тратить много времени на изучение 
рецептов и следование им. Но если в кафе есть автомат (фабрика), который умеет готовить разные напитки по запросу, то бариста просто нажимает кнопку (вызов фабричного метода) и получает готовый напиток.
Таким образом, бариста может фокусироваться на обслуживании клиентов, не думая о том, как именно готовятся напитки. Автомат (фабрика) берет на себя всю сложную работу по созданию напитков.


______________________________________________________________________________________
Очень упрощённая реализация от ChatGPT

#include <iostream>
#include <memory>
#include <string>

using namespace std;

class Transport { // Базовый класс для транспорта
public:
    virtual ~Transport() = default;
    virtual void drive() const = 0;
};

class Car : public Transport { // Класс для автомобиля
public:
    void drive() const override {
        cout << "Driving a car!" << endl;
    }
};

class Bike : public Transport { // Класс для велосипеда
public:
    void drive() const override {
        cout << "Riding a bike!" << endl;
    }
};

class TransportFactory { // Фабрика для создания транспорта
public:
    // Фабричный метод для создания объекта транспорта
    static unique_ptr<Transport> createTransport(const string& type) {
        if (type == "car") {
            return make_unique<Car>();
        } else if (type == "bike") {
            return make_unique<Bike>();
        } else {
            return nullptr;
        }
    }
};

int main() {
    // Создание автомобиля с помощью фабричного метода
    unique_ptr<Transport> myCar = TransportFactory::createTransport("car");
    if (myCar) {
        myCar->drive();  // Вывод: Driving a car!
    }

    // Создание велосипеда с помощью фабричного метода
    unique_ptr<Transport> myBike = TransportFactory::createTransport("bike");
    if (myBike) {
        myBike->drive();  // Вывод: Riding a bike!
    }

    return 0;
}



______________________________________________________________________________________
Общая реализации Фабричного метода на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/factory-method/realizacii-na-s++ (Удобнее смотреть)

### Файл Car:

class Car							// Абстрактный базовый класс
{
public:
    virtual ~Car() = default;
    virtual void drive() = 0;
};


class Sedan : public Car					// Наследник Car
{
public:
    Sedan() 
    { 
        cout << "Sedan constructor called" << endl; 
    }
    
    ~Sedan() override 
    { 
        cout << "Sedan destructor called" << endl; 
    }

    void drive() override 
    { 
        cout << "Driving sedan" << endl; 
    }
};

class SUV : public Car 						// Наследник Car
{
public:
    SUV() 
    {
        cout << "Calling the SUV constructor;" << endl;
    }
    
    ~SUV() override 
    { 
        cout << "Calling the SUV destructor;" << endl; 
    }

    void drive() override 
    { 
        cout << "Driving SUV;" << endl; 
    }
};


### Файл Concepts
// Здесь определяются два концепта, который позволяют уточнять, какие требования должны быть выполнены для типов, используемых в шаблонах. 

template <typename Derived, typename Base>
concept Derivative = is_abstract_v<Base> && is_base_of_v<Base, Derived>;  // Этот концепт проверяет, что тип Derived является потомком (унаследованным типом) от Base, где Base должен быть абстрактным классом.

template <typename Type>
concept NotAbstract = !is_abstract_v<Type>;				  // Этот концепт проверяет, что тип Type не является абстрактным классом.


### Файл CarCreator
// Этот код использует концепты для создания иерархии классов и гарантирует, что конкретные реализации фабричного метода соответствуют определённым условиям.

class CarCreator						// Абстрактный базовый класс, который определяет интерфейс для создания объектов типа Car
{
public:
    virtual ~CarCreator() = default;
    virtual unique_ptr<Car> createCar() const = 0;
};


template <Derivative<Car> TCar>				// Проверяет, что тип TCar является производным от Car.
requires NotAbstract<TCar>				// (Условие) Проверяет, что тип TCar не является абстрактным классом.
class ConcreteCarCreator : public CarCreator		// Принимает в качестве шаблонного параметра тип TCar, который должен быть производным от Car и не должен быть абстрактным. Это гарантируется через концепты.
{
public:
    unique_ptr<Car> createCar() const override 		// Создаёт объект типа TCar с помощью функции make_unique и возвращает уникальный указатель на этот объект
    {
        return make_unique<TCar>();
    }
};


### Файл CarCreatorMaker
// CarCreatorMaker реализует фабрику фабрик (Factory of Factories), то есть это метафабрика, которая создает объекты CarCreator, специализирующиеся на создании конкретных типов Car. 

class CarCreatorMaker
{
public:
    template <Derivative<Car> TCar>	// Шаблонный параметр TCar: Тип машины, который должен быть производным от Car и не должен быть абстрактным классом. Это обеспечивается концептами Derivative<Car> и NotAbstract<TCar>.
    NotAbstract<TCar>
    static unique_ptr<CarCreator> createCarCreator() 	// Возвращает указатель на объект CarCreator, который будет использоваться для создания объектов типа TCar.
    {
        return make_unique<ConcreteCarCreator<TCar>>();	// Метод создает и возвращает объект ConcreteCarCreator<TCar>, который знает, как создавать конкретные экземпляры типа TCar.
    }
};


### Файл User
// Представляет собой клиентский код, который использует объекты типа CarCreator для создания и использования объектов типа Car.

class User
{
public:
    void use(const shared_ptr<CarCreator>& creator)	// Метод принимает в качестве аргумента shared_ptr<CarCreator>, который указывает на объект, способный создавать экземпляры Car.
    {
        if (!creator) throw runtime_error("The creator is missing!");	// проверяется, что указатель creator не является nullptr

        shared_ptr<Car> car = creator->createCar();			// вызывает creator->createCar(), чтобы создать объект Car. Использование shared_ptr вместо unique_ptr здесь предполагает, что объект Car может быть использован в других местах программы после вызова метода use.
        car->drive();							// выполняет какое-то действие, связанное с конкретной реализацией автомобиля.
    }
};



#######
Класс Solution выполняет роль посредника между клиентским кодом и классами создателей продуктов. Он отвечает за регистрацию методов создания объектов для каждого типа продукта и предоставляет методы 
для создания объектов по их идентификаторам.


### Файл VehicleSolution
class VehicleSolution								// используется для регистрации и создания объектов CarCreator на основе идентификаторов. 
{
public:
    using CreateCarMaker = unique_ptr<CarCreator>(&)();				// CreateCarMaker - это тип, представляющий собой указатель на функцию, которая возвращает unique_ptr<CarCreator>. Это будет функция-фабрика, создающая объекты CarCreator.
    using CallBackMap = map<size_t, CreateCarCreator>;				// CallBackMap  - это тип, представляющий ассоциативный контейнер (карта), где ключ (size_t) — это идентификатор, а значение — это функция CreateCarCreator, которая создает объект CarCreator.

public:
    VehicleSolution() = default;
    VehicleSolution(initializer_list<pair<size_t, CreateCarCreator>> list);	// Конструктор, принимающий список инициализации (initializer_list), который позволяет инициализировать объект VehicleSolution с заранее определенным набором пар идентификаторов и функций создания.

    bool registrate(size_t id, CreateCarCreator createfun);			// Метод для регистрации новой функции создания объекта CarCreator в карте callbacks с определенным идентификатором id.
    bool check(size_t id) 							// Метод для удаления функции создания по заданному идентификатору id. Возвращает true, если элемент был удален (т.е. если такой идентификатор был в карте).
    { 
        return callbacks.erase(id) == 1; 
    }

    unique_ptr<CarCreator> create(size_t id);					// Метод для создания объекта CarCreator на основе зарегистрированной функции для указанного идентификатора id. Возвращает unique_ptr<CarCreator>.

private:
    CallBackMap callbacks;							// Карта, которая хранит ассоциации между идентификаторами и функциями создания объектов CarCreator.
};


### Файл Methods
// Реализация методов файла VehicleSolution

# pragma region Solution
VehicleSolution::VehicleSolution(initializer_list<pair<size_t, CreateCarCreator>> list) // Конструктор принимает список инициализации пар size_t (идентификатор) и CreateCarCreator (функция, создающая объект CarCreator).
{
    for (auto&& elem : list)								// В цикле проходит по каждой паре в списке и регистрирует ее, вызывая метод registrate.
        this->registrate(elem.first, elem.second);					// Вызываем registrate 
}

bool VehicleSolution::registrate(size_t id, CreateCarCreator createfun)			// Метод регистрирует новую функцию создания объекта CarCreator в карте callbacks с определенным идентификатором id.
{
    return callbacks.insert(CallBackMap::value_type(id, createfun)).second;
}

unique_ptr<CarCreator> VehicleSolution::create(size_t id)				// Метод ищет функцию создания CarCreator по переданному идентификатору id.
{
    CallBackMap::const_iterator it = callbacks.find(id);				// Если такая функция найдена, она вызывается для создания объекта CarCreator, и результат оборачивается в unique_ptr<CarCreator>.

    return it != callbacks.end() ? unique_ptr<CarCreator>(it->second()) : nullptr;
}

shared_ptr<VehicleSolution> make_solution(						// Эта функция служит фабрикой для создания объектов VehicleSolution, инициализируя их списком пар идентификаторов и функций создания.
    initializer_list<pair<size_t, 
    VehicleSolution::CreateCarCreator>> list
)
{
    return shared_ptr<VehicleSolution>(new VehicleSolution(list));
}
# pragma endregion



### Файл main

# include <iostream>
# include <initializer_list>
# include <memory>
# include <map>
# include <exception>

using namespace std;

int main()
{
    try
    {
        shared_ptr<VehicleSolution> solution
        = make_solution({ {1, CarCreatorMaker::createCarCreator<Sedan>} });		// создает экземпляр VehicleSolution. Внутри него регистрируется фабрика, ассоциированная с идентификатором 1, которая будет создавать машины типа Sedan.

        if (!solution->registrate(2, CarCreatorMaker::createCarCreator<SUV>))		// добавляет еще одну фабрику, ассоциированную с идентификатором 2, для создания машин типа SUV.
        {
            throw runtime_error("Error registration!");
        }
        shared_ptr<CarCreator> cr(solution->create(2));					// Создается объект CarCreator на основе идентификатора 2 (для SUV) и передается в метод User::use.

        User{}.use(cr);									// Метод use создает объект Car с помощью переданного CarCreator и вызывает метод drive.
    }
    catch (runtime_error& err)
    {
        cout << err.what() << endl;
    }
}


# Пример вывода:
Driving an SUV.


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/factory-method/concrete-implementation



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Абстрактная фабрика (Abstract factory)

# Проблема
В процессе разработки программы может возникнуть необходимость создания иерархии разных классов, объекты которых должны использоваться совместно. Таким примером может являться система графики, в 
которой происходит взаимодействие множества компонентов: кистей, ручек, форм, канвасов.

Фабричный метод не поддерживает связь между иерархиями классов. Например, нет возможности подменить одну графическую систему на другую. В таком случае возможным решением является объединение методов 
создания иерархий объектов разных классов в один класс.

# Назначение
Абстрактная фабрика(Abstract factory) — порождающий паттерн проектирования, определяющий единый интерфейс создания иерархий классов и позволяющий менять одно семейство связанных объектов на другое.
Семейством связанных объектов могут быть, например, объекты конкретной графической подсистемы (brush, pen, marker, canvas).

# Решаемые задачи
1) Возможность создавать и подменять одно семейство объектов на другое
Появляется возможность создавать семейства связанных объектов. При необходимости можно легко заменять или добавлять новые семейства объектов, не изменяя другие части кода, которые используют 
эти объекты.

2) Отделение принятия решения о том, какое семейство объектов нужно создать, от самого процесса создания объектов семейства
Решение о выборе конкретного семейства принимается в части кода, который использует абстрактную фабрику. Во время выполнения этот код определяет, какое семейство связанных объектов требуется 
создать, и создает соответствующую фабрику. В коде через абстрактную фабрику вызываются методы создания объектов конкретных иерархий классов.

3) Повторное использование объектов
Появляется возможность повторного использования уже созданных семейств объектов.

# UML диаграмма паттерна "Абстрактная фабрика"

			/-----------\				 /------------------\				 /-----------\
			|  BasePen  |				 |  AbstractFactory |		  		 | BaseBrush |
			|-----------| <------------------------  |------------------|  ------------------------> |-----------|
			|    ...    |				 |   +createPen()   |				 |    ...    |
			\-----------/				 |  +createBrush()  |				 \-----------/
								 \------------------/		
			      /\					  /\					       /\
			      ||					  ||					       ||
			      ||					  ||					       ||
			      ||					  ||					       ||
		      /---------------\				 /------------------\   		      	  /----------\   
		      |	    QtPen     |	 			 | QtGraphicFactory |  			      	  |  QtBrush |
	 	      |---------------|	       			 |------------------|			      	  |----------|
		      |	    -//-      |	       			 |	 -//-       |			      	  |   -//-   |
                      \---------------/	     			 \------------------/			      	  \----------/


# Преимущества
1) Избавление методов от привязки к конкретным классам, что решает проблему подмены объекта одного семейства класса на объект другого семейства классов.
2) Упрощение добавления новых семейств объектов без изменения написанного кода.
3) Возможность принимать решение, объект какого семейства создавать, и создавать объекты в разных местах программы.
4) Возможность принимать решение, объект какого семейства необходимо создавать, не во время компиляции, а во время выполнения программы.
5) Возможность во время выполнения программы подменять создание объекта одного семейства класса на объект другого класса.

# Недостатки
1) Увеличивается объем кода.
2) Увеличивается время компиляции.
3) Увеличивается время выполнения программы из-за использования полиморфизма.
4) Увеличивается количество требуемой памяти.
5) Требуется создание параллельных иерархий классов.
6) Необходимость перекомпилировать один и тот же код при добавлении новых типов объектов.
7) Семейства объектов должны быть однородны по своей структуре, иначе выделить базовую абстракцию в абстрактной фабрике будет невозможно.
8) Возможность наличия неполных семейств объектов.

# Связь с другими паттернами
1) Абстрактная фабрика может использовать Фабричный метод для создания конкретных объектов. Вместо того, чтобы иметь только один метод для создания объектов, абстрактная фабрика может использовать 
фабричный метод в своей реализации.
2) Абстрактная фабрика может быть комбинирована с паттерном Строитель для создания сложных объектов.



______________________________________________________________________________________
Объяснение от ChatGPT

Представьте, что вы владелец мебельного магазина. В вашем магазине есть разные коллекции мебели: например, "Современная" и "Викторианская". В каждой коллекции есть столы, стулья и диваны, которые 
соответствуют стилю этой коллекции.
Абстрактная фабрика в этом случае — это ваш заказ на мебель, который может быть оформлен для любой из коллекций, но вам не нужно думать о том, как именно создается каждый предмет мебели.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <memory>

using namespace std;

// Абстрактный интерфейс для стула
class Chair {
public:
    virtual ~Chair() = default;
    virtual void sit() const = 0;
};

// Абстрактный интерфейс для стола
class Table {
public:
    virtual ~Table() = default;
    virtual void use() const = 0;
};

// Конкретный стул в современном стиле
class ModernChair : public Chair {
public:
    void sit() const override {
        cout << "Sitting on a modern chair." << endl;
    }
};

// Конкретный стол в современном стиле
class ModernTable : public Table {
public:
    void use() const override {
        cout << "Using a modern table." << endl;
    }
};

// Конкретный стул в викторианском стиле
class VictorianChair : public Chair {
public:
    void sit() const override {
        cout << "Sitting on a Victorian chair." << endl;
    }
};

// Конкретный стол в викторианском стиле
class VictorianTable : public Table {
public:
    void use() const override {
        cout << "Using a Victorian table." << endl;
    }
};

// Абстрактная фабрика для создания мебели
class FurnitureFactory {
public:
    virtual ~FurnitureFactory() = default;
    virtual unique_ptr<Chair> createChair() const = 0;
    virtual unique_ptr<Table> createTable() const = 0;
};

// Фабрика для создания современной мебели
class ModernFurnitureFactory : public FurnitureFactory {
public:
    unique_ptr<Chair> createChair() const override {
        return make_unique<ModernChair>();
    }
    unique_ptr<Table> createTable() const override {
        return make_unique<ModernTable>();
    }
};

// Фабрика для создания викторианской мебели
class VictorianFurnitureFactory : public FurnitureFactory {
public:
    unique_ptr<Chair> createChair() const override {
        return make_unique<VictorianChair>();
    }
    unique_ptr<Table> createTable() const override {
        return make_unique<VictorianTable>();
    }
};

int main() {
    // Создаем фабрику для викторианской мебели
    unique_ptr<FurnitureFactory> factory = make_unique<VictorianFurnitureFactory>();

    // Создаем викторианский стул и стол через фабрику
    unique_ptr<Chair> chair = factory->createChair();
    unique_ptr<Table> table = factory->createTable();

    chair->sit(); // Вывод: Sitting on a Victorian chair.
    table->use(); // Вывод: Using a Victorian table.

    // Теперь можем легко сменить фабрику на современную
    factory = make_unique<ModernFurnitureFactory>();

    chair = factory->createChair();
    table = factory->createTable();

    chair->sit(); // Вывод: Sitting on a modern chair.
    table->use(); // Вывод: Using a modern table.

    return 0;
}



______________________________________________________________________________________
Общая реализация на языке С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/abstract-factory/realizacii-na-s++

### Файл BaseGraphics:

class BaseGraphics 						// Базовый абстрактный класс графики
{
public:
    virtual ~BaseGraphics() = 0;
};

BaseGraphics::~BaseGraphics() {}


class QtGraphics : public BaseGraphics				// Наследуемый класс
{
public:
	QtGraphics(shared_ptr<Image> im) 
	{
		cout << "Calling the QtGraphics constructor;" << endl; 
	}
	
	~QtGraphics() override 
	{ 
		cout << "Calling the QtGraphics destructor;" << endl; 
	}
};


### Файл AbstractGraphFactory:

class AbstractGraphFactory 					// это абстрактный класс, который объявляет методы для создания различных графических объектов: Graphics, Pen и Brush.
{			
public:
	virtual ~AbstractGraphFactory() = default;

	virtual unique_ptr<BaseGraphics> createGraphics(shared_ptr<Image> im) = 0; // Каждый метод возвращает указатель (unique_ptr) на базовый класс (BaseGraphics, BasePen, BaseBrush), что позволяет скрыть детали конкретных реализаций.
	virtual unique_ptr<BasePen> createPen(shared_ptr<Color> cl) = 0;
	virtual unique_ptr<BaseBrush> createBrush(shared_ptr<Color> cl) = 0;
};


class QtGraphFactory : public AbstractGraphFactory	// QtGraphFactory — это конкретная реализация абстрактной фабрики. Она создает объекты, специфичные для Qt.
{
public:
	unique_ptr<BaseGraphics> createGraphics(shared_ptr<Image> im) override	// Метод createGraphics создает и возвращает объект типа QtGraphics, используя переданный объект Image.
	{
		return make_unique<QtGraphics>(im);
	}

	unique_ptr<BasePen> createPen(shared_ptr<Color> cl) override
	{
		return make_unique<QtPen>();
	}

	unique_ptr<BaseBrush> createBrush(shared_ptr<Color> cl) override
	{
		return make_unique<QtBrush>();
	}
};


Абстрактная фабрика позволяет создать целое семейство связанных или зависимых объектов (в данном случае, объекты Graphics, Pen, и Brush) без необходимости привязываться к конкретным классам этих 
объектов. Клиентский код (тот, который будет использовать эту фабрику) будет работать с объектами через их базовые интерфейсы, не зная о том, какие именно конкретные классы используются. Это позволяет 
легко заменить, например, QtGraphFactory на другую фабрику (например, GDIPlusGraphFactory), которая будет создавать объекты для другой графической системы, без изменений в клиентском коде.


### Файл User
class User 			// класс User взаимодействует с объектами, создаваемыми с помощью фабрики AbstractGraphFactory
{
public:
	void use(shared_ptr<AbstractGraphFactory>& cr) // Метод use принимает объект cr, который является shared_ptr на объект типа AbstractGraphFactory. Этот объект AbstractGraphFactory может быть любой конкретной фабрикой, которая наследует AbstractGraphFactory, например, QtGraphFactory.
	{
		shared_ptr<Image> image = make_shared<Image>(); // Внутри метода use создается объект Image с помощью make_shared<Image>. Это изображение будет использоваться при создании объекта Graphics.
		auto graphics = cr->createGraphics(image); // Вызов cr->createGraphics(image) использует фабрику, чтобы создать объект графики (Graphics) на основе переданного изображения. Конкретный тип объекта Graphics зависит от того, какая конкретная фабрика передана в use (например, если это QtGraphFactory, то будет создан объект QtGraphics).
	}
};

Как это связано с Абстрактной фабрикой:
Абстракция: Пользователь (User) не знает и не интересуется, какой конкретный тип объекта Graphics будет создан. Он просто использует метод createGraphics фабрики.
Гибкость: В зависимости от того, какая фабрика была передана в use, могут создаваться разные объекты Graphics. Например, это может быть объект QtGraphics или объект, относящийся к другой графической 
системе.
Расширяемость: Если в будущем понадобится поддержка другой графической системы, вам нужно будет лишь создать новую фабрику (например, DirectXGraphFactory) и передать ее в use, не изменяя сам метод use.


### Файл Pen:
class BasePen {}; // это базовый класс, который может служить общим интерфейсом или основой для различных типов "ручек" (инструментов рисования линий, контуров и т.д.).

class QtPen : public BasePen {}; // конкретный тип "ручки". 

Когда вы создаете такие классы в контексте паттерна Абстрактная фабрика, вы позволяете фабрике создавать объекты определенных типов, не завися от их конкретной реализации.


### Файл Brush:
class BaseBrush {};

class QtBrush : public BaseBrush {};


### Файл Image:
class Image {};


### Файл Color:
class Color {};


### Файл Main:
# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<AbstractGraphFactory> grfactory = make_shared<QtGraphFactory>(); 	// Создаем фабрику для Qt. Этот код создает объект QtGraphFactory, который является конкретной реализацией абстрактной фабрики AbstractGraphFactory. Указатель grfactory типа shared_ptr<AbstractGraphFactory> позволяет работать с фабрикой через абстрактный интерфейс, но на самом деле это конкретная фабрика QtGraphFactory.

	unique_ptr<User> us = make_unique<User>();					// Создаем пользователя. Создается объект User, который будет использовать графическую фабрику для создания и работы с графическими объектами.

	us->use(grfactory);								// Пользователь использует фабрику для создания и использования графических объектов. Внутри метода use User будет использовать фабрику для создания графических объектов, например, Graphics, Pen, Brush (зависит от того, как именно определен метод use).
}


# Что происходит на высоком уровне:
1) Инкапсуляция создания объектов: User не знает о том, какой конкретный тип графической системы используется (в данном случае это Qt), он просто получает фабрику через абстрактный интерфейс и 
использует ее для создания нужных объектов.
2) Гибкость и расширяемость: Если в будущем нужно будет поддерживать другую графическую систему (например, DirectX), можно создать новый класс фабрики (например, DirectXGraphFactory), который наследует 
AbstractGraphFactory. Весь остальной код останется неизменным — нужно будет только передать новую фабрику в метод use.


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++

https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/abstract-factory/vozmozhnye-realizacii-dlya-resheniya-konkretnykh-zadach-na-s++



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Прототип (Prototype)

# Проблемы
Представим, что вам потребовалось создать каркасную модель сферы из полигонов. Обычно таких полигонов очень много и при их создании необходимо вычислять координаты. Кроме того, в методы для создания 
объектов требуется передавать объект класса Creator (зачем он нужен? см. Фабричный метод). В данном случае более простым способом создания объекта может быть его копирование из существующего.

В итоге:
Необходимость передачи объекта класса Creator в методы для создания объектов
Необходимость большого количества информации и времени для создания нового объекта


# Назначение
Прототип (Prototype) — это порождающий паттерн проектирования, который поручает создание копий объектов самим копируемым объектам. Для этого в базовый класс добавляется метод для копирования, который 
создает новый объект на основе существующего. Паттерн вводит общий интерфейс для всех объектов, поддерживающих копирование. Это позволяет копировать объекты, не привязываясь к их классам.


# Решаемые задачи
1) Копирование объектов
Дает возможность создавать копии объектов на основе других объектов.

2) Создание сложных объектов
Паттерн прототип предоставляет альтернативу созданию подклассов для конструирования сложных объектов. Вместо того, чтобы создавать множество подклассов для каждой вариации объекта, можно использовать 
прототипы и копирование, чтобы создавать новые объекты с нужными параметрами и состоянием.


# UML диаграмма паттерна "Прототип"

	/--------------\			/-----------\
	|    Client    |			| Prototype |
	|--------------| ---------------------->|-----------|
	| +operation() |			|  +clone() |
	\--------------/			\-----------/
						      /\
						      ||
						      ||
			         /--------------------/\--------------------\
				 |					    |
				 |					    |
			/--------------------\			  /--------------------\
			| ConcretePrototype1 |			  | ConcretePrototypeN |
			|--------------------|        ...	  |--------------------| 
			|      +clone()	     |			  |      +clone()      |
			\--------------------/			  \--------------------/


# Преимущества
1) Возможность создавать новые объекты, используя уже существующие объекты в качестве прототипов.
2) Увеличение скорости создания сложных объектов.
3) Нет необходимости в передаче объекта класса Creator в методы для создания объектов.


# Недостатки
1) Необходимо убедиться в добавлении метода копирования в каждый класс, объект которого может быть скопирован.
2) Копируется внутреннее состояние объекта, в том числе значения приватных полей.
		

# Связь с другими паттернами
Паттерн Строитель может использовать прототипы для создания копий подобъектов.


______________________________________________________________________________________
Объяснение от ChatGPT

Представьте, что вы архитектор, и у вас есть чертеж здания. Если вам нужно спроектировать похожее здание, вы можете начать с нуля, но это займет много времени. Вместо этого вы берете копию уже 
существующего чертежа и изменяете его под новые требования. Это и есть суть Прототипа — создание копии с последующим изменением.

______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <memory>
#include <string>

using namespace std;

// Базовый класс Shape с виртуальным методом клонирования
class Shape {
public:
    virtual ~Shape() = default;
    
    // Виртуальный метод клонирования, который будет реализован в подклассах
    virtual unique_ptr<Shape> clone() const = 0;

    virtual void draw() const = 0;
};

// Конкретный класс Circle, который наследует Shape
class Circle : public Shape {
public:
    Circle(int radius) : radius(radius) {}
    
    // Реализация метода клонирования для Circle
    unique_ptr<Shape> clone() const override {
        return make_unique<Circle>(*this);
    }

    void draw() const override {
        cout << "Drawing a Circle with radius " << radius << endl;
    }

private:
    int radius;
};

// Конкретный класс Square, который наследует Shape
class Square : public Shape {
public:
    Square(int side) : side(side) {}
    
    // Реализация метода клонирования для Square
    unique_ptr<Shape> clone() const override {
        return make_unique<Square>(*this);
    }

    void draw() const override {
        cout << "Drawing a Square with side " << side << endl;
    }

private:
    int side;
};

int main() {
    // Создаем круг с радиусом 10
    unique_ptr<Shape> originalCircle = make_unique<Circle>(10);
    originalCircle->draw(); // Рисуем круг

    // Создаем копию круга с помощью метода clone
    unique_ptr<Shape> clonedCircle = originalCircle->clone();
    clonedCircle->draw(); // Рисуем клонированный круг

    // Создаем квадрат со стороной 20
    unique_ptr<Shape> originalSquare = make_unique<Square>(20);
    originalSquare->draw(); // Рисуем квадрат

    // Создаем копию квадрата с помощью метода clone
    unique_ptr<Shape> clonedSquare = originalSquare->clone();
    clonedSquare->draw(); // Рисуем клонированный квадрат

    return 0;
}



______________________________________________________________________________________
Общая реализация на языке С++

### Файл Car:

class Car									// Абстрактный базовый класс машин
{
public:
	virtual ~Car() = default;
	virtual unique_ptr<Car> clone() = 0;					// Метод предназначен для создания копии объекта, используя паттерн Прототип.
};


class Sedan : public Car							// Класс седан
{
public:
	Sedan() 
	{ 
		cout << "Calling the default constructor;" << endl; 
	}
	
	Sedan(const Sedan& car) 						// Конструктор копирования. Этот конструктор вызывается, когда объект Sedan копируется.
	{ 
		cout << "Calling the Copy constructor;" << endl; 
	}
	
	~Sedan() override 
	{ 
		cout << "Calling the destructor;" << endl; 
	}

	unique_ptr<Car> clone() override					// Метод clone() реализует паттерн Прототип, позволяя создавать копию объекта Sedan. 
	{									// Внутри метода создается новая копия текущего объекта Sedan, вызывая конструктор копирования, и возвращается unique_ptr на этот новый объект.
		return make_unique<Sedan>(*this);
	}
};


Паттерн Прототип позволяет создавать объекты путем копирования существующего экземпляра (прототипа), вместо создания нового с нуля. 


### Файл User:
class User
{
public:
	void use(shared_ptr<Car> &car) // Метод use принимает объект car по ссылке типа shared_ptr<Car>. Это означает, что car является указателем с подсчетом ссылок на объект типа Car (или его наследника). Копирование shared_ptr увеличивает счетчик ссылок, что гарантирует, что объект не будет уничтожен, пока существует хотя бы один указатель на него.
	{
		auto newCar = car->clone(); 	// Метод clone() вызывается для объекта car. Этот метод реализован в конкретных классах, наследующих Car, и возвращает копию объекта, заключенную в unique_ptr<Car>.
	}					// Результатом вызова car->clone() является новый объект, который хранится в newCar. Поскольку clone() возвращает unique_ptr, newCar будет уникальным указателем на новый объект.
};


User использует метод clone() для создания новой копии автомобиля, что может быть полезно, если User хочет работать с копией, не изменяя исходный объект car. 


### Файл Main:
# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<Car> sedan = make_shared<Sedan>(); // Создаем объект Sedan
	User{}.use(sedan); // Создается временный объект User, который сразу же вызывает метод use. Внутри метода use, переданный объект sedan (типа shared_ptr<Car>) используется для создания его клона. Вызов car->clone() приводит к вызову метода clone() у объекта sedan, который вызывает конструктор копирования для создания нового объекта Sedan. 
}				// Новый объект Sedan, созданный методом clone, временно хранится в unique_ptr<Car> newCar, который будет автоматически уничтожен, когда метод use завершится. После завершения метода use временный объект User будет уничтожен.


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/prototype/vozmozhnye-realizacii-dlya-resheniya-konkretnykh-zadach-na-s++




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Строитель (Builder)

# Проблема
Требуется создавать в одном месте сложный объект, состоящий из множества подобъектов.

Примером сложного объекта может служить объект почтового сообщения Email. У этого объекта может быть множество параметров, таких как отправитель, получатель, тема, текст, вложения. Используя паттерн 
Строитель, можно поэтапно создать объект почтового сообщения с различными параметрами.

# Назначение
Строитель (Builder) — это порождающий паттерн проектирования, который позволяет создавать сложные объекты, разбив процесс конструирования сложного объекта на отдельные шаги.

# Решаемые задачи
1) Поэтапное создание сложного объекта
Появляется возможность создавать сложные объекты пошагово. Каждый шаг строителя определяет значения и настройки для соответствующей части объекта.
2) Отделение процесса контроля за созданием объекта от самого процесса создания объекта.
Одна сущность (строитель) определяет шаги конструирования объекта, в то время как другая сущность (директор) управляет последовательностью этих шагов, обеспечивая создание объекта с нужной 
конфигурацией.

# UML диаграмма паттерна "Строитель"

		/-----------\			   /---------------\
		| Director  | 			   |    Builder    |
		|-----------| /\-----------------> |---------------|
		| +create() | \/		   | +buildPart1() |
		\-----------/ 			   |      ...      |
		      /\			   | +buildPartN() |
		      ||			   \---------------/
		      ||				   /\
		      ||				   ||
	     /------------------\			   ||
	     | ConcreteDirector |			   ||
	     |------------------|		  /------------------\
	     |       -//-       |		  | ConcreteBuilder  |
	     \------------------/		  |------------------|
						  |       -//-       |
						  \------------------/


# Преимущества
1) Упрощение процесса создания сложных объектов.
2) Разделение процесса создания объекта и контроля за созданием объекта.

# Недостатки
1) Усложнение кода из-за введения дополнительных иерархий классов.
2) Избыточность кода для создания простых объектов/

# Связь с другими паттернами
Паттерн Строитель может использоваться вместе с Фабричным методом для создания сложных объектов. "Фабричный метод" определяет интерфейс для создания взаимосвязанных объектов, а "Строитель" отвечает за 
создание отдельных частей сложного объекта.


______________________________________________________________________________________
Объяснение от ChatGPT

Представьте, что вы заказываете пиццу. Вы можете выбрать разные ингредиенты — тесто, соус, начинку, сыр и т.д. Процесс сборки пиццы состоит из нескольких шагов, и в зависимости от ваших предпочтений, 
вы можете выбрать разные комбинации. Шеф-повар (Строитель) выполняет каждый шаг, чтобы собрать вашу пиццу (объект).


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <memory>
#include <string>

using namespace std;

// Класс Car, представляющий сложный объект — автомобиль. У него есть методы для установки различных частей, таких как двигатель и шасси.
class Car {
public:
    void setEngine(const string& engine) { this->engine = engine; }
    void setChassis(const string& chassis) { this->chassis = chassis; }

    void show() const {
        cout << "Car with " << engine << " engine and " << chassis << " chassis." << endl;
    }

private:
    string engine;
    string chassis;
};

// Это интерфейс, который описывает шаги для создания автомобиля. Конкретные строители, такие как SedanBuilder, реализуют эти шаги по-своему.
class CarBuilder {
public:
    virtual ~CarBuilder() = default;

    virtual void buildEngine() = 0;
    virtual void buildChassis() = 0;

    shared_ptr<Car> getCar() { return car; }

protected:
    shared_ptr<Car> car = make_shared<Car>();
};

// Конкретный строитель для создания седана
class SedanBuilder : public CarBuilder {
public:
    void buildEngine() override {
        car->setEngine("Sedan Engine");
        cout << "Building engine for Sedan." << endl;
    }

    void buildChassis() override {
        car->setChassis("Sedan Chassis");
        cout << "Building chassis for Sedan." << endl;
    }
};

// Директор управляет процессом создания автомобиля. Он знает, в каком порядке вызывать методы строителя для получения готового объекта.
class CarDirector {
public:
    CarDirector(shared_ptr<CarBuilder> builder) : builder(builder) {}

    shared_ptr<Car> buildCar() {
        builder->buildEngine();
        builder->buildChassis();
        return builder->getCar();
    }

private:
    shared_ptr<CarBuilder> builder;
};

int main() {
    // Создаем строителя для седана
    shared_ptr<CarBuilder> sedanBuilder = make_shared<SedanBuilder>();

    // Создаем директора и строим автомобиль
    CarDirector director(sedanBuilder);
    shared_ptr<Car> sedan = director.buildCar();

    // Выводим информацию о созданном автомобиле
    sedan->show();

    return 0;
}


______________________________________________________________________________________
Общая реализация на языке С++


### Файл Car:

class Car									// Абстрактный класс Car
{
public:
	virtual ~Car() = default;
	virtual void drive() = 0;
};


class Sedan : public Car							// Наследуемый класс 
{
public:
	Sedan() 
	{ 
		cout << "Calling the Sedan constructor;" << endl; 
	}
	
	~Sedan() override 
	{ 
		cout << "Calling the Sedan destructor;" << endl; 
	}

	void drive() override 
	{ 
		cout << "Calling the drive method;" << endl; 
	}
};


### Файл CarBuilder:

class CarBuilder							// CarBuilder — это абстрактный класс, который определяет интерфейс для построения автомобиля (Car).
{
public:
	virtual ~CarBuilder() = default;

	virtual bool buildEngine() = 0;					// Он включает в себя методы для поэтапного создания машины (buildEngine, buildChassis)
	virtual bool buildChassis() = 0;

	shared_ptr<Car> getCar();					// И метод для получения готового объекта (getCar).

protected:
	virtual shared_ptr<Car> create() = 0;				// Предназначен для создания нового объекта Car. Он также является абстрактным и должен быть реализован в классах-наследниках.

	shared_ptr<Car> car{ nullptr };
	size_t part{ 0 };
};


class SedanBuilder : public CarBuilder					// реализует методы для поэтапного создания седана.
{
public:
	bool buildEngine() override					// проверяет текущий этап сборки (part) и, если это первый этап, строит двигатель для седана, увеличивая счетчик part.
	{
		if (!part)
			++part;

		if (part != 1) return false;
		
		cout << "Building part 1: Engine for Sedan;" << endl;
		return true;
	}
	
	bool buildChassis() override					// выполняет аналогичную функцию, но для второго этапа сборки, строя шасси для седана.
	{
		if (part == 1)
			++part;

		if (part != 2) return false;

		cout << "Building part 2: Chassis for Sedan;" << endl;
	}

protected:
	shared_ptr<Car> create() override;
};



### Файл Methods:

shared_ptr<Car> CarBuilder::getCar()					// Эти два метода отвечают за создание и возврат объекта автомобиля, если все необходимые этапы строительства завершены.
{
	if (!car) { car = create(); }

	return car;
}

shared_ptr<Car> SedanBuilder::create()
{
	if (part == 2) { car = make_shared<Sedan>(); }

	return car;
}


### Файл CarCreator:		

class CarCreator							// Абстрактным классом, который определяет интерфейс для создания объектов типа Car.
{									// CarCreator служит базой для всех классов, которые хотят создать объекты Car, предоставляя единый интерфейс для создания автомобилей.
public:
	virtual ~CarCreator() = default;
	virtual shared_ptr<Car> create() = 0;
};


class CarDirector : public CarCreator					// CarDirector наследует CarCreator и реализует метод create(), который отвечает за создание объекта Car.
{
public:
	CarDirector(shared_ptr<CarBuilder> builder) : br(builder) {} 	// В конструкторе CarDirector принимает shared_ptr<CarBuilder> в качестве параметра и сохраняет его в приватном поле br. Этот объект строителя (CarBuilder) отвечает за поэтапное создание автомобиля.

	shared_ptr<Car> create() override				// Метод create() в CarDirector использует объект строителя для поэтапного создания автомобиля:
	{
		if (br->buildEngine() && br->buildChassis()) return br->getCar();	// Сначала вызывается метод buildEngine() строителя.
											// Затем вызывается метод buildChassis() строителя. Если оба этапа строительства выполнены успешно, метод getCar() возвращает готовый объект Car.
		return nullptr;								// Если на каком-то этапе строительство не удалось, метод возвращает nullptr.
	}

private:
	shared_ptr<CarBuilder> br;
};


Этот код объединяет два паттерна: Строитель (Builder) и Фабричный метод (Factory Method). В результате мы получаем гибкую и модульную структуру для создания объектов типа Car через поэтапное 
строительство.


### Файл User:

class User
{
public:
	void use(shared_ptr<CarCreator>& creator)
	{
		shared_ptr<Car> car = creator->create();		// Использует фабрику для создания автомобиля

		if (car)						// Проверка, успешно ли создан автомобиль
			car->drive();					// Если автомобиль создан, вызывается метод drive()
	}
};

Класс User, представленный в вашем коде, показывает, как объект пользовательского класса может взаимодействовать с фабрикой для создания объектов Car и затем использовать их. 


### Файл Main:

# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<CarBuilder> builder = make_shared<SedanBuilder>(); 		// создается объект SedanBuilder, который является конкретной реализацией абстрактного класса CarBuilder. SedanBuilder отвечает за поэтапное создание автомобиля типа Sedan.
	shared_ptr<CarCreator> creator = make_shared<CarDirector>(builder);	// CarDirector является конкретной реализацией абстрактного класса CarCreator. В конструктор CarDirector передается builder, который будет использоваться для создания автомобиля.
										// CarDirector управляет процессом создания автомобиля, используя методы строителя (buildEngine() и buildChassis()), а затем возвращает готовый объект Car.
	User{}.use(creator);							// Создается временный объект класса User, который сразу же вызывает метод use() с переданным объектом CarCreator.
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Одиночка (Singleton)

# Проблема
Необходимость в создании одного экземпляра конкретного объекта.

Примером такого объекта может являться объект базы данных. Такие объекты нельзя клонировать или копировать, объект должен быть один во всей системе. Это необходимо для того, чтобы избежать проблем с 
целостностью и согласованностью данных.


# Назначение
Одиночка (Singleton) – это порождающий паттерн проектирования, который гарантирует, что будет создан только один экземпляр класса, и предоставляет к нему глобальную точку доступа.


# Решаемые задачи
1) Контроль за объектом.
Паттерн гарантирует, что у класса есть только один экземпляр


# Преимущества
1) Гарантия наличия единственного экземпляра объекта.
2) Предоставление глобальной точки доступа к объекту.
3) Оптимизация использования ресурсов.

# Недостатки
1) Создает проблемы с модификацией, расширением и управлением объектом.
2) Решение о том, какой объект создавать, не может приниматься при выполнении программы.
3) Создается глобальный объект и теряется контроль над его жизненным циклом.



______________________________________________________________________________________
Общая реализация на языке С++

### Файл Sun:
// Конструктор помечается модификатором private, чтобы объект класса нельзя было создать извне

class Sun
{
public:
	static shared_ptr<Sun> instance()
	{
		class SunProxy : public Sun {};					// SunProxy: Это вложенный класс-прокси, который наследуется от Sun. Этот подход используется для создания объекта Sun через закрытый конструктор.

		static shared_ptr<Sun> myInstance = make_shared<SunProxy>();	// Создается один статический экземпляр SunProxy через make_shared. Так как myInstance статический, он создается один раз и будет доступен при каждом вызове instance().

		return myInstance;						// возвращает shared_ptr, обеспечивая глобальную точку доступа к единственному экземпляру Sun.
	}
	
	~Sun() 
	{ 
		cout << "Calling the destructor;" << endl; 
	}

	void shine() 
	{ 
		cout << "The sun is shining;" << endl; 
	}

	Sun(const Sun&) = delete;					// Удаленные конструктор копирования и оператор присваивания:
	Sun& operator =(const Sun&) = delete;				// Эти операторы удалены, чтобы предотвратить копирование и присваивание объектов Sun. Singleton должен существовать в единственном экземпляре, и запрет на копирование помогает это обеспечить.

private:
	Sun() 								// Закрытый конструктор: делает невозможным создание объектов Sun извне класса. Это характерная черта паттерна Singleton, которая 
	{ 								// 	гарантирует, что экземпляр класса может быть создан только через статический метод instance().
		cout << "Calling the default constructor;" << endl; 
	}
};



### Файл Main:

# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<Sun> sun(Sun::instance());

	sun->shine();
}


Sun::instance() возвращает shared_ptr<Sun> на единственный экземпляр Sun. Поскольку instance() метод возвращает shared_ptr<Sun>, создаётся новый shared_ptr<Sun>, который управляет тем же объектом Sun.
Важно отметить, что, так как возвращаемое значение из instance() уже является shared_ptr<Sun>, использование конструкции shared_ptr<Sun> sun(Sun::instance()); избыточно. Более правильно использовать 
присваивание: shared_ptr<Sun> sun = Sun::instance(); (Подсказка от ChatGPT)


______________________________________________________________________________________
Возможные реализации для решения конкретных задач на С++
https://y2kot.gitbook.io/untitled/patterns/creationals-patterns/singleton/vozmozhnye-realizacii-dlya-resheniya-konkretnykh-zadach-na-s++




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Пул объектов (Object pool)

# Проблема
1) Требуется ограниченное количество объектов одного класса.
2) Переиспользование сложных объектов

Представь, что у тебя есть домашний Wi-Fi роутер. Вместо того чтобы каждый раз, когда устройство в доме нуждается в подключении к Интернету, создавать новое подключение к провайдеру интернета и 
разрывать его после использования, ты можешь использовать пул подключений.


# Назначение
Пул объектов (Object pool) – это порождающий паттерн проектирования, который предоставляет ограниченный набор инициализированных, по мере необходимости, и готовых для использования объектов. 
Используется для повышения производительности и управления ресурсами путем повторного использования предварительно созданных объектов вместо создания новых. Это полезно в случаях, когда создание 
объектов требует значительных ресурсов, таких как соединения с базой данных.


# Решаемые задачи
1) Централизованное управление доступом.
Обеспечивает централизованное управление доступом к объектам пула

2) Контроль и ограничение доступа.
Позволяет контролировать и ограничивать количество одновременно используемых объектов.

3) Повышение производительности.
Повторное использование объектов позволяет избежать увеличение затрачиваемых ресурсов на создание и уничтожение объектов.

4) Управление жизненным циклом объектов.
Упрощает управление жизненным циклом объектов, так как клиенту не нужно явно создавать и уничтожать объекты, а просто получать и возвращать их в пул.

# Преимущества
1) Повышается производительность за счет минимизации создания и уничтожения множества объектов.
2) Возможность ограничивать и контролировать число используемых объектов.
3) Возможность переиспользовать объект.


# Недостатки
1) Функция очистки, создания, удаления объекта. Возможность утечки информации. Если объект не очищается или его состояние не сбрасывается перед возвращением в пул, может возникнуть утечка информации. 
Например, если объект содержит конфиденциальные данные или ссылки на другие объекты, эта информация может остаться в объекте после его возврата в пул.
2) Увеличение объема кода. Внедрение паттерна требует создания дополнительной логики для управления пулом объектов, обработки доступа к объектам, контроля их состояния.
3) Усложнение архитектуры приложения.
4) В некоторых ситуациях сложная логика управления пулом.


______________________________________________________________________________________
Объяснение от ChatGPT

Представьте себе библиотеку, где книги можно брать на время, а затем возвращать обратно. Вместо того чтобы каждый раз печатать новую книгу для каждого читателя, библиотека хранит ограниченное количество
экземпляров, которые читатели могут брать и возвращать. Это и есть идея пула объектов: повторное использование ограниченного числа ресурсов.


______________________________________________________________________________________
Общая реализация на языке С++

### Файл EmployeePoolObject:

template <typename T>
concept EmployeePoolObject = requires(T t) 		// Концепция EmployeePoolObject задает контракт (или набор требований), которому должен соответствовать тип T для того, чтобы считаться допустимым для этого концепта.
{
	t.clockIn();					// Требование t.clockIn() внутри requires(T t) означает, что для любого типа T, который будет использоваться с этой концепцией, должен быть определен метод clockIn(), который может быть вызван у объекта типа T.
};



### Файл Employee:

class Employee						// Класс, который отслеживает количество созданных и уничтоженных объектов. 
{
private:
	static size_t count;

public:
	Employee() 
	{ 
		cout << "Constructor(" << ++count << ");" << endl; 
	}
	
	~Employee() 
	{ 
		cout << "Destructor(" << count-- << ");" << endl; 
	}

	void clockIn() 					// Выводит сообщение о том, что сотрудник "отметился" (clocked in), и отображает адрес текущего объекта (this) в памяти.
	{ 
		cout << "Employee clocked in: 0x" << this << endl; 
	}
};

size_t Employee::count = 0;				// хранит количество созданных объектов Employee



### Файл EmployeePool:

template <EmployeePoolObject Type>							// Шаблонный класс для управления пулом сотрудников.
class EmployeePool						
{
public:
	static shared_ptr<EmployeePool<Type>> instance();				// Статический метод возвращает shared_ptr на единственный экземпляр EmployeePool. Это обеспечивает реализацию паттерна Singleton для пула сотрудников.

	shared_ptr<Type> hireEmployee();						// Этот метод предназначен для "нанятия" нового сотрудника, т.е., добавления нового сотрудника в пул и возвращения умного указателя на этот сотрудник.
	bool fireEmployee(shared_ptr<Type>& employee);					// Этот метод предназначен для "увольнения" сотрудника из пула. Он принимает умный указатель на сотрудника и удаляет его из пула.
	size_t count() const { return pool.size(); }					// count(): Возвращает количество сотрудников в пуле.
		
	EmployeePool(const EmployeePool&) = delete;					// Удаленные конструктор копирования и оператор присваивания: Запрещает копирование и присваивание экземпляра EmployeePool, что также является частью паттерна Singleton.
	EmployeePool& operator =(const EmployeePool&) = delete;				

private:
	vector<pair<bool, shared_ptr<Type>>> pool;					// Хранит информацию о сотрудниках. vector содержит пары, где первый элемент bool может указывать на состояние (например, занято/свободно), а второй элемент — умный указатель на сотрудника.

	EmployeePool() {}								// Закрытый конструктор для предотвращения создания экземпляров EmployeePool извне. Это свойственно паттерну Singleton.

	pair<bool, shared_ptr<Type>> createEmployee();					// Создает нового сотрудника и возвращает его в виде пары с состоянием.

	template <typename Type>							// operator <<: Дружественная функция, которая позволяет выводить содержимое пула сотрудников в поток вывода (например, в cout).
	friend ostream& operator << (ostream& os, const EmployeePool<Type>& pl);
};


### Файл instance():

template <EmployeePoolObject Type>							// реализует паттерн Singleton с использованием shared_ptr. 
shared_ptr<EmployeePool<Type>> EmployeePool<Type>::instance()
{
	static shared_ptr<EmployeePool<Type>> myInstance(new EmployeePool<Type>());	// Создается новый объект EmployeePool<Type>, и shared_ptr на этот объект присваивается переменной myInstance. Это гарантирует, что myInstance будет управлять единственным экземпляром EmployeePool<Type>, создавая его при первом вызове instance().

	return myInstance;
}


### Файл hireEmployee():

template <EmployeePoolObject Type>				// отвечает за предоставление доступного сотрудника из пула или создание нового сотрудника, если все существующие сотрудники заняты. 
shared_ptr<Type> EmployeePool<Type>::hireEmployee()
{
	size_t i;
	for (i = 0; i < pool.size() && pool[i].first; ++i);	// Цикл for проходит по всем элементам в pool до тех пор, пока не найдет свободного сотрудника

	if (i < pool.size())
	{
		pool[i].first = true;				// Если в пуле есть свободное место (т.е., i < pool.size()), то сотрудник становится доступным
	}
	else
	{
		pool.push_back(createEmployee());		// Если все сотрудники заняты (т.е., i >= pool.size()), создается новый сотрудник с помощью метода createEmployee() и добавляется в пул.
	}

	return pool[i].second;					// Возвращается умный указатель на сотрудника, который был найден или только что создан. 
}


### Файл fireEmployee():

template <EmployeePoolObject Type>				// Метод fireEmployee в классе EmployeePool предназначен для "увольнения" сотрудника из пула. Этот метод помечает сотрудника как освобожденного и выполняет определенные действия, связанные с его увольнением.
bool EmployeePool<Type>::fireEmployee(shared_ptr<Type>& employee)
{
	size_t i;
	for (i = 0; pool[i].second != employee && i < pool.size(); ++i); 	// Цикл for используется для поиска сотрудника в пуле.

	if (i == pool.size()) return false;					// Если после завершения цикла переменная i равна pool.size(), это означает, что сотрудник не был найден в пуле. В таком случае метод возвращает false.

	employee.reset();							// "Увольнение" сотрудника: Сбрасывает умный указатель employee, что освобождает его и обнуляет.
	pool[i].first = false;							// Помечает сотрудника как освобожденного, установив соответствующий флаг bool в false.
	pool[i].second->clockIn();						// Вызывает метод clockIn() у сотрудника, возможно для выполнения каких-то действий, связанных с "увольнением" или освобождением.

	return true;
}


### Файл createEmployee():

template <EmployeePoolObject Type>						// Метод createEmployee для класса EmployeePool предназначен для создания нового сотрудника и возвращения его вместе с флагом, указывающим на его доступность.
pair<bool, shared_ptr<Type>> EmployeePool<Type>::createEmployee()
{
	return { true, make_shared<Type>() };					// Создает новый объект типа Type (где Type должен быть классом, удовлетворяющим концепции EmployeePoolObject) и возвращает умный указатель shared_ptr<Type> на этот объект.
}


### Файл operator <<:

template <typename Type>							// Шаблонный оператор вывода operator<< для класса EmployeePool предназначен для вывода состояния пула сотрудников на поток, например, на консоль.
ostream& operator << (ostream& os, const EmployeePool<Type>& pl)
{
	for (auto elem : pl.pool)						// Цикл for используется для перебора всех элементов в pl.pool. 
		os << "{" << elem.first << ", 0x" << elem.second << "} ";	// elem.first: Выводит булевый флаг, показывающий состояние сотрудника (доступен или занят). elem.second: Выводит адрес объекта в памяти в шестнадцатеричном формате. 

	return os;
}


### Файл Main:

# include <iostream>
# include <memory>
# include <iterator>
# include <vector>

using namespace std;

int main()
{
	shared_ptr<EmployeePool<Employee>> pool = EmployeePool<Employee>::instance();	// Получаем экземпляр пула сотрудников

	vector<shared_ptr<Employee>> vec(4);						// Создаем вектор из 4 умных указателей на сотрудников

	for (auto& elem : vec)								// Заполняем вектор сотрудниками из пула
		elem = pool->hireEmployee();

	pool->fireEmployee(vec[1]);							// Увольняем второго сотрудника из вектора

	cout << *pool << endl;								// Выводим текущее состояние пула сотрудников

	shared_ptr<Employee> ptr = pool->hireEmployee();				// Нанимаем нового сотрудника и заменяем свободное место во векторе
	vec[1] = pool->hireEmployee();

	cout << *pool << endl;								// Выводим текущее состояние пула сотрудников после изменений
}





______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Структурные паттерны

# Общее описание
Структурные паттерны - это группа шаблонов проектирования, которая решает задачи, связанные с организацией классов и объектов в более крупные структуры.
1) Структурные паттерны уровня класса используют наследование для составления композиций из интерфейсов и реализаций.
Или
2) Вместо композиции интерфейсов или реализаций структурные паттерны уровня объекта компонуют объекты для получения новой функциональности.

Дополнительная гибкость в последнем случае связана с возможностью изменить композицию объектов во время выполнения, что недопустимо для статической композиции классов.

К структурным паттернам уровня класса можно отнести: адаптер и мост.

К структурным паттернам уровня объекта можно отнести: декоратор, компоновщик, заместитель, фасад.


# Используются следующие механизмы:
1) Наследование - это концепция, позволяющая описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом. Базовый класс определяет интерфейс, а подклассы - 
реализацию. Структуры на основе наследования получаются статичными.

2) Композиция - построение структуры путем объединения объектов некоторых классов.
Композиция позволяет получать структуры, которые можно изменять во время выполнения.


______________________________________________________________________________________
Адаптер (Adapter)

# Назначение
Паттерн адаптер (Adapter) преобразует интерфейс одного класса в интерфейс другого, который ожидают клиенты. Адаптер обеспечивает совместную работу классов с несовместимыми интерфейсами, которая 
без него была бы невозможна.

Например: контейнеры queue, priority_queue и stack библиотеки стандартных шаблонов STL реализованы на базе последовательных контейнеров list, deque и vector, адаптируя их интерфейсы к нужному виду. 
Именно поэтому эти контейнеры называют контейнерами-адаптерами.

# Решаемые задачи
1) Разделение ответственностей
Согласно принципу единственной ответственности (Single Responsibility) один класс должен иметь одну область ответственности. Когда существует сущность на которую возложены 2 или более ответственностей, 
они разделяются посредством вынесения каждой в адаптер. Ответственности делаются независимыми друг от друга.

2) Подмена одного интерфейса на другой
Позволяет преобразовывать интерфейс одного класса в интерфейс другого, который ожидают клиенты.

Интерфейс является абстракцией, которая определяет, как объект может быть использован, независимо от его конкретной реализации. Он представляет из себя набор методов и свойств класса.

3) Использование сторонних библиотек
Использовать класс из нестандартной библиотеки следует через адаптер. Делается это для решения проблем совместимости интерфейсов библиотеки и рабочей среды, адаптации кода к новым версиям библиотеки, 
устранения сильной зависимости кода от библиотеки. Возможность контролировать и модифицировать адаптер делает код более гибким и легким в сопровождении.

4) Расширение базового интерфейса
Интерфейс базового класса в общем случае плохо расширять, так как нарушаются принципы инкапсуляции и единственной ответственности (Single Responsibility). Код становится тяжелее поддерживать и 
модифицировать. Появляется потребность в дополнительных проверках и приведениях типов при работе с указателями на базовый класс.

При использовании адаптера расширение может относиться не к одному классу, а к целой иерархии классов.


# UML диаграмма паттерна "Адаптер"

		
		/-------------\			/----------------\			/-------------\		
		|   AdapterA  |			|     Adaptee    |			|   AdapterB  |
		|-------------|			|----------------|			|-------------|	
		| +requestA() |			| +specRequest() |			| +requestB() |
		\-------------/			\----------------/			\-------------/
		      /\		          /\	/\   /\					/\
		      ||		          ||	||   ||					||
		      ||   //=====================//	||   \\============================\\	||
		      ||   ||				||				   ||	||
		      ||   /\				||				   /\	||
		      ||   \/				||				   \/	||
	     /------------------\		/------------------\		      /------------------\
	     | ConcreteAdapterA |		| ConcreteAdaptee  |		      | ConcreteAdapterB |
	     |------------------|		|------------------|	              |------------------|
	     |	     -//-	|		|	-//-	   |		      |	      -//-	 |
	     \------------------/		\------------------/		      \------------------/



# Преимущества
1) отделяет и скрывает от клиента подробности преобразования различных интерфейсов
2) позволяет адаптировать интерфейс к требуемому
3) позволяет разделить роли сущности
4) дает возможность независимо развивать различные ответственности сущности
5) расширение интерфейса


# Недостатки
1) необходимость плодить много классов приводит к увеличению количества времени и памяти,необходимых для исполнения программы
2) дублирование кода (в различных конкретных адаптерах может требоваться одна и та же реализация методов)
3) часто адаптер должен иметь доступ к реализации класса


# Связь с другими паттернами
1) Мост: структура паттерна мост аналогична структуре адаптера, но у моста иное назначение. Он отделяет интерфейс от реализации, чтобы то и другое можно было изменять независимо. Адаптер же призван 
изменить интерфейс существующего объекта.
2) Фасад: адаптер может использоваться внутри фасада для обеспечения совместимости между подсистемами, имеющими несовместимые интерфейсы.
3) Заместитель: адаптер может служить в качестве простого заместителя для объекта, предоставляя тот же интерфейс, но с другой реализацией.
4) Декоратор: оба паттерна имеют схожую структуру, но разные цели. Адаптер изменяет интерфейс объекта, в то время как декоратор расширяет функциональность объекта, не изменяя его интерфейса


______________________________________________________________________________________
Объяснение от ChatGPT

Адаптер — это паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. Он как "переходник" между двумя вещами, которые сами по себе не могут взаимодействовать 
напрямую.

Представьте, что у вас есть розетка с европейским стандартом (две круглые вилки), а зарядное устройство от вашего телефона имеет американскую вилку (две плоские вилки). Чтобы подключить зарядное 
устройство к розетке, вам нужен переходник, который позволит подключить несовместимые устройства друг к другу. Этот переходник и есть адаптер.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

Допустим, у нас есть старый класс, который измеряет температуру в градусах Цельсия, но мы работаем с новой системой, которая ожидает температуру в Фаренгейтах. Вместо того чтобы переписывать старый 
класс, мы создаём адаптер.

#include <iostream>

// Старый класс, который измеряет температуру в Цельсиях
class CelsiusThermometer {
public:
    double getTemperature() {
        return 25.0; // Просто пример, возвращает 25 градусов Цельсия
    }
};

// Интерфейс для новой системы, которая ожидает температуру в Фаренгейтах
class FahrenheitThermometer {
public:
    virtual double getTemperature() = 0; // Абстрактный метод
};

// Адаптер, который позволяет использовать старый класс в новой системе
class CelsiusToFahrenheitAdapter : public FahrenheitThermometer {
public:
    CelsiusToFahrenheitAdapter(CelsiusThermometer* celsiusThermometer)
        : celsiusThermometer(celsiusThermometer) {}

    // Преобразуем температуру из Цельсия в Фаренгейт
    double getTemperature() override {
        double celsius = celsiusThermometer->getTemperature();
        return (celsius * 9.0 / 5.0) + 32.0;
    }

private:
    CelsiusThermometer* celsiusThermometer;
};

int main() {
    // Старый термометр, который измеряет в Цельсиях
    CelsiusThermometer oldThermometer;

    // Адаптер, который преобразует данные в Фаренгейты
    CelsiusToFahrenheitAdapter adapter(&oldThermometer);

    // Используем адаптер для получения температуры в Фаренгейтах
    std::cout << "Temperature in Fahrenheit: " << adapter.getTemperature() << std::endl;

    return 0;
}



______________________________________________________________________________________
Общая реализация на языке С++


### Файл includes:

// подключаем нужные для работы программы библиотеки
# include <iostream>
# include <memory>

// подключаем пространство имен std
using namespace std;


### Файл BaseAdaptee:

// класс BaseAdaptee является базовым описанием интерфейса, 
// который нуждается в адаптации
 
class BaseAdaptee
{
public:
    virtual ~BaseAdaptee() = default;
    virtual void specificRequest() = 0;
};


### Файл ConcreteAdaptee:

// класс ConcreteAdaptee определяет существующий интерфейс, 
// который нуждается в адаптации
// (реализует адаптируемый интерфейс) 

class ConcreteAdaptee : public BaseAdaptee
{
public:
    virtual void specificRequest() override 
    { 
        cout << "Method ConcreteAdaptee;" << endl; 
    }
};


### Файл Adapter:

// Adapter - базовый абстрактный класс для адапетров

// Adapter адаптирует интерфейс Adaptee к зависящему от 
// предметной области интерфейсу, которым пользуется Client

// Client - сущность, которая вступает во взаимоотношения с объектами, 
// удовлетворяющими интерфейсу
 
class Adapter
{
public:
    virtual ~Adapter() = default;
    virtual void request() = 0;
};


### Файл ConcreteAdapter:

// конкретная реализация экзмпляра BaseAdapter

// ConcreteAdapter адаптирует интерфейс BaseAdaptee к интерфейсу Adapter,
// чтобы клиентский код мог использовать адаптируемый класс через адаптер

class ConcreteAdapter : public Adapter
{
private:
    shared_ptr<BaseAdaptee>  adaptee;
public:
    ConcreteAdapter(shared_ptr<BaseAdaptee> ad) : adaptee(ad) {}
    void request() override;
};


### Файл Methods:

# pragma region Methods
void ConcreteAdapter::request()
{
    cout << "Adapter: ";
    if (adaptee)
    {
        adaptee->specificRequest();
    }
    else
    {
        cout << "Empty!" << endl;
    }
}


### Файл Main:

int main()
{
    shared_ptr<BaseAdaptee> adaptee = make_shared<ConcreteAdaptee>();
    shared_ptr<Adapter> adapter = make_shared<ConcreteAdapter>(adaptee);

    adapter->request();
}



______________________________________________________________________________________
Возможные реализации для решения конкретных задач
https://y2kot.gitbook.io/untitled/patterns/structural-patterns/adapter/vozmozhnye-realizacii-dlya-resheniya-konkretnykh-zadach



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Декоратор (Decorator)

# Назначение
1) Паттерн декоратор (Decorator) позволяет динамически добавлять новые обязанности объекту. Декораторы являются гибкой альтернативой порождению подклассов для расширения функциональности.

2) Рекурсивно декорирует основной объект.
Предполагает возможность применять несколько декораторов последовательно, оборачивая один декоратор в другой. Каждый декоратор добавляет свою функциональность к объекту, а затем передает управление 
следующему декоратору в цепочке, пока не достигнет последнего.

3) Паттерн декоратор использует схему "обертываем подарок, кладем его в коробку, обертываем коробку".

# Решаемые задачи
1) динамическое, прозрачное для клиентов добавление обязанностей объектам
2) реализация обязанностей, которые могут быть сняты с объекта
3) применяется, когда расширение путем наследования по каким-то причинам неудобно или невозможно
Наследование от некоторых классов может быть запрещено.

# UML диаграмма паттерна "Декоратор"

		
			/--------------\
			|   Component  |
			|--------------| <==============================================\\
			| +operation() |						||
			\--------------/						||
			       /\							||
			       ||							||
			       ||							||
			       /\							||
		  //============================================================\\      ||
		  ||			       ||				||      ||
		  ||			       ||				||      /\
		  ||			       ||				||      \/
	/--------------------\	     /--------------------\		    /--------------\
	| ConcreteComponent1 |	     | ConcreteComponentN |		    |   Decorator  |
	|--------------------|	...  |--------------------|		    |--------------|
	|	 -//-	     |	     |	      -//-	  |		    | +operation() |
	\--------------------/	     \--------------------/		    \--------------/
		  /\				/\				   /\
		  ||				||				   ||
		  ||				||			 	   /\
		  ||				||		        //================================\\
	/--------------------\	     /--------------------\		||		      		  ||
	|		     |	     |		          |		||		      		  ||
	|--------------------|	     |--------------------|	/--------------------\		/--------------------\
	|		     |       |		          |	| ConcreteDecorator1 |		| ConcreteDecoratorN |
	\--------------------/       \--------------------/	|--------------------|		|--------------------|
								|	-//-	     |		|	 -//-	     |
								\--------------------/		\--------------------/




# Преимущества
1) Гибкость: возможность добавлять желаемую реализацию к любому классу. Появлется возможность "декорировать" декораторы.
2) Отсутсвие разрастания иерархии.
3) Позволяет избежать перегруженных функциями классов на верхних уровнях иерархии.
4) Возможность обращаться с декорированным объектом так же как и с исходной сущностью.
5) Отсутствие дублирования кода, данный код просто уходит в конкретный декоратор.


# Недостатки
1) Снижение производительности программы.
Не используя декораторы можно напрямую пользоваться методом класса. Декоратор же может долго полиморфно совершать цепочку вызовов, что сказывается на времени выполнения программы.

2) Вся ответственность за декорирование "ложится на плечи" программиста
Нет сущности, которая бы полностью отвечала за последовательность декорирования: за порядок вызова и оборачивания декораторов.

3) В случае если в цепочке вызовов декоратора появляется необходимость изменить какую-либо обертку или удалить ее, то приходится заново оборачивать исходный объект.

4) Необходимость в создании сущности, отвечающей за декорирование.

# Связь с другими паттернами
1) Компоновщик: декоратор можно рассматривать как вырожденный случай компоновщика с единственным компонентом. Однако Decorator добавляет новые обязанности и не предназначен для агрегирования объектов.
2) Стратегия: декоратор хорошо совмещается с паттерном стратегия. Декоратор позволяет изменить внешний облик объекта, стратегия – его внутреннее содержание. Это два взаимодополняющих способа изменения 
объекта.
3) Адаптер: если декоратор изменяет только обязанности объекта, но не его интерфейс, то адаптер придает объекту совершенно новый интерфейс.



______________________________________________________________________________________
Объяснение от ChatGPT

Декоратор — это паттерн проектирования, который позволяет динамически добавлять новую функциональность объектам, не изменяя их исходный код. Это как обёртка, которая добавляет что-то новое к 
существующему объекту.

Представьте, что вы покупаете подарок, например, книгу. Вы можете просто купить книгу и подарить её, но чтобы сделать подарок более особенным, вы можете упаковать его в красивую обёртку, добавить 
бантик или даже положить его в подарочную коробку. Каждое из этих действий — это своего рода декорирование вашего подарка.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <string>
using namespace std;

// Базовый класс для человека в обычной одежде
class Person {
public:
    virtual string getOutfit() const {
        return "Basic outfit";
    }
};

// Декоратор для добавления шляпы
class HatDecorator : public Person {
private:
    const Person& person;
public:
    HatDecorator(const Person& person) : person(person) {}

    string getOutfit() const override {
        return person.getOutfit() + " + hat";
    }
};

// Декоратор для добавления куртки
class JacketDecorator : public Person {
private:
    const Person& person;
public:
    JacketDecorator(const Person& person) : person(person) {}

    string getOutfit() const override {
        return person.getOutfit() + " + jacket";
    }
};

int main() {
    // Базовый наряд
    Person basicPerson;

    // Наряд с шляпой
    HatDecorator personWithHat(basicPerson);
    cout << "Outfit 1: " << personWithHat.getOutfit() << endl;

    // Наряд с шляпой и курткой
    JacketDecorator personWithHatAndJacket(personWithHat);
    cout << "Outfit 2: " << personWithHatAndJacket.getOutfit() << endl;

    return 0;
}


______________________________________________________________________________________
Общая реализация на языке С++

### Файл includes:

# include <iostream>
# include <memory>

using namespace std;


### Файл Component:

class Component
{
public:
    virtual ~Component() = default;
    virtual void operation() = 0;
};


### Файл ConcreteComponent:

class ConcreteComponent : public Component
{
public:
    void operation() override 
    { 
        cout << "ConcreteComponent; "; 
    }
};


### Файл Decorator:

class Decorator : public Component
{
protected:
    shared_ptr<Component> component;
public:
    Decorator(shared_ptr<Component> comp) : component(comp) {}
};


### Файл ConcreteDecorator:

class ConcreteDecorator : public Decorator
{
public:
    using Decorator::Decorator;
    void operation() override;
};

# pragma region Method
void ConcreteDecorator::operation()
{
    if (component)
    {
        component->operation();
        cout << "ConDecorator; ";
    }
}
# pragma endregion


### Файл Main:

int main()
{
    shared_ptr<Component> component = make_shared<ConcreteComponent>();
    shared_ptr<Component> decorator1 = make_shared<ConcreteDecorator>(component);

    decorator1->operation();
    cout << endl;

    shared_ptr<Component> decorator2 = make_shared<ConcreteDecorator>(decorator1);

    decorator2->operation();
    cout << endl;
}


______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Компоновщик (Composite)

# Назначение
Компоновщик (Composite) - структурный паттерн проектирования, который позволяет сгруппировать объекты в древовидные структуры для представления иерархий "часть-целое". Позволяет клиентам единообразно 
трактовать индивидуальные и составные объекты.

# Используется в случаях, когда:
1) Объекты могут быть как примитивными (элементарными), так и составными (сложными). 

2) Составной объект может включать в себя коллекции других объектов, образуя сложные древовидные структуры.
Пример: директория файловой системы состоит из элементов, каждый их которых также может быть директорией.

3) Код клиента работает с примитивными и составными объектами единообразно.

# Решаемые задачи
1) композиция объектов
Дает возможность представления иерархии объектов вида часть-целое. С помощью композиции можно создавать древовидные структуры объектов, группировать объекты в контейнеры и управлять ими единообразно.

2) предоставление единообразного интерфейса
Единообразная трактовка клиентами составных и индивидуальных объектов, то есть паттерн компоновщик позволяет клиентам взаимодействовать с отдельными объектами и группами объектов (составными объектами) 
через единый интерфейс.

В качестве клиентов может выступать пользовательский код или другие классы, взаимодействующие с объектами иерархии Composite.

3) создание рекурсивных операций
Паттерн компоновщик позволяет выполнять операции на составных объектах рекурсивно. Когда операция вызывается на составном объекте, он автоматически распространяет операцию на все объекты в иерархии, 
включая объекты, содержащие другие объекты. Происходит рекурсивный проход по иерархии. Таким образом, можно легко применять операции как к отдельным объектам, так и ко всему дереву объектов.

# UML диаграмма паттерна "Компоновщик"


		/-------------------\
		|     Component	    |
		|-------------------|	1..*
		| +operation()      | <=======================================\\
		| +add(Component)   |					      ||
		| +remove(Iterator) |					      ||
		| +begin()	    |					      ||
		| +end()	    |		       //===========\\	      ||
		| +isComposite()    | 		       ||	    ||	      /\
		\-------------------/		       ||	    ||	      \/
			/\			       ||	/-------------------\
			||			       ||	|     Composite     |
			||			       ||	|-------------------|
			/\			       ||	| +operation()      |
	     //========================================//	| +add(Component)   |
	     ||				   ||			| +remove(Iterator) |
	     ||				   ||			| +begin()	    |
	     ||				   ||			| +end()	    |
    /--------------------\	 /--------------------\		| +isComposite()    |
    | ConcreteComponent1 |	 | ConcreteComponentN |		\-------------------/
    |--------------------|  ...  |--------------------|
    | 	     -//-        |	 | 	  -//-        |
    \--------------------/	 \--------------------/



# Преимущества
1) упрощение архитектуры клиентского кода
Предоставление клиентскому коду удобного и единого интерфейса для работы как с отдельными, так и с составными объектами позволяет ему работать с иерархией объектов без необходимости проверять их типы и 
выбирать разные пути обработки.

2) повышение гибкости и расширяемости системы за счет добавления новых компонентов в иерархию без изменения существующего кода
3) возможность выполнения рекурсивных операций на составных объектах
4) предоставление удобных методов для добавления, удаления и обхода компонентов в иерархии объектов

# Недостатки
1) потребность в создании сущности, отвечающей за за логику сборки компоновщика, которая может оказаться нетривиальной
2) нетривиальная логика обхода и работы с сущностью как с контейнером, если в компоновщике содержатся другие компоновщики
3) потеря типизации

Использование общего интерфейса может привести к потере типизации и нарушению статической проверки типов. Появляется необходимость решать проблему типизации вынесением всех методов из компоновщика в 
класс компонента. В свою очередь, это приводит к следующей проблеме

4) появление нелогичных операций
Максимизация интерфейса класса компонент, приводит к тому, что у подклассов появляются нелогичные операции

# Связь с другими паттернами
1) Цепочка обязанностей: отношение компонент-родитель используется в паттерне цепочка обязанностей.
2) Декоратор: паттерн декоратор часто применяется совместно с компоновщиком. Когда декораторы и компоновщики используются вместе, у них обычно бывает общий родительский класс. Поэтому декораторам 
придется поддержать интерфейс компонента такими операциями, как Add, Remove.
3) Приспособленец: паттерн приспособленец позволяет разделять компоненты, но ссылаться на своих родителей они уже не могут.
4) Итератор: итератор можно использовать для обхода составных объектов.
5) Посетитель: посетитель локализует операции и поведение, которые в противном случае пришлось бы распределять между классами Composite и Leaf

Leaf – лист:
– представляет листовые узлы композиции и не имеет потомков;
– определяет поведение примитивных объектов в композиции;

Composite – составной объект:
– определяет поведение компонентов, у которых есть потомки;
– хранит компоненты-потомки;
– реализует относящиеся к управлению потомками операции в интерфейсе класса Component;

Component – компонент:
– объявляет интерфейс для компонуемых объектов;
– предоставляет подходящую реализацию операций по умолчанию, общую для всех классов;
– объявляет интерфейс для доступа к потомкам и управления ими;



______________________________________________________________________________________
Объяснение от ChatGPT

Паттерн "Компоновщик" (или "Composite") позволяет работать с группами объектов так же, как и с отдельными объектами. Это особенно полезно, когда у вас есть иерархия объектов, например, структура, где 
есть контейнеры, которые могут содержать как простые элементы, так и другие контейнеры.

Представьте, что у вас есть компания, где есть сотрудники и отделы. Отделы могут включать в себя как отдельных сотрудников, так и другие отделы. Вам нужно обрабатывать их одинаково — например, 
посчитать количество сотрудников во всей компании.

Простой объект: Это обычный сотрудник.
Контейнер: Это отдел, который может содержать как сотрудников, так и другие отделы.
С помощью паттерна "Компоновщик" вы можете создать такую структуру, где каждый элемент (будь то сотрудник или отдел) будет обрабатываться одинаково.

Пример из жизни:
Давайте представим дерево каталогов и файлов в компьютере:

Файл: Это простой элемент, который содержит данные.
Папка: Это контейнер, который может содержать как файлы, так и другие папки.
Используя "Компоновщик", вы можете создавать структуры, где папка может содержать файлы и другие папки, и вы можете обращаться с папками и файлами одинаково — например, узнать их размер.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

class FileSystemItem {
public:
    virtual ~FileSystemItem() = default;
    virtual void showDetails() const = 0;
};

class File : public FileSystemItem {
private:
    string name;
public:
    File(const string& name) : name(name) {}

    void showDetails() const override {
        cout << "File: " << name << endl;
    }
};

class Folder : public FileSystemItem {
private:
    string name;
    vector<shared_ptr<FileSystemItem>> items;
public:
    Folder(const string& name) : name(name) {}

    void add(const shared_ptr<FileSystemItem>& item) {
        items.push_back(item);
    }

    void showDetails() const override {
        cout << "Folder: " << name << endl;
        for (const auto& item : items) {
            item->showDetails();
        }
    }
};

int main() {
    // Создаем файлы
    shared_ptr<File> file1 = make_shared<File>("File1.txt");
    shared_ptr<File> file2 = make_shared<File>("File2.txt");

    // Создаем папку и добавляем в нее файлы
    shared_ptr<Folder> folder1 = make_shared<Folder>("Folder1");
    folder1->add(file1);
    folder1->add(file2);

    // Создаем еще одну папку и добавляем в нее папку и файл
    shared_ptr<Folder> folder2 = make_shared<Folder>("Folder2");
    folder2->add(folder1);
    folder2->add(make_shared<File>("File3.txt"));

    // Показать детали всех элементов в folder2
    folder2->showDetails();

    return 0;
}



______________________________________________________________________________________
Общая реализация на языке С++

### Файл includes:

# include <iostream>
# include <initializer_list>
# include <memory>
# include <vector>


### Файл using:

using namespace std;

class Component

using PtrComponent = shared_ptr<Component>;
using VectorComponent = vector<PtrComponent>;


### Файл Component:

class Component
{
public:
    using value_type = Component;
    using size_type = size_t;
    using iterator = VectorComponent::const_iterator;
    using const_iterator = VectorComponent::const_iterator;

    virtual ~Component() = default;

    virtual void operation() = 0;

    virtual bool isComposite() const 
    { 
        return false; 
    }
    virtual bool add(initializer_list<PtrComponent> comp) 
    { 
        return false; 
    }
    virtual bool remove(const iterator& it) 
    { 
        return false; 
    }
    virtual iterator begin() const 
    { 
        return iterator(); 
    }
    virtual iterator end() const 
    { 
        return iterator(); 
    }
};


### Файл Figure:

class Figure : public Component
{
public:
    virtual void operation() override 
    { 
        cout << "Figure method;" << endl; 
    }
};


### Файл Camera:

class Camera : public Component
{
public:
    virtual void operation() override 
    { 
        cout << "Camera method;" << endl; 
    }
};


### Файл Composite:

class Composite : public Component
{
private:
    VectorComponent vec;
public:
    Composite() = default;
    Composite(PtrComponent first, ...);

    void operation() override;

    bool isComposite() const override 
    { 
        return true; 
    }
    bool add(initializer_list<PtrComponent> list) override;
    bool remove(const iterator& it) override 
    { 
        vec.erase(it); return true; 
    }
    iterator begin() const override 
    { 
        return vec.begin(); 
    }
    iterator end() const override 
    { 
        return vec.end(); 
    }
};


### Файл CompositeMethods:

# pragma region Methods
Composite::Composite(PtrComponent first, ...)
{
    for (shared_ptr<Component>* ptr = &first; *ptr; ++ptr)
        vec.push_back(*ptr);
}

void Composite::operation()
{
    cout << "Composite method:" << endl;
    for (auto elem : vec)
        elem->operation();
}

bool Composite::add(initializer_list<PtrComponent> list)
{
    for (auto elem : list)
        vec.push_back(elem);
return true;
}
# pragma endregion


### Файл Main:

int main()
{
    using Default = shared_ptr<Component>;
    PtrComponent fig = make_shared<Figure>(), cam = make_shared<Camera>();
    auto composite1 = make_shared<Composite>(fig, cam, Default{});

    composite1->add({ make_shared<Figure>(), make_shared<Camera>() });
    composite1->operation();
    cout << endl;

    auto it = composite1->begin();

    composite1->remove(++it);
    composite1->operation();
    cout << endl;

    auto composite2 = make_shared<Composite>(make_shared<Figure>(), composite1, Default());

    composite2->operation();
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Мост (Bridge)

# Назначение
Мост (Bridge) - структурный паттерн, предназначенный для отделения абстракции от ее реализации так, чтобы была возможность изменять их независимо друг от друга.

# Решаемые задачи
1) возможность выбирать реализацию во время выполнения программы
Мост позволяет избежать постоянной привязки абстракции к реализации.

2) комбинирование разных абстракций и реализаций и изменение их независимо
3) избежание перекомпиляции клиентского кода при изменениях в реализации абстракции
4) полное сокрытие от клиентов реализации абстракции
5) разделение одной реализации между несколькими объектами и сокрытие деталей разделения от клиента
6) декомпозиция иерархии: позволяет управлять ростом и сложностью иерархии

Зачастую иерархию разделяют на две части: абстракцию и реализацию.
В некоторых случаях может потребоваться более чем две части для разделения иерархии на более гибкие и независимые компоненты. Количество частей зависит от конкретных требований и особенностей системы.


# UML диаграмма паттерна "Мост"


		/--------------\			/-----------------\
		| Abstraction  |			|   Implementor   |
		|--------------|/\===================>  |-----------------|
		| +operation() |\/			| +impOperation() |
		\--------------/			\-----------------/
		       /\					/\
		       ||					||
		       ||					||
		       ||					||		
		/--------------\			  /--------------\
		|	       |			  |	         |	
		|--------------| <======================= |--------------|
		|     -//-     |			  |     -//-     |
		\--------------/			  \--------------/



# Преимущества
1) избавление от дублирования кода
Дублирование кода может возникать в случае, когда несколько реализаций содержат одинаковые методы. Данную проблему можно решить вынесением одинаковых методов на более высокий уровень абстракции. 
Однако такой подход вынуждает реализовывать вынесенные методы во всех остальных экземплярах реализации

2) позволяет иерархии не разрастаться
3) сокрытие деталей реализации от клиентов
4) возможность изменять реализацию во время выполнения программы

# Недостатки
1) увеличение времени выполнения
2) тяжелый процесс реализации паттерна: введение дополнительного уровня абстракции между "реализацией" и "абстракцией"
Из-за дополнительных затрат на разработку паттерна и усложнения структуры кода появляется необходимость закладывать реализацию моста в систему на этапе проектирования

3) связь между абстрактными понятиями не всегда может быть выделена

# Связь с другими паттернами
1) Абстрактная фабрика: паттерн абстрактная фабрика может создать и сконфигурировать мост
2) Адаптер: для обеспечения совместной работы не связанных между собой классов прежде всего предназначен паттерн адаптер. Обычно он применяется в уже готовых системах. Мост же участвует в проекте с 
самого начала и призван поддерживать возможность независимого изменения абстракций и их реализаций.
3) Компоновщик: мост и компоновщик могут совместно использоваться для создания сложных структур, состоящих из связанных объектов.
4) Декоратор: мост может быть комбинирован с декоратором для добавления дополнительной функциональности к объектам абстракции и реализации.
5) Стратегия: мост может быть реализован с использованием стратегии. В этом случае, абстракция содержит ссылку на объект стратегии, который предоставляет конкретную реализацию. Стратегия может быть 
легко заменена другой, не нарушая интерфейса абстракции.



______________________________________________________________________________________
Объяснение от ChatGPT

Представь себе, что ты разрабатываешь программу для работы с разными формами (например, круги и квадраты), которые можно рисовать в различных стилях (например, синим цветом или красным). Вместо того 
чтобы создавать класс для каждой комбинации форм и стилей (например, СинийКруг, КрасныйКвадрат и т.д.), паттерн "Мост" предлагает разделить формы и стили на два независимых набора классов:

Форма: это абстракция, которая определяет общие методы для всех форм (например, нарисовать).
Стиль рисования: это реализация, которая определяет, как конкретно форма будет нарисована (например, цвет).
С помощью "Моста" ты можешь создавать новые формы и стили независимо друг от друга и комбинировать их по мере необходимости.

Пример из жизни:
Представь себе пульт дистанционного управления для телевизора.
Пульт: это абстракция, которая определяет основные действия, такие как включение, выключение, изменение канала.
Телевизор: это реализация, которая определяет, как эти действия будут выполнены. У тебя может быть пульт, который работает с разными моделями телевизоров.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

// Абстракция - форма
class Shape {
protected:
    shared_ptr<DrawStyle> style;  // Мост к реализации
public:
    Shape(shared_ptr<DrawStyle> style) : style(style) {}

    virtual void draw() = 0;
};

// Реализация - стиль рисования
class DrawStyle {
public:
    virtual void drawShape(const string& shape) = 0;
};

class Circle : public Shape {
public:
    Circle(shared_ptr<DrawStyle> style) : Shape(style) {}

    void draw() override {
        style->drawShape("Circle");
    }
};

class Square : public Shape {
public:
    Square(shared_ptr<DrawStyle> style) : Shape(style) {}

    void draw() override {
        style->drawShape("Square");
    }
};

// Конкретная реализация стиля рисования
class RedStyle : public DrawStyle {
public:
    void drawShape(const string& shape) override {
        cout << "Drawing " << shape << " in red color." << endl;
    }
};

class BlueStyle : public DrawStyle {
public:
    void drawShape(const string& shape) override {
        cout << "Drawing " << shape << " in blue color." << endl;
    }
};


int main() {
    shared_ptr<DrawStyle> redStyle = make_shared<RedStyle>();
    shared_ptr<DrawStyle> blueStyle = make_shared<BlueStyle>();

    unique_ptr<Shape> redCircle = make_unique<Circle>(redStyle);
    unique_ptr<Shape> blueSquare = make_unique<Square>(blueStyle);

    redCircle->draw();   // Вывод: Drawing Circle in red color.
    blueSquare->draw();  // Вывод: Drawing Square in blue color.

    return 0;
}


______________________________________________________________________________________
Общая реализация на языке С++

### Файл includes

# include <iostream>
# include <memory>

using namespace std;


### Файл implementor

class Implementor
{
public:
    virtual ~Implementor() = default;
    virtual void operationImp() = 0;
};


### Файл Abstraction

class Abstraction
{
protected:
    shared_ptr<Implementor> implementor;
public:
    Abstraction(shared_ptr<Implementor> imp) : implementor(imp) {}
    virtual ~Abstraction() = default;
    virtual void operation() = 0;
};



### Файл Concretelmplementor

class ConcreteImplementor : public Implementor
{
public:
    virtual void operationImp() override 
    { 
        cout << "Implementor;" << endl; 
    }
};


### Файл Entity

class Entity : public Abstraction
{
public:
    using Abstraction::Abstraction;
    virtual void operation() override 
    {     
        cout << "Entity: "; 
        implementor->operationImp(); 
    }
};


### Файл Main

int main()
{
    shared_ptr<Implementor> implementor = make_shared<ConcreteImplementor>();
    shared_ptr<Abstraction> abstraction = make_shared<Entity>(implementor);

    abstraction->operation();
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Заместитель (Proxy)

# Назначение
Паттерн проектирования заместитель (Proxy) имитирует интерфейс и поведение оригинального объекта и контролирует доступ к нему.
Заместитель (Proxy) обычно создается для того, чтобы предоставить дополнительные функции или управлять доступом к оригинальному объекту без изменения его основной логики или структуры.

Назначение паттерна заместитель заключается в добавлении дополнительного уровня абстракции между клиентом и реальным объектом.

# Решаемые задачи
1) предоставление локального объекта, который работает с удаленным объектом, скрывая детали удаленного взаимодействия [удаленный заместитель (Remote Proxy)]
2) создание заглушки для ресурсоемкого объекта, позволяющей откладывать его создание или загрузку до момента реального использования [виртуальный прокси (Virtual Proxy)]
3) контроль доступа к объекту, ограничение различных операций в зависимости от прав доступа [защищающий заместитель (Protection Proxy)]
4) выполнение дополнительных действий при доступе к объекту, например, подсчет ссылок на объект или отслеживание изменений ["умная" ссылка (Smart Reference)]
5) кэширование результатов операций объекта для избегания повторных вычислений или загрузки [кэширующий заместитель (Caching Proxy)]

# UML диаграмма паттерна "Заместитель"


			/------------\
			|    Base    |
			|------------|
			| +request() |
			\------------/
			      /\
			      ||
			      ||
			      /\
	    //===================================\\
	    ||					 ||
	    ||					 ||
    /------------\			    /------------\
    |   Object   |			    |    Proxy   |
    |------------|  1			  /\|------------|
    | +request() | <======================\/| +request() |
    \------------/			    \------------/


# Преимущества
1) контроль доступа к объекту
Позволяет реализовать механизмы безопасности, аутентификации и авторизации в системе.

2) возможность работы при отсутствии самого объекта
В этом случае поведение заместителя может быть неоднозначным. Необходимо предупреждение о возможной недостоверности ответа

3) упрощение работы с ресурсоемкими объектами, "разгрузка" тяжелого оригинального объекта
4) добавление дополнительного функционала перед или после обращения к оригинальному объекту
5) возможность отвечать за жизненный цикл объекта
6) кэширование: возможность хранить результаты операций и предоставлять их повторно без обращения к оригинальному объекту

# Недостатки
1) увеличение накладных расходов: увеличение времени выполнения операций
2) усложнение кода: необходимость в добавлении дополнительных классов и методов

# Связь с другими паттернами
1) Адаптер: предоставляет другой интерфейс к адаптируемому объекту. Напротив, заместитель в точности повторяет интерфейс своего субъекта.
Интерфейс заместителя может быть и подмножеством интерфейса субъекта.

2) Декоратор: реализация паттерна декоратор похожа на реализацию заместителя, но назначение совершенно иное. Декоратор добавляет объекту новые обязанности, а заместитель контролирует доступ к объекту.
3) Фабричный метод: заместитель может быть создан с помощью фабричного метода. Фабричный метод позволяет инкапсулировать процесс создания заместителя и предоставляет гибкость в выборе типа заместителя, 
который будет создан.

4) Одиночка: заместитель может быть реализован как одиночка, гарантируя, что будет создан только один объект заместителя для доступа к оригинальному объекту
5) Стратегия: заместитель может использоваться для введения различных стратегий доступа к объекту.



______________________________________________________________________________________
Объяснение от ChatGPT

Простое объяснение:
Представь, что у тебя есть дорогая (в плане ресурсов) операция, например, загрузка большого изображения с сервера. Если ты каждый раз загружаешь изображение напрямую, это может быть неэффективно. 
Вместо этого ты можешь создать объект-заместитель, который будет притворяться этим изображением. Когда изображение нужно будет действительно загрузить и показать, заместитель выполнит эту задачу, но 
только тогда, когда это действительно необходимо.

Пример из жизни:
Представь, что ты хочешь купить билет в кино. Ты не идёшь сразу в зал, а сначала идёшь в кассу. Кассир — это "заместитель", который проверяет, есть ли места, продаёт тебе билет и только потом пропускает
тебя в зал. Кассир контролирует доступ к кинозалу.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

// Интерфейс, который реализует и реальное изображение, и его заместитель
class Image {
public:
    virtual void display() = 0;
};

// Реальный класс изображения, который загружает изображение с сервера
class RealImage : public Image {
private:
    string filename;

public:
    RealImage(const string& filename) : filename(filename) {
        loadImageFromDisk();
    }

    void display() override {
        cout << "Displaying " << filename << endl;
    }

private:
    void loadImageFromDisk() {
        cout << "Loading " << filename << " from disk..." << endl;
    }
};

// Заместитель изображения, который загружает изображение только при необходимости
class ProxyImage : public Image {
private:
    string filename;
    unique_ptr<RealImage> realImage;

public:
    ProxyImage(const string& filename) : filename(filename) {}

    void display() override {
        if (!realImage) {
            realImage = make_unique<RealImage>(filename);
        }
        realImage->display();
    }
};


int main() {
    unique_ptr<Image> image = make_unique<ProxyImage>("test_image.jpg");

    // Изображение будет загружено и показано только при первом вызове display()
    image->display();
    cout << "Calling display again...\n";
    image->display();  // В этот раз изображение не будет загружаться заново

    return 0;
}



______________________________________________________________________________________
Общая реализация на языке С++

### Файл Includes:

# include <iostream>
# include <memory>
# include <map>
# include <random>

using namespace std;


### Файл Subject:

class Subject
{
public:
    virtual ~Subject() = default;

    virtual pair<bool, double> request(size_t index) = 0;
    virtual bool changed() 
    { 
        return true; 
    }
};


### Файл RealSubject:

class RealSubject : public Subject
{
private:
    bool flag{ false };
    size_t counter{ 0 };
public:
    virtual pair<bool, double> request(size_t index) override;
    virtual bool changed() override;
};


### Файл Proxy:

class Proxy : public Subject
{
protected:
    shared_ptr<RealSubject> realsubject;
public:
    Proxy(shared_ptr<RealSubject> real) : realsubject(real) {}
};


### Файл ConcreteProxy:

class ConcreteProxy : public Proxy
{
private:
    map<size_t, double> cache;
public:
    using Proxy::Proxy;
    virtual pair<bool, double> request(size_t index) override;
};


### Файл RealSubjectMethods:

bool RealSubject::changed()
{
    if (counter == 0)
    {
        flag = true;
    }
    if (++counter == 7)
    {
        counter = 0;
        flag = false;
    }
    return flag;
}

pair<bool, double> RealSubject::request(size_t index)
{
    random_device rd;
    mt19937 gen(rd());

    return pair<bool, double>(true, generate_canonical<double, 10>(gen));
}


### Файл ConcreteProxyMethods:

pair<bool, double> ConcreteProxy::request(size_t index)
{
    pair<bool, double> result;

    if (!realsubject)
    {
        cache.clear();
        result = pair<bool, double>(false, 0.);
    }
    else if (!realsubject->changed())
    {
        cache.clear();
        result = realsubject->request(index);
        cache.insert(map<size_t, double>::value_type(index, result.second));
    }
    else
    {
        map<size_t, double>::const_iterator it = cache.find(index);
        if (it != cache.end())
        {
            result = pair<bool, double>(true, it->second);
        }
        else
        {
            result = realsubject->request(index);
            cache.insert(map<size_t, double>::value_type(index, result.second));
        }
    }
    return result;
}


### Файл Main:
int main()
{
    shared_ptr<RealSubject> subject = make_shared<RealSubject>();
    shared_ptr<Subject> proxy = make_shared<ConcreteProxy>(subject);

    for (size_t i = 0; i < 21; ++i)
    {
        cout << "( " << i + 1 << ", " << proxy->request(i % 3).second << " )" << endl;
    if ((i + 1) % 3 == 0)
        cout << endl;
    }
}




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Фасад (Facade)

# Назначение
Паттерн фасад (Facade) относится к структурным шаблонам проектирования и предоставляет унифицированный интерфейс вместо набора интерфейсов некоторой подсистемы. Он определяет интерфейс более высокого 
уровня, который упрощает использование подсистемы.

# Решаемые задачи
1) предоставление простого интерфейса к сложной подсистеме
2) ослабление связей между компонентами системы

# UML диаграмма паттерна "Фасад"

			
				/--------\
				| Facade |
				\--------/				  /---------\
				    ||					  |         |
			//=====================================\\	  \---------/      
			||	    ||		 ||	       ||	      /\
			\/	    ||		 ||	       ||	      ||
		   /---------\	    ||		 ||	       ||    //=================\\
		   |	     |	    ||		 ||	       ||    ||  		||
		   \---------/	    ||		 ||	       \/    ||			||
				    \/ 		 ||	     /---------\	    /---------\
    /---------\			/---------\	 ||	     |         |	    |         |
    |	      |=================|	  |	 ||	     \---------/	    \---------/
    \---------/			\---------/	 ||
	/\					 ||
	||					 ||
	||	/----------\			 ||
	\\======|	   |<====================//
		\----------/



# Преимущества
1) упрощение взаимодействия: предоставление простого интерфейса к сложной подсистеме
2) снижение зависимости клиентского кода от подсистемы: работа происходит с одним объектом

# Недостатки
1) увеличение сложности и сопровождаемости фасада
Если подсистема имеет большое количество компонентов или сложную структуру, фасад рискует стать сложным, перегруженным объектом, что приведет к укреплению связей между компонентами вместо их ослабления.

# Связь с другими паттернами
1) Абстрактная фабрика: допустимо использовать вместе с фасадом, чтобы предоставить интерфейс для создания объектов подсистем способом, не зависимым от этих подсистем. Абстрактная фабрика может 
выступать и как альтернатива фасаду, чтобы скрыть платформенно-зависимые классы.
2) Посредник: аналогичен фасаду в том смысле, что абстрагирует функциональность существующих классов.
3) Одиночка: обычно требуется только один фасад. Поэтому объекты фасадов часто бывают одиночками.
4) Подписчик-издатель: фасад может применять паттерн наблюдатель для уведомления клиентов о событиях, происходящих в подсистеме.
5) Компоновщик: фасад может использовать компоновщик для предоставления единого интерфейса к группе объектов внутри подсистемы.
6) Адаптер: фасад может использовать адаптеры для преобразования интерфейсов подсистемы в интерфейс, ожидаемый клиентом



______________________________________________________________________________________
Объяснение от ChatGPT

Простое объяснение:
Представь, что у тебя есть современный дом с множеством умных устройств: умные светильники, системы отопления, музыкальные колонки и т.д. Каждый из этих устройств можно управлять через отдельное 
приложение на телефоне, но это сложно и неудобно. Вместо этого у тебя есть единое приложение, которое позволяет одним нажатием кнопки настроить всю систему — включить свет, нагреть дом, включить музыку.
Это приложение — фасад. Оно скрывает сложность взаимодействия с каждым устройством и предлагает тебе простой и удобный интерфейс.

Допустим, у тебя есть сложный набор процессов при приготовлении кофе: нужно нагреть воду, измельчить зерна, заварить кофе и налить его в чашку. Фасад в этом случае будет машиной для приготовления кофе. 
Вместо того чтобы управлять каждым процессом по отдельности, ты просто нажимаешь кнопку "Сделать кофе", и машина делает всё за тебя.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

// Классы, представляющие различные компоненты домашнего кинотеатра

class Amplifier {
public:
    // Включение усилителя
    void on() { cout << "Amplifier is on" << endl; }

    // Установка громкости
    void setVolume(int level) { cout << "Volume set to " << level << endl; }

    // Выключение усилителя
    void off() { cout << "Amplifier is off" << endl; }
};

class DvdPlayer {
public:
    // Включение DVD-плеера
    void on() { cout << "DVD Player is on" << endl; }

    // Проигрывание фильма
    void play(string movie) { cout << "Playing " << movie << endl; }

    // Выключение DVD-плеера
    void off() { cout << "DVD Player is off" << endl; }
};

class Projector {
public:
    // Включение проектора
    void on() { cout << "Projector is on" << endl; }

    // Установка широкоформатного режима
    void wideScreenMode() { cout << "Projector in widescreen mode" << endl; }

    // Выключение проектора
    void off() { cout << "Projector is off" << endl; }
};

// Класс-фасад, который упрощает взаимодействие с системой домашнего кинотеатра
class HomeTheaterFacade {
private:
    Amplifier amp;      // Усилитель
    DvdPlayer dvd;      // DVD-плеер
    Projector projector; // Проектор

public:
    // Конструктор, принимающий ссылки на компоненты системы
    HomeTheaterFacade(Amplifier a, DvdPlayer d, Projector p) : amp(a), dvd(d), projector(p) {}

    // Метод для подготовки к просмотру фильма
    void watchMovie(string movie) {
        cout << "Get ready to watch a movie..." << endl;
        amp.on();                       // Включаем усилитель
        amp.setVolume(5);               // Устанавливаем громкость
        dvd.on();                       // Включаем DVD-плеер
        dvd.play(movie);                // Проигрываем фильм
        projector.on();                 // Включаем проектор
        projector.wideScreenMode();     // Переключаем проектор в широкоформатный режим
    }

    // Метод для завершения просмотра фильма и выключения системы
    void endMovie() {
        cout << "Shutting down movie theater..." << endl;
        projector.off();    // Выключаем проектор
        dvd.off();          // Выключаем DVD-плеер
        amp.off();          // Выключаем усилитель
    }
};

int main() {
    // Создаем объекты компонентов системы
    Amplifier amp;
    DvdPlayer dvd;
    Projector projector;

    // Создаем фасад для домашнего кинотеатра
    HomeTheaterFacade homeTheater(amp, dvd, projector);

    // Используем фасад для начала просмотра фильма
    homeTheater.watchMovie("Inception");

    // Используем фасад для завершения просмотра фильма
    homeTheater.endMovie();
}


Комментарии к классам компонентов: Каждому классу (Amplifier, DvdPlayer, Projector) добавлены комментарии, поясняющие методы, которые они выполняют (включение, выключение, настройка).

Комментарии к классу HomeTheaterFacade: Здесь поясняется роль фасада как посредника, который упрощает управление сложной системой. Также описаны действия, которые выполняет каждый метод фасада 
(watchMovie, endMovie).

Комментарии в функции main: Поясняют процесс создания объектов компонентов системы и использования фасада для упрощенного управления этими компонентами.



______________________________________________________________________________________
Пример реализации паттерна фасад для подсистемы компиляции на языке С++

### Файл Scanner:

class Scanner 
{
public:
    Scanner(istream&);
    virtual ~Scanner();
    virtual Token& Scan();
private:
    istream& _inputStream;
};


### Файл Parser:

class Parser 
{
public:
    Parser();
    virtual ~Parser();
    virtual void Parse(Scanner&, ProgramNodeBuilder&);
};


### Файл ProgramNodeBuilder:

class ProgramNodeBuilder 
{
public:
    ProgramNodeBuilder();
    virtual ProgramNode* NewVariable(const char* variableName) const;
    virtual ProgramNode* NewAssignment(ProgramNode* variable, ProgramNode* expression) const;
    virtual ProgramNode* NewReturnStatement(ProgramNode* value) const;
    virtual ProgramNode* NewCondition(ProgramNode* condition,ProgramNode* truePart, ProgramNode* falsePart) const;
    ProgramNode* GetRootNode();
private:
    ProgramNode* _node;
};


### Файл ProgramNode:

class ProgramNode
{
public:
    virtual void GetSourcePosition(int& line, int& index);
    virtual void Add(ProgramNode*);
    virtual void Remove(ProgramNode*);
    virtual void Traverse(CodeGenerator&);
protected:
    ProgramNode();
};


### Файл CodeGenerator:

class CodeGenerator 
{
public:
    virtual void Visit(StatementNode*);
    virtual void Visit(ExpressionNode*);
protected:
    CodeGenerator(BytecodeStream&);
protected:
    BytecodeStream& _output;
};


### Файл Compiler:

// класс Compiler, который будет служить фасадом, позволяющим 
// собрать приведенные классы подсистемы компиляции 

class Compiler 
{
public:
    Compiler();
    virtual void Compile(istream&, BytecodeStream&);
};
void Compiler::Compile (istream& input, BytecodeStream& output) 
{
    Scanner scanner(input);
    ProgramNodeBuilder builder;
    Parser parser;
    parser.Parse(scanner, builder);
    RISCCodeGenerator generator(output);
    ProgramNode* parseTree = builder.GetRootNode();
    parseTree->Traverse(generator);
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Приспособленец (Flyweight)

# Назначение
Паттерн Приспособленец (Flyweight) — это структурный паттерн проектирования, который применяется для эффективной поддержки большого числа мелких объектов засчет разделения объектов на две части: 
внутреннее состояние (уникальная информация, специфичная для каждого объекта) и внешнее состояние (общая информация, которая может быть разделяемой между объектами)

# Решаемые задачи
1) потребность в создании огромного количество объектов, каждый из которых содержит часть информации, которая является общей для множества других объектов
2) экономия времени на создание и уничтожение объектов

# Данный паттерн проектирования будет эффективен при выполнении всех последующих условий:
1) в приложении используется большое число объектов
2) накладные расходы на хранение высоки
3) большую часть состояния объектов можно вынести вовне
4) многие группы объектов можно заменить относительно небольшим количеством разделяемых объектов, поскольку внешнее состояние вынесено
5) приложение не зависит от идентичности объекта

# UML диаграмма паттерна "Приспособленец"


		/-----------------------\			/-------------------------------\
		|    FlyweightFactory   |			|     "interface" Flyweight     |
		|-----------------------|/\			|-------------------------------|
		| +getFlyweight(in key) |\/==================> 	| +operation(in extrinsicState) |
		\-----------------------/			\-------------------------------/
			/\							  /\
			||							  ||
			||							  ||	
			||					//================/\====================\\
			||					||					||
		   /----------\					||					||
		   |  Client  |			/-------------------------------\	/-------------------------------\
		   |----------|			| ConcreteFlyweight	   	|	| UnsharedConcreteFlyweight 	|		
		   |          |			|-------------------------------|	|-------------------------------|
		   \----------/			| -intrinsicState	   	|	| -allState		    	|
			||			|-------------------------------|	|-------------------------------|
			||			| +operation(in extrinsicState) |	| +operation(in extrinsicState) |
			||			\-------------------------------/	\-------------------------------/
			||					/\					/\
			||					||					||
			\\======================================/\======================================//



# Преимущества
1) создание более гибкого и поддерживаемого кода
2) увеличение скорости выполнения ресурсоемких операций: за счет снижения нагрузки на создание и удаление объектов
3) экономия оперативной памяти

# Недостатки
1) расход процессорного времени на поиск/вычисление контекста
2) усложнение кода программы из-за введения множества дополнительных классов

# Связь с другими паттернами
1) Компоновщик: паттерн приспособленец часто используется в сочетании с компоновщиком для реализации иерархической структуры в виде ациклического направленного графа с разделяемыми листовыми вершинами.
2) Стратегия: часто наилучшим способом реализации объектов стратегии является паттерн приспособленец.



______________________________________________________________________________________
Объяснение от ChatGPT

Простое объяснение:
Представь, что ты работаешь в типографии и печатаешь огромное количество книг. Каждая книга может содержать тысячи одинаковых букв (например, букву "А"). Вместо того чтобы хранить каждую "А" отдельно 
для каждой книги, ты можешь хранить одну "А" и использовать её везде, где она нужна. Это позволяет сэкономить много бумаги (или в случае программирования — памяти).

Пример из жизни:
Представь, что ты играешь в видеоигру, в которой на экране одновременно может быть множество деревьев. Все деревья выглядят одинаково, но у каждого из них есть своя позиция на карте. Вместо того чтобы 
создавать и хранить отдельно каждый объект дерева (что бы заняло много памяти), программа создаёт один объект "дерево", который используется для отображения всех деревьев на карте, с разными позициями.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

Представим, что у нас есть игра, где на карте нужно отобразить много деревьев. Все деревья имеют одинаковый внешний вид, но различаются своим положением (координатами) на карте. Мы можем использовать 
паттерн "Приспособленец", чтобы хранить общий объект для всех деревьев (например, текстуру или модель дерева) и лишь хранить координаты для каждого конкретного дерева.

#include <iostream>
#include <vector>
#include <memory>
#include <unordered_map>
using namespace std;

// Это класс, который представляет общую модель дерева, например, текстуру. Все деревья одного типа будут использовать одну и ту же модель, экономя память.
class TreeModel {
public:
    TreeModel(string texture) : texture(texture) {}

    void display(int x, int y) const {
        cout << "Displaying tree with texture '" << texture << "' at (" << x << ", " << y << ")" << endl;
    }

private:
    string texture;
};

// Этот класс представляет конкретное дерево на карте. У каждого дерева есть свои уникальные координаты (x, y), но модель (текстура) может быть общей.
class Tree {
public:
    Tree(int x, int y, shared_ptr<TreeModel> model) : x(x), y(y), model(model) {}

    void display() const {
        model->display(x, y);
    }

private:
    int x, y; // Координаты дерева
    shared_ptr<TreeModel> model; // Общая модель дерева
};

// Фабрика для создания и управления объектами TreeModel и повторным использованием моделей деревьев. Если модель с определенной текстурой уже существует, она возвращает ссылку на неё вместо создания новой.
class TreeFactory {
public:
    shared_ptr<TreeModel> getTreeModel(const string& texture) {
        // Если модель с данной текстурой не существует, создаем ее
        if (models.find(texture) == models.end()) {
            models[texture] = make_shared<TreeModel>(texture);
        }
        return models[texture];
    }

private:
    unordered_map<string, shared_ptr<TreeModel>> models; // Карта моделей деревьев
};

int main() {
    TreeFactory treeFactory;

    // Создаем деревья с использованием общей модели
    vector<shared_ptr<Tree>> forest;
    forest.push_back(make_shared<Tree>(10, 20, treeFactory.getTreeModel("OakTexture"))); // создается несколько деревьев на карте, некоторые из них используют одну и ту же модель (например, "OakTexture"). Это позволяет экономить память, поскольку вместо хранения каждой текстуры отдельно для каждого дерева, текстура хранится единожды и используется для всех деревьев этого типа.
    forest.push_back(make_shared<Tree>(30, 40, treeFactory.getTreeModel("OakTexture")));
    forest.push_back(make_shared<Tree>(50, 60, treeFactory.getTreeModel("PineTexture")));
    forest.push_back(make_shared<Tree>(70, 80, treeFactory.getTreeModel("PineTexture")));

    // Отображаем деревья
    for (const auto& tree : forest) {
        tree->display();
    }

    return 0;
}



______________________________________________________________________________________
Общая реализация на языке С++

### Файл Glyph:

class Glyph 
{
public:
    virtual ~Glyph();
    virtual void Draw(Window*, GlyphContext&);
    virtual void SetFont(Font*, GlyphContext&);
    virtual Font* GetFont(GlyphContext&);
    virtual void First(GlyphContext&);
    virtual void Next(GlyphContext&);
    virtual bool IsDone(GlyphContext&);
    virtual Glyph* Current(GlyphContext&);
    virtual void Insert(Glyph*, GlyphContext&);
    virtual void Remove(GlyphContext&);
protected:
    Glyph();
};


### Файл Character:

class Character : public Glyph 
{
public:
    Character(char);
    virtual void Draw(Window*, GlyphContext&);
private:
    char _charcode;
};


### Файл GlyphContext:

class GlyphContext 
{
public:
    GlyphContext();
    virtual ~GlyphContext();
    virtual void Next(int step = 1);
    virtual void Insert(int quantity = 1);
    virtual Font* GetFont();
    virtual void SetFont(Font*, int span = 1);
private:
    int _index;
    BTree* _fonts;
};


### Файл GlyphFactory:

const int NCHARCODES = 128;

class GlyphFactory 
{
public:
    GlyphFactory();
    virtual ~GlyphFactory();
    virtual Character* CreateCharacter(char);
    virtual Row* CreateRow();
    virtual Column* CreateColumn();
private:
    Character* _character[NCHARCODES];
};


### Файл GlyphFactoryMethods:

# pragma region Methods
GlyphFactory::GlyphFactory () 
{
    for (int i = 0; i < NCHARCODES; ++i) 
        _character[i] = 0;
}
Character* GlyphFactory::CreateCharacter (char c) 
{
    if (!_character[c]) 
        _character[c] = new Character(c);
    return _character[c];
}
Row* GlyphFactory::CreateRow () 
{
    return new Row;
}
Column* GlyphFactory::CreateColumn () 
{
    return new Column;
}
# pragma endregion



______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Поведенческие паттерны

# Общее описание
Поведенческие паттерны - это шаблоны проектирования, которые определяют взаимодействие и коммуникацию между объектами в программе. Управляют их поведением, а также обеспечивают более гибкую и 
переиспользуемую архитектуру. Они облегчают разработку сложных систем, позволяют легко добавлять новую функциональность и изменять поведение объектов.

Поведенческие паттерны помогают разделить ответственность между объектами, упрощая поддержку и изменение логики взаимодействия. Они также повышают гибкость системы, позволяя изменять поведение объектов 
во время выполнения программы без изменения их классов.

Основная идея поведенческих паттернов состоит в том, чтобы выделить изменчивую часть кода и инкапсулировать ее в отдельные классы или объекты, чтобы они могли быть легко заменены или модифицированы без 
влияния на остальную систему.

Инкапсуляция является одним из основных принципов ООП. Она означает объединение данных и методов, работающих с этими данными, внутри класса, и предоставление интерфейса для взаимодействия с внешними 
объектами. Каждый класс, отвечающий за конкретное поведение, инкапсулирует свою собственную логику и не зависит от остальных частей системы.



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Стратегия (Strategy)

# Назначение
Паттерн Стратегия (Strategy) – это поведенческий шаблон проектирования, который предназначен для определения реализации алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это 
позволяет легко подменять и модифицировать алгоритмы во время выполнения программы без изменения класса, который их использует. Используется для того, чтобы клиентский код мог выбирать нужный вариант 
раелизации алгоритма в зависимости от контекста или условий. Каждый вариант реализации алгоритма выделяется в отдельную стратегию.

Примером такого алгоритма может быть алгоритм обработки заказов в интернет-магазине. В зависимости от способа доставки заказа (курьерская доставка, почта, самовывоз), нужно применить разные варианты 
расчета стоимости доставки.

# Решаемые задачи
1) Разделение алгоритма на отдельные классы
Паттерн позволяет выделить различные варианты реализации алгоритма в отдельные классы, что упрощает структуру кода и делает его более модульным.

2) Подмена алгоритма во время выполнения программы
Появляется возможность во время выполнения программы динамически выбирать и подменять нужную стратегию и передавать ее в основной класс для выполнения операции.

3) Изменение поведения объекта
Паттерн позволяет изменять поведение объекта без изменения самого объекта или его наследников.

# UML диаграмма паттерна "Стратегия"


		/--------------\			/--------------\
		|   Context    |			|   Strategy   |
		|--------------|/\			|--------------|
		| +operation() |\/====================> | +algotithm() |
		\--------------/			\--------------/
			/\					/\
			||					||
			||					||
			||					||
		/-----------------\			/------------------\
		| ConcreteContext |			| ConcreteStrategy |
		|-----------------|			|------------------|
		|       -//-	  |			|	-//-	   |
		\-----------------/			\------------------/


# Преимущества
1) Инкапсуляция реализации различных алгоритмов.
2) Вызов всех алгоритмов одним стандартным образом. Все конкретные стратегии реализуют общий интерфейс. Это позволяет вызывать все алгоритмы одним стандартным образом, независимо от конкретной стратегии.
3) Возможность подмены алгоритмов во время выполнения.

# Недостатки
1) Конкретная стратегия может не работать с данными определенного класса, что приводит к появлению зависимостей между конкретными сущностями и стратегиями.
2) Увеличение количества кода за счёт появления параллельных иерархий классов.

# Взаимодействие с другими паттернами
1) Паттерн Фабричный методможет использоваться для создания объектов стратегий.
2) Паттерн Декоратор может использоваться для добавления дополнительного поведения или функциональности к конкретным стратегиям. Декоратор позволяет обернуть стратегию в другой объект и добавить ему 
дополнительные возможности, не изменяя саму стратегию.

3) Паттерн Команда может использоваться для инкапсуляции вызова стратегии в отдельный объект команды. Команда может содержать ссылку на объект стратегии и вызывать его методы при выполнении команды. 
Это позволяет легко переключаться между разными стратегиями, используя различные команды.


______________________________________________________________________________________
Объяснение от ChatGPT

Стратегия — это поведенческий паттерн проектирования, который позволяет выбирать алгоритм поведения программы во время её выполнения, не меняя при этом саму программу.

Простое объяснение:
Представь, что ты занимаешься доставкой товаров. В зависимости от ситуации, ты можешь выбрать разные способы доставки: пешком, на велосипеде, на машине или грузовике. Какой бы способ ты ни выбрал, цель 
остаётся той же — доставить товар. В любой момент ты можешь изменить способ доставки, если условия изменятся (например, если станет слишком далеко, чтобы идти пешком). В программировании паттерн 
"Стратегия" работает точно так же. У тебя есть один набор действий (например, доставка товара), но ты можешь менять конкретный алгоритм выполнения этого действия (как именно доставить товар) в 
зависимости от условий.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <memory>
using namespace std;

// Интерфейс стратегии расчёта стоимости поездки. Этот метод будет реализован в разных классах.
class FareStrategy {
public:
    virtual double calculateFare(double distance) = 0;
    virtual ~FareStrategy() = default;
};

// Конкретная стратегия для города. (Это конкретные стратегии, которые реализуют расчёт стоимости для разных условий (город и загород).)
class CityFare : public FareStrategy {
public:
    double calculateFare(double distance) override {
        return distance * 2.0; // Городской тариф: 2.0 единицы за км
    }
};

// Конкретная стратегия для поездок за город
class SuburbanFare : public FareStrategy {
public:
    double calculateFare(double distance) override {
        return distance * 3.0; // За городом: 3.0 единицы за км
    }
};

// Класс, который использует выбранную стратегию расчёта стоимости. Он может легко переключаться между разными стратегиями в зависимости от условий.
class TaxiMeter {
private:
    unique_ptr<FareStrategy> strategy;

public:
    TaxiMeter(unique_ptr<FareStrategy> strat) : strategy(move(strat)) {}

    double calculateFare(double distance) {
        return strategy->calculateFare(distance);
    }
};

int main() {
    double distance = 10; // Например, 10 км
    
    // Создаём таксометр с городской стратегией
    TaxiMeter cityMeter(make_unique<CityFare>());
    cout << "City fare for " << distance << " km: " << cityMeter.calculateFare(distance) << endl;

    // Меняем стратегию на загородную
    TaxiMeter suburbanMeter(make_unique<SuburbanFare>());
    cout << "Suburban fare for " << distance << " km: " << suburbanMeter.calculateFare(distance) << endl;
}


______________________________________________________________________________________
Общая реализация на языке С++

### Файл Strategy:

class Strategy
{
public:
    virtual void algorithmSort(shared_ptr<double[]> ar, unsigned cnt) = 0;
};


### Файл BustStrategy:

template <typename TComparison>
class BustStrategy : public Strategy
{
public:
	virtual void algorithmSort(shared_ptr<double[]> ar, unsigned cnt) override
	{
		for (int i = 0; i < cnt - 1; i++)
			for (int j = i + 1; j < cnt; j++)
			{
				if (TComparison::compare(ar[i], ar[j]) > 0)
					swap(ar[i], ar[j]);
			}
	}
};


### Файл Array:

class Array
{
public:
	Array(initializer_list<double> list)
	{
		this->count = list.size();
		this->arr = shared_ptr<double[]>(new double[this->count]);
	
		unsigned i = 0;
		for (auto elem : list)
			arr[i++] = elem;
	}

	void sort(shared_ptr<Strategy> algorithm
	{
		algorithm->algorithmSort(this->arr, this->count);
	}

	const double& operator [](int index) const 
	{ 
		return this->arr[index]; 
	}
	
	unsigned size() const 
	{ 
		return count; 
	}

private:
	shared_ptr<double[]> arr;
	unsigned count;
};


### Файл Comparison:

template <typename Type>
class Comparison
{
public:
	static int compare(const Type& elem1, const Type& elem2) { return elem1 - elem2; }
};

ostream& operator <<(ostream& os, const Array& ar)
{
	for (int i = 0; i < ar.size(); i++)
		os << " " << ar[i];
	return os;
}


### Файл Main:

# include <iostream>
# include <memory>
# include <initializer_list>

using namespace std;

void main()
{
	using TStrategy = BustStrategy<Comparison<double>>;
	shared_ptr<Strategy> strategy = make_shared<TStrategy>();

	Array ar{ 8., 6., 4., 3., 2., 7., 1. };

	ar.sort(strategy);

	cout << ar << endl;
}


______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Команда (Command)

# Назначение
Паттерн Команда (Command) — это поведенческий шаблон проектирования, который позволяет инкапсулировать запрос на выполнение действия в виде отдельного объекта. Создается абстрактный интерфейс, который 
определяет метод, используемый для выполнения команд. Каждая конкретная команда реализует этот интерфейс и предоставляет свою собственную реализацию метода, соответствующую своей операции. Используется 
когда необходимо управлять последовательным выполнением действий над объектом.
 
# Решаемые задачи
1) Организация очереди или журнала действий
Паттерн позволяет создавать очередь запросов или вести журнал действий. Появляется возможность добавлять команды в очередь в определенном порядке, а затем последовательно их вызывать.

2) Разделение ответственностей
Паттерн позволяет разделить логику выполнения операций от объектов, которые инициируют эти операции. Различные компоненты системы, которые требуют выполнения определенных операций, не знают о деталях 
реализации этих операций. Они работают с абстрактным интерфейсом, который определяет метод для выполнения действия, а конкретные команды реализуют этот интерфейс.

3) Реализация набора действий над объектом
Появляется возможность создавать набор операций над объектом: операция выполнения, отмены и повтора действия.

UML диаграмма паттерна "Команда"


		/------------\
		|  Command   |
		|------------| <==========================\\
		| +execute() |				  ||
		\------------/				  ||
		      /\				  ||
		      ||				  ||
		      /\				  ||
	//===============================\\		  ||
	||				 ||		  ||
	||				 ||		  ||
  /-----------------\		/------------------\	  ||
  | ConcreteCommand |		| CompositeCommand |	  ||
  |-----------------|		|------------------|/\	  ||
  |      -//-       |		|	-//-	   |\/====//
  \-----------------/		\------------------/



# Преимущества
1) Уменьшение зависимости между объектами. Это связано с тем, что объекты-инициаторы не привязаны напрямую к объектам, которые выполняют операции.
2) Возможность формирования очереди команд.
3) Унификация обработки событий или запросов к системе. Паттерн повзоляет инкапсулировать операции в отдельные команды и предоставляет единый интерфейс для их обработки.

# Недостатки
1) Требуется изначально знать, кто может обработать команду и какое конкретное действие должно быть совершено.
2) По умолчанию команда выполняется только над одним объектом. Это связано с тем, что каждая команда инкапсулирует конкретное действие и ссылается на конкретный объект-получатель для его выполнения. 
Однако, если требуется, чтобы команда была выполнена над несколькими объектами, то можно столкнуться с ограничениями: усложнение логики команды, обработка конфликтов и т.д.

3) Увеличение количества и усложнение структуры кода за счет появления новых иерархий классов.

# Связь с другими паттернами
1) Паттерн Цепочка обязанностей может использоваться вместе с паттерном команда. Цепочка обязанностей позволяет создать цепочку объектов-обработчиков, где каждый объект может обработать команду или 
передать ее следующему объекту в цепочке.
2) Используя паттерн Компоновщик, можно создавать сложные команды, состоящие из нескольких простых команд или даже других составных команд. Это позволяет строить иерархические структуры команд.
3) Паттерн Фабричный метод может быть использован для создания различных типов команд. Фабричный метод может инкапсулировать процесс создания команды и предоставить подклассам возможность создавать 
конкретные команды в соответствии с требованиями системы.


______________________________________________________________________________________
Объяснение от ChatGPT

Паттерн Команда позволяет превращать запросы или операции в самостоятельные объекты. Это упрощает управление операциями, позволяет легко отменять и повторять действия, а также помогает строить гибкие 
системы с возможностью комбинировать операции.

Простое объяснение:
Представь, что ты управляешь телевизором. Ты можешь нажимать кнопки на пульте, чтобы включить телевизор, изменить канал или регулировать громкость. Каждая кнопка пульта управляет определенной командой 
(например, «включить телевизор», «переключить канал» и т.д.).

В паттерне Команда каждая операция (включение, переключение, выключение) оформляется как отдельный объект — команда. Этот объект знает, как выполнить действие, и его можно передать кому-то другому 
(например, записать в очередь, сохранить для повторного выполнения или отмены).

Реальный пример:
В текстовом редакторе каждая кнопка, например "Отменить" или "Повторить", может быть реализована как команда. Эти команды можно сохранять, чтобы потом можно было отменить или повторить действия 
пользователя.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <memory>
#include <vector>

using namespace std;

// Интерфейс команды
class Command {
public:
    virtual ~Command() = default;
    virtual void execute() = 0;
};

// Класс телевизора, который будет выполнять команды. Это наш «исполнитель», он знает, как выполнять действия (включение, выключение, смена канала).
class TV {
public:
    void on() { cout << "TV is ON" << endl; }
    void off() { cout << "TV is OFF" << endl; }
    void changeChannel(int channel) { cout << "Channel changed to " << channel << endl; }
};

// Команда для включения телевизора. Каждая команда представляет собой объект, который содержит ссылку на TV и знает, как вызвать нужный метод (on(), off(), changeChannel()).
class TVOnCommand : public Command {
public:
    TVOnCommand(shared_ptr<TV> tv) : tv(tv) {}
    void execute() override { tv->on(); }

private:
    shared_ptr<TV> tv;
};

// Команда для выключения телевизора
class TVOffCommand : public Command {
public:
    TVOffCommand(shared_ptr<TV> tv) : tv(tv) {}
    void execute() override { tv->off(); }

private:
    shared_ptr<TV> tv;
};

// Команда для смены канала на телевизоре
class TVChangeChannelCommand : public Command {
public:
    TVChangeChannelCommand(shared_ptr<TV> tv, int channel) : tv(tv), channel(channel) {}
    void execute() override { tv->changeChannel(channel); }

private:
    shared_ptr<TV> tv;
    int channel;
};

// Пульт управления, который может выполнять команды. Это объект, который может принимать команду и выполнять её по нажатию кнопки. Он не знает, что делает команда, он просто вызывает метод execute().
class RemoteControl {
public:
    void setCommand(shared_ptr<Command> command) {
        this->command = command;
    }

    void pressButton() {
        if (command) command->execute();
    }

private:
    shared_ptr<Command> command;
};

int main() {
    shared_ptr<TV> tv = make_shared<TV>();

    // Создаем команды
    shared_ptr<Command> tvOn = make_shared<TVOnCommand>(tv);
    shared_ptr<Command> tvOff = make_shared<TVOffCommand>(tv);
    shared_ptr<Command> changeChannel = make_shared<TVChangeChannelCommand>(tv, 5);

    // Используем пульт управления
    RemoteControl remote;

    remote.setCommand(tvOn);
    remote.pressButton();

    remote.setCommand(changeChannel);
    remote.pressButton();

    remote.setCommand(tvOff);
    remote.pressButton();

    return 0;
}


______________________________________________________________________________________
Общая реализация на языке С++

### Файл Command:

template <typename Reseiver>
class Command
{
public:
	virtual ~Command() = default;
	
	virtual void execute(shared_ptr<Reseiver>) = 0;
};



### Файл ConcreteCommand:

template <typename Reseiver>
class ConcreteCommand : public Command<Reseiver>
{
	using Action = void(Reseiver::*)();
private:
	Action act;

public:
	ConcreteCommand(Action a) : act(a) {}

	virtual void execute(shared_ptr<Reseiver> r) override { ((*r).*act)(); }
};


### Файл Object:

class Object
{
public:
    virtual void run() = 0; 
};


### Файл ConcreteObject:

class ConcreteObject : public Object
{
public:
	virtual void run() override 
	{ 
		cout << "Run method;" << endl; 
	}
};

### Файл Main:

# include <iostream>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<Command<Object>> command = make_shared<SimpleCommand<Object>>(&Object::run);

	shared_ptr<Object> obj = make_shared<ConObject>();

	command->execute(obj);
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Цепочка обязанностей (Chain of Responsibility)

# Назначение
Паттерн Цепочка обязанностей (Chain of Responsibility) – это поведенческий шаблон проектирования, который позволяет создать цепочку объектов-обработчиков. Паттерн не требует связи запроса с конкретным 
объектом и методом, а несет в себе только данные запроса. Каждый обработчик знает, какой объект он может обработать. Если обработчик не может совершить действие над запросом, он передаёт его следующему,
пока один из обработчиков не сможет обработать запрос. Используется, когда нужно предоставить различные варианты обработки запросов или когда необходимо динамически изменять порядок обработки.

Примером системы, использующей этот паттерн может быть система обработки запросов клиентов в банке. Запросы могут быть разного типа (запрос на открытие счета, запрос на получение кредита и т. д.). 
Каждый тип запроса может иметь свои собственные правила и условия обработки.

# Решаемые задачи
1) Разделение ответственности.
Паттерн позволяет разделить логику обработки запросов на отдельные объекты. Каждый объект имеет свою конкретную обязанность.
2) Избавление от жесткой зависимости объекта и действия над ним.
Клиентский код не зависит от конкретных обработчиков и их порядка в цепочке. Он просто передает запрос в начало цепочки, и дальнейшая обработка происходит автоматически.

# UML диаграмма паттерна "Цепочка обязанностей"


		/---------------\
		|     Handler 	|
		|---------------|
		|   +handle() 	|
		| +add(handler) |
		\---------------/
			/\
			||
			||
			/\
	 //=====================\\
 	 ||			||
	 ||			||
   /-----------\     	/-----------\
   | ConcreteA |     	| ConcreteZ |
   |-----------|  ... 	|-----------|
   |	-//-   |     	|   -//-    |
   \-----------/     	\-----------/



# Преимущества
1) Возможность легко встроить новый объект обработчик в цепь.
2) Запрос может обрабатываться несколькими объектами. Каждый обработчик выполняет свою часть работы и может изменять или расширять данные запроса перед передачей его следующему обработчику.
3) Запрос не связан конкретным объектом или методом.

# Недостатки
1) Если нужный обработчик не был найден, то запрос игнорируется.
2) Требуется реализация сущности, ответственной за принятие решений о создании, удалении и упорядочивании обработчиков в списке.
3) Производительность системы ухудшается, если запросу нужно пройти через большое количество лишних обработчиков.

# Связь с другими паттернами.
1) Паттерн может использоваться вместе с паттерном Компоновщик для создания иерархической структуры объектов-обработчиков. Обработчики могут быть объединены в древовидную структуру, где каждый узел 
может быть либо цепочкой обработчиков, либо конкретным обработчиком.
2) Паттерн может быть комбинирован с паттерном Декоратор для добавления дополнительной функциональности к обработчикам в цепочке. Декораторы могут обернуть обработчики и добавить новую функциональность 
без изменения их базового поведения.
3) Паттерн может работать вместе с паттерном Стратегия для определения различных способов обработки запросов. Обработчики могут быть реализованы в виде стратегий, которые могут быть выбраны и заменены 
во время выполнения программы.



______________________________________________________________________________________
Объяснение от ChatGPT

Пример из жизни:
Представьте, что вы находитесь в большом офисе, и вам нужно утвердить новый проект. Для этого необходимо пройти несколько этапов утверждения:

Менеджер проекта: Сначала проект рассматривает ваш непосредственный менеджер. Он может утвердить его, если проект укладывается в бюджет и сроки.
Руководитель отдела: Если менеджер проекта не может утвердить проект (например, проект выходит за рамки его полномочий), он передает запрос на утверждение своему руководителю.
Генеральный директор: Если руководитель отдела также не может утвердить проект, запрос передается на утверждение генеральному директору.

Таким образом, запрос последовательно проходит через цепочку людей, каждый из которых решает, может ли он его утвердить. Если нет, запрос передается дальше по цепочке.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <memory>

// Базовый класс обработчика
class Handler {
public:
    virtual ~Handler() = default;

    // Метод для обработки запроса или передачи его дальше по цепочке
    void setNext(std::shared_ptr<Handler> nextHandler) {
        next = nextHandler;
    }

    virtual void handleRequest(int amount) {
        if (next) {
            next->handleRequest(amount);
        } else {
            std::cout << "No handler could process the request." << std::endl;
        }
    }

protected:
    std::shared_ptr<Handler> next;
};

// Конкретный обработчик: Менеджер проекта
class ProjectManager : public Handler {
public:
    void handleRequest(int amount) override {
        if (amount <= 1000) {
            std::cout << "ProjectManager approved request of $" << amount << std::endl;
        } else {
            Handler::handleRequest(amount);
        }
    }
};

// Конкретный обработчик: Руководитель отдела
class DepartmentHead : public Handler {
public:
    void handleRequest(int amount) override {
        if (amount <= 10000) {
            std::cout << "DepartmentHead approved request of $" << amount << std::endl;
        } else {
            Handler::handleRequest(amount);
        }
    }
};

// Конкретный обработчик: Генеральный директор
class CEO : public Handler {
public:
    void handleRequest(int amount) override {
        if (amount > 10000) {
            std::cout << "CEO approved request of $" << amount << std::endl;
        } else {
            Handler::handleRequest(amount);
        }
    }
};

// Клиентский код
int main() {
    auto manager = std::make_shared<ProjectManager>();
    auto head = std::make_shared<DepartmentHead>();
    auto ceo = std::make_shared<CEO>();

    // Формируем цепочку: менеджер проекта -> руководитель отдела -> генеральный директор
    manager->setNext(head);
    head->setNext(ceo);

    // Подаем запросы на утверждение
    manager->handleRequest(500);    // ProjectManager approved request of $500
    manager->handleRequest(5000);   // DepartmentHead approved request of $5000
    manager->handleRequest(20000);  // CEO approved request of $20000

    return 0;
}


______________________________________________________________________________________
Общая реализация на языке С++

### Файл AbstractHandler:

class AbstractHandler
{
	using PtrAbstractHandler = shared_ptr<AbstractHandler>;
protected:
	PtrAbstractHandler next;

	virtual bool run() = 0;

public:
	using Default = shared_ptr<AbstractHandler>;

	virtual ~AbstractHandler() = default;

	virtual bool handle() = 0;

	void add(PtrAbstractHandler node);
	void add(PtrAbstractHandler node1, PtrAbstractHandler node2, ...);
	void add(initializer_list<PtrAbstractHandler> list);
};


### Файл ConcreteHandler:

class ConcreteHandler : public AbstractHandler
{
private:
	bool condition
	{ 
		false 
	};

protected:
	virtual bool run() override 
	{ 
		cout << "Method run;" << endl; 
		return true; 
	}

public:
	ConcreteHandler() : ConcreteHandler(false) {}
	
	ConcreteHandler(bool c) : condition(c) 
	{ 
		cout << "Constructor;" << endl; 
	}
	
	virtual ~ConcreteHandler() override 
	{ 
		cout << "Destructor;" << endl; 
	}

	virtual bool handle() override
	{
		if (!condition) return next ? next->handle() : false;

		return run();
	}

};


### Файл Methods:

#pragma region Methods

void AbstractHandler::add(PtrAbstractHandler node)
{
	if (next)
		next->add(node);
	else
		next = node;
}

void AbstractHandler::add(PtrAbstractHandler node1, PtrAbstractHandler node2, ...)
{
	for (Default* ptr = &node1; *ptr; ++ptr)
		add(*ptr);
}

void AbstractHandler::add(initializer_list<PtrAbstractHandler> list)
{
	for (auto elem : list)
		add(elem);
}

#pragma endregion


### Файл Main:

# include <iostream>
# include <initializer_list>
# include <memory>

using namespace std;

int main()
{
	shared_ptr<AbstractHandler> chain = make_shared<ConcreteHandler>();

	chain->add(
		{
		make_shared<ConcreteHandler>(false),
		make_shared<ConcreteHandler>(true),
		make_shared<ConcreteHandler>(true),
		AbstractHandler::Default()
		}
	);

	cout << "Result = " << chain->handle() << ";" << endl;
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Подписчик-издатель (Publisher-subscriber) (Очень похож на паттерн Наблюдатель. Или это вообще одно и тоже?)

Паттерн Подписчик-издатель (Publisher-subscriber) – поведенческий шаблон проектирования, позволяющий установить зависимость между объектами таким образом, чтобы при изменении состояния одного объекта 
(Издателя) все зависимые от него объекты (Подписчики) автоматически уведомлялись и обновлялись. У издателя определены методы подписки/отписки на изменения его состояния. Используется, когда часто надо 
передавать какое-то обновление многим объектам на этапе выполнения программы.

# Решаемые задачи
1) Уведомление об изменениях
Паттерн позволяет объектам автоматически уведомлять друг друга о произошедших изменениях или событиях, что помогает поддерживать согласованность данных между объектами.

2) Разделение ответственностей
Паттерн позволяет отделить логику обработки событий от объектов, генерирующих эти события.

# UML диаграмма паттерна "Подписчик-издатель"


			/----------------\				/------------\
			|    Publisher	 |			0..*  	| Subscriber |
			|----------------|/\==========================> |------------|
			| +subscribe()   |\/		  \  /		| +method1() |
			| +unsubscribe() |		   \/	      /\| +method2() |
			| +operation()   | <==========================\/\------------/
			\----------------/		   /\		      /\
							  /  \		      ||
									      ||
									      ||
									/--------------------\
									| ConcreteSubscriber |
									|--------------------|
									|	 -//-	     |
									\--------------------/


# Преимущества
1) Издатели не зависят от конкретных подписчиков и могут отправлять уведомления или запросы без прямой зависимости от них.
2) Подписчики могут подписаться/отписаться на издателя во время исполнения программы.

# Недостатки
1) Возможна утечка памяти при циклической зависимости.
Циклическая зависимость происходит когда объект A подписывается на уведомления объекта B, а объект B в свою очередь подписывается на уведомления объекта A. Это означает, что каждый объект ссылается на 
другой объект, и они не могут быть удалены из памяти, так как они всегда ссылаются друг на друга. Такая ситуация может привести к утечке памяти, поскольку объекты будут продолжать существовать в памяти,
даже если они больше не нужны. (Возможно для решения этой проблемы нужен weak_ptr. Это мои догадки.)

2) Произвольный порядок оповещения подписчиков.
3) Необходимость держать список подписчиков. Издатели должны хранить список своих подписчиков для того, чтобы иметь возможность отправлять им уведомления или запросы. При удалении издателя, необходимо 
отписать всех подписчиков из списка, чтобы избежать утечек памяти и нежелательного взаимодействия.

# Связь с другими паттернами
1) Паттерн Фасад может быть использован для создания удобного интерфейса для взаимодействия с паттерном. Фасад может скрыть сложности подписки, отписки и уведомлений, предоставляя простой интерфейс для 
взаимодействия с издателями и подписчиками.
2) Паттерн Посредник может быть использован вместе с паттерном для управления сложными взаимодействиями между объектами. Посредник может выступать в роли издателя, а другие объекты могут быть 
подписчиками, взаимодействуя через посредника.
3) Паттерн Цепочка обязанностей может быть использован для обработки уведомлений, полученных от издателей. Каждый объект в цепочке может быть подписчиком, который обрабатывает уведомления, а затем 
передает их следующему объекту в цепочке, если не может обработать сам.


______________________________________________________________________________________
Объяснение от ChatGPT

Пример из жизни:
Представьте, что у вас есть блог, и вы регулярно пишете статьи. Ваши читатели могут подписаться на обновления вашего блога. Каждый раз, когда вы публикуете новую статью, всем подписчикам автоматически отправляется уведомление о новом материале.

Издатель: Это вы, автор блога. Вы создаете контент и уведомляете своих подписчиков о новых публикациях.
Подписчики: Это ваши читатели. Они подписываются на ваш блог, чтобы получать уведомления о новых статьях.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <vector>
#include <memory>
#include <string>

// Базовый класс подписчика. Интерфейс или базовый класс, который определяет метод update(), который будет вызван при получении уведомления.
class Subscriber {
public:
    virtual ~Subscriber() = default;
    virtual void update(const std::string& message) = 0;
};

// Конкретный подписчик. Реализация подписчика, который выводит новость на экран.
class NewsReader : public Subscriber {
public:
    NewsReader(const std::string& name) : name(name) {}

    void update(const std::string& message) override {
        std::cout << name << " received news: " << message << std::endl;
    }

private:
    std::string name;
};

// Класс издателя. Этот класс управляет списком подписчиков и уведомляет их о новостях с помощью метода notifySubscribers().
class NewsPublisher {
public:
    void subscribe(std::shared_ptr<Subscriber> subscriber) {
        subscribers.push_back(subscriber);
    }

    void unsubscribe(std::shared_ptr<Subscriber> subscriber) {
        subscribers.erase(
            std::remove(subscribers.begin(), subscribers.end(), subscriber), 
            subscribers.end());
    }

    void notifySubscribers(const std::string& message) {
        for (const auto& subscriber : subscribers) {
            subscriber->update(message);
        }
    }

    void publishNews(const std::string& news) {
        std::cout << "Publishing news: " << news << std::endl;
        notifySubscribers(news);
    }

private:
    std::vector<std::shared_ptr<Subscriber>> subscribers;
};

// Клиентский код. Подписывает подписчиков на новости и публикует новости через издателя.
int main() {
    auto publisher = std::make_shared<NewsPublisher>();

    auto reader1 = std::make_shared<NewsReader>("Alice");
    auto reader2 = std::make_shared<NewsReader>("Bob");

    publisher->subscribe(reader1);
    publisher->subscribe(reader2);

    publisher->publishNews("New C++ version released!");

    publisher->unsubscribe(reader1);

    publisher->publishNews("Python 4.0 is out!");

    return 0;
}


______________________________________________________________________________________
Общая реализация на языке С++

### Файл Subscriber:

class Subscriber
{
public:
	virtual ~Subscriber() = default;

	virtual void method() = 0;
};

using Reseiver = Subscriber;


### Файл Publisher:

class Publisher
{
	using Action = void(Reseiver::*)();
	
	using Pair = pair<shared_ptr<Reseiver>, Action>;
private:
	vector<Pair> callback;

	int indexOf(shared_ptr<Reseiver> r);

public:
	bool subscribe(shared_ptr<Reseiver> r, Action a);
	bool unsubscribe(shared_ptr<Reseiver> r);
	
	void run();
};


### Файл ConcreteSubscriber:

class ConcreteSubscriber : public Subscriber
{
public:
	virtual void method() override 
	{ 
		cout << "method;" << endl; 
	}
};


### Файл MethodsPublisher:

#pragma region Methods Publisher

bool Publisher::subscribe(shared_ptr<Reseiver> r, Action a)
{
	if (indexOf(r) != -1) return false;

	Pair pr(r, a);

	callback.push_back(pr);

	return true;
}

bool Publisher::unsubscribe(shared_ptr<Reseiver> r)
{
	int pos = indexOf(r);

	if (pos != -1)
		callback.erase(callback.begin() + pos);

	return pos != -1;
}

void Publisher::run()
{
	cout << "Run:" << endl;
	for (auto elem : callback)
		((*elem.first).*(elem.second))();
}

int Publisher::indexOf(shared_ptr<Reseiver> r)
{
	int i = 0;
	for (auto it = callback.begin(); it != callback.end() && r != (*it).first; i++, ++it);

	return i < callback.size() ? i : -1;
}

#pragma endregion


### Файл Main:

# include <iostream>
# include <memory>
# include <vector>

using namespace std;

int main()
{
	shared_ptr<Subscriber> subscriber1 = make_shared<ConSubscriber>();
	shared_ptr<Subscriber> subscriber2 = make_shared<ConSubscriber>();
	shared_ptr<Publisher> publisher = make_shared<Publisher>();

	publisher->subscribe(subscriber1, &Subscriber::method);
	if (publisher->subscribe(subscriber2, &Subscriber::method))
		publisher->unsubscribe(subscriber1);

	publisher->run();
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Посетитель (Visitor)

# Назначение
1) Идея поведенческого паттерна проектирования посетитель (Visitor) заключается в объединении различных стратегий в одну иерархию и предоставлении возможности объектам принимать посетителей (visitors) для 
выполнения определенных операций.

2) Расширяется функциональность объектов без изменения их структуры.
3) Посетитель позволяет выполнить нужные действия в зависимости от типов объектов.

# Решаемые задачи
1) возможность выполнять операции (зависящие от конкретных классов) над объектами многих классов с различными интерфейсами
2) объединение родственных операций в один класс
Если структура объектов является общей для нескольких приложений, то паттерн посетитель позволит в каждое приложение включить только относящиеся к нему операции.

3) определение новых операций без изменения классов
4) разделение ответственности между классами: вынесение операций, находящихся в самих классах, в отдельные классы-посетители



		/------------------\				/------------------\
		|      Elment 	   |				|      Visitor     |
		|------------------| ========================> 	|------------------|
		| +accept(Visitor) |				| +visit(ElementA) |
		|       -//-	   |				|	...	   |
		\------------------/				| +visit(ElementZ) |
			/\					\------------------/
			||						/\
			||						||
			||						||
		   /----------\					/-----------------\
		   | ElementA |					| ConcreteVisitor |
		   |----------| <==============================	|-----------------|
		   |   -//-   |					| 	-//-	  |
		   \----------/					\-----------------/



# Преимущества
1) объединение разных иерархий в одну (решение проблемы стратегии)
2) значительное упрощение схемы использования
3) отсутствие оберточных функций (решение проблемы адаптера)
4) открытость кода для расширения: добавление новых классов-посетителей позволяет расширять функциональность без изменения существующего кода
5) упрощение поддержки разных типов объектов

# Недостатки
1) расширение иерархии, добавление новых классов приводит к необходимости модификации посетителей
Неудобство при добавлении новых типов объектов: требуется изменение всех классов посетителей.

2) необходимость установления дружественных связей для обеспечения доступа к реализации
Посетитель получает доступ к внутреннему состоянию объекта, с которым взаимодействует. Это может привести к потенциальному раскрытию деталей реализации объектов и нарушению принципа инкапсуляции.

3) проблема связи на уровне базовых классов
Происходит из-за сильной зависимости между посетителем и элементами, которые он посещает.

# Связь с другими паттернами
1) Компоновщик: посетители могут использоваться для выполнения операции над всеми объектами структуры, определенной с помощью паттерна компоновщик.
2) Посредник: посетитель может быть связан с паттерном посредник для обмена информацией между различными объектами в системе. Посредник может передавать посетителям необходимую информацию о состоянии 
объектов, чтобы они могли выполнить соответствующие операции. 
3) Стратегия: посетитель может быть связан с паттерном стратегия для предоставления различных стратегий обработки элементов структуры. Посетитель может быть реализован как одна из стратегий, которая 
может быть выбрана во время выполнения в зависимости от требуемой операции.


______________________________________________________________________________________
Объяснение от ChatGPT

Паттерн "Посетитель" (Visitor) позволяет добавлять новые операции к существующим объектам без изменения их структуры. Это достигается за счет разделения операций и объектов, над которыми эти операции 
выполняются.

Пример из жизни:
Представьте, что у вас есть зоопарк, где обитают различные животные: львы, слоны, жирафы и так далее. Допустим, вы хотите выполнять разные действия с этими животными, например, кормить их, показывать 
их посетителям или проверять их здоровье.
Если вы будете добавлять каждое новое действие прямо в класс животного, то со временем ваш код станет сложным и громоздким, особенно если нужно будет добавлять новые типы животных или новые действия.
Паттерн "Посетитель" позволяет решить эту проблему, вводя отдельный объект (посетитель), который выполняет операции над животными, а животные просто "принимают" посетителя и передают ему управление.

Как это работает:
Элементы (Животные): У вас есть набор классов, представляющих различные виды животных. В каждом классе животного есть метод accept, который принимает посетителя.

Посетитель: Это класс, который реализует различные действия, выполняемые над животными. Например, может быть посетитель для кормления, посетитель для осмотра или посетитель для демонстрации.

Метод accept: Этот метод вызывается для каждого животного, и он передает посетителя внутрь животного. Затем посетитель выполняет нужную операцию в зависимости от типа животного.



______________________________________________________________________________________
Упрощённая реализация от ChatGPT

У нас есть разные виды животных: Лев и Слон.
У каждого животного есть метод accept, который принимает объект типа Посетитель.
Посетитель (в данном случае Доктор) выполняет разные действия с животными. В нашем примере доктор осматривает каждого животного, и действия зависят от типа животного.

#include <iostream>
#include <memory>
#include <vector>

// Базовый класс Животного
class Animal {
public:
    virtual ~Animal() = default;
    virtual void accept(class AnimalVisitor& visitor) = 0;
};

// Конкретный класс Льва
class Lion : public Animal {
public:
    void accept(AnimalVisitor& visitor) override;
};

// Конкретный класс Слона
class Elephant : public Animal {
public:
    void accept(AnimalVisitor& visitor) override;
};

// Базовый класс Посетителя
class AnimalVisitor {
public:
    virtual void visit(Lion& lion) = 0;
    virtual void visit(Elephant& elephant) = 0;
};

// Реализация метода accept для Льва
void Lion::accept(AnimalVisitor& visitor) {
    visitor.visit(*this);
}

// Реализация метода accept для Слона
void Elephant::accept(AnimalVisitor& visitor) {
    visitor.visit(*this);
}

// Конкретный посетитель - Доктор
class Doctor : public AnimalVisitor {
public:
    void visit(Lion& lion) override {
        std::cout << "Доктор осматривает льва." << std::endl;
    }

    void visit(Elephant& elephant) override {
        std::cout << "Доктор осматривает слона." << std::endl;
    }
};

int main() {
    std::vector<std::unique_ptr<Animal>> zoo;
    zoo.push_back(std::make_unique<Lion>());
    zoo.push_back(std::make_unique<Elephant>());

    Doctor doctor;

    for (auto& animal : zoo) {
        animal->accept(doctor);
    }
}



______________________________________________________________________________________
Общая реализация на языке С++

### Файл Visitor:

class Circle;
class Rectangle;

class Visitor
{
public:
    virtual ~Visitor() = default;
    virtual void visit(Circle& ref) = 0;
    virtual void visit(Rectangle& ref) = 0;
};


### Файл Shape:

class Shape
{
public:
    virtual ~Shape() = default;
    virtual void accept(shared_ptr<Visitor> visitor) = 0;
};


### Файл Circle:

class Circle : public Shape
{
public:
    void accept(shared_ptr<Visitor> visitor) override 
    { 
        visitor->visit(*this); 
    }
};


### Файл Rectangle:

class Rectangle : public Shape
{
public:
    void accept(shared_ptr<Visitor> visitor)  override 
    { 
        visitor->visit(*this); 
    }
};


### Файл ConcreteVisitor:

class ConcreteVisitor : public Visitor
{
public:
    void visit(Circle& ref) override 
    { 
        cout << "Circle;" << endl; 
    }
    void visit(Rectangle& ref) override 
    { 
        cout << "Rectangle;" << endl; 
    }
};


### Файл Figure:

class Figure : public Shape
{
    using Shapes = vector<shared_ptr<Shape>>;
private:
    Shapes shapes;
public:
    Figure(initializer_list<shared_ptr<Shape>> list)
    {
        for (auto&& elem : list)
            shapes.emplace_back(elem);
    }
    void accept(shared_ptr<Visitor> visitor)  override
    {
        for (auto& elem : shapes)
            elem->accept(visitor);
    }
};


### Файл Main:

# include <iostream>
# include <memory>
# include <vector>

using namespace std;

int main()
{
    shared_ptr<Shape> figure = make_shared<Figure>(
        initializer_list<shared_ptr<Shape>>(
            { make_shared<Circle>(), make_shared<Rectangle>(), make_shared<Circle>() }
        )
    );
    shared_ptr<Visitor> visitor = make_shared<ConVisitor>();
    figure->accept(visitor);
}


______________________________________________________________________________________
Возможные реализации для решения конкретных задач

https://y2kot.gitbook.io/untitled/patterns/behavioral-patterns/visitor/visitor-concrete-implementation




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Посредник (Mediator)

# Назначение
Паттерн Посредник (Mediator) – это поведенческий шаблон проектирования, который используется для упрощения взаимодействия между объектами путем вынесения логики их взаимодействия в отдельный класс. 
Этот класс выступает в роли посредника, который контролирует и координирует взаимодействие между объектами, вместо того чтобы позволять им обмениваться информацией напрямую. Используется, когда имеется 
большое количество объектов, каждый из которых должен взаимодействовать с другими объектами, и прямое взаимодействие между всеми парами объектов становится сложным и запутанным.

# Решаемые задачи
1) Упрощение взаимодействия между объектами
Паттерн обеспечивает централизованное взаимодействие между объектами, устраняя необходимость прямого взаимодействия между каждой парой объектов.

2) Снижение зависимости между объектами
Паттерн позволяет объектам взаимодействовать друг с другом через абстрактный интерфейс, не зависящий от конкретных классов. Это позволяет объектам меняться независимо друг от друга, не затрагивая 
другие части системы.

3) Избавление от лишней логики взаимодействия в классах
Появляется возможность очистить классы от избыточной логики, связанной с их взаимодействием. Вместо того чтобы каждый класс самостоятельно управлял своими зависимостями и коммуникацией с другими 
классами, эта логика выносится в посредник.

# UML диаграмма паттерна "Посредник"


		/------------------------\			/--------------------------\
		| 	Colleague        |====================> | 	Mediator 	   |
		|------------------------|			|--------------------------|
		| +setMediator(Mediator) |			| +send(Colleague message) |
		| +send(Massage) 	 |		      /\| 	+add() 	   	   |
		| +receive(Massage) 	 | <==================\/| 	+remove()	   |
		\------------------------/		1..*	\--------------------------/
			/\							/\
			||							||
			||							||
			||							||
		/-----------------------\			/-----------------------\
		|   ConcreteColleague 	|			|   ConcreteMediator 	|
		|-----------------------|			|-----------------------|
		| 	   -//-		|			| 	   -//-		|
		\-----------------------/			\-----------------------/



# Преимущества

1) Устранение прямых зависимостей между объектами.
2) Уменьшение дублирования кода. Паттерн позволяет выделить поведение, которое должно быть общим для нескольких объектов, в отдельный класс посредника.
3) Расширяемость системы. Паттерн облегчает добавление новых объектов и изменение взаимодействия между ними. Новые объекты могут быть легко интегрированы в систему, а изменения взаимодействия между 
объектами могут быть внесены в посредника.

# Недостатки
1) Увеличение количества кода за счёт появления дополнительных иерархий классов.
2) Увеличение времени выполнения. Объекты отправляют сообщения посреднику, который затем передает их другим объектам. Этот дополнительный уровень косвенности может привести к снижению производительности
программы.

# Связь с другими паттернами
1) Паттерн Посредник может быть реализован как Одиночка, чтобы гарантировать единственный экземпляр посредника в системе. Это обеспечивает централизованный контроль и управление взаимодействием между 
объектами.

2) Паттерн Посредник может работать с паттерном Стратегия для динамического изменения поведения объектов. Посредник может выбирать различные стратегии, в зависимости от текущего состояния системы, и 
передавать их объектам для выполнения соответствующих действий.

3) Паттерн посредник может использоваться вместе с паттерном Цепочка обязанностей для передачи запросов между объектами. Посредник может принимать запросы и передавать их по цепочке объектов, пока один 
из объектов не обработает запрос.



______________________________________________________________________________________
Объяснение от ChatGPT

Паттерн "Посредник" (Mediator) используется для упрощения взаимодействия между объектами. Вместо того чтобы объекты напрямую общались друг с другом, они общаются через специальный объект — посредника. Этот посредник 
контролирует и координирует все взаимодействия между объектами, благодаря чему уменьшается связанность (зависимость) между ними.

Пример из жизни:
Представьте себе диспетчера на железнодорожной станции. У вас есть несколько поездов, и каждый из них должен следить за сигналами, чтобы не столкнуться с другим поездом и чтобы не было задержек. 
Если каждый поезд будет напрямую связываться с другими поездами, чтобы согласовать своё движение, это может быть довольно сложно и запутанно.
Вместо этого у нас есть диспетчер (посредник). Каждый поезд сообщает диспетчеру свои намерения, и диспетчер управляет движением поездов, чтобы избежать конфликтов и обеспечить безопасное и эффективное 
движение.

Как это работает в программировании:
Компоненты (поезда): Есть набор объектов, которые должны взаимодействовать друг с другом.
Посредник (диспетчер): Это объект, который управляет взаимодействием между этими компонентами.
Компоненты взаимодействуют через посредника: Вместо того чтобы напрямую взаимодействовать друг с другом, компоненты передают свои сообщения посреднику, а тот решает, как они должны взаимодействовать.


______________________________________________________________________________________
Упрощённая реализация от ChatGPT

У нас есть два компонента (Component1 и Component2).
Оба компонента не взаимодействуют друг с другом напрямую, вместо этого они отправляют сообщения посреднику (ConcreteMediator).
Посредник решает, какой компонент должен получить сообщение и передает его нужному объекту.


#include <iostream>
#include <string>
#include <memory>
#include <vector>

// Базовый класс компонента
class Component {
public:
    virtual void send(const std::string& message) = 0;
    virtual void receive(const std::string& message) = 0;
    virtual void setMediator(class Mediator* mediator) = 0;
};

// Посредник
class Mediator {
public:
    virtual void notify(Component* sender, const std::string& message) = 0;
};

// Конкретный компонент 1
class Component1 : public Component {
    Mediator* mediator;
public:
    void send(const std::string& message) override {
        std::cout << "Component1 отправляет сообщение: " << message << std::endl;
        mediator->notify(this, message);
    }

    void receive(const std::string& message) override {
        std::cout << "Component1 получает сообщение: " << message << std::endl;
    }

    void setMediator(Mediator* m) override {
        mediator = m;
    }
};

// Конкретный компонент 2
class Component2 : public Component {
    Mediator* mediator;
public:
    void send(const std::string& message) override {
        std::cout << "Component2 отправляет сообщение: " << message << std::endl;
        mediator->notify(this, message);
    }

    void receive(const std::string& message) override {
        std::cout << "Component2 получает сообщение: " << message << std::endl;
    }

    void setMediator(Mediator* m) override {
        mediator = m;
    }
};

// Конкретный посредник
class ConcreteMediator : public Mediator {
    Component1* component1;
    Component2* component2;
public:
    void setComponents(Component1* c1, Component2* c2) {
        component1 = c1;
        component2 = c2;
    }

    void notify(Component* sender, const std::string& message) override {
        if (sender == component1) {
            component2->receive(message);
        } else {
            component1->receive(message);
        }
    }
};

int main() {
    Component1 c1;
    Component2 c2;
    ConcreteMediator mediator;

    mediator.setComponents(&c1, &c2);
    c1.setMediator(&mediator);
    c2.setMediator(&mediator);

    c1.send("Привет!");
    c2.send("Привет, как дела?");
}



______________________________________________________________________________________
Общая реализация на языке С++

### Файл Mediator:

class Mediator
{
protected:
    list<shared_ptr<Colleague>> colleagues;

public:
    virtual ~Mediator() = default;

    virtual bool send(const Colleague* coleague, shared_ptr<Message> msg) = 0;

    static bool add(shared_ptr<Mediator> mediator, initializer_list<shared_ptr<Colleague>> list)
    {
        if (!mediator || list.size() == 0) return false;
    
        for (auto elem : list)
        {
            mediator->colleagues.push_back(elem);
            elem->setMediator(mediator);
        }
        return true;
    }
};


### Файл ConcreteMediator:

class ConcreteMediator : public Mediator
{
public:
    virtual bool send(const Colleague* coleague, shared_ptr<Message> msg) override
    {
        bool flag = false;
        for (auto& elem : colleagues)
        {
            if (dynamic_cast<const ColleagueLeft*>(colleague) && dynamic_cast<ColleagueRight*>(elem.get()))
            {
                elem->receive(msg);
                flag = true;
            }
            else if (dynamic_cast<const ColleagueRight*>(colleague) && dynamic_cast<ColleagueLeft*>(elem.get()))
            {
                elem->receive(msg);
                flag = true;
            }
        }
        return flag;
    }
};


### Файл Colleague:

class Colleague
{
private:
    weak_ptr<Mediator> mediator;

public:
    virtual ~Colleague() = default;

    void setMediator(shared_ptr<Mediator> mdr) 
    { 
        mediator = mdr; 
    }

    virtual bool send(shared_ptr<Message> msg);
    
    virtual void receive(shared_ptr<Message> msg) = 0;
};


### Файл ColleagueLeft:

class ColleagueLeft : public Colleague
{
public:
    virtual void receive(shared_ptr<Message> msg) override 
    { 
        cout << "Right - > Left;" << endl; 
    }
};


### Файл ColleagueRight:

class ColleagueRight : public Colleague
{
public:
    virtual void receive(shared_ptr<Message> msg) override 
    { 
        cout << "Left - > Right;" << endl; 
    }
};


### Файл Message:

// Класс "Message" или "Request" используется для представления сообщений или запросов, которые передаются между объектами через посредника.
// Этот класс обычно содержит информацию, необходимую для выполнения определенной операции или взаимодействия между объектами. Он может содержать данные, параметры, команды и другую информацию, которая 
// требуется для передачи между объектами.

class Message {}; 


### Файл Main:

# include <iostream>
# include <memory>
# include <list>
# include <vector>

using namespace std;

int main()
{
    shared_ptr<Mediator> mediator = make_shared<ConcreteMediator>();

    shared_ptr<Colleague> col1 = make_shared<ColleagueLeft>();
    shared_ptr<Colleague> col2 = make_shared<ColleagueRight>();
    shared_ptr<Colleague> col3 = make_shared<ColleagueLeft>();
    shared_ptr<Colleague> col4 = make_shared<ColleagueLeft>();

    Mediator::add(mediator, { col1, col2, col3, col4 });

    shared_ptr<Message> msg = make_shared<Message>();

    col1->send(msg);
    col2->send(msg);
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Шаблонный метод (Template Method)

# Назначение
Паттерн шаблонный метод (Template Method) представляет из себя класс, который позволяет собирать метод из алгоритмов на основе этапов и варьировать каждый из этих алгоритмов.
При этом задачей самого шаблонного метода становится передача данных после выполнения определённого этапа на следующий этап.

# Решаемые задачи
1) управление расширениями подклассов
Можно определить шаблонный метод так, что он будет вызывать операции-зацепки (hooks) в определенных местах программы, разрешив тем самым расширение только в этих местах.

2) избавление от дублирования кода методом вычленения и локализации в одном классе поведения, общего для всех подклассов
Сначала идентифицируются различия в существующем коде, а затем они выносятся в отдельные операции (методы или функции). В конечном итоге различающиеся фрагменты кода заменяются шаблонным методом, из 
которого вызываются новые операции.

3) необходимость использовать одни и те же части алгоритма повторно, оставляя возможность изменять специфическое поведение в разных подклассах

# Преимущества
1) позволяет избежать дублирования кода
2) облегчается замена алгоритмов и методов без внесения изменений в основную структуру кода
3) упрощается понимание и поддержка кода за счет разделения алгоритмов на более мелкие этапы
4) возможность управления расширениями подклассов

# Недостатки
1) внесение изменений в общую структуру алгоритма может потребовать соответствующих изменений во всех подклассах.
2) при значительном увеличении числа этапов алгоритма класс может стать слишком сложным и трудным для поддержки и понимания
3) множественные шаги алгоритма, каждый из которых требует изменений в отдельном подклассе, могут привести к созданию большого количества классов-наследников

# Связь с другими паттернами
1) Фабричный метод: часто вызывается из шаблонных методах.
2) Стратегия: шаблонные методы применяют наследование для модификации части алгоритма. Стратегии используют делегирование для модификации алгоритма в целом.
3) Декоратор: шаблонный метод может быть использован вместе с паттерном декоратор для добавления дополнительного поведения внутри шагов алгоритма. Декораторы могут быть применены к определенным шагам 
алгоритма, чтобы модифицировать их поведение без изменения самого шаблона метода.

4) Цепочка обязанностей: шаблонный метод может быть частью цепочки обязанностей, где каждый шаг алгоритма представляет отдельное звено в цепочке. Цепочка обязанностей позволяет разделить обработку 
запросов на разные уровни и динамически определить, какой шаг должен обработать конкретный запрос.



______________________________________________________________________________________
Объяснение от ChatGPT

Шаблонный метод (Template Method) — это поведенческий паттерн проектирования, который определяет скелет алгоритма в базовом классе, но позволяет подклассам переопределять определённые этапы алгоритма, 
не изменяя его структуру.

Основная идея:
В шаблонном методе базовый класс определяет основную логику алгоритма через метод, называемый "шаблонным методом". Этот метод состоит из вызовов других методов, некоторые из которых могут быть 
абстрактными или виртуальными. Эти методы являются "переменными шагами" алгоритма, которые могут быть переопределены в подклассах для предоставления конкретной реализации. Таким образом, подклассы 
могут изменять конкретные этапы выполнения алгоритма, не затрагивая общую структуру.

Структура:
Базовый класс: Содержит шаблонный метод и набор шагов, которые могут быть переопределены.
Подклассы: Реализуют конкретные шаги алгоритма, переопределяя методы базового класса.



______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>

// Базовый класс, содержащий шаблонный метод process, который задаёт последовательность шагов: загрузка данных, их обработка и сохранение.
// Методы loadData, processData и saveData: loadData и processData являются абстрактными методами, которые должны быть реализованы в подклассах. Метод saveData имеет реализацию по умолчанию, но может быть переопределён.

class DataProcessor {
public:
    // Шаблонный метод, определяющий общий алгоритм
    void process() {
        loadData();
        processData();
        saveData();
    }

protected:
    // Шаги алгоритма, которые могут быть переопределены
    virtual void loadData() = 0;    // Абстрактный метод
    virtual void processData() = 0; // Абстрактный метод
    virtual void saveData() {       // Виртуальный метод с реализацией по умолчанию
        std::cout << "Saving processed data to the database." << std::endl;
    }
};

// Конкретный класс, реализующий конкретные шаги алгоритма
class CSVProcessor : public DataProcessor {
protected:
    void loadData() override {
        std::cout << "Loading data from a CSV file." << std::endl;
    }

    void processData() override {
        std::cout << "Processing data from the CSV file." << std::endl;
    }
};

// Другой конкретный класс, с собственной реализацией шагов
class JSONProcessor : public DataProcessor {
protected:
    void loadData() override {
        std::cout << "Loading data from a JSON file." << std::endl;
    }

    void processData() override {
        std::cout << "Processing data from the JSON file." << std::endl;
    }

    void saveData() override {
        std::cout << "Saving processed data to a JSON file." << std::endl;
    }
};

int main() {
    CSVProcessor csvProcessor;
    JSONProcessor jsonProcessor;

    std::cout << "CSV Processor:" << std::endl;
    csvProcessor.process();

    std::cout << "\nJSON Processor:" << std::endl;
    jsonProcessor.process();

    return 0;
}


______________________________________________________________________________________
Общая реализация на языке С++

### Файл AbstractClass:

class AbstractClass
{
public:
    void templateMethod()
    {
        primitiveOperation();
        concreteOperation();
        hook();
    }
    virtual ~AbstractClass() = default;
protected:
    virtual void primitiveOperation() = 0;
    void concreteOperation() 
    { 
        cout << "concreteOperation;" << endl; 
    }
    virtual void hook() 
    { 
        cout << "hook Base;" << endl; 
    }
};


### Файл ConcreteClassA:

class ConcreteClassA : public AbstractClass
{
protected:
    void primitiveOperation() override 
    { 
        cout << "primitiveOperation A;" << endl; 
    }
};


### Файл ConcreteClassB:

class ConcreteClassB : public AbstractClass
{
protected:
    void primitiveOperation() override 
    { 
        cout << "primitiveOperation B;" << endl; 
    }
    void hook() override 
    { 
        cout << "hook B;" << endl; 
    }
};


### Файл Main:

#include <iostream>

using namespace std;

int main()
{
    ConcreteClassA ca;
    ConcreteClassB cb;

    ca.templateMethod();
    cb.templateMethod();
}




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Опекун (Memento)

# Назначение
Паттерн опекун (Memento)- поведенческий паттерн проектирования, который обеспечивает механизм сохранения состояния объекта без нарушения принципа инкапсуляции таким образом, чтобы он мог быть 
восстановлен в будущем.

# Решаемы задачи
1) возможность сохранить мгновенный снимок состояния объекта (или его части), чтобы впоследствии объект можно было восстановить в том же состоянии
2) используется в случае, если прямое получение состояния объекта раскрывает детали реализации и нарушает принцип инкапсуляции

# UML диаграмма паттерна "Опекун"


		/--------------------------\					/-----------------\
		| 	   Object	   |					|     Memento     |
		|--------------------------|=================================>	|-----------------|
		| +createMemento() 	   |					| +set(Object)    |
		| +restoreMemento(Memento) |					| +get()	  |
		\--------------------------/					\-----------------/
				/\							/\
				||							|| 0..*
				||							||
				||							||
				||							/\
				||							\/
				||						/---------------\
				||						|   CareTaker   |
				\\==============================================|---------------|
										| +set(Memento) |
										| +get() 	|
										\---------------/


# Преимущества
1) отделение логики сохранения и восстановления состояния от логики самого объекта: позволяет снять с класса задачу о сохранении своих предыдущих состояний
2) предоставление возможности откатиться к предыдущему состоянию объекта
3) возможность предоставлять различные алгоритмы сохранения состояния, позволяя выбрать наиболее подходящий подход для конкретной ситуации

# Недостатки
1) затраты памяти на сохранение снимков состояний
2) потребность в реализации механизма очистки и определения того, нужны снимки или нет
3) увеличение сложности кода из-за потребности создания дополнительных классов и методов

# Связь с другими паттернами
1) Команда: паттерн опекун может использоваться в сочетании с паттерном команда для реализации отмены и повтора операций. Команда может создавать опекуна, содержащего текущее состояние объекта перед выполнением операции, и 
сохранять его в стеке или списке. Затем операции отмены и повтора могут использовать сохраненного опекуна, чтобы восстановить предыдущее состояние объекта.

2) Итератор: хранитель может быть использован вместе с итератором для сохранения текущего состояния итератора в виде снимка. Это позволяет итератору восстановить свое состояние после некоторых операций 
или переходов.



______________________________________________________________________________________
Объяснение от ChatGPT

Паттерн "Опекун" (или "Хранитель", "Memento") позволяет сохранять и восстанавливать состояние объекта, не раскрывая его внутреннюю структуру. Это как функция "отмены" (undo) в текстовом редакторе, 
которая позволяет вернуться к предыдущему состоянию документа.

Пример из жизни:
Представьте, что вы играете в видеоигру, и в какой-то момент вы можете сохранить прогресс, а потом вернуться к этому сохранению, если что-то пойдет не так.
Сохранение игры — это создание "опекуна", который хранит текущее состояние игры.
Загрузка сохранения — это восстановление состояния игры до момента сохранения.

Как это работает в программировании:
Объект (например, игра): Это ваш основной объект, который выполняет свою работу и изменяет свое состояние со временем.
Опекун (Memento): Этот объект сохраняет состояние другого объекта (например, сохраняет текущий прогресс игры).
Клиент (например, игрок): Клиент может попросить объект создать опекуна, чтобы сохранить текущее состояние, или восстановить состояние объекта из ранее созданного опекуна.



______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <string>

// Класс Memento хранит состояние объекта, которое можно сохранить и восстановить
class Memento {
public:
    // Конструктор сохраняет текущее состояние
    Memento(const std::string& state) : state_(state) {}

    // Возвращает сохраненное состояние
    std::string getState() const { return state_; }

private:
    std::string state_;  // Сохраненное состояние (например, текст)
};

// Класс TextEditor является основным объектом, который может изменять свое состояние
class TextEditor {
public:
    // Метод для добавления текста в редактор
    void write(const std::string& text) {
        content_ += text;
    }

    // Метод для сохранения текущего состояния редактора в Memento
    Memento save() {
        return Memento(content_);
    }

    // Метод для восстановления состояния редактора из Memento
    void restore(const Memento& memento) {
        content_ = memento.getState();
    }

    // Метод для отображения текущего состояния редактора
    void print() const {
        std::cout << "Current content: " << content_ << std::endl;
    }

private:
    std::string content_;  // Содержимое редактора (текущий текст)
};

// Основная функция для демонстрации работы паттерна "Опекун"
int main() {
    TextEditor editor;  // Создаем текстовый редактор

    // Пишем текст и выводим его на экран
    editor.write("Hello, ");
    editor.print();  // Вывод: "Hello, "

    // Сохраняем текущее состояние редактора
    Memento saved = editor.save();

    // Добавляем новый текст и выводим его на экран
    editor.write("world!");
    editor.print();  // Вывод: "Hello, world!"

    // Восстанавливаем состояние редактора до сохраненного момента
    editor.restore(saved);
    editor.print();  // Вывод: "Hello, "

    return 0;
}



______________________________________________________________________________________
Общая реализация на языке С++

### Файл includes:

# include <iostream>
# include <memory>
# include <list>

using namespace std;


### Файл Caretaker:

class Memento;

class Caretaker
{
public:
    unique_ptr<Memento> getMemento();
    void setMemento(unique_ptr<Memento> memento);
private:
    list<unique_ptr<Memento>> mementos;
};


### Файл Originator:

class Originator
{
public:
    Originator(int s) : state(s) {}
    const int getState() const 
    { 
        return state; 
    }
    void setState(int s) 
    { 
        state = s; 
    }
    std::unique_ptr<Memento> createMemento() 
    { 
        return make_unique<Memento>(*this); 
    }
    void restoreMemento(std::unique_ptr<Memento> memento);
private:
    int state;
};


### Файл Memento:

class Memento
{
    friend class Originator;
public:
    Memento(Originator o) : originator(o) {}
private:
    void setOriginator(Originator o) 
    { 
        originator = o; 
    }
    Originator getOriginator() 
    { 
        return originator; 
    }
private:
    Originator originator;
};


### Файл MethodsCaretaker:

# pragma region Methods Caretaker
void Caretaker::setMemento(unique_ptr<Memento> memento)
{
    mementos.push_back(move(memento));
}
unique_ptr<Memento> Caretaker::getMemento() 
{
    unique_ptr<Memento> last = move(mementos.back());
    mementos.pop_back();
    return last;
}
# pragma endregion


### Файл MethodOriginator:

# pragma region Method Originator
void Originator::restoreMemento(std::unique_ptr<Memento> memento)
{
    *this = memento->getOriginator();
}
# pragma endregion


### Файл Main:

int main()
{
    auto originator = make_unique<Originator>(1);
    auto caretaker = make_unique<Caretaker>();

    cout << "State = " << originator->getState() << endl;
    caretaker->setMemento(originator->createMemento());

    originator->setState(2);
    cout << "State = " << originator->getState() << endl;
    caretaker->setMemento(originator->createMemento());
    originator->setState(3);
    cout << "State = " << originator->getState() << endl;
    caretaker->setMemento(originator->createMemento());

    originator->restoreMemento(caretaker->getMemento());
    cout << "State = " << originator->getState() << endl;
    originator->restoreMemento(caretaker->getMemento());
    cout << "State = " << originator->getState() << std::endl;
    originator->restoreMemento(caretaker->getMemento());
    cout << "State = " << originator->getState() << std::endl;
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Итератор (Iterator)

# Назначение
Поведенческий паттерн итератор (Iterator) предоставляет способ последовательного доступа ко всем элементам составного объекта, не раскрывая его внутреннего представления.

# Решаемые задачи
1) сохранение инкапсуляции объектов при переборе в структуре данных
2) поддержка нескольких активных обходов одного и того же агрегированного (составленного из подобъектов) объекта
3) предоставление единообразного интерфейса с целью обхода различных агрегированных структур (поддержка полиморфной итерации)

# Преимущества
1) упрощение работы со структурами данных: обход элементов без знания об особенностях внутренней реализации структуры данных
2) возможность работать с различными типами структур данных независимо от их реализации
3) возможность реализовывать различные алгоритмы обработки структур данных

# Недостатки
добавление новых типов структур данных может потребовать изменения кода итератора

# Связь с другими паттернами
1) Компоновщик: итераторы довольно часто применяются для обхода рекурсивных структур, создаваемых компоновщиком.
2) Фабричный метод: полиморфные итераторы поручают фабричным методам инстанцировать (создание экземпляров) подходящие подклассы класса Iterator.
3) Хранитель: итератор может использовать хранитель для сохранения состояния итерации и при этом содержит его внутри себя.



______________________________________________________________________________________
Объяснение от ChatGPT

Паттерн "Итератор" (Iterator) — это способ доступа к элементам коллекции (например, списка, массива) без необходимости знать о внутренней структуре этой коллекции. Он позволяет последовательно обходить 
элементы коллекции, не раскрывая, как именно эти элементы хранятся.

Основные идеи:
1) Абстракция обхода: Итератор предоставляет способ перебора элементов коллекции, скрывая детали хранения данных.
2) Упрощение кода: С помощью итератора можно легко перемещаться по элементам коллекции, не заботясь о том, как эта коллекция реализована.

Пример из жизни:
Представьте себе библиотеку с книгами. Если вы хотите прочитать все книги, вам не нужно знать, как книги организованы в библиотеке (по алфавиту, по жанрам и т.д.). Вы просто идете по полкам и выбираете 
книги одну за другой. В этом случае библиотекарь — это ваш итератор, который помогает вам перебрать книги.

Как это работает в программировании:
В программировании итератор — это объект, который реализует определённые методы для доступа к элементам коллекции. Он позволяет перебрать элементы без необходимости знать детали реализации коллекции.



______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>
#include <vector>

using namespace std;

// Класс итератора для обхода элементов вектора
class VectorIterator {
public:
    // Конструктор инициализирует итератор вектором и начальным индексом
    VectorIterator(vector<int>& v) : vec(v), index(0) {}

    // Метод для проверки, есть ли еще элементы в векторе
    bool hasNext() const {
        return index < vec.size(); // Возвращает true, если индекс меньше размера вектора
    }

    // Метод для получения следующего элемента вектора
    int next() {
        return vec[index++]; // Возвращает текущий элемент и увеличивает индекс
    }

private:
    vector<int>& vec; // Ссылка на вектор, который мы перебираем
    size_t index;     // Текущий индекс в векторе
};

// Основная программа
int main() {
    // Создаем вектор с числами от 1 до 5
    vector<int> numbers = {1, 2, 3, 4, 5};

    // Создаем итератор для этого вектора
    VectorIterator it(numbers);

    // Используем итератор для обхода элементов вектора
    cout << "Elements in the vector: ";
    while (it.hasNext()) { // Проверяем, есть ли еще элементы
        cout << it.next() << " "; // Получаем следующий элемент и выводим его
    }

    cout << endl; // Завершаем строку вывода

    return 0; // Завершаем программу
}


______________________________________________________________________________________
Общая реализация на языке С++

### Файл includes:

#include <iostream>
#include <string>
#include <vector>


### Файл Iterator:

template <typename T, typename U>
class Iterator 
{
public:
    typedef typename std::vector<T>::iterator iter_type;
    Iterator(U *p_data, bool reverse = false) : m_p_data_(p_data) 
    {
        m_it_ = m_p_data_->m_data_.begin();
    }
    void First() 
    {
        m_it_ = m_p_data_->m_data_.begin();
    }
    void Next() 
    {
        m_it_++;
    }
    bool IsDone() 
    {
        return (m_it_ == m_p_data_->m_data_.end());
    }
    iter_type Current() 
    {
        return m_it_;
    }
private:
    U *m_p_data_;
    iter_type m_it_;
};


### Файл Container:

template <class T>
class Container 
{
    friend class Iterator<T, Container>;
public:
    void Add(T a) 
    {
        m_data_.push_back(a);
    }
    Iterator<T, Container> *CreateIterator() 
    {
        return new Iterator<T, Container>(this);
    }
private:
    std::vector<T> m_data_;
};


### Файл Data:

class Data 
{
public:
    Data(int a = 0) : m_data_(a) {}
    void set_data(int a) 
    {
        m_data_ = a;
    }
    int data() 
    {
        return m_data_;
    }
private:
    int m_data_;
};


### Файл ClientCode:

void ClientCode() 
{
    std::cout << "Iterator with int" << std::endl;
    Container<int> cont;
    for (int i = 0; i < 10; i++) 
        cont.Add(i);
    Iterator<int, Container<int>> *it = cont.CreateIterator();
    for (it->First(); !it->IsDone(); it->Next()) 
        std::cout << *it->Current() << " ";
    std::cout << std::endl;
    Container<Data> cont2;
    Data a(100), b(1000), c(10000);
    cont2.Add(a);
    cont2.Add(b);
    cont2.Add(c);
    std::cout << std::endl << "Iterator with custom Class" << std::endl;
    Iterator<Data, Container<Data>> *it2 = cont2.CreateIterator();
    for (it2->First(); !it2->IsDone(); it2->Next()) 
        std::cout << it2->Current()->data() << " ";
    std::cout << std::endl;
    delete it;
    delete it2;
}


### Файл Main:

int main() 
{
    ClientCode();
    return 0;
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Свойство (Property)

# Назначение
Паттерн свойство (Property) представляет собой объединение двух методов - получения и изменения значения, что позволяет обеспечить сохранение целостности доступа к данным объекта.

# Решаемые задачи
1) инкапсуляция данных: паттерн Свойство помогает обеспечить инкапсуляцию данных, скрывая их реализацию и предоставляя контролируемый доступ к ним
2) валидация данных: возможность добавления логики проверки данных на соответствие определенным правилам или условиям в методах, реализующих паттерн Свойство
3) ленивая инициализация: паттерн Свойство может быть использован для реализации ленивой инициализации, при которой инициализация объекта или вычисление значения откладывается до момента его 
фактического использования

Основная цель ленивой инициализации - избежать необязательных ресурсозатратных операций или вычислений, которые могут быть не нужны до момента использования объекта. Это позволяет повысить 
производительность и эффективность написанной программы.

# Преимущества
1) реализация принципа инкапсуляции
2) обеспечение контроля доступа к данным, которое позволяет избежать ошибок при работе с объектами
3) возможность добавлять дополнительную логику при доступе к данным (например, проверку на корректность значений или логирования запроса доступа к данным)

# Недостатки
приводит к увеличению количества типового кода, так как для каждого поля объекта требуется создание методов доступа

# Связь с другими паттернами
1) Одиночка: паттерн Свойство может быть частью реализации паттерна Одиночки. В этом случае свойство, представляющее экземпляр Singleton класса, может быть доступно через геттер и сеттер методы Property.
2) Декоратор: паттерн Свойство может использоваться вместе с паттерном Декоратор для добавления дополнительной функциональности к свойству объекта. Декоратор может обернуть объект Свойства и расширить 
его поведение без изменения самого объекта.

3) Заместитель: паттерн Свойство может быть реализован в виде прокси-объекта, который обеспечивает контроль доступа к свойству. Заместитель может добавлять дополнительную логику перед доступом к 
свойству или ограничивать доступ к нему.

4) Адаптер: паттерн Свойство может быть использован в связке с паттерном Adapter для адаптации интерфейса свойства к требуемому интерфейсу.



______________________________________________________________________________________
Объяснение от ChatGPT

Паттерн "Свойство" (Property) — это способ управления доступом к данным объекта. Он позволяет вам контролировать, как данные объекта устанавливаются и извлекаются. Вместо прямого доступа к переменным 
объекта (например, через публичные поля), вы используете методы, которые предоставляют доступ к этим данным. Эти методы обычно называются "геттеры" и "сеттеры".

Простой пример:
Представьте, что у вас есть дверь, которая может быть открыта или закрыта. Вместо того, чтобы напрямую открывать или закрывать дверь, вы используете ручку (или замок), чтобы управлять дверью.
Геттер (Getter) — это метод, который позволяет вам узнать, в каком состоянии находится дверь (открыта или закрыта).
Сеттер (Setter) — это метод, который позволяет вам изменить состояние двери (открыть или закрыть её).

Почему это полезно:
Контроль над данными: Вы можете добавлять логику проверки или преобразования данных перед их установкой или извлечением.
Сокрытие внутренней реализации: Пользователи класса взаимодействуют с объектом через свойства, а не напрямую с его внутренними данными.
Управление изменениями: Легко добавлять логику, которая должна выполняться при изменении значения, например, валидацию данных или уведомления.



______________________________________________________________________________________
Упрощённая реализация от ChatGPT

#include <iostream>

using namespace std;

class Person {
public:
    // Геттер для получения возраста
    int getAge() const {
        return age;
    }

    // Сеттер для установки возраста
    void setAge(int newAge) {
        if (newAge >= 0) {  // Проверка на корректность значения
            age = newAge;
        } else {
            cout << "Invalid age!" << endl;
        }
    }

private:
    int age; // Приватная переменная для хранения возраста
};

int main() {
    Person person;
    person.setAge(25);  // Устанавливаем возраст через сеттер
    cout << "Age: " << person.getAge() << endl;  // Получаем возраст через геттер

    person.setAge(-5);  // Попытка установить неверное значение

    return 0;
}



______________________________________________________________________________________
Общая реализация на языке С++

### Файл includes:

#include <iostream>
#include <memory>

using namespace std;


### Файл Property:

template <typename Owner, typename Type>
class Property
{
    using Getter = Type(Owner::*)() const;
    using Setter = void (Owner::*)(const Type&);
private:
    Owner* owner;
    Getter methodGet;
    Setter methodSet;
public:
    Property() = default;
    Property(Owner* const owr, Getter getmethod, Setter setmethod) : owner(owr), methodGet(getmethod), methodSet(setmethod) {}
    void init(Owner* const owr, Getter getmethod, Setter setmethod)
    {
        owner = owr;
        methodGet = getmethod;
        methodSet = setmethod;
    }
    operator Type() // Getter
    { 
        return (owner->*methodGet)(); 
    }
    void operator=(const Type& data) // Setter
    { 
        (owner->*methodSet)(data); 
    }
};


### Файл Object:

class Object
{
private:
    double value;
public:
    Object(double v) : value(v) 
    { 
        Value.init(this, &Object::getValue, &Object::setValue); 
    }
    double getValue() const 
    { 
        return value; 
    }
    void setValue(const double& v) 
    { 
        value = v; 
    }
    Property<Object, double> Value;
};


### Файл Main:

int main()
{
    Object obj(5.);
    cout << "value = " << obj.Value << endl;
    obj.Value = 10.;
    cout << "value = " << obj.Value << endl;
    unique_ptr<Object> ptr = make_unique<Object>(15.);
    cout << "value =" << ptr->Value << endl;
    obj = *ptr;
    obj.Value = ptr->Value;
}





______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Введение в идиомы

# Что такое идиомы?
Идиомы - это конструкции языка или подходы в программировании, которые позволяют эффективно решать определёные задачи. Они представляют собой общепринятые идеи и методы, 
которые применяются для достяжения поставленных целей.

# Разница между идиомами и паттернами:
Идиомы обычно являются низкоуровневыми, охватывают более узкий круг задач и могут быть специфичны для определённого языка или области программирования. Паттерны, напротив,
являются более общими архитектурными решениями и могут быть применены в различных областях и языках программирования.

# Основная идея
Основная идея использования идиом заключается в том, чтобы предоставить разработчикам готовые решенеия для типичных задач программирования. Идиомы являются соглашениями о том,
как организовывать классы, методы и связи между ними, чтобы код был более понятным, гибким и расширяемым. Они облегчают разработку и поддерживание программного кода, 
позволяют создавать более эффективные и надёжные программы.

# Преимущества
1) Улучшение читаемости кода. Идиомы предоставляют стандартные шаблоны и конструкции, которые повышают читаемость кода. Это делает его более понятным и лёгким для 
сопровождения другими разработчиками.
2) Повтороное использование кода. Они предлагают готовые решения для типичных задач, которые можно применять в разных проектах. Это позволяет экономить время и услилия при 
разработке новых программ.
3) Улучшение структуры и модульности. Идиомы помогают организовать код в модули и классы, что способствует его логическому разделению и улучшает структуру и модульность 
программы. Это делает код более гибким, легко расширяемым и поддерживаемым.
4) Снижение вероятности ошибок. Использование идиом позволяет избежать типичных ошибок программирования. Они предлагают проверенные временем и опытом решения, которые
учитывают возможные проблемы и сложности.

# Недостатки
Увеличение количества и сложности кода. Использование идиом может привести к увеличению объёма кода и его сложности. Некоторые идиомы требуют добавления дополнительных 
классов, методов или шаблонов, что может усложнить код и сделать его более громоздким.



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
RAII (Resourse Acquisition Is Initialization) перевод: (Приобритение ресурсов - это инициализация)

# Альтернативные названия
CADR (Constructor Acquires, Destructor Releases)
SBRM (Scope-Bound Resourse Management)


# Моё старое объяснение 

Управление ресурсами. Идиома RAII

Объекты классов могут на протяжении всего своего существования использовать различные ресурсы - динамически выделенная память, файлы, сетевые подключения и т.д. В этом случае в 
C++ применяется так называемый принцип/идиома RAII (resource acquisition is initialization). RAII предполагает, что получение ресурса производится при инициализации объекта. А
освобождение ресурса производится в деструкторе объекта. Например, получение динамической памяти происходит в конструкторе объекта, а освобождение в деструкторе. При этом важно, 
чтобы ресурс (в данном случае динамическая память) освобождался только один раз. Для этой цели в классе удалены конструктор копирования и оператор присваивания, что позволяет 
избежать ситуации, когда два объекта хранят указатель на одну и ту же область динамической памяти и соответственно потом в деструкторе будут пытаться освободить эту память.




# Назанчение
Resourse Acquisition Is Initialization (RAII) - программная идиома, смысл которой заключается в том, чтобы с помощью тех или иных программных механизмов получение некоторого
ресурса неразрывно совмещалось с инициализацией, а освобождение - с уничтожением объекта.

C++ не имеет встроенного процесса автоматической сборки мусора. Вместо этого программа должна вручную освобождать ресуры, чтобы избежать утечек. Современный C++ позволяет 
управлять ресурсами объектов, использую принцип получения ресурсов при инициализации (RAII). Это позволяет избежать утечек памяти, утечек, вызванных некорректной работой с 
ресурсами (файловых, сетевых, потоков, процессов, баз данных, устройств).

# Решаемые задачи
1) Необходимость освобождения ресурсов: например памяти для дескрипторов ресурсов
Идиома RAII широко используется в стандартной библиотеке C++, чтобы управлять различными ресурсами, такими как память, файлы, потоки.

2) Гарантированное освобождение ресурсов при выходе из области видимости
3) Позволяет избежать потери данных при освобождении ресурсов

# Общая реализация на C++

В приведённом ниже примере класс File использует идиому RAII для открытия файла в конструкторе и закрытия файла в деструкторе. Это гарантирует, что если возникает 
исключительная ситуация, файл будет закрыт корректно, а данные не будут утеряны.

Согласно идеоме RAII, нам следует "обернуть" файловый дескриптор в объект специального класса. Тогда открытие файла соответствовало бы инициализации объекта в его 
конструкторе, а закрытие файла - уничтожению объекта в деструкторе. В случае ошибки при открытии файла мы бы сгенерировали исключение, и объект нашего класса не был бы создан.


### Файл includes:

#include <cstdio>
#include <exception>
#include <string>


### Файл CannotOpenFileException:

class CannotOpenFileException {};


### Файл File:

class File {
private:
	std::FILE* f; // файловый дескриптор, который мы оборачивем
public:
	File(const std::string& name) {
		if(f = std::fopen(name.c_str(), "r"); f == nullptr) {
			throw CannotOpenFileException();
		}
	}
	File(const File&) = delete;
	File& operator = (const File&) = delete;
       	// Конструктор перемещения
	File(File&& other) noexcept { // File&& - ссылкана временный объект
		f = other.f;
		other.f = nullptr; // забираем владение декскрипотором у временного объекта other
	}
	// Оператор присваиваня с семантикой перемещения
	File& operator = (File&& other) noexcept {
		if(f != nullptr && f != other.f) {
			std::fclose(f); // Закрываем файл у текущего объекта
		}
		f = other.f; // забирваем владение у временного объекта other
		other.f = nullptr;
		return *this;
	}
	~File() noexcept
	{
		if(f != nullptr) {
			std::fclose(f);
		}
	}
	std::string Read() const {
		...
	}
}


### Файл Main:

int main() {
	try
	{
		File file("input.txt");
		auto str = file.Read();
		// ...
	}
	catch (const CannotOpenFileException&)
	{
		std::cout << "File open failure!\n";
	}
}


# RAII в стандартной библиотеке

Некоторые примеры применения:

- std::unique_ptr и std::shared_ptr - умные указатели, которые используют идиому RAII для автоматического освобождения памяти в деструкторе объекта.
- std::ifstream и std::ofstream - классы, которые используют идиому RAII для автоматического закрытия файловых потоков в деструкторе объекта.
- std::lock_quard и std_unique_lock - классы, которые используют идиому RAII для автоматического освобождения блокировок при выходе из области видимости объекта.
- std::thread - класс, который используют идиому RAII для автоматического завершения потока при выходе из области видимости объекта.

Использование RAII  в стандартной библиотеке C++ позволяет создавать более безопасный и понятный код, а также уменьшить количество ошибок и утечек памяти.




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Type erasure (Стирание типа) 

# Назначение 
Идиома Type erasure позволяет работать с объектами разных типов, скрывая их реальный тип при помощи абстрактного интерфейса.

"Стирание типа" позволяет описать общую концепцию, которую могут реализовывать объекты различных типов, при этом скрывая от пользователя конкретный тип объекта.

# Решаемые задачи
1) Необходимость работать с объектами разных типов, но при этом обеспечить единый интерфейс и скрыть от пользователя реальный тип объекта
C++ - это статический типизированный язык. В языках со статической типизацией тип объекта известен и установливается во время компиляции. В то время как в языках с 
динамической типизацией тип связан со значениями времени выполнения. Механизм, осуществляющий идиомой type erasure позволяет преодолеть эти ограничения и предоставить 
возможнность реализовать функции, существующие в языках с динамической типизацией.


# различные методы реализации "Стирания типа"
1) Стирание типа, используя void*

void qsort (void* base, size_t num, size_t size,
	int (*compare)(const void*, const void*));

Недостаток: небезопасно и для каждого типа требуется отдельная функция сравнения


2) Стирание типа с использованием шаблонов C++

template <class RandomAccessIterator>
void sort(RandomAccessIterator first, RandomAccessIterator last);

Недостаток: может привести к появлению множества экземпляров шаблона функции и увеличению времени компиляции


3) Стирание типа с использованием полиморфизма

struct base 
{
	virtual void method() = 0;
};

struct derived_1 : base 
{
	void method() {
		cout << "derived_1\n";
	}
};

struct derived_2 : base 
{
	void method() {
		cout << "derived_2\n";
	}
};

void call(const base& l){
	l.method();
}

Недостаток: затраты времени выполнения


4) Стирание типа с помощью объединения union

struct Data{};

union U
{
	Data d;
	std::int_32_t n;
	char c;
	~U() {}
};

Недостаток: не является типобезопасным

 

______________________________________________________________________________________
Контейнеры с type erasure

1) std::any - контейнер, котрый может хранить объекты разных типов данных

int main() {
	std::any a = 42;
	std::cout << std::any_cast<int>(a) << std::endl;
	
	a = 3.14;
	std::cout << std::any_cast<double>(a) << std::endl;

	a = std::string("Hellow, World!");
	std::cout << std::any_cast<std::string>(a) << std::endl;
	return 0;
}


2) std::variant - может хранить объекты только заданных типов данных

int main() {
	std::variant<int, double, std::string> v;
	
	v = 42;
	std::cout << std::get<int>(v) << std::endl;

	v = 3.14;
	std::cout << std::get<double>(v) << std::endl;

	v = std::string("Hello, World!");
	std::cout << std::get<std::string>(v) << std::endl;
	return 0;
}


3) std::function - объект функции, который может хранить функции разных типов данных

void call_function(const std::function<void ()>& func){
	std::cout << "Calling function...";
	func();
}

void print_hello() {
	std::cout << "Hello, ";
}

void print_world() {
	std::cout << "Hello, " << std::endl;
}

int main(){
	std::function<void ()> f1 = print_hello;
	std::function<void ()> f2 = print_world;
	call_function(f1);
	call_function(f2);
}




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
CRTP (Curiously recurring template pattern) перевод: (Любопытно повторяющийся шаблон проектирования)

# Назначение 
Идиома CRTP предоставляет статическое полиморфное поведение без использования виртуальных функций, что позволяет увеличить производительность за счёт отказа от 
динамического связывания.
CRTP использует наследование и шаблоны для создания связи между базовым классом и его производным классом.
Идиома CRTP разделяет функциональность, зависящую от типа и связывает функциональность, независимую от типа, с базовым классом, используя шаблон с "саморекурсией".

# Решаемые задачи
1) Достяжение статического полиморфизма
2) Получение возможности повторного использования кода

# Пример реализации идиомы CRTP

template <class derived>
struct compare {};

struct value : compare<value>
{
	int m_x;
	value(int x) : m_x(x) {}
	bool operator<(const value &rhs) const>
	{
		return m_x < rhs.m_x;
	}
};

template <class derived>
bool operator > (const compare<derived> &lhs, const compare<derived> &rhs)
{
	// static_assert(std::is_base_of_v<compare<derived>, derived>); // безопасность времени компиляции
	return (static_cast<const derived&>(rhs) < static_cast<const derived&>(lhs));
}

int main()
{
	value v1{5}, v2{10};
	cout << boolalpha << "v1 > v2: " << (v1 > v2) << '\n';
	return 0;

}




______________________________________________________________________________________
Объяснение от ChatGPT

CRTP (Curiously recurring template pattern) - это идиома, использующая шаблоны в C++, при которой класс наследуется от шаблона, параметром которого является этот же класс.
Эта идиома полезна в некоторых ситуациях, например, для реализации статической полиморфизации, добавления функциональности в классы и оптимизации производительности.

# Как это работает?
CRTP включает создание базового класса-шаблона, в который передаётся класс-наследник в качестве параметра шаблона. Базовый класс может использовать этот параметр для 
выполнения операций, которые работают с производным классом.

Вот общая структура CRTP:

template <typename Derived>
class Base {
public:
	void interface(){
		// Общая логика, использующая возможности производного класса
		static_cast<Derived*>(this)->implementation();
	}
	// Базовая реализация, которая мб переопределена в Derived
	void implementation() {
		std::cout << "Base implementation" << std::endl;
	}
};

class Derived: public Base<Derived> {
	// Реализация, специфичная для Derived
	void implementation(){
		std::cout << "Derived implementation" << std::endl;
	}
};

int main() {
	Derived d;
	d.interface(); // Выведет Derived implementation
	return 0;
}


# Детальное объяснение:
1) Класс Base  это шаблонный класс, который принимает тип Derived как параметр шаблона. Метод interface() предоставляет некоторый интерфейс, который будет использовать метод
implementation(). Метод implementation() может быть переопределён в классе Derived. 

static_cast<Derived*>(this)->implementation() - это ключевой момент CRTP. Этот вызов преобразует указатель this к типу Derived*, чтобы вызвать метод implementation(),
определённый в классе Derived.

2)Класс Derived наследуется от Base<Derived>, где Derived - это конкретный класс. Также этот класс переопределяет метод implementation(), предоставляя свою специфическую
реализацию.

# Зачем используется CRTP?
1) Статическая полиморфизация: позволяет добиваться полиморфного поведения без накладных расходов, связанных с виртуальными функциями.
2) Реализация методов: Базовый класс может предоставлять базовую реализацию некоторых методов, которая мб переопределена в производном классе.
3) Добавление функциональности: Можно использовать CRTP для добавления стандартного поведения или интерфейсов в произвольные классы.
4) Оптимизация производительности: В отличие от динамического полиморфизма (через виртуальные фукнции), CRTP позволяет компилятору выполнить инлайн-функции и другие оптимизации, так как конкретный тип известен на этапе компиляции.


# Пример реального использования
CRTP часто используется в библиотеках C++, таких как Eigen или Boost. Например, в библиотеке Eigen CRTP применяется для добавления арифметических операций к векторным и
матричным классам без использования виртуальных функций.

template<typename Derived>
class MatrixBase {
public:
	Derived& derived() {
		return *static_cast<Derived*>(this);
	}
	
	const Derived& derived() const{
		return *ststic_cast<const Derived*>(this);
	}
	
	// Пример операции добавления
	Derived operator+(const Derived& other) const{
		Derived result = derived();
		result += other;
		return result;
	}
};

class Matrix : public MatrixBase<Matrix> {
	// Реализация специфических для Matrix операций
};


# Вывод
Класс производный от базового, наследует его методы. Затем производный класс может вызывать функции public и protect. В случае CRTP всё наоборот, базовый класс вызывает 
методы в производном классе. Этот приём позволяет достичь эффекта, похожего на использование виртуальных функций без использования динамического полиморфизама.

Например у нас есть базовый класс вообще без виртуальных методов. Это означает, что вызов любого метода базового класса, используя указатель на базовый класс, приведёт к 
вызову метода именно этого базового класса, даже если он был переопределён в классе-наследнике. Например, если наследник вызывает непереопределённый метод базового класса,
который в свою очередь, вызывает другой метод базового класса, уже переропределённый наследником, то будет вызван не метод наследника, а метод базового класса.
Однако, если методы базового класса используют CRTP для вызовов других методов, то переопределённые функции будут выбраны во время компиляции. Это эффективно эмулирует систему
виртуальных функций во время компиляции без необходимости платить цену за динамический полиморфизм (таблицы виртуальных методов, время затрачиваемое на выбор метода,
множественное наследование), но не позволяет делать этого во время выполнения программы.




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Статический полиморфизм

# Назначение

Идиома Статический полиморфизм основана на шаблонах, которые позволяют создавать обощённые алгоритмы и контейнеры, которыйе могут работать с различными типами данных. 
Компилятор при использовании шаблона генерирует конкретный коды для каждого типа данных, что позволяет избежать дублирования кода.

# решаемые задачи
1) уменьшение дублировнаия кода
2) возможность повторного использования кода
3) статическая проверка типов

Пример использования идиомы Статический полиморфизм

template<typename T>
void sort_vector(std::vector<T>& v){
	for(int i = 0; i < v.size(); i++)
		for(int j = i + 1; j < v.size(); j++)
			if(v[i] > v[j]){
				T temp = v[i];
				v[i] = v[j];
				v[j] = temp;
			}	
}

int main(){
	std::vector<int> v1 = { 3, 1, 4, 1, 5, 9, 2, 6, 5, 3};
	std::vector<std::string> v2 = {"apple", "banana", "cherry", "date", "elderberry"};
	
	sort_vector(v1);
	sort_vector(v2);
	return 0;
}


# недостатки использования
1) Необходимость явного указания типа данных при использования шаблонов, что приводит к усложнению кода и затруднении чтения и поддержки.
2) Шаблоны могут занимать большой объём памяти, если используются для хранения больших объёмов данных.
3) Не подходит для задач, которые требуют динамического выбора данных во время выполнения программы. В этом случае используются виртуальные функции и динамический 
полиморфизм.


______________________________________________________________________________________
Объяснение от ChatGPT (Скорее всего это подходит больше к предыдущей теме CRTP)

Статический полиморфизм - это способ реализации полиморфизма (то есть возможности объектов разных типов вести себя по-разному при одинаковом интерфейсе) без использования
виртуальных функций и наследования, которые применяются в обычном (динамическом) полиморфизме.

# Пример
Представьте, что у нас есть разные типы животых, например "Кошка" и "Собака", и мы хотим чтобы у каждого была функция звука. В классическом полиморфизме вы бы создали базовый 
класс "Животное" с виртуальной функцией "звук()", а затем унаследовали от него классы "Кошка" и "Собака", переопределяя функцию "звук()". 
В статическом полиморфизме мы можем добиться того же эффекта, используя шаблоны:

#include <iostream>

// Базовый шаблонный класс, который принимает тип производного класса
template <typename T>
class Animal {
public:
	// Метод, который вызывает специфичный для производного класса метод
	void makeSound() {
		// Вызов метода из производного класса
		static_cast<T*>(this)->sound();
	}
}

// Класс Кошка
class Cat : public Animal<Cat> {
	public:
	void sound(){
		std::cout << "Meow!" << std::endl;
	}
}

// Класс Собака
class Dog : public Animal<Dog> {
public:
	void sound(){
		std::cout << "Woof!" << std::endl;
	}
}

int main(){
	Cat cat;
	Dpg dog;
	
	cat.makeSound(); // Вывод: Meow!
	dog.makeSound(); // Вывод: Woof!
}


# Как это работает?

1) Шаблонный класс Animal принимает тип производного класса как параметр шаблона (T). этот тип используется для вызова метода sound(), который будет реализован в производных 
классах.
2) Классы Cat и Dog наследуются от Animal<Cat> и Animal<Dog>, соответственно. Он реализуют метод sound(), который описывает, какой звук издаёт каждое животное.
3) Когда мы вызываем makeSound() у объектов Cat и Dog, компилятор подставляет соответствующий метод sound() для правильного класса.

# В чём преимущества?
1) Без виртуальных функций. Статический полиморфизм не требует использования виртуальных функций, что устраняет накладные раскходы, связанные с ними(например, таблицу 
виртуальных методов).
2) Производительность. Компилятор делает все разрешения вызовов во время компиляции, что делает вызовы более быстрыми.
3) Гибкость. Позволяет создавать легко расширяемые конструкции без необходимости изменять существующие классы.

# Когда использовать?

Статический полиморфизм часто используется, когда важна высокая производительность и нет необходимости в динамичесокм выборе методов во времея выполнения программы. Его удобно
использовать в ситуациях, когда вы заранее знаете, какие типы объектов будете использовать, и хотите избежать издержек динамического полиморфизма.




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Shrink to fit (Уменьшить до нужного размера)

# Назначение
Идиома Shrink to fit решает проблему избыточного использования памяти при работе с контейнерами. Реализация заключается в создании или вызове метода shrink_to_fit(), который
прнудительно уменьшает выделенную память до минимально возможного размера, необходимого для хранения содержимого контейнерами.

# Решаемые задачи
1) экономия ресурсов памяти
2) уменьшение нагрузки на систему

# примеры реализации идиомы hrink to fit
1) 

std::vector<int> v;
// v заменяется его временной копией,которая является оптимальной по ёмкости
std::vector<int>(v.begin(), v.end()).swap(v);

2)

int main() {
	std::vector<int> vec = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	
	for(auto it = vec.begin(); it != vec.end(); ) {
		it = vec.erase(it);
		if(it != vec.end())
			++it;
	}
	vec.shrink_to_fit(); // Уменьшаем выделенную память до минимально возможного размера
	std::cout << "Size: " << vec.size() << std::endl;
	std::cout << "Capacity: " << vec.capacity() << std::endl;
	return 0;
}


В C++11 некоторые контейнеры (такие как vector, deque, basic_string) объявляют идиому "Shrink to fit", как функцию shrink_to_fit(). 
shrink_to_fit() - это необязательный запрос на уменьшение capacity() до size().



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Proxy (Заместитель)

# Назначение
Идиома Proxy позволяет клиентскому коду работать с заместителем таким же образом, как с реальным объектом, не внося в него изменений. Реализуется идиома при помощи шаблонов
и наследования. Заместитель может быть реализован как класс, который имеет тот же интерфейт, что и оригинальный объект, но но может выполнять дпополнительные действия
перед вызовом методов оригинального объекта.

# Разница между паттерном Proxy и идиомой Proxy
Паттерн Proxy и идиома Proxy на C++ являются разными концепциями:
Паттерн Proxy является одинм из классических порождающих паттерном проектирования. Он предоставляет структуру для создания объекта-посредника, который выступает в роли ЗАМЕНЫ
или Объёртки для реального объекта. Прокси имитирует интерфейс реального объекта, позволяя себе встраиваться в клиентский код без изменения логики. Главная цель паттерна 
Proxy - контроль доступа к реальному объекту и предоставление дополнительной функциональности при его обращении.

Идиома Proxy является практикой или подходом к реализации классов-объёрток или прокси-классов для достижения определённых целей. Идиома Proxy используется для предостовления 
прокси-объектов, которые оборачивают реальные объекты и ДОБАВЛЯЮТ дополнительное поведение без изменения интерфейса реальных объектов.

# Решаемые задачи
1) управление доступом к ресурсам или сервисам
2) кэширование данных
3) проведение логирования и аудита
4) обеспечивание защищённого соединения между клиентом и сервером

# Примеры реализации идиомы Proxy

### Файл Object:

// Интерфейс для оригинального объекта и прокси
class Object
{
public:
	virtual void DoSomething() = 0;
};


### Файл RealObject:

// Интерфейс оригинального объекта
class RealObject : public Object
{
public:
	RealObject() {
		// Здесь может быть дорогостоящая инициализация объекта
		std::cout << "RealObject: Created." << std::endl;
	}
	void DoSomething() override {
		// Здесь может быть дорогостоящая операция
		std::cout << "RealObject: Doing something." << std::endl;
	}
};


### Файл OblectProxy:

// Прокси для оригинального объекта
class ObjectProxy : public Object {
public:
	ObjectProxy() : real_object_(nullptr){}
	void DoSomething() override {
		// Создаём оригинальный объект только при певром вызове его метода
		if(!real_object_) {
			std::cout << "ObjectProxy: Creating real object." << std::endl;
			real_object_ = new RealObject();
		}
	// Выполняем операцию на оригинальном объекте
	std::cout <<  "ObjectProxy: Doing something." << std:: endl;
	real_object_ -> DoSomething();
	}
	
	~ObjectProxy() {
		delete real_object_;
	}
private:
	RealObject *real_object_;
};


### Файл Main:

int main() {
	std::vector<ObjectProxy> objects(10);
	// Выполняем опреацию для каждого объекта
	for(Object &obj : objects)
		obj.DoSomething();
	return 0;
}



______________________________________________________________________________________
Объяснение от ChatGPT

Паттер Proxy и идиома Proxy имеют сходство в том, что оба подразумевают использование объекта-заместителя для управления доступом к другому объекту. Однако их цели, 
реализация и применение различаются.

# Паттерн Proxy
Цель: Паттерн Proxy используется для управления доступом к объекту, предоставляя ему подмену или обёртку. Это может быть сделано для разных целей:
1) Управление доступом: Контроль за тем, когда и как объект используется (например Protection Proxy).
2) Оптимизация: Отоложенная загрузка (например Virtual Proxy).
3) удалённый доступ: Локальный объект управляет вызовами удалённого объекта (например Remote Proxy).

# Пример: Представим,что у нас есть удалённый сервис, и для доступа к нему мы используем объект Proxy. Этот объект перехватывает вызовы методов и отправляет их через сеть на 
удалённый сервер:

class RemoteService {
public:
	void performAction() {
		// Вызов удалённого сервиса
	}
};

class ServiceProxy {
private:
	RemoteService *realService;

public:
	ServiceProxy() : realService(nullptr){}

	void performAction() {
		if(!realService) {
			realService = new RemoteService();
		}
		realService->performAction(); // Перенаправление вызова
	}
};


# Идиома Proxy
Цель: Идиома Proxy в основном используется для сокрытия деталей реализации и уменьшения зависимости между модулями. Она применяется для сокрытия сложных деталей реализации 
от интерфейса класса и часто используется длся ускорения времени компиляции и снижения зависимости от изменяемого кода. 

# Пример: Рассмотрим ситуацию, когда класс имеет сложные внутренние детали, которые мы не хотим раскрывать в заголовочном файле. Мы можем скрывать их за указателем на 
внутренний объект (реализацию).

// Заголовочный файл MyClass.h
class MyClass {
public:
	MyClass();
	~MyClass();
	voud DoSomething();

private:
	class lmpl; // Forward declaration
	lpli *plmpl; // Указатель на реализацию
}

// Файл реализации MyClass.cpp
class MyClass::lmpl {
public:
	void DoSomething() {
		// Реализация метода
	}
}

MyClass::MyClass() : plmpl(new lmpl()) {}
MyClass::~MyClass() { delete plmpl;}

void MyClass::DoSomething() {
	plmpl->DoSomething(); // Делегирование работы реальному объекту
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Eraser remove (Стереть удалить)

# Назначение 
Erase-remove относится к алгоритмической операции, которая используется для удаления элементов из контейнера на основе заданного критерия удаления, сохраняя порядок 
расположения элементов.

# Решаемые задачи
Отсутствие смещения элементов, расположенных после удаленного элемента.

При удалении элемента из контейнера с помощью метода erase() может возникнуть смещение всех элементов, расположенных после удалённого элемента. Это может привести к ошибкам
в работе программы. Идиома решает эту задачу, позволяя эффективно удалять элементы, перемещая их в конец контейнера, а затем удалить все элементы, расположенные в конце.
Таким образом, порядок оставшихся элементов сохраняется, и не происходит ненужного смещения элементов.

# Общая реализация на языке C++
Удаление происходит в два этапа:
1) Метод remove() перемещает все элементы, не удовлетворяющие условию, в начало контейнера, а затем возвращает итератор на элемент, следующий за последним перемещённым 
элементом.
2) Метод erase() удаляет элементы, начиная с указанного итератора до конца контейнера.

int main(){
	std::vector<int> vec = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

	ver.erase(std::remove_if(vec.begin(), v.end(), [](int x0)
	{
		return x % 2 == 0;
	}), vec.end());
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Decltype(auto)

# Назначение
Идиома Decltype - это оператор языка C++, который возвращает тип выражения во время компиляции. Он позволяет определить тип переменной, функции или выражения, явно не
задавая их.

# Решаемые задачи
Определить точный тип выражения
В C++ тип перемнной обычно указывается явно, либо компилятор выводит тип на основе инициализаии переменной. Однако, в случае использования шаблонов или сложных выражения, 
иногда может быть сложно или невозможно явно указать тип. Используя идиому Decltype (auto), компилятор будет выводить тип переменной, исходя из типа выражения, которое 
присваивается этой переменно.

# Общая реализация на C++
тип переменной result определяется автоматически, при этом сохраняется ссылочность и константность выражения.

int main {
	int x = 42;
	const int& y = x;
	
	decltype(auto) result = y;
	std::cout << "resilt = " << result << std::endl;
	
	retutn 0;
} 


# Примеры использования
1)
int x = 10;
decltype(auto) y = x; // y будетиметь тип int

2)
int x = 10;
int& ref_x = x;
decltype(auto) y = ref_x; // у будет иметь int& (ссылка на x)

3) 
int x = 10;
int& getX() {return x;}

decltype(auto) func() {
	return getX(); // возвращает int&, т.е. ссылку на x
}


# В чём разница с auto?
auto выводит тип значения, а не ссылку. Если вы присваиваете int&, auto определит его как int, а не int&.
decltype(auto) выводит тип точно таким, каким он есть в выражении, включая ссылки и константы.


# Зачем это нужно?
decltype(auto) полезен в тех ситуациях, когда вы хотите автоматически вывести тип, но хотите сохоранить все аспекты этого типа (например, ссылки и константность), особенно
когда вы работаете с шаблонами и обощённым программированием.

# Наглядное сравнение decltype(auto) и auto

#include <iostream>
#include <vector>

// Функция возвращает ссылку на элемент вектора
int& getElement(std::vector<int>& vec, size_t index) {
	return vec[index];
}

int main(){
	std::vector<int> vec = { 1, 2, 3, 4, 5};

	// Использование auto: тип выводиться как int (значение)
	auto elemAuto = getElement(vec, 1);
	elemAuto = 10; 								// Изменяем elemAuto, но это не влияет на исходный вектор

	// Использование decltype(auto) : тип выводиться как int& (ссылка)
	decltype(auto) elemDecltypeAuto = getElement(vec, 2);
	elemDecltypeAuto = 20; 							// Изменение elemDecltypeAuto изменяет вектор

	// Вывод результата
	std::cout << "vec[1] after auto: " << vec[1] << std::endl;		// Выводит 2 (не изменился)
	std::cout << "vec[2] after decltype(auto): " << vec[2] << std::endl;	// Выводит 20 (изменился, было 3)

	return 0;
}

В строке auto elemAuto = getElement(vec, 1); - auto выводит тип как int, потому что возвращаемое значение getElement привязано к int&, но auto "отбрасывает" ссылку. В 
результату elemAuto становиться копией значения элемента вектора, а не ссылкой на него. Поэтому изменение elemAuto не влияет на исходный вектор vec.

В строке decltype(auto) elemDecltypeAuto = getElement(vec, 2); - decltype(auto) сохраняет точный тип, возвращаемого функцией, включая ссылку. В этом случае elemDecltypeAuto
становиться ссылкой на элемент вектора. Изменение elemDecltypeAuto изменяет исходный вектор vec.




______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Copy and swap (Копирование и замена)

# Назначение
Идиома Copy and swap является одним из подходов к реализации операции присваивания для объекта класса. Она предлагает эффективный способ обеспечить безопасную и эффективную
реализацию этой операции. Используется для реализации оператора присваивания, конструктора копирования, обмена значениями.

# Решаемые задачи
Безопасное присваивание объектов
При изменении состояния одного или нескольких объектов на любом этапе модификации может возникнуть исключительная ситуация, приводящая к неправильному освобождению ресурсов,
если произошла ошибка после выделения памяти для нового объекта. Идиома Copy and swap обеспечивает безопасность операции присваивания. Она позволяет избежать проблем с 
самоприсваиванием и гарантировать освобождение ресурсов.

# Общая реализация на языке C++
Реализация идиомы заключается в создании функции swap(), которая:
1) Создаёт копию объектов
2) Изменяет копию. Оригинальные объекты остаются нетронутыми.
3) Если все изменения прошли успешно - происходит замена оригинального объекта изменённой копией. Если же при изменении копии на каком-то этапе появилась ошибка, то 
оригинальный объект не меняется.

В данном примере для обмена значениями реализована функция swap(). Блягодаря этому удаётся избежать утечки памяти в случае выброса исключения.

#include <iostream>
#include <algorithm> // Для std::swap

template<typename T>
class Array {
public:
	Array(unsigned size) : data {new T[size] }, size{ size } {} 	// Создаём массив заданного размера
	~Array() { delete [] data; }
	
	// Конструктор копирования
	Array(const Array& array) : Array{ array.size } { 		// Вызов конструктора с параметром размера
		for(unsigned i {}; i < size; ++i)			// Копирование данных из другого массива	
			data[i] = array.data[i];
	}
	
	// Опреатор присваивания
	Array <T>& operator=(const Array& other) {
		Array <T> copy{ other };				// Создаём копию другого массива
		swap(copy);						// Меняем местами данные текущего объекта и копии
		return *this;						// Возвращаем текущий объект
	}

	// Оператор доступа по индексу: возвращает ссылку на элемент массива
	T & operator[](unsigned index) {
		return data[index];
	}
	
	// Функция обмена содержимого с другим объектом Array
	void swap(Array & other) noexcept {
		std::swap(data, other.data); 				// Меняем местами указатели на данные
		std::swap(size, other.size); 				// Меняем местами размеры массивов
	}	

	// Получаю размер массива
	unsigned getSize() const {
		return size;
	}
private:
	T *data;							// Указатель на динамический массив	
	unsigned size;							// Размер массива
}


int main() {
	// Пример использования класса Array
	Array<int> arr1(5);						// Создание массива из 5 элементов
	Array<int> arr2 = arr1;						// Копирование массива через конструктор копирования
	arr2[0] = 42;							// Изменение элемента в скопированном массиве

	Array<int> arr3(10);						// Создание массива из 10 элементов
	arr3 = arr2;							// Присваивание одного массива другому
		
	std::cout << "arr2[0] = " << arr2[0] << std::endl;
	std::cout << "arr3[0] = " << arr3[0] << std::endl;

	return 0;
}



______________________________________________________________________________________
Старое объяснение Идиома копирования и замены

Когда нужно изменить состояние одного или нескольких объектов, и на любом этапе модификации может возникнуть ошибка, для создания кода, устойчиваого к ошибкам, может применяться
идиома копирования и замены (copy-and-swap idiom). Суть данной идиомы состоит в следующей последовательности действий:

1. Создаем копию объекта(ов)

2. Изменяем копию. При этом оригинальные объекты остаются нетронутыми

3. Если все изменения прошли успешно, заменяем оригинальный объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то оригинальный объект 
не заменяется.

Обычно эта идиома применяется в функциях и частным, хотя и распространенным, случаем ее применения является оператор присваивания. В общем случаем это выглядит так:

// оператор присвоения некоторого класса Copyable
Copyable& operator=(const Copyable& obj) {
    Copyable copy{obj}; 				// создаем копию через конструктор копирования
    swap(copy);         				// обмениваем значения копии и оригинального объекта
    return *this;
}
// некоторая функция для обмена значениями
void swap(Copyable& copy) noexcept;

В функции оператора присваивания сначала создается временная копия присваиваемого объекта. И в случае успешного создания копиии текущий объект (this) и копия обмениваются 
содержимым через некоторую функцию swap().

Функция swap может быть реализована как внешняя функция или как функция-член класса (в примере выше предполагается, что она реализована внутри класса). При этом функция swap 
определяется как не генерирующая исключения (с ключевым словом noexcept). Поэтому единственной точкой, где может возникнуть исключение, функция копирования (конструктор 
копирования) объекта. Если копирование не удается, то управление не доходит до выполнения функции swap.

Устойчивость к исключениям заключается в том, что в операторе присваивания нет точки, где генерация исключения могла бы привести к утечке памяти. Приведённая выше реализация 
также устойчива к присваиваниям объекта самому себе (a=a), однако содержит издержки, связанные с тем, что временная копия в этом случае тоже будет создаваться. Исключить 
издержки можно дополнительной проверкой:

// оператор присвоения некоторого класса Copyable
Copyable& operator=(const Copyable& obj) {
    Copyable copy{obj};     				// создаем копию через конструктор копирования
    if(this != &obj)        				// если не текущий объект
        swap(copy);         				// обмениваем значения копии и оригинального объекта
    return *this;
}
// некоторая функция для обмена значениями
void swap(Copyable& copy) noexcept;

Хотя часто подобный способ применяется именно в операторах присвоения, но также он может применяться в других ситуациях, где необходимо выполнить устойчивую к исключениям 
модификацию объекта. И всегда принцип будет тот же. Сначала копируем объект, который надо изменить. Далее выполняем над объектом-копией изменения. И если все пройдет удачно, 
обмениваем значениями целевой объект и объект-копию.



______________________________________________________________________________________
Идиома Move-and-Swap / Перемещение с обменом

Идиома move-and-swap или перемещение с обменом применяется в операторах присвоения с перемещением. Она позволяет избежать дублирования кода деструктора и конструктора 
копирования. Суть данной идиомы состоит в следующей последовательности действий:

1. Для перемещаемого объекта создаем копию с помощью конструктора перемещения

2.Заменяем текущий объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то текущий объект не заменяется.

Общая форма move-and-swap выглядит следующим образом:

MyClass& MyClass::operator=(MyClass&& rhs) noexcept
{
    MyClass moved(std::move(rhs)); // получаем перемещаемый объект
    swap(moved);                  // выполняем обмен значениями
    return *this; // возвращаем текущий объект
}



______________________________________________________________________________________
Паттерн swap delete

Когда удалил ту память на которую ссылаешься, и потом указатель ты занулил



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Safe bool (Безопасное преобразование в булево значение)

# Назначение

Идиома Safe bool (безопасное преобразование в булево значение) - это подход в программировании, который обеспечивает безопасное преобразование объектов в булево значение.
Назначение идиомы состоит в том, чтобы предоставить объектам способность быть использованными в условных операторах (if, while) при проверке на истинность без явного 
преобразования в булево значение. Это особенно полезно в контексте условных операторов, где требуется использование объектов, которые не являются простыми булевыми значениями.

# Решаемые значения
Проверка корректности объектов с помощью условных операторов

В языке C++ условные операторы, такие как if или while, ожидают, что условие будет иметь булево значение (true или false). Однако в некоторых случаях объекты не могут быть 
просто преобразованы в булево значение, так как они прдставляют более сложные состояния или требуют дополнительной логики для определения исмогает решить эту задачу. Вместо
использования явного преобразования в булево значение, можно просто проверить объект на истинность с помощью условных операторов.

# Общая реализация на языке С++

Идиома может быть реализована несколькими способами:
1) перегрузкой оператора приведения к типу operator bool().
2) перегрузкой оператора приведения к типу operator void*().
3) перегрузкой оператора приведения к логическому типу (basic_ios).

### 
1) Перегрузка оператора bool
В этом примере перегружен оператор приведения к типо bool, который возвращает true, если значение объекта MyClass не равно нулю, и false в противном случае. Это позволяет
использовать объекты MyClass в условиях ветвлений if и while.

#include <iostream>

class MyClass {
public:
	MyClass(int value) : value_(value) {}
	
	operator bool() const {
		return value_ != 0;
	}

private:
	int value_;
}

int main() {
	MyClass obj1(10);
	MyClass obj2(0);

	if(obj1) {
		std::cout << "obj1 is true" << std:: endl;
	}

	if(!obj2) {
		std::cout << "obj2 is false" << std:: endl;
	}

	return 0;
}


###
2) Перегрузка оператора void*
В этом примере перегружен оператр приведения к типу void*, который возвращает указатель на объект MyClass, сли значение объекта не равно нулю, и nullptr в противном случае.
Это позволяет использовать объекты MyClass в условиях ветвлений if и while, а также при работе с указателями.

#include <iostream>

class MyClass {
public:
	MyClass(int value) : value_(value){}
	
	operator void* () const {
		return value_ != 0 ? this : nullptr;
	}
private:
	int value_;
}

int main() {							// main такой же как и в предыдущем примере
	MyClass obj1(10);
	MyClass obj2(0);

	if(obj1) {
		std::cout << "obj1 is true" << std:: endl;
	}

	if(!obj2) {
		std::cout << "obj2 is false" << std:: endl;
	}

	return 0;
}


###
3) Перегурзка оператора basic_ios
В этом примере перегружен оператор приведения к логическому типу (basic_ios). Служебное слово explicit означаает, что эта функция сработает только при явном вызвове 
преобразования, например static_cast<bool>(поток). Но в стандарте C++11 отмечено, что данная функция будет срабатывать и в условиях ветвлений if, циклов while и других
подобных случаях.

struct Testable {
	explicit operator bool() const {
		// Обработка
		return false;
	}
};

int main() {
	Tastable a, b;
	if(a) {
		// Процесс
	}
	return 0;
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Scope guard (Область хранения)

# Назначение
Идиома Scope guard явялется подходом в программировании, который используется для автоматического освобождения ресурсов и выполнения определённых действий при выходе из 
области видимости (scope) в программе. Используется при:

1) Работе с ресурсами, которые должны быть освобождены в случае исключения.
2) Реализации обратных вызовов (например, при регистрации обработчика событий в библиотеке или фреймворке, Scope Guard может быть использован для отмены регистрации 
обработчика, когда он больше не нужен.).
3) Работе с транзакциями (например, при работе с базой данных, транзакции могут быть начаты в конструкторе объекта и завершены в деструкторе. Scope Guard может быть 
использован для отката транзакции, если произошло исключение, но не для освобождения ресурсов, связанных с транзакцией.).

# Решаемые задачи
Сохранение ресурсов при выходе из области видимости, если исключение не проброшено

Идиома RAII позволяет получать ресурсы в конструкторе и всывобождать их в деструкторе, когда область заканчивается успешно или из-за исключения. Однако, иногда необходимо
не высвобождать ресурсы, если исключение не выбрасывается. Идиома Scope-guard ешит эту задачу и улучшит типичную реализацию идиомы RAII с помощью условной проверки.

# Общая реализация на языке C++

class ScopeGuard {
public:
	ScopeGuard() : engaged_(true){
		// Выделение ресурсов
	}

	~ScopeGuard() {
		if(engaged_) {					// Условия для освобождения ресурсов
			// Освобождение ресурсов
		}
	}
	
	void release() {					// Если метод отрабатывает, то ресурсы не будут освобождены при вызове деструктора
		engaged_ = false;
		// Ресурсы больше не будут освобождаться
	}

private:
	bool engaged_;
}

void some_init_function() {
	ScopeGuaed quard;
	// Если выброситься какая-то ошибка, ресурсы будут освобождены.
	guard.release(); // Ресурсы не будут освобождены при обычном выполнении. 
}



______________________________________________________________________________________
######################################################################################
______________________________________________________________________________________
Addressof

# Назначение 
Идиома Addressof используется для получения адреса объекта. Она позволяет получить фактический адрес, где данные хранятся в памяти компьютера. Затем этот адрес может быть
использован для различных целей, например, для передачи в функцию, сохранения в указатель или создания ссылки.

# Решаемые задачи
Нахождение реального адреса объекта в памяти
C++ позволяет перегружать унарный оператор амперсанда (&) для типов классов. Тип возврата такого оператора не обязательно должен быть фактическим адресом объекта. Идиома
Addressof позволяет найти реальный адрес объекта независимо от перегружаемого унарного оператора амперсанда и его защиты доступа.

# Общая реализация на языка C++ 

Внутри функции addressof() используется оператор reinterpret_cast, который выполняет преобразование указателей между различными типами. В данном случае, функция addressof 
использует reinterpret_cast для преобразования ссылки на объект типа T в указатель на этот объект. Преобразование начинается с преобразования ссылки на объект типа T 
в ссылку на объект типа const volatile char, чтобы обеспечить максимальную возможную совместимость между типами. Затем используется оператор const_cast для удаления 
квалификатора const ссылки на объект типа const volatile char, чтобы получить ссылку на изменяемый объект типа volatile char.

template<class T>
T *addressof(T &v)
{
	return reinterpret_cast<T *> (&const_cast<char &> (reinterpret_cast<const volatile char &> (v)));
}

int main() {
	nonaddressable na;
	nonaddressable *naptr = addressof(na);

	return 0;
}














