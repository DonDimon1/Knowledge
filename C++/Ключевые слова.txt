																					   |
Ключевое слово auto
Язык C++ это строго типизированный яп, в нём есть чёткое разграничение на различные типы данных, и прежде чем работать с какими то данными, мы должны компилятору среды
разработки какого типа данные мы хотим использовать, работая с той или иной переменной. Переменная это именнованная область памяти, в которой хранятся данные определённого
типа. При создании переменной мы должны указать её тип данных: int a;

Ключевое слово auto позволяет не указывать компилятору явно тип данных переменной, которую мы создаём, и разрешает компилятору самому догадаться какой тип данных в этой
переменной должен храниться, на основании того, что мы в это переменную присвоим.

auto a = 10; //Тип данных не указан явно

auto b = 1.44;

auto c = "string";

//auto d;//Ошибка, поскольку мы не присвоили значение переменной, компилятор не знает, что за тип данных в ней может храниться.

Ключевое слово auto может ухудшить читабельность кода, однако может и помочь, например: Для того чтобы создать итератор для вектора, нам нужно описывать тип данных для
этого итератора:

vector<int> myVector = { 11,46,9 };
vector<int>::iterator it = myVector.begin(); //Длинная запись

чтобы не писать полностью вторую строку мы можем написать так:

vector<int> myVector = { 11,46,9 };
auto it = myVector.begin();


______________________________________________________________________________________
Цикл foreach. range-based циклы.

Цикл foreach отличается от других циклов своим специфическим предназначением, он в первую очередь предназначен для того, чтобы итерироваться по каким либо контейнерами, и 
получать доступ к элементам этого контейнера (перебор коллекции элементов).

Базовое построение цикла foreach:

for each (object var in collection_to_loop)
{

}

Мы ищем в какой то коллекции объектов (collection_to_loop) какой то конкретный объект (object var).

Сейчас почему то foreach так уже не работает. Теперь он работает вот так:

int arr[] = { 5,11,94,99,44 };

for (int var : arr) //Перебор всех элементов массива arr
{
	cout << var << endl;
};

этот цикл называется range-based цикл. В каждой итерации этого цикла в переменную var будет скопирован следующий элемент массива (начинаю с 0). Это означает что при изменении
переменной var, элемент коллекции не изменяется. Если нужно изменять элементы коллекции, то нужно передавать элементы по ссылке:

for (int &var : arr) //Перебор всех элементов массива arr
{
	var++;
	cout << var << endl;
};

Если нужно передавать элемент по ссылке, но не нужно его его изменять, то нужно указать ключевое слово const:

for (const int &var : arr)
{
	//var++; //Не получится
	cout << var << endl;
};

С помощью этого цикла мы можем перебрать контейнер без итератора:

list<int> myList = { 1,99,4,94,799,44,6 };

for (const auto &var : myList)
{
	cout << var << endl;
};



______________________________________________________________________________________
typedef (псевдоним)

Ключево слово typedef используется для отого, чтобы мы могли определённым типам данных присваивать какой то элиас, т.е. давать псевданим. Например, для того чтобы указать какого
типа данных у нас будет например контейнер STL, нам необходимо как минимум указать название самого контейнера, далее тип данных, с которым этот конкретный экземпляр контейнера
будет использоваться и дальше дать имя контейнеру. Мы указываем достаточно много параметров. Если это единичный случай, то указать все эти параметры не сложно. Но если мы часто
используем какой то тип данных, и нам постоянно приходится всё это набирать, это занимает много времени. Чтобы избежать этой рутины и было придумано ключевое слово typedef.


std::vector<int> myVector; //Например полная инициализация вектора. 

Для typedef в глобальном пространстве пишем: 


typedef std::vector<int> int_vector; //int_vector это имя нашего нового псевдонима

int main()
{
	std::vector<int> myVector; //Мы всё также по старому можем инициализировать вектор

	int_vector myVector2;	//Но теперь нам достаточно указать имя псевдонима чтобы проинициализировть вектор.
	

	return 0;
}


Коментарии под видео:

А через дерективы препроцесора нельзя так сделать? например через #define

define влияет не только на файл, в котором его написали, но и на файлы, в которые подключили файл с define - Это не мой ответ, вопросы уже были такие, так что перед тем как 
писать подобный вопрос поищите его, ведь комментов не так много!




______________________________________________________________________________________
Union Объединение.

Union такая вещь, которая чем то напоминает классы и структуры, но только внешне, потому что предназначение у union совсем другое. Это технология которая позволяет расшаривать
(делить) одну и ту же область памяти под разные данные.

Когда мы создаём какую либо переменную, помещаем в неё какие либо данные, то по сути у нас в памяти есть определённое место конкретно под эту нашу переменную, где хранятся
наши данные (int a = 10). Не даром переменная называется именнованой областью в памяти. Если мы создаём другую переменную, не важно какого типа, под эту новую переменную
выберается другая область памяти (float b = 1.464). Каждая из этих областей памяти независимы друг от друга. Union позволяет нам сделать так, чтобы в одной и той же области 
памяти мы могли бы хранить и данные переменной a и данные переменной b, т.е. не выделять под каждую переменную свою область в памяти, а выделить просто какую то область в 
памяти и в зависимости от надобности хранить там те или иные данные. Union это наследие тех времён, когда на компах было очень мало оперативной памяти и поэтому приходилось 
очень жёстко экономить. В один момент времени мы можем хранить только данные одной переменной, и поэтому использование union может привести к грубым ошибкам.


union MyUnion {
	short int a; 	//Занимает в памяти 2 байта (от -32768 до 32767)
	int b;		//Занимает 4 байта (от -2147483648 до 2147483647)
	float c; 	//Занимает 4 байта (от -2147483648.0 до 2147483647.0)
};

int main()
{
	setlocale(LC_ALL, "Russian");

	MyUnion u;	//Объект нашего union
	u.a = 5;	//Сейчас в union хранится элемент типа short int со значением 5. В остальных ячейках мусор и данные u.b и u.c не актуальны.
	u.b = 40000;	//Теперь в union хранится элемент типа int со значением 40000. Данные u.a и u.c не актуальны.
	u.c = 43.54;	//Теперь в union хранится элемент типа float со значением 43.54. Данные u.a и u.b не актуальны.
	return 0;
}

Union выделяет под общие нужды место между всеми теми переменными, которые в нём есть, то количество памяти которое требуется для хранения самой большой переменной.
При записи (например) float в union мы используем все 4 байта памяти. Когда же мы хотим взять из этого же unium'а short int(2 байта), то мы будем кушать не первые 
2 байта, а последние. Т.е., запись более маленьких переменных производится в конец выделенной памяти, а не в начало 
	


______________________________________________________________________________________
noexcept (без исключений)

Этим вы как автор гарантируете, что ваша функция не генерирует исключений, так что компилятор может, полагаясь на это, выполнять ряд оптимизаций.
Понятно, что вы хозяин своему слову - сам дал, сам и назад забрал! Только потом не удивляйтесь результатам - завершению программы.


______________________________________________________________________________________
Приведение типов

Приведение типов — это процесс преобразования значения из одного типа данных в другой. В C++ существует четыре различных метода приведения типов:

1) Приведение в стиле C : это синтаксис, унаследованный от C, и он выполняется путем простого помещения целевого типа данных в круглые скобки перед приводимым значением. Пример:

int a = 10;
float b = (float)a;


2) static_cast: это наиболее часто используемый метод приведения типов в C++. Он выполняется во время компиляции, и его следует использовать, когда у вас есть явное преобразование 
между типами данных. Этот тип приведения выполняет проверку во время компиляции и выдает ошибку, если допустимое преобразование между заданными типами невозможно. static_cast обычно 
безопаснее, чем приведение в стиле C, поскольку оно не выполняет небезопасную реинтерпретацию данных и позволяет лучше проверять типы.
Пример:

int a = 10;
float b = static_cast<float>(a);


3) dynamic_cast: этот метод специально используется для безопасного преобразования указателей и ссылок между базовыми и производными классами в иерархии классов. Это тип оператора 
приведения в C++, который используется специально для полиморфизма. 
Пример:

class Base {};
class Derived : public Base {};

Base* base_ptr = new Derived();
Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr);


4) reinterpret_cast: это приведение изменяет тип указателя, ссылки или целочисленного значения. Его также называют побитовым приведением, поскольку оно меняет способ интерпретации 
компилятором базовых битов. это тип приведения в C++, который позволяет изменять тип указателя или целого числа без изменения представления данных. Обычно он используется, когда 
требуемое преобразование слишком низкоуровневое или не поддерживается другими методами приведения, такими как static_cast. Используйте его reinterpret_castтолько в том случае, если у 
вас есть глубокое понимание того, что вы делаете, поскольку это не гарантирует, что полученное значение будет иметь смысл. 
Пример:

int* a = new int(42);
long b = reinterpret_cast<long>(a);


5) const_cast: этот метод приведения позволяет удалять или добавлять константность переменной. Другими словами, он позволяет вам модифицировать объект const или volatile или изменить
указатель или ссылку на тип const или volatile. Это полезно в определенных сценариях, когда вам нужно передать constпеременную в качестве аргумента или когда параметр функции требует 
неконстантного типа, но вы хотите, чтобы переменная оставалась постоянной во всем коде.Обычно это не рекомендуется, но может быть полезно в определенных ситуациях, когда вы не можете 
контролировать константность переменной.
Пример:

const int a = 10;
int* ptr = const_cast<int*>(&a);  // const_cast from const int* to int*
*ptr = 20;  // Not recommended, use with caution


______________________________________________________________________________________
Поиск Кенига

Правила этого поиска довольно сложны и включают в себя девять (!!!) пунктов различных условий. Однако то, что нас интересует в данный момент, можно выразить достаточно просто: при 
разрешении вызова функции список кандидатов составляется не только из элементов, доступных в данном пространстве имён, но и в пространствах имён аргументов вызова. 

#include <iostream>

namespace A {
    struct SomeClass {};

    void func(const SomeClass& value) {
    std::cout << "Hello from A::func!" << std::endl;
    }
}

int main(int argc, char * argv[]) {
    func(A::SomeClass{});
    return 0;
}

Таким образом, встретив вызов 

func(A::SomeClass{});

компилятор будет искать целевую функцию с именем func не только в текущем пространстве имён, но и в пространстве имён аргумента (в данном случае в namespace A). 

Почему поиск работает именно так, а не иначе?
Вопрос резонный. Для того, чтобы лучше понять и запомнить что-то, иногда бывает полезно осознать мотивацию. Тем более в данном случае мотивация очень и очень серьёзная. Достаточно 
посмотреть на следующий пример кода, который пришлось бы написать, не будь в языке C++ реализован ADL:

// std::cout << "Hello, World!" << std::endl;
std::operator<<(std::operator<<(std::cout, "Hello, World!"), "\n");

Обратите внимание на закомментированную строчку 1. Знакомо, не правда ли? Каждый программист на C++ довольно часто пользуется оператором operator<< для вывода в std::cout. Но проблема
в том, что в глобальном пространстве имён такого оператора нет! 

Он имеется только в пространстве имён std. Поэтому без поиска Кенига нам бы пришлось написать полную квалификацию пространств имён используемых функций 
(в данном случае это operator<<). 

В результате изо дня в день пришлось бы писать строчки, как строка 2 в приведённом выше примере. Спасибо Кенигу! Оказывается, мы пользуемся его творением практически постоянно!


______________________________________________________________________________________
explicit (Переводится как явный)

Ключевое слово explicit используется для предотвращения неявных преобразований типов данных, которые могут быть вызваны конструкторами или операторами преобразований. Это ключевое
слово вноситься в объявление конструктора или оператора преобразования для указания компилятору, что такое преобразование должно быть разрешено только при явном указании. Без этого
ключевого слова конструкторы могут быть неожиданно вызваны там, где это не предполагалось, например в параметрах функций или в операциях сравнения.

Конструктор

class MyClass {
public:
	explicit MyClass(int value) : value_(value) {}

private:
	int value_;
};

void processClass(MyClass obj) {
	// Функции обработки
};

int main() {
	MyClass obj = MyClass(10); // Допустимо, явное преобразование
	MyClass obj2(20); //Также допустимо

	// processClass(10); // Ошибка компиляции, т.к. конструктор explicit
	processClass(MyClass(10)); // Допустимо, явное преобразование
	return 0;
}

В этом пример конструктор MyClass объявлен как explicit, что предотвращает его использование для неявного преобразования целочисленного аргумента 10 в объект MyClass при вызове 
processClass.

Оператор преобразования

class Weight {
public:
	explicit opetator int() const {return weight_;}

private:
	int weight_ = 0;
};

void processWeight(int weight) {
	// Функции обработки
};

int main() {
	Weight w;
	processWeight(w); // Ошибка компиляции, т.к. оператор преобразования explicit
	processWeight(static_cast<int>(w)); // Допустимо, явное преобразование
	return 0;
}

Здесь оператор преобразования типа объявлен как explicit, что требует явного указания типа для его использования.


Кодстайл - если у вас есть конструктор от одного аргумента всегда писать его explicit

Под if есть специальный каст. Конверсии бывают explicit(явные), implicit(вроде так пишется)(неявные), а бывают ещё contextual conversion - это как раз конверсия которая 
происходит под if, while и тернарном операторе. Это особый вид конверсии, который разрешает в том числе и explicit конверсии рассматривать. Т.е. если мы преобразование 
сделаем explicit, то под if он всё ровно может работать неявно, но в обычных выражениях работать не будет. Т.е. приведение типа даже к bool нужно делать explicit.


______________________________________________________________________________________
placement new

placement new` — это разновидность оператора `new`, который позволяет конструировать объекты в предварительно выделенной области памяти. Это особенно полезно в случаях, когда 
необходимо точно контролировать, где объект должен быть расположен в памяти, или когда нужно избежать лишних выделений памяти для повышения производительности или из-за ограничений 
среды выполнения.

Основные принципы и использование

Не выделяет память. Вместо этого он использует указатель на уже выделенную область памяти, чтобы инициализировать объект в этом месте. Для этого требуется передать в `new` адрес, 
где должен быть размещен объект.Синтаксис выглядит следующим образом:

#include <new>  // Необходим для std::nothrow и std::placement_new

char buffer[sizeof(MyClass)];
MyClass* pMyClass = new (buffer) MyClass();

В этом примере объект типа `MyClass` создается непосредственно в буфере, предоставленном пользователем. Это означает, что память для объекта не выделяется динамически через 
стандартный механизм выделения памяти, а используется область, указанная пользователем.

Преимущества и особенности

1. Контроль расположения: Позволяет разработчикам выбирать, где именно в памяти будет расположен объект. Это может быть критически важно для систем, требующих определенного 
выравнивания или расположения объектов для оптимизации производительности.

2. Избежание дополнительного выделения памяти: При его использовании можно повторно использовать или эффективно управлять памятью, что может быть важно в системах с ограниченными 
ресурсами или в высокопроизводительных приложениях.

3. Конструирование объектов на месте: Полезно для создания объектов внутри предварительно выделенных массивов или сложных структур данных, как например, в памяти, выделенной для 
контейнеров.

Осторожность при использовании

Управление памятью: Поскольку он не освобождает память автоматически, разработчики должны вручную вызывать деструктор для любых объектов, созданных с помощью `placement new`, когда 
объекты больше не нужны.

Исключения и безопасность: Нужно быть внимательным при обработке исключений в конструкторах объектов, созданных через `placement new`, чтобы избежать утечек ресурсов.

pMyClass->~MyClass();

Это необходимо, поскольку `delete` не может быть использован с объектами, созданными с помощью `placement new`.

`Placement new` — это мощный инструмент, предоставляющий гибкость в управлении памятью и расположении объектов. Он особенно полезен в ситуациях, когда требуется оптимизация 
производительности или когда работа ведется в средах с ограниченными ресурсами. Однако его использование требует тщательного управления жизненным циклом объекта и явного вызова 
деструкторов.



______________________________________________________________________________________
final

Ключевое слово final применяется для явного запрета наследования от этого класса или переопределения виртуальной функции. Это обеспечивает контроль над использованием класса в качестве базового и 
предотвращает изменение поведения определенных функций в производных классах. 

Запрет наследования от класса:

class Base final {
	// Определение класса с ключевым словом final
};

В этом примере класс Base объявлен с ключевым словом final, что означает, что нельзя создать производный класс от Base.


Запрет переопределения функции:
class Base {
public:
	virtual void print() const final {
		// Определение виртуальной функции с ключевым словом final
	}
};

В этом примере функция print объявлена виртуальной и помечена как final, что запрещает ее переопределение в производных классах.

final также позволяет выполнять оптимизацию, известную как девиртуализация, тем самым повышая производительность во время выполнения. 
(https://blog.llvm.org/2017/03/devirtualization-in-llvm-and-clang.html)

https://habr.com/ru/companies/otus/articles/704016/ - статья


______________________________________________________________________________________
extern (Внешний)

Для подключения внешних объектов в файл кода применяется ключевое слово extern. Т.е. extern означает что мы не объявляем новую переменную, а используем какую то переменную, объявленную в другом cpp 
файле.

Например, пусть у нас есть файл objects.cpp, в котором определяются :

#include <string>
std::string message {"Hello"};
unsigned times {3};

Здесь определены переменные типа std::string и unsigned int. Для использования типа std::string необходимо подключить заголовочный файл <string>

Пусть главный файл программы называется app.cpp и использует эти переменные:

#include <iostream>
 
extern std::string message;
extern unsigned times;
 
int main()
{
    for(unsigned i{}; i < times; i++)
    {
        std::cout << message << std::endl;
    }
}

Чтобы использовать переменные, определенные во внешнем файле, они объявляются с помощью ключевого слова extern

extern std::string message;
extern unsigned times;

########
Подключение констант
Подключение констант имеет особенность - ключевое слово extern надо указывать и при определении константы. Так, изменим файл objects.cpp следующим образом:

#include <string>
 
extern const std::string message {"Hello"}; // константа
unsigned times {3};

Также изменим файл app.cpp:

#include <iostream>
 
extern const std::string message;   // подключаем константу
extern unsigned times;
 
int main()
{
    for(unsigned i{}; i < times; i++)
    {
        std::cout << message << std::endl;
    }
}

Результат будет тот же, что и в предыдущем случае.

########
Вынесение объявления в заголовочные файлы

В примере выше мы вынуждены подключать в главный файл программы два внешних объекта. Но что, если этих переменных и констант очень много? Чтобы не загрязнять главный файл программы, мы можем, как и в 
случае с внешними функциями, вынести объявления внешних объектов в отдельный заголовочный файл. Так, определим в той же папке, где располагаются файлы app.cpp и objects.cpp, новый файл - objects.h:

objects.h:
extern const std::string message;   // подключаем константу
extern unsigned times;

Теперь подключим этот заголовочный файл в файле app.cpp:

app.cpp:
#include <iostream>
#include "objects.h"        // подключаем внешние объекты
 
int main()
{
    for(unsigned i{}; i < times; i++)
    {
        std::cout << message << std::endl;
    }
}


______________________________________________________________________________________
Volatile (Волатильность - неустойчивый, непостоянный)

Volatile — ключевое слово языков C/C++, которое информирует компилятор о том, что значение переменной может меняться из вне и что компилятор не будет оптимизировать эту переменную. Это может произойти 
под управлением операционной системы, аппаратных средств или другого потока. Поскольку значение может измениться, компилятор каждый раз загружает его из памяти.

Волатильную целочисленную переменную можно объявить как:

int volatile х;volatile int х;

Чтобы объявить указатель на эту переменную, нужно сделать следующее:

volatile int *х;int volatile *х;

Волатильный указатель на неволатильные данные используется редко, но допустим:
int *volatile х;

Если вы хотите объявить волатильный указатель на волатильную область памяти, необходимо сделать следующее:

int volatile *volatile х;

Волатильные переменные не оптимизированы, что может пригодиться. Представьте следующую функцию:

int opt = 1;
void Fn(void) {
    start:
        if (opt == 1)
            goto start;
        else
            break;
}

На первый взгляд кажется, программа зациклится. Компилятор может оптимизировать ее следующим образом:

void Fn(void) {
    start:
    int opt = 1;
    if (true)
        goto start;
}

Вот теперь цикл точно станет бесконечным. Однако внешняя операция позволит записать 0 в переменную opt и прервать цикл.

Предотвратить такую оптимизацию можно с помощью ключевого слова volatile, например объявить, что некий внешний элемент системы изменяет переменную:

volatile int opt = 1;
void Fn(void) {
    start:
    if (opt == 1)
        goto start;
    else
        break;
}

Волатильные переменные используются как глобальные переменные в многопотоковых программах — любой поток может изменить общие переменные. Мы не хотим оптимизировать эти переменные.

Разбор взят из книги Гейл Л. Макдауэлл «Cracking the Coding Interview» (есть в переводе).



______________________________________________________________________________________
Запись int i{}; Инициализацию по умолчанию

Данная конструкция - объявление с инициализатором.

Пустые скобки - () или {} - на месте инициализатора всегда означают инициализацию по умолчанию в С++. В данном случае, т.е. для типа int, это инициализация нулем.

Пример: Пузырьковая сортировка:

std::vector<int> A = {1, 10, 223, 41, 532, -224, 33};
for (size_t i{}; i < A.size(); ++i) {			// Могли бы написать size_t i = 0;
	for (size_t j{}; j < A.size() - i - 1; ++j) {	// Могли бы написать size_t j = 0;
		if(A[j] > A[j + 1])
			std::swap(A[j], A[j + 1]);
	}
}

Инициализатор () существует в C++ с "начала времен" (C++98), а инициализатор {} в такой роли появился в C++11. То есть во многих контекстах у вас есть выбор между () и {}. Однако в вашем конкретном 
контексте () в корне поменяет смысл декларатора, поэтому остается только вариант {}. (Собственно поэтому в С++11 возможности {}-синтаксиса инициализации и сделали универсальными и основными).

Разумеется, когда тип известен - int - вы можете пользоваться любым иным способом инициализации нулем, например, возможно более читаемым int i = 0; или int i(0);. Но в общем случае, особенно когда тип 
неизвестен, {} является наиболее универсальным вариантом для инициализации по умолчанию.


#######
Разница между инициализацией по умолчанию и инициализацией по значению

int x;			// x и x2 инициализированны по умолчанию и содержат мусор.
int *x2 = new int;

int y{};		// y, y2, y3 инициализированны с значением. Они все гарантированно содержат 0. Это возможно немного менее эффективно, но является хорошей практикой.
int *y2 = new int{};
int *y2 = new int();

int z(); 		// Объявление функции

Тоже самое происходит, когда у нас есть тип структуры или массива:

struct S {
	int n, m;
	std::string s;
}

S x;			// n и m будут содержать мусорные значения, а строка s пустая.
S *x2 = new S;

S y{};			// n и m будут равны 0. строка s пустая.
S *y2 = new S{};
S *y3 = new S();



______________________________________________________________________________________
const

Кроме переменных в языке программирования C++ можно определять константы. Их значение устанавливается один раз и впоследствии мы его не можем изменить. И так как нельзя изменить значения константы, то 
ее всегда необходимо инициализировать, если мы хотим, чтобы она имела некоторое значение. Если константа не будет инициализирована, то компилятор также выведет ошибку и не сможет скомпилировать 
программу. 

Объекты классов также могут представлять константы. Для константного объекта можно вызывать только константные функции. Потому что в любой функции класса теоретически можно изменять его поля, а 
компилятор не может определить, меняется ли значение в функции или нет. Поэтому одинаково отказывается компилировать и те функции, которые меняют состояние объекта, и те функции, которые его не меняют.
Еще одно ограничение, с которым можно столкнуться, касается вызова в константной функции других функций этого же класса - константная функция может вызыть только константные функции класса.
Еще одно ограничение, связанное с константными функциями, состоит в том, что, если мы хотим возвратить из константной функции указатель или ссылку, то они указетель должен указывать на константу, а 
ссылка должна быть константной.



______________________________________________________________________________________
mutable (изменяемый)

Иногда бывает необходимо, чтобы какие-то данные константного объекта все-таки можно было менять. В этом случае для переменной, которую необходимо менять, можно использовать ключевое слово mutable. 
И даже если объект является константным, значение такой переменной можно изменить.

#include <iostream>
  
class Person 
{
public:
    std::string name;
    mutable unsigned age;   					// 2) Однако, переменную age можно изменить
    Person(std::string p_name, unsigned p_age)
    {
        name = p_name;
        age = p_age;
    }
    void print() const 
    {
        std::cout << "Name: " << name  << "\tAge: " << age << std::endl;
    }
};
int main()
{
    const Person tom{"Tom", 38};				// 1) Константный объект(По идеи его данные менять нельзя)
    tom.age = 22;
    tom.print();    // Name: Tom       Age: 22
}



Изменяемые лямбда-функции

Есть и ещё один вариант применения ключевого слова mutable и он связан с сохранением состояния в лямбда-функциях. Обычно оператор вызова функции замыкания является константным. Другими словами — лямбда 
не может модифицировать переменные, захваченные по значению:

int main() {
  int i = 2;
  auto ok = [&i](){ ++i; }; //OK, i захватывается по ссылке
  auto err = [i](){ ++i; }; //Ошибка: попытка изменения внутренней копии i
  auto err2 = [x{22}](){ ++x; }; //Ошибка: попытка изменения внутренней переменной x
}

Но ключевое слово mutable может быть применено ко всей лямбда-функции, что сделает все её переменные изменяемыми:

int main() {
  int i = 2;
  auto ok = [i, x{22}]() mutable { i++; x+=i; };
}

Следует заметить, что в отличии от mutable-переменных в объявлении класса, мутабельные лямбда-функции должны использоваться относительно редко и очень аккуратно. Сохранение состояния между вызовами лямбда-функции может быть опасным и 
контринтуитивным.



______________________________________________________________________________________
new и expression new

В чем разница между operator new и expression new?

В том, что это совершенно разные, хоть и взаимосвязанные, вещи.

New-expression - это встроенная конструкция языка, при помощи которой в языке С++ создаются объекты в динамической памяти. Например:

int *p1 = new int();			// Это New-expression и оно выхывает конструкторы для объектов.
SomeClass *p2 = new SomeClass[20];

А operator new (и operator new[]) - это функции выделения "сырой" неинициализированной памяти, которые неявно вызываются изнутри new-expression. В упрощенной форме алгоритм работы new-expression 
состоит из двух этапов:

1) Вызвать функцию выделения "сырой" памяти operator new/operator new[]
2) Проинициализировать (если необходимо) полученную от operator new "сырую" память - например, путем вызова конструктора(-ов) создаваемого объекта(-ов).

Стандартная библиотека предоставляет некую "базовую" реализацию функций operator new. Эти функции, при необходимости, также являются замещаемыми/перегружаемыми пользователем, в том числе индивидуально 
для каждого пользовательского класса.

Получается: operator new() НЕ вызывает конструктор(ы) для объекта(ов), под который(ые) выделяется память. Он просто выделяет память нужного размера и все. Его отличие от сишных функций в том, что он 
может бросить исключение и его можно переопределить, а так же сделать оператором для отдельно взятого класса, тем самым переопределить его только для этого класса (остальное вспомните сами:)).

А вот new-expression как раз и вызывает конструктор(ы) объекта(ов). Хотя правильней сказать, что он тоже ничего не вызывает, просто, встречая его, компилятор генерирует код вызова конструктора(ов).

Пример:

#include <iostream>

class Test {
public:
    Test() {
        std::cout << "Test::Test()" << std::endl;
    }

    void* operator new (std::size_t size) throw (std::bad_alloc) {
        std::cout << "Test::operator new(" << size << ")" << std::endl;
        return ::operator new(size);
    }
};

int main() {
    Test *t = new Test();
    void *p = Test::operator new(100); // 100 для различия в выводе
}

Этот код выведет следующее:
Test::operator new(1)
Test::Test()
Test::operator new(100)

P.S. оператор delete и operator delete() имеют аналогичное различие.



______________________________________________________________________________________
using

Подключение пространств имен и определение псевдонимов:

using пространство_имен::объект

Например:
using namespace std;    // эта директива using указывает компилятору импортировать

Или:

#include <iostream>
using std::cin;
using std::cout;
using std::endl;
 
int main()
{   
    int age;
    cout << "Input age: ";			//std::cout не нужно уточнять
    cin >> age;
    cout << "Your age: " << age << endl;
}



##############
Определение псевдонимов

Ключевое слово using также позволяет определять псевдонимы для типов. Это может пригодиться, когда мы работаем с типами с длинными названиями, а определение коротких псевдонимов 
позволит сократить код. Например:

using ullong = unsigned long long;
int main()
{
    ullong n {10234};
    std::cout << n << std::endl;
}

В данном случае для типа unsigned long long определен псевдоним ullong. Стоит отметить, что это именно определение псевдонима, а НЕ определение нового типа.

Стоит отметить, что для определения псевдонимов в С++ также может использоваться старый подход в стиле языка С с помощью оператора typedef:

typedef unsigned long long ullong;
int main()
{
    ullong n {10234};
    std::cout << n << std::endl;
}


Область видимости объявлений и директив using
Если объявление using или директива using используется в блоке, имена применимы только в этом блоке (они следуют обычным правилам области видимости блока). Это хорошо, поскольку 
снижает вероятность возникновения конфликтов имен внутри этого блока.

Если объявление using или директива using используются в глобальном пространстве имен, имена применимы ко всему остальному файлу (они имеют область видимости файла).

Отмена или замена инструкции using
После объявления инструкции using ее невозможно отменить или заменить ее другой инструкцией using в той области видимости, в которой она была объявлена.

Лучшие практики для инструкций using
В современном C++ на самом деле нет места для использования директив. Они увеличивают вероятность коллизий имен сейчас и в будущем и могут вызывать более коварные проблемы. Хотя во 
многих учебниках и руководствах они широко используются, использования директив лучше вообще избегать.

Объявления using обычно считаются безопасными для использования внутри блоков. Ограничьте их использование в глобальном пространстве имен файлов исходного кода и никогда не 
используйте их в глобальном пространстве имен заголовочных файлов.



#############
Восстановить уровень доступа спецификатора при наследовании. См. ООП - Установка публичного доступа using



______________________________________________________________________________________
constexpr 

Одна из новых возможностей C++11 — спецификатор constexpr. С помощью него можно создавать переменные, функции и даже объекты, которые будут рассчитаны на этапе компиляции.

Пример:
constexpr int sum (int a, int b)
{
	return a + b;
}

void func()
{
	constexpr int c = sum (5, 12); // значение переменной будет посчитано на этапе компиляции
}


constexpr-функция: constexpr возвращаемое_значение имя_функции (параметры)
Ключевое слово constexpr, добавленное в C++11, перед функцией означает, что если значения параметров возможно посчитать на этапе компиляции, то возвращаемое значение также должно посчитаться на этапе 
компиляции. Если значение хотя бы одного параметра будет неизвестно на этапе компиляции, то функция будет запущена в runtime (а не будет выведена ошибка компиляции).

constexpr-переменная: constexpr тип = expression;
Ключевое слово в данном случае означает создание константы. Причем expression должно быть известно на этапе компиляции. constexpr-переменная является константой (const), но константа не является 
constexpr-переменной.

Пример:

int sum (int a, int b)
{
	return a + b;
}

constexpr int new_sum (int a, int b)
{
	return a + b;
}

void func()
{
	constexpr int a1 = new_sum (5, 12); // ОК: constexpr-переменная
	constexpr int a2 = sum (5, 12); // ошибка: функция sum не является constexp-выражением
	int a3 = new_sum (5, 12); // ОК: функция будет вызвана на этапе компиляции
	int a4 = sum (5, 12); // ОК
}

В случае «утери» constexpr-спецификатора переменной вернуть обратно его уже не получится, даже если значение может посчитаться на этапе компиляции. constexpr-спецификатор нельзя добавить с помощью 
const_cast, так как constexpr не является cv-спецификатором (это const и volatile).

Параметры функций не могут быть constexpr. То есть не получится создать исключительно constexpr-функцию, которая может работать только на этапе компиляции.


##################
Ограничения

Начнем с ограничений constexpr-переменных. Тип constexpr-переменной должен быть литеральным типом, то есть одним из следующих:
	Скалярный тип
	Указатель
	Массив скалярных типов
	Класс, который удовлетворяет следующим условиям:
		Имеет деструктор по умолчанию
		Все нестатические члены класса должны быть литеральными типами
		Класс должен иметь хотя бы один constexpr-конструктор (но не конструктор копирования и перемещения) или не иметь конструкторов вовсе

constexpr-переменная должна удовлетворять следующим условиям:
Ее тип должен быть литеральным
Ей должно быть сразу присвоено значение или вызван constexpr-конструктор
Параметры конструктора или присвоенное значение могут содержать только литералы или constexpr-переменные и constexpr-функции


Основные ограничения наложены на constexpr-функции:
	Она не может быть виртуальной (virtual)
	Она должна возвращать литеральный тип (void вернуть нельзя*)
	Все параметры должны иметь литеральный тип
	Тело функции должно содержать только следующее:
		static_assert
		typedef или using, которые объявляют все типы, кроме классов и перечислений (enum)
		using для указания видимости имен или пространств имен (namespace)
		Ровно один return, который может содержать только литералы или constexpr-переменные и constexpr-функции

	*С C++14 void также будет литеральным типом.


https://habr.com/ru/articles/228181/



______________________________________________________________________________________
std::optional

Вообще std::optional это класс из стандартной библиотеки, который может пригодиться на замену exception. Если функция может завершиться неудачно, то с помощью std::optional функция
может либо вернуть T, либо ничего. Так он обходит выделение динамической памяти, при использовании placement new мы понимаем что можем просто на массиве char либо положить value,
либо не положить. Если мы разыменуем optional в котором ничего не лежало, то это UB. 


template <typename T>						// Реализация std::optional C++17
class optional {
	char value[sizeof(T)];
	bool initialized = false;
public:
	optional(const T& newvalue) : initialized(true) {
		new (value) T(newvalue);
	}
	optional() {} 						// optional по умолчанию ничего не делает
	~optional() {
		if(initialized) {
			reinterpret_cast<T>(value)->~T();
		}
	}
	bool has_value() const {				
		return initialized;
	}
	operator bool() const {					// Можно проверить лежит ли чтото в optional, просто скастив его к bool.
		return initialized;
	}
	T& operator*() {					// Вернуть из optional, то что в нём лежит
		return reinterpret_cast<T&>(*value);		
	}
	const T& value_or(const T& other) const {		// Если в optional что то лежит, то верни мне это, а иначе верни константу которую мы передали в параметр.
		return initialized ? reinterpret_cast<T&>(*value) : other;
	}
};


Есть ещё глобальная переменная std::nullopt.  

struct nullopt_t();
nullopt_t nullopt;

Она нужна для того, чтобы optional проинициализировать явно пустым значением.



______________________________________________________________________________________








