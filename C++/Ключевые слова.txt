																					   |
Ключевое слово auto
Язык C++ это строго типизированный яп, в нём есть чёткое разграничение на различные типы данных, и прежде чем работать с какими то данными, мы должны компилятору среды
разработки какого типа данные мы хотим использовать, работая с той или иной переменной. Переменная это именнованная область памяти, в которой хранятся данные определённого
типа. При создании переменной мы должны указать её тип данных: int a;

Ключевое слово auto позволяет не указывать компилятору явно тип данных переменной, которую мы создаём, и разрешает компилятору самому догадаться какой тип данных в этой
переменной должен храниться, на основании того, что мы в это переменную присвоим.

auto a = 10; //Тип данных не указан явно

auto b = 1.44;

auto c = "string";

//auto d;//Ошибка, поскольку мы не присвоили значение переменной, компилятор не знает, что за тип данных в ней может храниться.

Ключевое слово auto может ухудшить читабельность кода, однако может и помочь, например: Для того чтобы создать итератор для вектора, нам нужно описывать тип данных для
этого итератора:

vector<int> myVector = { 11,46,9 };
vector<int>::iterator it = myVector.begin(); //Длинная запись

чтобы не писать полностью вторую строку мы можем написать так:

vector<int> myVector = { 11,46,9 };
auto it = myVector.begin();


______________________________________________________________________________________
Цикл foreach. range-based циклы.

Цикл foreach отличается от других циклов своим специфическим предназначением, он в первую очередь предназначен для того, чтобы итерироваться по каким либо контейнерами, и 
получать доступ к элементам этого контейнера (перебор коллекции элементов).

Базовое построение цикла foreach:

for each (object var in collection_to_loop)
{

}

Мы ищем в какой то коллекции объектов (collection_to_loop) какой то конкретный объект (object var).

Сейчас почему то foreach так уже не работает. Теперь он работает вот так:

int arr[] = { 5,11,94,99,44 };

for (int var : arr) //Перебор всех элементов массива arr
{
	cout << var << endl;
};

этот цикл называется range-based цикл. В каждой итерации этого цикла в переменную var будет скопирован следующий элемент массива (начинаю с 0). Это означает что при изменении
переменной var, элемент коллекции не изменяется. Если нужно изменять элементы коллекции, то нужно передавать элементы по ссылке:

for (int &var : arr) //Перебор всех элементов массива arr
{
	var++;
	cout << var << endl;
};

Если нужно передавать элемент по ссылке, но не нужно его его изменять, то нужно указать ключевое слово const:

for (const int &var : arr)
{
	//var++; //Не получится
	cout << var << endl;
};

С помощью этого цикла мы можем перебрать контейнер без итератора:

list<int> myList = { 1,99,4,94,799,44,6 };

for (const auto &var : myList)
{
	cout << var << endl;
};



______________________________________________________________________________________
typedef (псевдоним)

Ключево слово typedef используется для отого, чтобы мы могли определённым типам данных присваивать какой то элиас, т.е. давать псевданим. Например, для того чтобы указать какого
типа данных у нас будет например контейнер STL, нам необходимо как минимум указать название самого контейнера, далее тип данных, с которым этот конкретный экземпляр контейнера
будет использоваться и дальше дать имя контейнеру. Мы указываем достаточно много параметров. Если это единичный случай, то указать все эти параметры не сложно. Но если мы часто
используем какой то тип данных, и нам постоянно приходится всё это набирать, это занимает много времени. Чтобы избежать этой рутины и было придумано ключевое слово typedef.


std::vector<int> myVector; //Например полная инициализация вектора. 

Для typedef в глобальном пространстве пишем: 


typedef std::vector<int> int_vector; //int_vector это имя нашего нового псевдонима

int main()
{
	std::vector<int> myVector; //Мы всё также по старому можем инициализировать вектор

	int_vector myVector2;	//Но теперь нам достаточно указать имя псевдонима чтобы проинициализировть вектор.
	

	return 0;
}


Коментарии под видео:

А через дерективы препроцесора нельзя так сделать? например через #define

define влияет не только на файл, в котором его написали, но и на файлы, в которые подключили файл с define - Это не мой ответ, вопросы уже были такие, так что перед тем как 
писать подобный вопрос поищите его, ведь комментов не так много!




______________________________________________________________________________________
Union Объединение.

Union такая вещь, которая чем то напоминает классы и структуры, но только внешне, потому что предназначение у union совсем другое. Это технология которая позволяет расшаривать
(делить) одну и ту же область памяти под разные данные.

Когда мы создаём какую либо переменную, помещаем в неё какие либо данные, то по сути у нас в памяти есть определённое место конкретно под эту нашу переменную, где хранятся
наши данные (int a = 10). Не даром переменная называется именнованой областью в памяти. Если мы создаём другую переменную, не важно какого типа, под эту новую переменную
выберается другая область памяти (float b = 1.464). Каждая из этих областей памяти независимы друг от друга. Union позволяет нам сделать так, чтобы в одной и той же области 
памяти мы могли бы хранить и данные переменной a и данные переменной b, т.е. не выделять под каждую переменную свою область в памяти, а выделить просто какую то область в 
памяти и в зависимости от надобности хранить там те или иные данные. Union это наследие тех времён, когда на компах было очень мало оперативной памяти и поэтому приходилось 
очень жёстко экономить. В один момент времени мы можем хранить только данные одной переменной, и поэтому использование union может привести к грубым ошибкам.


union MyUnion {
	short int a; 	//Занимает в памяти 2 байта (от -32768 до 32767)
	int b;		//Занимает 4 байта (от -2147483648 до 2147483647)
	float c; 	//Занимает 4 байта (от -2147483648.0 до 2147483647.0)
};

int main()
{
	setlocale(LC_ALL, "Russian");

	MyUnion u;	//Объект нашего union
	u.a = 5;	//Сейчас в union хранится элемент типа short int со значением 5. В остальных ячейках мусор и данные u.b и u.c не актуальны.
	u.b = 40000;	//Теперь в union хранится элемент типа int со значением 40000. Данные u.a и u.c не актуальны.
	u.c = 43.54;	//Теперь в union хранится элемент типа float со значением 43.54. Данные u.a и u.b не актуальны.
	return 0;
}

Union выделяет под общие нужды место между всеми теми переменными, которые в нём есть, то количество памяти которое требуется для хранения самой большой переменной.
При записи (например) float в union мы используем все 4 байта памяти. Когда же мы хотим взять из этого же unium'а short int(2 байта), то мы будем кушать не первые 
2 байта, а последние. Т.е., запись более маленьких переменных производится в конец выделенной памяти, а не в начало 



______________________________________________________________________________________
std::function | Полиморфная обёртка функции

Класс function является полиморфной обёрткой для функций. Объект такого класса может хранить, копировать любой вызываемы объект (функцию, метод класса, лямбда выражение).
Это некий аналог указателя на функцию, только из мира ООП.

#include <functional> //Для использования function

Класс function может создать объект, который будет ссылаться на какую либо функцию, либо лямбда выражение. При создании объекта класса function у него должа быть указана 
сигнатура функции, с которой такой объект может взаимодействовать. Т.о. этот объект function сможет ссылаться на любую функцию с аналогичной сигнатурой (сигнатура это тип
возвращаемого значения, а так же типы и кол-во принимаемых параметров). Далее мы можем работать с функцией через этот объект.

void Foo() {
	cout << "Foo()" << endl;
}
void Bar() {
	cout << "Bar()" << endl;
}
int Sum(int a, int b) {
	return a + b;
}
int main()
{
	setlocale(LC_ALL, "Russian");
	function<void()> f; //Объект класса function
	f = Foo; //Аналогично указателю на функцию, мы можем указать что наш объект будет ссылатьяс на функцию.
	f(); // Вызов функции Foo (оператор вызова хранимой функции).
	f = Bar; //Присваиваем объекту другую функцию с той же сигнатурой
	f();

	function<int(int, int)> f2; //<тип возвращаемого значения(тип параметра 1, тип параметра 2)>
	f2 = Sum;
	cout << f2(2, 3) << endl;;

	return 0;
}


##########
Пример передачи указателя на функцию в параметре:

void Foo(int a) {	//Вывод только диапазон чисел
	if (a > 10 && a < 40)
		cout << a << endl;
}
void Bar(int a) {	//Вывод только чётных функций
	if (a % 2 == 0)
		cout << a << endl;
}
void DoWork(vector<int> &vc, function<void(int)> f) { //Пербор вектора
	for (auto el : vc)
		f(el);	//Вызов функции в параметре
}
int main()
{
	setlocale(LC_ALL, "Russian");
	vector<int> vc = { 1,51,4,10,44,98,8,12,22,29,49 };
	DoWork(vc, Foo); //Передача указателя на функцию в параметре
	DoWork(vc, Bar);
	return 0;
}


##########
Но что если нам нужно передавать в качестве параметра не просто любую функцию, а нам нужно чтобы мы выполняли в коде набор различных функций, при чём кол-во функций не было
постоянным.

void Foo(int a) {							//Вывод толкь диапазон числе
	if (a > 10 && a < 40)
		cout << "FOO\t"<< a << endl;
}
void Bar(int a) {							//Вывод только чётных функций
	if (a % 2 == 0)
		cout << "BAR\t" << a << endl;
}
void DoWork(vector<int> &vc, vector<function<void(int)>> funcVector) { 	//Пербор вектора
	for (auto el : vc) { 						//Перебор всех чисел
		for (auto &fel : funcVector) { 				//Перебор всех функций для обработки чисел.
			fel(el); 					//На каждой итерации новая функция вызывается с параметром текущего числа.
		}
	}
}
int main()
{
	setlocale(LC_ALL, "Russian");
	vector<int> vc = { 1,51,4,10,44,98,8,12,22,29,49 };
	vector <function<void(int)>> fVector; 				//Вектор функций для работы функции DoWork.
	fVector.emplace_back(Foo); 					//Добавить в вектор функций нужные нам функции.
	fVector.emplace_back(Bar);

	DoWork(vc, fVector); 						//Вызов функции 

	return 0;
}



______________________________________________________________________________________
Лямбда-выражения | Лямбда функции | Анонимные функции

[](){}; //Это анонимная функция, которая пока что ничего не умеет. [Работа со внешним контекстом](Парамтеры){тело функции}.


void DoWork(vector<int> &vc, function<void(int)> func) { 	//Пербор вектора
	for (auto el : vc) { 					//Перебор всех чисел в векторе
		func(el);					//Вызов анонимной функции
	}
}
int main()
{
	setlocale(LC_ALL, "Russian");
	vector<int> vc = { 1,51,4,10,44,98,8,12,22,29,49 };

	function<void(int)> f; 					//Полиморфная обёртка функции
	f = [](int a) { 					//Объект класса function ссылается на анонимную функцию
		cout << "Вызвана анонимная функция с параметром - " << a << endl;
	};
	
	DoWork(vc, f); 						//Вызов функции 



	/*DoWork(vc, [](int a) { 				//2-ой вариант вызова функции DoWork. Вместо f просто пишем лямбда функцию.
		cout << "Вызвана анонимная функция с параметром - " << a << endl;
	}); 							//Вызов функции */

	return 0;
}


Смысл [] в лямбда функции: Всё пространство, которое находится рядом с нашей анонимной функцией это контекст этой функции. Реализация лямбда функции изолирована от этой функции.

//контекст 

[](){
    //Внутренний контекст (реализация). Изолирован от внешнего контекста.
};

//контекст 


Если мы хотим внутри этой анонимной функции обратиться к чему то из контекста
int p = 0; 		//Внешняя переменная

[&p](int a){ 		//Передача внешней переменной по ссылке в квадратные скобки
	p = 5;
};



С 14 стандарта с++ мы можем присвоить переменной лямбда функцию:

int p = 0; 		//Внешняя переменная

auto f = [&p]() { 	//Передача внешней переменной по ссылке в квадратные скобки
	p = 5;
};

f(); 			//Вызов лямбда функции



Тип возвращаемого значения лямбда функции можно определить так:

auto f = []() { 
	return 1; //Например, в результате работы лямбда функции возврашаем значение типа int
};

auto q = f(); //q становиться int и берёт значение возврата функции.

Реальное полезное применение расмотренно в файле "Многопоточном программирование" в четвёртой теме.



______________________________________________________________________________________
Захват контекста лямбдой

Внутреннее пространство лямбда функции изолировано от внешнего контекста. За захват контекста у нас отвечают [] скобки.

Захват переменной в лямбда функции по значению. Если мы добавляем переменну по значению, нам доступна только операция чтения, но не изменения.

int main()
{
	setlocale(LC_ALL, "Russian");

	int a = 55;			//Переменная a, которая нужна для работы нашей лямбда функции

	auto f = [a]() { 		//Создание переменной, которая приравнивается лямбда функция.
		cout << a << endl;	//Чтение переменной a работает
		//a = 100; 		//Изменение не работает, поскольку переменная a передаётся по значению.
	};

	f();				//Вызов лямбда функции

	return 0;
}


Захват переменной в лямбда функции по ссылке. Теперь мы можем и читать и изменять переменную a.

int main()
{
	setlocale(LC_ALL, "Russian");

	int a = 55;			//Переменная a, которая нужна для работы нашей лямбда функции

	auto f = [&a]() { 		//Создание переменной, которая приравнивается лямбда функция.
		a = 100; 		//Теперь можем изменять переменную a
		cout << a << endl; 	//Чтение переменной a работает
	};

	f();				//Вызов лямбда функции

	return 0;
}


Захват нескольких переменных в лямбда функции. Просто перечесляем их через запятую.

int main()
{
	setlocale(LC_ALL, "Russian");

	int a = 55;			//Переменная a, которая нужна для работы нашей лямбда функции
	int b = 10;			//Переменная b

	auto f = [&a, &b]() { 		//Создание переменной, которая приравнивается лямбда функция.
		cout << a + b << endl; 	
	};

	f();				//Вызов лямбда функции

	return 0;
}


Если нам нужно захватить большое количество переменных которые находятся вне контекста нашей лямбда функции, то просто в квадратных скобках ставим знак =. 
Это будет означать, что мы захватили все объекты вне контекста нашей лямбды по значению. Т.е. все переменные мы сможем прочитать, но не изменять.

int main()
{
	setlocale(LC_ALL, "Russian");

	int a = 55;			//Наши переменные
	int b = 10;

	auto f = [=]() { 		//в контекст кладём знак =
		cout << a + b << endl; 	//Чтение переменных работает
		//a = 100;		//Изменение не работает
	};

	f();				//Вызов лямбда функции

	return 0;
}


Так же мы можем захватить все переменные в контекст по ссылке. Теперь мы можем и считывать и изменять все переменные.

int main()
{
	setlocale(LC_ALL, "Russian");

	int a = 55;			//Переменная a, которая нужна для работы нашей лямбда функции
	int b = 10;

	auto f = [&]() { 		//Создание переменной, которая приравнивается лямбда функция.
		a = 10;			// Изменение теперь работает
		b = 10;
		cout << a + b << endl; 	//Чтение тоже работает
	};

	f();				//Вызов лямбда функции

	return 0;
}


Помимо захвата переменных по ссылке или по значению, у нас есть возможность сделать захват в контекст объектов, таким образом, чтобы это выглядело как передача параметров по
значению. Т.е. чтобы внутри нашей лямбды создавалась новоя копия этой переменной, мы могли с ней производить какие либо операции, но всё это не отображалось на оригинале 
переменной (вне контекста этой лямбды). Для этого в квадратных скобках ставим знак = , а после параметров лямбда функции нужно написать ключевое слово mutable. Т.о. с 
помощью ключевого слова mutable и захвата переменных по значению создать поведения для переменных, которых мы захватили в контекст лямбды, такое, что как будто мы их передали
по значению в функцию.

int main()
{
	setlocale(LC_ALL, "Russian");

	int a = 55;			//Переменная a останеться 55
	int b = 10;			//Переменная b, останеться 10

	auto f = [=]() mutable{ 	//Создание переменной, которая приравнивается лямбда функция.
		a = 10;			//Это локальные переменные. Их изменение не отобразится на внешние переменные. 
		b = 90;
		cout << a + b << endl; 	//Чтение тоже работает
	};

	f();				//Вызов лямбда функции

	return 0;
}

Если одна переменная будет по ссылке, а вторая по значению с ключевым словом mutable, то с переменной a всё что мы будем делать отобразиться на оригинале, а с переменной b нет.

int main()
{
	setlocale(LC_ALL, "Russian");

	int a = 55;			//Переменная a станет 10
	int b = 10;			//Переменная b останется 10

	auto f = [&a,b]() mutable{ 	//Создание переменной, которая приравнивается лямбда функция.
		a = 10;			//Изменение сохраниться
		b = 90;			//Изменение не сохраниться, т.к. работаем с локальной переменной.
		cout << a + b << endl; 	//Чтение тоже работает
	};

	f();				//Вызов лямбда функции

	return 0;
}


Так же возможно захватить в контекст целый класс, с которым мы работаем.

class MyClass {
public:
	int a = 11;
	void Msg(){					// 5)
		cout << "msg" << endl;
	}
	void lambda() {					// 2.1)
		auto f = [this]() { 			// 3) Для работы лямбды с классом нужно передать этот класс в контекст, с помощью this.
			this->Msg();			// 4) Теперь возможна работа с методами и полями класса.
		};
		f();					// 2.2) Вызываем лямбда функцию
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	MyClass m;
	m.lambda();					// 1) Вызываем метод класса

	return 0;
}


Ещё один способ как указать лямбда функции какой тип возвращаемого значения у неё должен быть.

auto f = []()->int 		//Явно указываем тип возвращаемого значения (->int)
{ 
	return 1;
};

f();

auto res = f();

######################
int a = 1;
int b = 2;
auto f = [a, &b]() mutable ->int //- если хотите после mutable вставить(->)
{

};

f();

auto res = f();		



______________________________________________________________________________________
Функторы. Функциональные объекты.

Функтор это класс, у которого переопределён оператор (). Мы получаем объект класса, который ведёт себя как функция. Отличительной особенностью функтора, является то что по сути,
хотя он и ведёт себя как функция, но это в тоже время объект класса, а значит он может иметь и все остальные функции признаки и возможности класса. То есть в отличие от функции,
функтор может хранить состояния полей.

class MyFunctor {
public:
	void operator ()() { 					//Перегрузка круглых скобок
		cout << "Я функтор " << count << endl;
		count++;					//Каждый раз переменная становится на + 1
	}
private:
	int count = 0;						//И она сохраняется 
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyFunctor f;						//Создание объекта класса (функтора)
	f();							//Вызов перегруженного метода класса MyFunctor
	f();
	f();

	return 0;
}


Так же мы можем принимать параметры в методе функтора.

class MyFunctor {
public:
	int operator ()(int a, int b) { 			//Перегрузка круглых скобок
		cout << "Я функтор " << endl;
		return a + b;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyFunctor f;
	int res = f(5, 2); 					//Функтор превратился в функцию, задача которой сложить два числа.

	return 0;
}


Простейший пример использования функторов:

class EvenFunctor {
public:
	void operator()(int value) { 					//Узнаём чётное или нечётное число
		if (value % 2 == 0) {
			evenSum += value;
			evenCount++;
		}

	}
	void ShowEvenSum() { 						//Метод вывода суммы чётных чисел
		cout << "Сумма чётных чисел = " << evenSum << endl;
	}
	void ShowEvenCount() { 						//Метод вывода кол-ва чётных чисел
		cout << "Кол-во чётных чисел = " << evenCount << endl;
	}
private:
	int evenSum = 0; 						//Сумма всех чётных чисел.
	int evenCount = 0; 						//Их количество.
};

int main()
{
	setlocale(LC_ALL, "Russian");
	int arr[] = {1,2,55,99,44,3, 6};
	EvenFunctor ef;							//Создаём объект класса
	
	for (auto element : arr){					//Перебор всех чисел
		ef(element);						//Вызов перегруженного метода
	}
	ef.ShowEvenCount();						//Вызов методов
	ef.ShowEvenSum();
	return 0;
}



______________________________________________________________________________________
Предикаты

Предикат это функция или функтор, которая возвращает логическое значение (bool). Задача предиката ответить на вопрос - да или нет.


bool GreaterThenZero(int a) { 				//Предикат отвечающий на вопрос больше ли наше число чем ноль.
	return a > 0;
}

int main()
{
	setlocale(LC_ALL, "Russian");
	
	cout << GreaterThenZero(1) << endl;		//Вывод ответа в консоль.

	return 0;
}


Вроде бы просто, тогда зачем их выделяют как то отдельно? Всё дело в их применении, наиболее типичным применением предикатов является их использования с алгоритмами STL. 
Допустим нам нужно подсчитать кол-во элементов в вектора, которое больше нуля. Мы можем сделать цикл и отдельный счётчик, но в реальных проектах так никто не делает. Просто
воспользуемся алгоритмами STL.

#include <algorithm> 							//Для того чтобы пользоваться алгоритмами STL.


bool GreaterThenZero(int a) { 						//Предикат отвечающий на вопрос больше ли наше число чем ноль. 
	return a > 0;							//Если предикат возвращает true то счётчик count_if увеличивается.
}

int main()
{
	setlocale(LC_ALL, "Russian");
	
	vector<int> v = { 1,-2,-55,9,-3,8 };				//Наша коллекция.

	int res = count_if(v.begin(), v.end(), GreaterThenZero); 	//Алгоритм STL, который может подсчитать что либо в коллекции

	cout << res << endl;		 //Выведет число 3. Т.е. count_if подсчитал, что в нашей коллекции v есть три числа, отвечающие требованиям предиката GreaterThenZero.
	
	return 0;
}



Допустим нам нужно подсчитать кол-во студентов, проходной балл которых больше 180:

class Person { //Класс студентов
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 	//Функтор предикат
		return p.score > 180;		
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	
	vector<Person> people{			//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150)
	};
	
	int res = count_if(people.begin(), people.end(), people.front()); //Подсчёт 

	cout << res << endl;

	return 0;
}


Для тех у кого были проблемы с .front() как и у меня. Функция count_if третьим параметром принимает предикат. Если не перегружен оператор (), то .front() просто вернет ссылку 
на первый элемент класса и выкинет ошибку. Работать будет только если мы перегрузили оператор (), и таким образом третьим параметром у нас получился перегруженный предикат.



Предикат унарный, если он принимает один входящий параметр:
bool GreaterThenZero(int a) { 						
	return a > 0;							
}


Бинарный предикат имеет два входящих параметра:

bool MyPred(int a, int b){
	return a > b;
}



______________________________________________________________________________________
noexcept (без исключений)

Этим вы как автор гарантируете, что ваша функция не генерирует исключений, так что компилятор может, полагаясь на это, выполнять ряд оптимизаций.
Понятно, что вы хозяин своему слову - сам дал, сам и назад забрал! Только потом не удивляйтесь результатам - завершению программы.


______________________________________________________________________________________
Приведение типов

Приведение типов — это процесс преобразования значения из одного типа данных в другой. В C++ существует четыре различных метода приведения типов:

1) Приведение в стиле C : это синтаксис, унаследованный от C, и он выполняется путем простого помещения целевого типа данных в круглые скобки перед приводимым значением. Пример:

int a = 10;
float b = (float)a;


2) static_cast: это наиболее часто используемый метод приведения типов в C++. Он выполняется во время компиляции, и его следует использовать, когда у вас есть явное преобразование 
между типами данных. Этот тип приведения выполняет проверку во время компиляции и выдает ошибку, если допустимое преобразование между заданными типами невозможно. static_cast обычно 
безопаснее, чем приведение в стиле C, поскольку оно не выполняет небезопасную реинтерпретацию данных и позволяет лучше проверять типы.
Пример:

int a = 10;
float b = static_cast<float>(a);


3) dynamic_cast: этот метод специально используется для безопасного преобразования указателей и ссылок между базовыми и производными классами в иерархии классов. Это тип оператора 
приведения в C++, который используется специально для полиморфизма. 
Пример:

class Base {};
class Derived : public Base {};

Base* base_ptr = new Derived();
Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr);


4) reinterpret_cast: это приведение изменяет тип указателя, ссылки или целочисленного значения. Его также называют побитовым приведением, поскольку оно меняет способ интерпретации 
компилятором базовых битов. это тип приведения в C++, который позволяет изменять тип указателя или целого числа без изменения представления данных. Обычно он используется, когда 
требуемое преобразование слишком низкоуровневое или не поддерживается другими методами приведения, такими как static_cast. Используйте его reinterpret_castтолько в том случае, если у 
вас есть глубокое понимание того, что вы делаете, поскольку это не гарантирует, что полученное значение будет иметь смысл. 
Пример:

int* a = new int(42);
long b = reinterpret_cast<long>(a);


5) const_cast: этот метод приведения позволяет удалять или добавлять константность переменной. Другими словами, он позволяет вам модифицировать объект const или volatile или изменить
указатель или ссылку на тип const или volatile. Это полезно в определенных сценариях, когда вам нужно передать constпеременную в качестве аргумента или когда параметр функции требует 
неконстантного типа, но вы хотите, чтобы переменная оставалась постоянной во всем коде.Обычно это не рекомендуется, но может быть полезно в определенных ситуациях, когда вы не можете 
контролировать константность переменной.
Пример:

const int a = 10;
int* ptr = const_cast<int*>(&a);  // const_cast from const int* to int*
*ptr = 20;  // Not recommended, use with caution


______________________________________________________________________________________
Поиск Кенига

Правила этого поиска довольно сложны и включают в себя девять (!!!) пунктов различных условий. Однако то, что нас интересует в данный момент, можно выразить достаточно просто: при 
разрешении вызова функции список кандидатов составляется не только из элементов, доступных в данном пространстве имён, но и в пространствах имён аргументов вызова. 

#include <iostream>

namespace A {
    struct SomeClass {};

    void func(const SomeClass& value) {
    std::cout << "Hello from A::func!" << std::endl;
    }
}

int main(int argc, char * argv[]) {
    func(A::SomeClass{});
    return 0;
}

Таким образом, встретив вызов 

func(A::SomeClass{});

компилятор будет искать целевую функцию с именем func не только в текущем пространстве имён, но и в пространстве имён аргумента (в данном случае в namespace A). 

Почему поиск работает именно так, а не иначе?
Вопрос резонный. Для того, чтобы лучше понять и запомнить что-то, иногда бывает полезно осознать мотивацию. Тем более в данном случае мотивация очень и очень серьёзная. Достаточно 
посмотреть на следующий пример кода, который пришлось бы написать, не будь в языке C++ реализован ADL:

// std::cout << "Hello, World!" << std::endl;
std::operator<<(std::operator<<(std::cout, "Hello, World!"), "\n");

Обратите внимание на закомментированную строчку 1. Знакомо, не правда ли? Каждый программист на C++ довольно часто пользуется оператором operator<< для вывода в std::cout. Но проблема
в том, что в глобальном пространстве имён такого оператора нет! 

Он имеется только в пространстве имён std. Поэтому без поиска Кенига нам бы пришлось написать полную квалификацию пространств имён используемых функций 
(в данном случае это operator<<). 

В результате изо дня в день пришлось бы писать строчки, как строка 2 в приведённом выше примере. Спасибо Кенигу! Оказывается, мы пользуемся его творением практически постоянно!


______________________________________________________________________________________
explicit (Переводится как явный)

Ключевое слово explicit используется для предотвращения неявных преобразований типов данных, которые могут быть вызваны конструкторами или операторами преобразований. Это ключевое
слово вноситься в объявление конструктора или оператора преобразования для указания компилятору, что такое преобразование должно быть разрешено только при явном указании. Без этого
ключевого слова конструкторы могут быть неожиданно вызваны там, где это не предполагалось, например в параметрах функций или в операциях сравнения.

Конструктор

class MyClass {
public:
	explicit MyClass(int value) : value_(value) {}

private:
	int value_;
};

void processClass(MyClass obj) {
	// Функции обработки
};

int main() {
	MyClass obj = MyClass(10); // Допустимо, явное преобразование
	MyClass obj2(20); //Также допустимо

	// processClass(10); // Ошибка компиляции, т.к. конструктор explicit
	processClass(MyClass(10)); // Допустимо, явное преобразование
	return 0;
}

В этом пример конструктор MyClass объявлен как explicit, что предотвращает его использование для неявного преобразования целочисленного аргумента 10 в объект MyClass при вызове 
processClass.

Оператор преобразования

class Weight {
public:
	explicit opetator int() const {return weight_;}

private:
	int weight_ = 0;
};

void processWeight(int weight) {
	// Функции обработки
};

int main() {
	Weight w;
	processWeight(w); // Ошибка компиляции, т.к. оператор преобразования explicit
	processWeight(static_cast<int>(w)); // Допустимо, явное преобразование
	return 0;
}

Здесь оператор преобразования типа объявлен как explicit, что требует явного указания типа для его использования.


______________________________________________________________________________________
placement new

placement new` — это разновидность оператора `new`, который позволяет конструировать объекты в предварительно выделенной области памяти. Это особенно полезно в случаях, когда 
необходимо точно контролировать, где объект должен быть расположен в памяти, или когда нужно избежать лишних выделений памяти для повышения производительности или из-за ограничений 
среды выполнения.

Основные принципы и использование

Не выделяет память. Вместо этого он использует указатель на уже выделенную область памяти, чтобы инициализировать объект в этом месте. Для этого требуется передать в `new` адрес, 
где должен быть размещен объект.Синтаксис выглядит следующим образом:

#include <new>  // Необходим для std::nothrow и std::placement_new

char buffer[sizeof(MyClass)];
MyClass* pMyClass = new (buffer) MyClass();

В этом примере объект типа `MyClass` создается непосредственно в буфере, предоставленном пользователем. Это означает, что память для объекта не выделяется динамически через 
стандартный механизм выделения памяти, а используется область, указанная пользователем.

Преимущества и особенности

1. Контроль расположения: Позволяет разработчикам выбирать, где именно в памяти будет расположен объект. Это может быть критически важно для систем, требующих определенного 
выравнивания или расположения объектов для оптимизации производительности.

2. Избежание дополнительного выделения памяти: При его использовании можно повторно использовать или эффективно управлять памятью, что может быть важно в системах с ограниченными 
ресурсами или в высокопроизводительных приложениях.

3. Конструирование объектов на месте: Полезно для создания объектов внутри предварительно выделенных массивов или сложных структур данных, как например, в памяти, выделенной для 
контейнеров.

Осторожность при использовании

Управление памятью: Поскольку он не освобождает память автоматически, разработчики должны вручную вызывать деструктор для любых объектов, созданных с помощью `placement new`, когда 
объекты больше не нужны.

Исключения и безопасность: Нужно быть внимательным при обработке исключений в конструкторах объектов, созданных через `placement new`, чтобы избежать утечек ресурсов.

pMyClass->~MyClass();

Это необходимо, поскольку `delete` не может быть использован с объектами, созданными с помощью `placement new`.

`Placement new` — это мощный инструмент, предоставляющий гибкость в управлении памятью и расположении объектов. Он особенно полезен в ситуациях, когда требуется оптимизация 
производительности или когда работа ведется в средах с ограниченными ресурсами. Однако его использование требует тщательного управления жизненным циклом объекта и явного вызова 
деструкторов.



______________________________________________________________________________________
final

Ключевое слово final применяется для явного запрета наследования от этого класса или переопределения виртуальной функции. Это обеспечивает контроль над использованием класса в качестве базового и 
предотвращает изменение поведения определенных функций в производных классах. 

Запрет наследования от класса:

class Base final {
	// Определение класса с ключевым словом final
};

В этом примере класс Base объявлен с ключевым словом final, что означает, что нельзя создать производный класс от Base.


Запрет переопределения функции:
class Base {
public:
	virtual void print() const final {
		// Определение виртуальной функции с ключевым словом final
	}
};

В этом примере функция print объявлена виртуальной и помечена как final, что запрещает ее переопределение в производных классах.

final также позволяет выполнять оптимизацию, известную как девиртуализация, тем самым повышая производительность во время выполнения. 
(https://blog.llvm.org/2017/03/devirtualization-in-llvm-and-clang.html)

https://habr.com/ru/companies/otus/articles/704016/ - статья


______________________________________________________________________________________
extern (Внешний)

Для подключения внешних объектов в файл кода применяется ключевое слово extern. Т.е. extern означает что мы не объявляем новую переменную, а используем какую то переменную, объявленную в другом cpp 
файле.

Например, пусть у нас есть файл objects.cpp, в котором определяются :

#include <string>
std::string message {"Hello"};
unsigned times {3};

Здесь определены переменные типа std::string и unsigned int. Для использования типа std::string необходимо подключить заголовочный файл <string>

Пусть главный файл программы называется app.cpp и использует эти переменные:

#include <iostream>
 
extern std::string message;
extern unsigned times;
 
int main()
{
    for(unsigned i{}; i < times; i++)
    {
        std::cout << message << std::endl;
    }
}

Чтобы использовать переменные, определенные во внешнем файле, они объявляются с помощью ключевого слова extern

extern std::string message;
extern unsigned times;

########
Подключение констант
Подключение констант имеет особенность - ключевое слово extern надо указывать и при определении константы. Так, изменим файл objects.cpp следующим образом:

#include <string>
 
extern const std::string message {"Hello"}; // константа
unsigned times {3};

Также изменим файл app.cpp:

#include <iostream>
 
extern const std::string message;   // подключаем константу
extern unsigned times;
 
int main()
{
    for(unsigned i{}; i < times; i++)
    {
        std::cout << message << std::endl;
    }
}

Результат будет тот же, что и в предыдущем случае.

########
Вынесение объявления в заголовочные файлы

В примере выше мы вынуждены подключать в главный файл программы два внешних объекта. Но что, если этих переменных и констант очень много? Чтобы не загрязнять главный файл программы, мы можем, как и в 
случае с внешними функциями, вынести объявления внешних объектов в отдельный заголовочный файл. Так, определим в той же папке, где располагаются файлы app.cpp и objects.cpp, новый файл - objects.h:

objects.h:
extern const std::string message;   // подключаем константу
extern unsigned times;

Теперь подключим этот заголовочный файл в файле app.cpp:

app.cpp:
#include <iostream>
#include "objects.h"        // подключаем внешние объекты
 
int main()
{
    for(unsigned i{}; i < times; i++)
    {
        std::cout << message << std::endl;
    }
}


______________________________________________________________________________________
Volatile (Волатильность - неустойчивый, непостоянный)

Volatile — ключевое слово языков C/C++, которое информирует компилятор о том, что значение переменной может меняться из вне и что компилятор не будет оптимизировать эту переменную. Это может произойти 
под управлением операционной системы, аппаратных средств или другого потока. Поскольку значение может измениться, компилятор каждый раз загружает его из памяти.

Волатильную целочисленную переменную можно объявить как:

int volatile х;volatile int х;

Чтобы объявить указатель на эту переменную, нужно сделать следующее:

volatile int *х;int volatile *х;

Волатильный указатель на неволатильные данные используется редко, но допустим:
int *volatile х;

Если вы хотите объявить волатильный указатель на волатильную область памяти, необходимо сделать следующее:

int volatile *volatile х;

Волатильные переменные не оптимизированы, что может пригодиться. Представьте следующую функцию:

int opt = 1;
void Fn(void) {
    start:
        if (opt == 1)
            goto start;
        else
            break;
}

На первый взгляд кажется, программа зациклится. Компилятор может оптимизировать ее следующим образом:

void Fn(void) {
    start:
    int opt = 1;
    if (true)
        goto start;
}

Вот теперь цикл точно станет бесконечным. Однако внешняя операция позволит записать 0 в переменную opt и прервать цикл.

Предотвратить такую оптимизацию можно с помощью ключевого слова volatile, например объявить, что некий внешний элемент системы изменяет переменную:

volatile int opt = 1;
void Fn(void) {
    start:
    if (opt == 1)
        goto start;
    else
        break;
}

Волатильные переменные используются как глобальные переменные в многопотоковых программах — любой поток может изменить общие переменные. Мы не хотим оптимизировать эти переменные.

Разбор взят из книги Гейл Л. Макдауэлл «Cracking the Coding Interview» (есть в переводе).



______________________________________________________________________________________
Запись int i{}; Инициализацию по умолчанию

Данная конструкция - объявление с инициализатором.

Пустые скобки - () или {} - на месте инициализатора всегда означают инициализацию по умолчанию в С++. В данном случае, т.е. для типа int, это инициализация нулем.

Пример: Пузырьковая сортировка:

std::vector<int> A = {1, 10, 223, 41, 532, -224, 33};
for (size_t i{}; i < A.size(); ++i) {			// Могли бы написать size_t i = 0;
	for (size_t j{}; j < A.size() - i - 1; ++j) {	// Могли бы написать size_t j = 0;
		if(A[j] > A[j + 1])
			std::swap(A[j], A[j + 1]);
	}
}

Инициализатор () существует в C++ с "начала времен" (C++98), а инициализатор {} в такой роли появился в C++11. То есть во многих контекстах у вас есть выбор между () и {}. Однако в вашем конкретном 
контексте () в корне поменяет смысл декларатора, поэтому остается только вариант {}. (Собственно поэтому в С++11 возможности {}-синтаксиса инициализации и сделали универсальными и основными).

Разумеется, когда тип известен - int - вы можете пользоваться любым иным способом инициализации нулем, например, возможно более читаемым int i = 0; или int i(0);. Но в общем случае, особенно когда тип 
неизвестен, {} является наиболее универсальным вариантом для инициализации по умолчанию.



______________________________________________________________________________________
const

Кроме переменных в языке программирования C++ можно определять константы. Их значение устанавливается один раз и впоследствии мы его не можем изменить. И так как нельзя изменить значения константы, то 
ее всегда необходимо инициализировать, если мы хотим, чтобы она имела некоторое значение. Если константа не будет инициализирована, то компилятор также выведет ошибку и не сможет скомпилировать 
программу. 

Объекты классов также могут представлять константы. Для константного объекта можно вызывать только константные функции. Потому что в любой функции класса теоретически можно изменять его поля, а 
компилятор не может определить, меняется ли значение в функции или нет. Поэтому одинаково отказывается компилировать и те функции, которые меняют состояние объекта, и те функции, которые его не меняют.
Еще одно ограничение, с которым можно столкнуться, касается вызова в константной функции других функций этого же класса - константная функция может вызыть только константные функции класса.
Еще одно ограничение, связанное с константными функциями, состоит в том, что, если мы хотим возвратить из константной функции указатель или ссылку, то они указетель должен указывать на константу, а 
ссылка должна быть константной.



______________________________________________________________________________________
mutable (изменяемый)

Иногда бывает необходимо, чтобы какие-то данные константного объекта все-таки можно было менять. В этом случае для переменной, которую необходимо менять, можно использовать ключевое слово mutable. 
И даже если объект является константным, значение такой переменной можно изменить.

#include <iostream>
  
class Person 
{
public:
    std::string name;
    mutable unsigned age;   					// 2) Однако, переменную age можно изменить
    Person(std::string p_name, unsigned p_age)
    {
        name = p_name;
        age = p_age;
    }
    void print() const 
    {
        std::cout << "Name: " << name  << "\tAge: " << age << std::endl;
    }
};
int main()
{
    const Person tom{"Tom", 38};				// 1) Константный объект(По идеи его данные менять нельзя)
    tom.age = 22;
    tom.print();    // Name: Tom       Age: 22
}



Изменяемые лямбда-функции

Есть и ещё один вариант применения ключевого слова mutable и он связан с сохранением состояния в лямбда-функциях. Обычно оператор вызова функции замыкания является константным. Другими словами — лямбда 
не может модифицировать переменные, захваченные по значению:

int main() {
  int i = 2;
  auto ok = [&i](){ ++i; }; //OK, i захватывается по ссылке
  auto err = [i](){ ++i; }; //Ошибка: попытка изменения внутренней копии i
  auto err2 = [x{22}](){ ++x; }; //Ошибка: попытка изменения внутренней переменной x
}

Но ключевое слово mutable может быть применено ко всей лямбда-функции, что сделает все её переменные изменяемыми:

int main() {
  int i = 2;
  auto ok = [i, x{22}]() mutable { i++; x+=i; };
}

Следует заметить, что в отличии от mutable-переменных в объявлении класса, мутабельные лямбда-функции должны использоваться относительно редко и очень аккуратно. Сохранение состояния между вызовами лямбда-функции может быть опасным и 
контринтуитивным.



______________________________________________________________________________________
new и expression new

В чем разница между operator new и expression new?

В том, что это совершенно разные, хоть и взаимосвязанные, вещи.

New-expression - это встроенная конструкция языка, при помощи которой в языке С++ создаются объекты в динамической памяти. Например:

int *p1 = new int();			// Это New-expression и оно выхывает конструкторы для объектов.
SomeClass *p2 = new SomeClass[20];

А operator new (и operator new[]) - это функции выделения "сырой" неинициализированной памяти, которые неявно вызываются изнутри new-expression. В упрощенной форме алгоритм работы new-expression 
состоит из двух этапов:

1) Вызвать функцию выделения "сырой" памяти operator new/operator new[]
2) Проинициализировать (если необходимо) полученную от operator new "сырую" память - например, путем вызова конструктора(-ов) создаваемого объекта(-ов).

Стандартная библиотека предоставляет некую "базовую" реализацию функций operator new. Эти функции, при необходимости, также являются замещаемыми/перегружаемыми пользователем, в том числе индивидуально 
для каждого пользовательского класса.

Получается: operator new() НЕ вызывает конструктор(ы) для объекта(ов), под который(ые) выделяется память. Он просто выделяет память нужного размера и все. Его отличие от сишных функций в том, что он 
может бросить исключение и его можно переопределить, а так же сделать оператором для отдельно взятого класса, тем самым переопределить его только для этого класса (остальное вспомните сами:)).

А вот new-expression как раз и вызывает конструктор(ы) объекта(ов). Хотя правильней сказать, что он тоже ничего не вызывает, просто, встречая его, компилятор генерирует код вызова конструктора(ов).

Пример:

#include <iostream>

class Test {
public:
    Test() {
        std::cout << "Test::Test()" << std::endl;
    }

    void* operator new (std::size_t size) throw (std::bad_alloc) {
        std::cout << "Test::operator new(" << size << ")" << std::endl;
        return ::operator new(size);
    }
};

int main() {
    Test *t = new Test();
    void *p = Test::operator new(100); // 100 для различия в выводе
}

Этот код выведет следующее:
Test::operator new(1)
Test::Test()
Test::operator new(100)

P.S. оператор delete и operator delete() имеют аналогичное различие.



______________________________________________________________________________________
using

Подключение пространств имен и определение псевдонимов:

using пространство_имен::объект

Например:
using namespace std;    // эта директива using указывает компилятору импортировать

Или:

#include <iostream>
using std::cin;
using std::cout;
using std::endl;
 
int main()
{   
    int age;
    cout << "Input age: ";			//std::cout не нужно уточнять
    cin >> age;
    cout << "Your age: " << age << endl;
}



##############
Определение псевдонимов

Ключевое слово using также позволяет определять псевдонимы для типов. Это может пригодиться, когда мы работаем с типами с длинными названиями, а определение коротких псевдонимов 
позволит сократить код. Например:

using ullong = unsigned long long;
int main()
{
    ullong n {10234};
    std::cout << n << std::endl;
}

В данном случае для типа unsigned long long определен псевдоним ullong. Стоит отметить, что это именно определение псевдонима, а НЕ определение нового типа.

Стоит отметить, что для определения псевдонимов в С++ также может использоваться старый подход в стиле языка С с помощью оператора typedef:

typedef unsigned long long ullong;
int main()
{
    ullong n {10234};
    std::cout << n << std::endl;
}


Область видимости объявлений и директив using
Если объявление using или директива using используется в блоке, имена применимы только в этом блоке (они следуют обычным правилам области видимости блока). Это хорошо, поскольку 
снижает вероятность возникновения конфликтов имен внутри этого блока.

Если объявление using или директива using используются в глобальном пространстве имен, имена применимы ко всему остальному файлу (они имеют область видимости файла).

Отмена или замена инструкции using
После объявления инструкции using ее невозможно отменить или заменить ее другой инструкцией using в той области видимости, в которой она была объявлена.

Лучшие практики для инструкций using
В современном C++ на самом деле нет места для использования директив. Они увеличивают вероятность коллизий имен сейчас и в будущем и могут вызывать более коварные проблемы. Хотя во 
многих учебниках и руководствах они широко используются, использования директив лучше вообще избегать.

Объявления using обычно считаются безопасными для использования внутри блоков. Ограничьте их использование в глобальном пространстве имен файлов исходного кода и никогда не 
используйте их в глобальном пространстве имен заголовочных файлов.



#############
Восстановить уровень доступа спецификатора при наследовании. См. ООП - Установка публичного доступа using



______________________________________________________________________________________




















