Управление ресурсами. Идиома RAII

Объекты классов могут на протяжении всего своего существования использовать различные ресурсы - динамически выделенная память, файлы, сетевые подключения и т.д. В этом случае в 
C++ применяется так называемый принцип/идиома RAII (resource acquisition is initialization). RAII предполагает, что получение ресурса производится при инициализации объекта. А
освобождение ресурса производится в деструкторе объекта. Например, получение динамической памяти происходит в конструкторе объекта, а освобождение в деструкторе. При этом важно, 
чтобы ресурс (в данном случае динамическая память) освобождался только один раз. Для этой цели в классе удалены конструктор копирования и оператор присваивания, что позволяет 
избежать ситуации, когда два объекта хранят указатель на одну и ту же область динамической памяти и соответственно потом в деструкторе будут пытаться освободить эту память.



______________________________________________________________________________________
Идиома копирования и замены

Когда нужно изменить состояние одного или нескольких объектов, и на любом этапе модификации может возникнуть ошибка, для создания кода, устойчиваого к ошибкам, может применяться
идиома копирования и замены (copy-and-swap idiom). Суть данной идиомы состоит в следующей последовательности действий:

1. Создаем копию объекта(ов)

2. Изменяем копию. При этом оригинальные объекты остаются нетронутыми

3. Если все изменения прошли успешно, заменяем оригинальный объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то оригинальный объект 
не заменяется.

Обычно эта идиома применяется в функциях и частным, хотя и распространенным, случаем ее применения является оператор присваивания. В общем случаем это выглядит так:

// оператор присвоения некоторого класса Copyable
Copyable& operator=(const Copyable& obj) {
    Copyable copy{obj}; 				// создаем копию через конструктор копирования
    swap(copy);         				// обмениваем значения копии и оригинального объекта
    return *this;
}
// некоторая функция для обмена значениями
void swap(Copyable& copy) noexcept;

В функции оператора присваивания сначала создается временная копия присваиваемого объекта. И в случае успешного создания копиии текущий объект (this) и копия обмениваются 
содержимым через некоторую функцию swap().

Функция swap может быть реализована как внешняя функция или как функция-член класса (в примере выше предполагается, что она реализована внутри класса). При этом функция swap 
определяется как не генерирующая исключения (с ключевым словом noexcept). Поэтому единственной точкой, где может возникнуть исключение, функция копирования (конструктор 
копирования) объекта. Если копирование не удается, то управление не доходит до выполнения функции swap.

Устойчивость к исключениям заключается в том, что в операторе присваивания нет точки, где генерация исключения могла бы привести к утечке памяти. Приведённая выше реализация 
также устойчива к присваиваниям объекта самому себе (a=a), однако содержит издержки, связанные с тем, что временная копия в этом случае тоже будет создаваться. Исключить 
издержки можно дополнительной проверкой:

// оператор присвоения некоторого класса Copyable
Copyable& operator=(const Copyable& obj) {
    Copyable copy{obj};     				// создаем копию через конструктор копирования
    if(this != &obj)        				// если не текущий объект
        swap(copy);         				// обмениваем значения копии и оригинального объекта
    return *this;
}
// некоторая функция для обмена значениями
void swap(Copyable& copy) noexcept;

Хотя часто подобный способ применяется именно в операторах присвоения, но также он может применяться в других ситуациях, где необходимо выполнить устойчивую к исключениям 
модификацию объекта. И всегда принцип будет тот же. Сначала копируем объект, который надо изменить. Далее выполняем над объектом-копией изменения. И если все пройдет удачно, 
обмениваем значениями целевой объект и объект-копию.



______________________________________________________________________________________
Идиома Move-and-Swap / Перемещение с обменом

Идиома move-and-swap или перемещение с обменом применяется в операторах присвоения с перемещением. Она позволяет избежать дублирования кода деструктора и конструктора 
копирования. Суть данной идиомы состоит в следующей последовательности действий:

1. Для перемещаемого объекта создаем копию с помощью конструктора перемещения

2.Заменяем текущий объект измененной копией. Если же при изменении копии на каком-то этапе возникла ошибка, то текущий объект не заменяется.

Общая форма move-and-swap выглядит следующим образом:

MyClass& MyClass::operator=(MyClass&& rhs) noexcept
{
    MyClass moved(std::move(rhs)); // получаем перемещаемый объект
    swap(moved);                  // выполняем обмен значениями
    return *this; // возвращаем текущий объект
}



______________________________________________________________________________________




















