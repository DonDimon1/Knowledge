Чем больше проект, тем больше строчек кода в нём будет. Например если проект будет состоять из 10 тыс. строчек кода в одном файле то понять и работать с ним будет крайне сложно.
Преимущество использования многофайловых проектов в том, что участки кода распределены по отдельным файлам и из-за этого с ними проще работать и проще их искать.

Отдельные модули (объекты) состоят из двух файлов: заголовочный файл (.h) и файл с исходным кодом(.cpp).

Создать файл заголовка: Заголовочные файлы, ПКМ добавить, создать, файл заголовка.

#pragma once - деректива препроцессора для решения задачи повтороного включения.

Заголовки в многофайловых проектах предназанчены для того, чтобы хранить здесь интерфейс взаимодействия с тем функционалом, который у нас будет описан в cpp файле. В заголовке
определяются прототипы функций, но никакой реализации.

Создание файла реализации: Файлы исходного кода, ПКМ добавить, создать элемент, выбрать Файл С++ (.cpp).

Если используем кавычки "" вместо <>, это означает что мы будем искать файл, который хотим подключить с помощью дерективы include прямо среди файлов нашего проекта. Деректива
include вместо себя вставляет код из файла, который мы подключаем.

Пример реализации функции:

Файл Sum.h

#pragma once
int Sum(int a, int b); 	//Прототип функции Sum

Файл Sum.cpp

#include "Sum.h"	//Подключение нашего хедера. Используются кавычки "" вместо <>

int Sum(int a, int b)	//Функция вычисления
{
	return a + b;
}

Базовый файл с функцией main

#include <iostream>
#include "Sum.h" //Подключаем заголовочный файл Sum

using namespace std;

int main()
{
	setlocale(LC_ALL, "Russian");
	int res = Sum(2, 3);
	cout << res << endl;
	return 0;
}


Пример реализации класса:

Наш проект (ниже Решения), ПКМ добавить, класс

В хеддере мы прописываем только прототипы для методов класса (интерфейс), и также все нужные библиотеки (например #include <iostream>). В .cpp файле опысывается реализация, 
и туда подключается хеддер, в котором описываются прототипы.

Файл MyClass.h

#pragma once
#include <iostream>
class MyClass 					//Здесь мы описываем только прототипы для методов класса.
{
public:
	MyClass();
	~MyClass();
	void PrintMassage(const char str[]);
};

Файл MyClass.cpp

#include "MyClass.h"
MyClass::MyClass() { 				//Определение метода вне класса и в разныйх файлах

}

MyClass::~MyClass() {

}

void MyClass::PrintMassage(const char str[])
{
	std::cout << str << std::endl; 		//Мы не использовали using namespace std, поэтому указываем полный путь к cout.
}

Базовый файл с функцией main

#include <iostream>
#include "MyClass.h" 				//Подключаем заголовочный файл с нашим классом

using namespace std;

int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass m;
	m.PrintMassage("Hellow World!");
	return 0;
}


###########
Помимо разбиения проекта на файлы, мы так же можем пользоваться разными пространствами имён. 

Файл MyClass.h

#pragma once
#include <iostream>

namespace myNamespace{					//Новое пространство имён
	class MyClass 					
	{
	public:
		MyClass();
		~MyClass();
		void PrintMassage(const char str[]);
	};
}


Файл MyClass.cpp

#include "MyClass.h"

namespace myNamespace{					//Новое пространство имён
	MyClass::MyClass() { 				

	}

	MyClass::~MyClass() {

	}

	void MyClass::PrintMassage(const char str[])
	{
		std::cout << str << std::endl; 		
	}
}


Базовый файл с функцией main

#include <iostream>
#include "MyClass.h" 					//Подключаем заголовочный файл с нашим классом

using namespace std;

int main()
{
	setlocale(LC_ALL, "Russian");
	myNamespace::MyClass m;				//Явно указываем пространство имён
	m.PrintMassage("Hellow World!");
	return 0;
}
______________________________________________________________________________________
Многофайловый проект 

Проблема повторного включения: Суть в том, каким образом работает деректива #include. Эта деректива вместо себя оставляет весь код файла, который был подключён этой дерективой.
У нас могут быть много функций в различных файлах, которые могут работать только с использованием определённой библиотеки (например <iostream>). Например, если мы подключаем 
в main библиотеку <iostream> и в подключаемый файл (который создали сами и тоже подключили в main) тоже подключаем <iostream>, то наш код уже дублируется два раза (код 
библиотеки <iostream> и в main и в нашем подключаемом файле). Файлы могут подключаться в сложной иеархии и у нас может быть задублированно большое количество одинакового кода.

Допустим у нас есть два файла Foo и Bar и в них есть одноимённые функции. В файле Bar в функции Bar нам нужно вызвать функцию Foo и наоборот в файле Foo в функции Foo нужно
вызвать функцию Bar. Для этого чтобы в функции Bar у нас была возможность обратиться к функционалу функции Foo, нам нужно подключить хеддер функции Foo. Аналогичто и для 
функции Foo нам нужно подключить хеддер функции Bar. Компилятор не даст нам этого сделать, он будет ругаться на включение файлов в само себя. Для того чтобы избежать этого, мы
можем использовать дерективу препроцессора #pragma once. Задача этой дерективы предотвратить повторное включение файлов. Если у нас в хеддере есть деректива #pragma once, то
весь последующий код, который следует в этом хеддере и в cpp файле, будет подключён только один раз. Если будет выполнена попытка подключить этот хеддер ещё раз, то 
предварительно будет выполнена проверка, не подключался ли он до этого. 

файл Foo.h
#pragma once
#include "Bar.h"
void Foo();

файл Foo.cpp
#include "Foo.h"
void Foo()
{
}

файл Bar.h
#pragma once
#include "Foo.h"
void Bar();

файл Bar.cpp
#include "Bar.h"
void Bar()
{
}


Но есть один важный момент, эта деректива не работает для всех компиляторов, поэтому обычно используют ещё один способ - Условная компиляция.

#ifndef 1 	//Условная компиляция (Если какое то значение не определено, то выполняется код начинаю от сюда. Определяться должно значение, которое отвечает за то, что 
		//подключён файл уже или нет. Это самое значение, которое определено или нет, по состоянию которого мы определяем нужно или нет подключать заголовок с нашим
		//файлом или он уже подключён обычно носит название хеддера с суффиксом H (Например для файла Bar.h значение будет _BAR_H_).
#endif // !1		
 

файл Foo.h
//#pragma once

#ifndef _FOO_H_		//Проверка: было ли определено имя _FOO_H_ вообще гдето в нашем коде? Если нет, то определяем кодом ниже

#define _FOO_H_		//Создаём (определяем значение). Теперь оно есть у нас в коде

#include "Bar.h"	//Подключаем файл

void Foo();		//Определяем функцию

#endif // !_FOO_H_	//Если значение _FOO_H_ уже определено то код начнётся от сюда



файл Bar.h

//#pragma once

#ifndef _BAR_H_ 	//Проверка: было ли определено имя _BAR_H_ вообще гдето в нашем коде? Если нет, то определяем кодом ниже.

#define _BAR_H_ 	//Создаём (определяем значение). Теперь оно есть у нас в коде.

#include "Foo.h" 	//Подключаем файл

void Bar();		//Определяем функцию

#endif // !_BAR_H_ 	//Если значение _BAR_H_ уже определено то код начнётся от сюда






























