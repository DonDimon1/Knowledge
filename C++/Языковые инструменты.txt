
______________________________________________________________________________________
Этапы компиляции C++

https://habr.com/ru/articles/478124/
http://knzsoft.ru/cpp-bgr-ls1/ - ТУТ более подробно.

В данной статье я хочу рассказать о том, как происходит компиляция программ, написанных на языке C++, и описать каждый этап компиляции.

Состав компилятора g++:
cpp — препроцессор
as — ассемблер
g++ — сам компилятор
ld — линкер

Исходный C++ (формата .cpp, например hello.cpp) файл — это всего лишь код, но его невозможно запустить как программу или использовать как библиотеку. Поэтому каждый исходный 
файл требуется скомпилировать в исполняемый файл, динамическую или статическую библиотеки.


Этапы компиляции:

1) Препроцессинг (предобработка) hello.ii
Препроцессор — это макро процессор, который преобразовывает вашу программу для дальнейшего компилирования. На данной стадии происходит происходит работа с препроцессорными 
директивами. Например, препроцессор добавляет хэдеры в код (#include), убирает комментирования, заменяет макросы (#define) их значениями, выбирает нужные куски кода в 
соответствии с условиями #if, #ifdef и #ifndef. На выходе получаем выходной файл с расширением hello.ii (файлы прошедшие через стадию препроцессинга C++ файлы имеют расширение 
.ii). В новом сгенерированном файле также можно увидеть огромное количество новых строк, это различные библиотеки и хэдеры подключаемых библиотек.


2) Компиляция (трансляция) hello.s
На данном шаге g++ выполняет свою главную задачу — компилирует, то есть преобразует полученный на прошлом шаге код без директив в ассемблерный код. Это промежуточный шаг между 
высокоуровневым языком и машинным (бинарным) кодом. Ассемблерный код — это доступное для понимания человеком представление машинного кода. На выходе получаем файл с расширением
hello.s. Мы можем все также посмотреть и прочесть полученный результат. Но для того, чтобы машина поняла наш код, требуется преобразовать его в машинный код, который мы и 
получим на следующем шаге.

3) Ассемблирование hello.o
Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном файле. Объектный файл — это созданный ассемблером промежуточный файл, хранящий кусок 
машинного кода. Этот кусок машинного кода, который еще не был связан вместе с другими кусками машинного кода в конечную выполняемую программу, называется объектным кодом. 
Выполняется специальной утилитой as, выходной файл обычно имеет расширение .o (и называется объектным файлом). На данном этапе не происходит ничего интересного — просто 
инструкции, которые были в ассемблере, перегоняются в машинный код. Поэтому файлы .o бесполезно смотреть глазами, они бинарные, для этого есть специальные утилиты, например, 
objdump. Далее возможно сохранение данного объектного кода в статические библиотеки для того, чтобы не компилировать данный код снова. Но на данном шаге еще ничего не закончено,
ведь объектных файлов может быть много и нужно их всех соединить в единый исполняемый файл с помощью компоновщика (линкера). Поэтому мы переходим к следующей стадии.

4) Линковка (Компоновка) 
Компоновщик (линкер) связывает все объектные файлы и статические библиотеки в единый исполняемый файл, который мы и сможем запустить в дальнейшем. Нужна, если файлов несколько: 
мы запускаем препроцессор, трансляцию и ассемблирование независимо для каждого файла, а объединяются они только на этапе линковки. Для того, чтобы понять как происходит связка, 
следует рассказать о таблице символов: Таблица символов — это структура данных, создаваемая самим компилятором и хранящаяся в самих объектных файлах. Таблица символов хранит 
имена переменных, функций, классов, объектов и т.д., где каждому идентификатору (символу) соотносится его тип, область видимости. Также таблица символов хранит адреса ссылок на 
данные и процедуры в других объектных файлах. Именно с помощью таблицы символов и хранящихся в них ссылок линкер будет способен в дальнейшем построить связи между данными среди 
множества других объектных файлов и создать единый исполняемый файл из них.



______________________________________________________________________________________
Системы сборки кода

Когда проект содержит десятки и даже сотни файлов с исходным кодом, процесс его сборки надо автоматизировать. Здесь на помощь приходят системы сборки, которые автоматически 
запускают все нужные команды, чтобы скомпилировать и скомпоновать все файлы проекта. В итоге на выходе получается один исполняемый файл. Они позволяют избежать ручного 
выполнения рутинных задач, таких как компиляция, линковка и копирование файлов, а также управление зависимостями между компонентами программы. Благодаря автоматизации данных 
процессов, разработчики могут сосредоточиться на более творческой работе и повысить эффективность своей деятельности.

Системы сборки кода — это специальные программы, которые собирают и пересобирают код проекта в автоматическом режиме по заранее заданным правилам. Эти системы определяют 
зависимости между файлами с исходным кодом и выходными файлами (программами, библиотеками и конфигурационными файлами) и в нескольких параллельных процессах выполняют команды 
компиляции для всех изменившихся со времени последней сборки файлов, соблюдая зависимости. Вторая задача систем сборок — это поиск в операционной системе и подключение к проекту
библиотек и программ, которая реализуется наиболее удобными способами в зависимости от операционной системы.


В новых языках программирования (Rust, Go) параллельная сборка и поиск зависимостей уже встроены, но для существующих языков (C, C++, Fortran) это невозможно сделать, поэтому 
для них используют отдельные системы сборки. Про них и пойдет речь в этой лекции.

Система сборки является самым важным элементом любого проекта. Эта программа генерирует команды для сборки исходного кода, и чем быстрее эта система собирает код и чем больше 
рутинных операций автоматизирует, тем быстрее идет разработка, и тем проще настроить непрерывную интеграцию — автоматизированную сборку и тестирование вашей программы. В задачи 
системы сборки входит

поиск зависимостей (заголовочных файлов и библиотек),
генерация различных версий кода в зависимости от платформы, на которой происходит сборка,
генерация вспомогательных файлов,
генерация команд для компиляции всех исходный файлов.

Как правило, системы сборки поддерживают опции для включения или отключения различных компонент программы. Результатом работы системы сборки является директория, в которой 
находятся сгенерированные файлы, а также файл с дальнейшими командами для подчиненной (более низкоуровневой) системы сборки. К высокоуровневым системам относятся Autoconf, 
Cmake, Meson, к низкоуровневым — Make, Ninja.


В общем случае сборка проекта состоит из двух этапов:

1) Генерация файлов для системы сборки.
2) Непосредственно сборка.

Компиляции и сборка программы не менее важный процесс, чем написание самой программы.



______________________________________________________________________________________
Пакетный менеджер

Система управления пакетами (также иногда «менеджер пакетов» или «пакетный менеджер») — набор программного обеспечения, позволяющего управлять процессом установки, удаления, 
настройки и обновления различных компонентов программного обеспечения. Системы управления пакетами активно используются в различных дистрибутивах операционной системы Linux и 
других UNIX-подобных операционных системах.

Программное обеспечение представляется в виде особых пакетов, содержащих, помимо дистрибутива программного обеспечения, набор определённых метаданных, которые могут включать в 
себя полное имя пакета, номер версии, описание пакета, имя разработчика, контрольную сумму, отношения с другими пакетами. Метаданные сохраняются в системной базе данных пакетов.

В проектах разработчики не всегда используют собственный код. На самом деле они вообще редко используют собственный код, особенно при написании сложной логики. Существует 
множество замечательных готовых решений, над которыми трудились другие разработчики и всемирно-известные организации. И эти решения доступны всем. B ряде экосистем языков 
программирования созданы собственные менеджеры пакетов, обеспечивающие установку приложений на этих языках и необходимых библиотек.

Пакет (зависимость) — это один или несколько файлов, аккуратно объединенных вместе, которые можно загрузить из реестра пакетов. И таких пакетов в одном проекте может быть 
использовано очень много. Грубо говоря, пакет — это кусок кода, загруженный в интернет другими разработчиками. 

Соответственно, менеджер пакетов — это инструмент, который помогает нам устанавливать зависимости в проект и автоматизирует этот процесс.

























