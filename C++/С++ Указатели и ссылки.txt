Определение указателя:
Синтаксис указателя: тип_данных* название_указателя; 
int* p;
Такой указатель может хранить только адрес переменной типа int.
Пустой указатель: int* p{nullptr};

Получение адреса и оператор &:
С помощью операция & можно получить адрес некоторого объекта, например, адрес переменной. 
Затем этот адрес можно присвоить указателю:
int number {25};
int *pnumber {&number}; // указатель pnumber хранит адрес переменной number
cout << "number addr: " << pnumber << endl; //Адрес переменной number
cout << "pnumber addr: " << &pnumber << endl;//Адрес указателя pnumbe

Получение значения по адресу (*):
Но так как указатель хранит адрес, то мы можем по этому адресу получить хранящееся там значение, то есть значение 
переменной number. Для этого применяется операция разыменования * ("indirection operator" / "dereference operator"). 
Результатом этой операции всегда является объект, на который указывает указатель.
int number {25};
int *pnumber {&number};
cout << "Address = " << pnumber<< endl;//Получаем адрес number
cout << "Value = " << *pnumber << endl;//Получаем значение number

Значение, которое получено в результате операции разыменования, можно присвоить другой переменной:
int n1 {25};
int *pn1 {&n1}; // указатель pn1 хранит адрес переменной n1
int n2 { *pn1}; // n2 получает значение, которое хранится по адресу в pn1
cout << "n2 = " << n2 << endl;  // n2=25

И также используя указатель, мы можем менять значение по адресу, который хранится в указателе:
int x = 10;
int *px = &x;
*px = 45;
cout << "x = " << x << endl;     // 45

Адрес указателя
Указатель хранит адрес переменной, и по этому адресу мы можем получить значение этой переменной. Но кроме того, указатель, как и любая переменная, сам имеет адрес, по которому 
он располагается в памяти. Этот адрес можно получить также через операцию &:
int a {10};
int *pa {&a};
std::cout << "address of pointer=" << &pa << std::endl;        // адрес указателя
std::cout << "address stored in pointer=" << pa << std::endl;  // адрес, который хранится в указателе - адрес переменной a         
std::cout << "value on pointer=" << *pa << std::endl;          // значение по адресу в указателе - значение переменной a

int* const - константный указатель на nt
const int* - указатель на const int
const int* const - константный указатель на const int



______________________________________________________________________________________
Константы и указатели



Указатели НА константы

Указатели могут указывать как на переменные, так и на константы. Чтобы определить указатель на константу, он тоже должен объявляться с ключевым словом const:

const int a {10};
const int *pa {&a};
std::cout << "address=" << pa << "\tvalue=" << *pa << std::endl;

Здесь указатель pa указывает на константу a. Поэтому даже если мы захотим изменить значение по адресу, который хранится в указателе, мы не сможем это сделать, например так:

*pa = 34; // Ошибка

В этом случае мы просто получим ошибку во время компиляции.

Возможна также ситуация, когда указатель на константу на самом деле указывает на переменную:

int a {10};
const int *pa {&a};
std::cout <<"value=" << *pa << std::endl;     // value=10
a = 22;
std::cout <<"value=" << *pa << std::endl;     // value=22
//*pa = 34;     			      // так делать нельзя

В этом случае переменную отдельно мы сможем изменять, однако по прежнему изменить ее значение через указатель мы не сможем.

Через указатель на константу мы не можем изменять значение переменной/константы. Но мы можем присвоить указателю адрес любой другой переменной или константы:

const int a {10};
const int *pa {&a};     			// указатель указывает на константу a
const int b {45};
pa = &b;                			// указатель указывает на константу b
std::cout <<"*pa = " << *pa << std::endl;     	// *pa = 45
std::cout <<"a = " << a << std::endl;     	// a = 10 - константа a не изменяется



###########################

Константный указатель

От указателей на константы надо отличать константные указатели. Они не могут изменять адрес, который в них хранится, но могут изменять значение по этому адресу.

int a {10};
int *const pa {&a};
std::cout << "value=" << *pa << std::endl;      // value = 10
*pa = 22;                                       // меняем значение
std::cout << "value=" << *pa << std::endl;      // value = 22
   
int b {45};
// pa = &b;         так нельзя сделать



###########################
Константный указатель на константу

И объединение обоих предыдущих случаев - константный указатель на константу, который не позволяет менять ни хранимый в нем адрес, ни значение по этому адресу:

int a {10};
const int *const pa {&a};
 
//*pa = 22;  так сделать нельзя
 
int b {45};
// pa = &b;  так сделать нельзя 



###########################
Резюме:
const int a {10};

const int *pa {&a}; // Указатели НА константы. Могут указывать как на переменные, так и на константы. Нельзя изменять значение переменной/константы (*pa = 34). Можем присвоить
		    // 	   адрес любой другой переменной или константы (pa = &b).

int *const pb {&a}; // Константный указатель. Слово const переместилось вправо от int. Не могут изменять адрес, который в них хранится, но могут изменять значение по этому адресу.

const int *const pc {&a}; // Константный указатель на константу. const и слева и справа от int. Не позволяет менять ни хранимый в нем адрес, ни значение по этому адресу.



Когда-то где-то вычитал (у Страуструпа может, не помню) чтобы легче читать код и определятся с синтаксисом при написании (запомнить в общем), нужно читать конструкцию справа налево:

const int* — указатель(*) на целую(int) константу(const)
int *const — константный(const) указатель(*) на целое(int)

Мои наблюдения: (Короче, перед каким словом стоит const, то и const):

Читайте справа налево, начиная от имени указательной переменной.
const int и int const — эквивалентные способы обозначить int-константу

const int *pa {&a}; // const перед типом данных int, значит сами данные const, значит *pa это указатель на константу. (pa) это указатель(*) на на целую(int) константу(const)

int *const pb {&a}; // Звёздочка указателя находится перед const, а сам const перед именем указателя pb, значит сам указатель const, значит это Константный указатель. (pb) это константный(const) указатель(*) на целое(int).

const int *const pc {&a}; // const везде, значит это Константный указатель на константу. pc это константный(const) указатель(*) на целое(int) которое тоже константа(const)


##########################################

const слева от звёздочки и const спарва от звёздочки имеет разный смысл.

int const* 
const int* pc = p; - это тоже самое что и первый вариант. тут константой является int, а указатель нет

int* const cp = p; - а тут указатель является константым а int нет

Если const справа от * то указатель константа, если const слева от *, то то что под указателем константа.



______________________________________________________________________________________
Сложное объявление 

int* a[10]; - массив из 10 указателей на int. Сначала читаем то что с права, потом то что слева.
int(*b)[10]; - указатель на массив из 10 int. Читае то что в скобках, потом то что спарва, потом то что слева.

void (*pf)(int); - указатель на функцию, которая принимает int а возвращает void.

void (*pfa[10])(int); - массив из 10 указателей на функцию которая принимает int и возвращает void.

void (*(*pff[10])(int))(int); - массив из 10 указателей на функцию, которая принимает int, а возвращает другую функци, которая принимает int а возвращает void.
Как это читать:
Правило такое: иди вправо пока можешь, затем иди влево.
pff[10] - массив из 10 
*pff[10] - указателей (Справа скобка закрывается, поэтому там нечего читать. Поэтому читаем слева.)
(*pff[10])(int) - на функцию, которая принимает int (Вышли из скобочек и видим скобочки справа. Если есть круглые скобочки справа значит это фунция.)
*(*pff[10])(int) - и возвращает указатель на (читаем слева)
(*pff[10])(int))(int) - функцию, которая принимает int (Вышли из скобочек и видим скобочки справа. Если есть круглые скобочки справа значит это фунция.)
void (*(*pff[10])(int))(int) - и возвращает void. (читаем слева)


int& f(int); - просто функция, которая принимает int и возвращает ссылку на int

int (&f)(int); - ссылка на функцию, которая принимает int и возвращает ссылку на inf



______________________________________________________________________________________
Умные указатели

Умные указатели это реализация RAII для выделения динамической памяти. За счёт того что умные указатели сами следят за владением объекта и освобождают память когда нужно, у нас не происходит утечки памяти.

https://habr.com/ru/companies/piter/articles/706866/
Мне нравится рассматривать умные указатели как упаковки, в которых хранятся динамические данные. На самом деле это просто классы, которые оборачивают обычный указатель в свои недра и 
перегружают операторы -> и *. Благодаря этому трюку умный указатель имеет тот же синтаксис, что и обычный указатель. Когда умный указатель выходит из области видимости, срабатывает 
его деструктор и происходит очистка памяти. Эта техника называется Resource Acquisition Is Initialization (RAII): класс оборачивает динамический ресурс (файл, сокет, подключение к 
базе данных, выделенная память, ...), который должным образом удаляется/закрывается в своем деструкторе. Таким образом, вы гарантированно избежите утечки ресурсов.


Типы умных указателей в современном C++:

std::unique_ptr — умный указатель, владеющий динамически выделенным ресурсом;
std::shared_ptr — умный указатель, владеющий разделяемым динамически выделенным ресурсом. Несколько std::shared_ptr могут владеть одним и тем же ресурсом, и внутренний счетчик ведет 
	их учет;
std::weak_ptr — подобен std::shared_ptr, но не увеличивает счетчик.

Возможно, вы также слышали о std::auto_ptr. Это вещь из прошлого, теперь не рекомендуемая к использованию: забудьте о ней.


_____________________________________________
Понимание std::unique_ptr: одиночный вариант

std::unique_ptr владеет объектом, на который он указывает, и никакие другие умные указатели не могут на него указывать. Когда std::unique_ptr выходит из области видимости, объект 
удаляется. Это полезно, когда вы работаете с временным, динамически выделенным ресурсом, который может быть уничтожен после выхода из области действия.


СОЗДАНИЕ

std::unique_ptr<Type> p(new Type); // Создание

Например:
std::unique_ptr<int>    p1(new int);
std::unique_ptr<int[]>  p2(new int[50]);
std::unique_ptr<Object> p3(new Object("Lamp"));

Также можно создать std::unique_ptrs с помощью специальной функции std::make_unique, вот так:
std::unique_ptr<Type> p = std::make_unique<Type>(...размер или параметры...);

Например:
std::unique_ptr<int>    p1 = std::make_unique<int>();
std::unique_ptr<int[]>  p2 = std::make_unique<int[]>(50);
std::unique_ptr<Object> p3 = std::make_unique<Object>("Lamp");

Если есть возможность, всегда старайтесь выделять объекты с помощью std::make_unique.


ПРИМЕНЕНИЕ

Главная особенность этого умного указателя — исчезать, когда он больше не используется.

void compute()
{
    std::unique_ptr<int[]> data = std::make_unique<int[]>(1024);
    /* выполнение некоторых значимых вычислений над вашими данными...*/
} // `data` выходит из области действия здесь: она автоматически уничтожается
int main()
{
    compute();
}

Умный указатель выходит из области видимости, когда функция compute() достигает конца тела. Вызывается деструктор указателя, и память очищается автоматически. Больше ни о чем 
волноваться не нужно.


ОДИН РЕСУРС, ОДИН std::unique_ptr

std::unique_ptr очень ревниво относится к динамическому объекту, который он хранит: невозможно иметь несколько ссылок на его динамические данные. Это сделано специально, и это важная 
особенность std::unique_ptr: на любой ресурс может указывать не более одного std::unique_ptr. Это предотвращает ошибочное многократное удаление указателя. Технически это происходит 
потому, что у std::unique_ptr нет конструктора копирования.

void compute(std::unique_ptr<int[]> p) { ... } 

int main()
{
    std::unique_ptr<int[]> ptr = std::make_unique<int[]>(1024);
    std::unique_ptr<int[]> ptr_copy = ptr; // ОШИБКА! Копирование запрещено
    compute(ptr);  // ОШИБКА! `ptr` передается копией, а копирование не разрешено
}

_____________________________________________
Реализация примитивного unique_ptr, здесь ничего сложного.

template <typename T, typename Deleter = std::default_delete<T>>
class unique_ptr {
	T* ptr;
	[[no_unique_address]] Deleter del;			// Храним делитер
public:
	unique_ptr(T* ptr): ptr(ptr){}
	unique_ptr(T* ptr, Deleter del): ptr(ptr), del(del){}	// Конструктор с делитером
	~unique_ptr() {
		del(ptr);					// Вызываем делитер как функцию
	}

	unique_ptr(const unique_ptr&) = delete;			// Запрещаем копирование
	unique_ptr& operator=(const unique_ptr&) = delete;

	unique_ptr(unique_ptr&& other): 			// Мув конструктор
		ptr(other.ptr), del(std::move(other.del))
	{
		other.ptr = nullptr;
	}
	unique_ptr& operator=(unique_ptr&& other) {
		if( this != &other) {				// Проверка на присваивание самому себе
			del(ptr);				// Не забываем удалять наш указатель
			ptr = other.ptr;
			del = std::move(other.del);
			other.ptr = nullptr;
		}
		return *this;
	}

	T& operator*() const {
		return *ptr;
	}
	T* operator->() const {
		return ptr;
	}
	T* get() const {					// Просим сырой указатель (это может быть опасно).
		return ptr;
	}
};

В этом классе мы запрещаем копирование, только один указатель может владеть объектом, однако мы разрешаем перемещение. 
У unique_ptr есть второй шаблонный параметр Deleter, который по умолчанию равен std::default_delete<T>. unique_ptr можно попросить в деструкторе вызывать не просто delete, а что то более умное. С чего мы вообще решили что именно 
delete ptr нужно вызывать когда мы делаем деструктор? Вдруг мы выделяли память с помощью malloc, тогда нужно вызывать free, а возможно у нас был кастомный delete. Также есть взгляд более высокого уровня - освобождение ресурсов
может заключаться не только в том, чтобы освободить память из под этих ресурсов. unique_ptr это реализация идеомы RAII, но это не обязательно выделение и освобождение памяти. Это может быть открытие файла с помощью сишной функции 
open, и когда заканчиваем работу, хотим его закрыть, тогда у нас в деструкторе нужно делать не delete, а close. Или например мы открыли сетевое соединение TCP,  когда нам нужно его закончить, мы делаем не delete, а посылаем разрыв 
соеденения. Короче unique_ptr можно использовать не только для освобождения ресурса в смысле delete, можно вызвать произвольную функцию над указателем, когда мы заканчиваем владение, и для этого у нас есть шаблонный параметр
Deleter. А std::default_delete это функтор, который по умолчанию делает delete.

template <typename T>
struct default_delete {
	void operator()(T* ptr) const {
		delete ptr;
	}
};

Т.е. когда unique_ptr освобождает ресурс он не в лоб вызывает delete ptr, а вызывает делитер del(ptr), который ему можно подменить. Данный делитер соптимизирован, он не имеет полей и следовательно не занимает лишнее место, поскольку 
почти всегда является тревиальным. До C++20 этой оптимизацией являлась EBO, т.е. unique_ptr делался приватным наследником, а сейчас мы можем написать [[no_unique_address]]. 

В мув конструкторе и операторе перемещения помимо указателя забираем ещё и делитер.




_____________________________________________
Понимание std::shared_ptr: конвивиальный вариант

std::shared_ptr владеет объектом, на который он указывает, но, в отличие от std::unique_ptr, он допускает множественные ссылки. Специальный внутренний счетчик уменьшается каждый раз, 
когда std::shared_ptr, указывающий на тот же ресурс, выходит из области видимости. Эта техника называется подсчетом ссылок. Когда последняя из них будет уничтожена, счетчик станет 
равным нулю, и данные будут высвобождены. Умный указатель такого типа полезен, когда требуется обмениваться динамически распределенными данными, точно так же, как это делается с 
обычными указателями или ссылками.

В std::shared_ptr используется два основных счётчика: счётчик сильных ссылок (strong reference count) и счётчик слабых ссылок(weak reference count). 

Счётчик сильных ссылок увеличивается каждый раз, когда новый std::shared_ptr создаётся как копия другогоstd::shared_ptr или когда объект присваивается std::shared_ptr. Этот счётчик 
уменьшается, когда std::shared_ptr уничтожается или когда его значение присваивается другому объекту. Когда счётчик сильных ссылок достигает нуля, объект, на который указывает 
std::shared_ptr уничтожается.

Счётчик слабых ссылок используется вместе с указателем std::weak_ptr, который может ссылаться на объект, управляемый std::shared_ptr, но не увеличивая счётчик сильных ссылок. Слабые
ссылки не предотвращают удаления объекта, к которому они имеют доступ, т.к. не участвуют в владении объектом. Счётчик слабых ссылок увеличивается каждый раз, когда создаётся 
std::weak_ptr, указывающий на объект и уменьшается, когда такой std::weak_ptr уничтожается. Когда счётчик сильных ссылок достигает нуля и объект уничтожается, память, выделенная под
сам объект, освобождается, но "control block"(блок управления), содержащий счётчики, сохраняется до тех пор, пока счётчик слабых ссылок также не обнулится. 

СОЗДАНИЕ

std::shared_ptr<Type> p(new Type);

Например:
std::shared_ptr<int>    p1(new int);
std::shared_ptr<Object> p2(new Object("Lamp"));

Существует альтернативный способ создания std::shared_ptr, использующий специальную функциюstd::make_shared: 
std::shared_ptr<Type> p = std::make_shared<Type>(...parameters...);

Это должен быть наиболее предпочтительный способ построения такого рода умных указателей. При вызове этой функции происходит одно выделение памяти для данных и контролирующего блока умного указателя. 
В этом случае контролирующий блок и данные распологаются рядом (Однако это не 100% гаранития, что произойдёт только одно выделение памяти, но скорее всего). А при создании без этой функции (1ый вариант) 
произойдёт два выделения памяти.


ПРОБЛЕМЫ С МАССИВАМИ

До C++17 не было простого способа соорудить std::shared_ptr, хранящий массив. До C++17 этот умный указатель по умолчанию всегда вызывает delete (а не delete[]) на своем ресурсе: вы 
можете создать обходной путь, используя кастомное удаление. Один из многих конструкторов std::shared_ptr принимает в качестве второго параметра лямбду, в которой вы вручную удаляете 
принадлежащий ему объект. Например:

std::shared_ptr<int[]> p2(new int[16], [] (int* i) { 
  delete[] i; // Кастомное удаление
});

К сожалению, нет возможности сделать это при использовании std::make_shared.


ПРИМЕНЕНИЕ

Одна из главных особенностей std::shared_ptr — возможность отслеживать, сколько указателей ссылаются на один и тот же ресурс. Получить информацию о количестве ссылок можно с помощью 
метода use_count().

void compute()
{
  std::shared_ptr<int> ptr = std::make_shared<int>(100);
  // ptr.use_count() == 1
  std::shared_ptr<int> ptr_copy = ptr;   // Сделать копию: с shared_ptr возможно!
  // ptr.use_count() == 2
  // ptr_copy.use_count() == 2, в конце концов, это одни и те же базовые данные.
} // Здесь `ptr` и `ptr_copy` выходят из области действия. Больше никаких ссылок  
  // исходные данные (т.е. use_count() == 0), поэтому они автоматически убираются.
int main()
{
  compute();
}

Обратите внимание, как ptr и ptr_copy выходят из области видимости в конце функции, доводя счетчик ссылок до нуля. В этот момент деструктор последнего объекта обнаруживает, что 
ссылок больше нет, и запускает очистку памяти.


ОДИН РЕСУРСБ МНОГО std::shared_ptr. НЕ ЗАБЫВАЙТЕ О ЦИКЛИЧЕСКИХ ССЫЛКАХ!

Сила множественных ссылок может привести к неприятным сюрпризам. Скажем, я пишу игру, в которой у игрока есть другой игрок в качестве компаньона, например, так:

struct Player
{
  std::shared_ptr<Player> companion;
  ~Player() { std::cout << "~Player\n"; }
};

int main()
{
  std::shared_ptr<Player> jasmine = std::make_shared<Player>();
  std::shared_ptr<Player> albert  = std::make_shared<Player>();

  jasmine->companion = albert; // (1)
  albert->companion  = jasmine; // (2)
}

Логично, не так ли? К сожалению, я только что создал так называемую круговую ссылку. В начале моей программы я создаю два умных указателя jasmine и albert, которые хранят динамически 
создаваемые объекты: назовем эти динамические данные jasmine-data и albert-data, чтобы было понятнее. Затем в (1) я передаю jasmine указатель на albert-data, а в (2) albert хранит 
указатель на jasmine-data. Это все равно что дать каждому игроку компаньона. Когда jasmine выходит из области видимости в конце программы, ее деструктор не может очистить память: все 
еще есть один умный указатель, указывающий на jasmine-data, это albert->companion. Аналогично, когда albert выходит из области видимости в конце программы, его деструктор не может 
очистить память: ссылка на albert-data все еще живет через jasmine->companion. В этот момент программа просто завершается, не освободив память: утечка памяти во всем ее великолепии. 
Если вы запустите приведенный выше фрагмент, то заметите, что ~Player() никогда не будет вызван. Это не такая большая проблема, так как операционная система позаботится об очистке 
памяти за вас. Однако вам не стоит иметь такие круговые зависимости (т.е. утечки памяти) в середине вашей программы. К счастью, на помощь придет последний тип умного указателя.


_____________________________________________
std::shared_ptr internals

Задача: реализовать свой shared_ptr.

shared_ptr очень часто можно встретить, это один из самых полезных классов стандартной библиотеки. std::shared_ptr неплох, однако некоторые компании пишут свои аналоги shared_ptr.

Что нужно хранить в полях? shared_ptr это штука, которая должна уметь следующее:

int main() {
	auto p = std::shared_ptr<int>(new int(5));	// Здесь shared_ptr завладел указателем
	auto p2 = p;					// Теперь у нас два shared_ptr указывают на один и тот же объект.
	auto p3 = p;					// Тепреь три shared_ptr указывают на один и тот же объект. Здесь p == p2 == p3 а все они указывают на 5

	p2 = new int(8);				// Теперь p и p3 указывают на один объект(5), а p2 на другой(8).

	auto p4 = std::move(p);				// p = nullptr, p2 указывает на 8, p3 и p4 указывают на 5

	//p3.reset();					// p3 забывает чем владеет, теперь p3 это nullptr;		
}

Ну и в конце когда main заканчивается, каждый объект уничтожен ровно один раз. 

Как реализовать такой функционал? Мы создали shared_ptr, хотим уметь его копировать, присваивать и мувать. Нам нужно хранить сам указатель, и ещё счётчик, который будет указывать сколько у нас shared_ptr указыват на один объект.

1) Самый тупой вариант, он не сработает. 

Представим что мы у такого shared_ptr пытаемся реализовать конструктор копирования. Мы копируем ptr, но что делать с count? У нас должен увеличиться count, но у каждого экземпляра shared_ptr свой
count, это значит, что нам нужно увеличить count и у одного shared_ptr и у другого. Но это классно пока нас двое, а если нас уже три или больше? Мы копируем shared_ptr, и мы должны увеличить count у всех shared_ptr, у кого тот же 
ptr, что и наш. Хранить глобально какой нибудь unordered_map из ptr в count это перебор. Короче так не работает.

template <typename T>
class shared_ptr {
	T* ptr;		// Храним указатель на объект
	int count;	// Хранить кол-во shared_ptr
 
	shared_ptr(const shared_ptr& other)
		: ptr(ptr),
};


2) Следующий тупой вариант, который обычно предлагают. Это чуть умнее, но всё еще тупая идея, потому что count будет общий для каждого T, не для каждого ptr, а для каждого T. Т.е. если у нас shared_ptr от int, у них у всех вообще будет
общий count.

template <typename T>
class shared_ptr {
	T* ptr;		
	static int count;		// Добавили static
 
	shared_ptr(const shared_ptr& other)
		: ptr(ptr),
};


3) Первая нетривиальная идея заключается в том, что мы будем хранить не счётчик, а указатель на счётчк. Сам счётчик мы будем выделять динамически. Когда мы создаём новое семейство shared_ptr, указывающих на некоторый объект, мы вместе
с созданием выделяем счётчик.

template <typename T>
class shared_ptr {
private:
	T* ptr;						// Храним указатель на объект
	size_t* count;					// Указатель на счётчик	

public:
	shared_ptr(T* ptr)
		: ptr(ptr), count(new size_t(1)) {} 	// В конструкторе shared_ptr динамически выделяем count.

	shared_ptr(const shared_ptr& other)		// Копи конструктор
			: ptr(ptr), count(count) {
		++*count;
	}
	
	~shared_ptr() {
		if(!count)				// Проверяем что указатель count непустой
			return;
		
		--*count;				// Уменьшаем счётчик
		if(!*count) {				// Если счётчик равен 0
			delete count;
			delete ptr;
		} 
	}
};

Однако, если мы два раза сделаем shared_ptr от одного и того-же сишного указателя, то мы проиграли. В Си умные указатели не защищают нас от создания двух разных умных указателей на один и тот же сишный указатель, от этого нас никак не 
спасти, никто не спасёт нас если мы сами себе стреляем в ногу. Также настараживает выделение динамической памяти с помощью new, но об этом позже. 

Также ещё стоит обратить внимание что у shared_ptr size_t* count может быть пустым, например мы можем создать shared_ptr по умолчанию, или при муве один из shared_ptr останеться пустым.

Это была реализация shared_ptr на оценку 3. Какие есть проблемы? Начнём с проблемы того, что мы хотим подстраховаться от создания двух shared_ptr на один сишный указатель. Мы всё ровно не сможем от этого защититься от этого напрямую,
всё ровно если мы явно создали два shared_ptr на один сишный указатель, то никто нас не спасёт. Но мы можем ввести некоторую обёртку, чтобы по возможности свести к минимуму вероятность такого развитя событий (std::make_shared и 
std::make_unique).

###############################
std::make_shared и std::make_unique

В STL есть функция std::make_shared, которая позволяет нам создать shared_ptr на объект, сразу из объекта, т.е. не делать new вручную:

auto p = std::shared_ptr<int>(new int(5));	// Делаем new вручную
auto p2 = std::make_shared<int>(5);		// Используем функцию std::make_shared

Разница в том, что в первом случае мы сами выделяем память под объект, и от уже готового поинтера вызываем конструктор, а во втором случае, мы просим создать нам расшаренный объект типа int из аргументов и пусть shared_ptr сам выделит
под него и память и счётчик, и мы вообще не будем иметь дело с сишными указателями, даже на промежуточных стадиях. Этот способ для создания shared_ptr используется чаще чем первый, современный код стайл рекомендует использовать 
std::make_shared. std::make_shared эта функция, которая сама создаёт shared_ptr и его счётчик, сама выделив память под объект.

Сначала реализуем функцию make_unique:

template <typename T, typename... Args>
unique_ptr<T> make_unique(Args&&... args) {
	return unique_ptr<T>(new T(std::forward<Args>(args)...));
}

unique_ptr не умеет использовать аллокатор. make_unique и make_shared это функции, который просто используют new, однако есть ещё allocate_shared, это другое.

Теперь реализуем make_shared: В функции make_shared мы можем сразу убить двух зайцев и заодно решить ещё одну проблему. Изначально мотивация для ввода функции make_shared была в следующем: с помощью функции make_shared мы экономим один
вызов оператора new, ведь когда мы создаём shared_ptr напрямую через конструктор, мы вынуждены сначала написать new сами для выделения памяти под объект, а потом shared_ptr ещё раз вызовет оператор new для выделения памяти для счётчика.
Но вызов new это очень долго, поэтому в функции make_shared используется только один вызов new сразу и на объект и на счётчик, а также в памяти они будут лежать рядом друг с другом. На самом деле мы заведём некоторую специальную 
структуру, она называется control block. Эта структура, в которой хранится объект и счётчик, и вот именно её выделяет shared_ptr. Тут тоже есть один нюанс: конструктор shared_ptr никто не отменял, и мы можем создать shared_ptr двумя 
разными способами с помощью конструктора и с помощью функции make_shared. Если бы shared_ptr всегда создавался с помощью make_shared, то мы просто бы создавали control block и всё, однако мы можем создавать создаём shared_ptr с помощью 
обычного конструктора (олдовский способ), тогда никакого control block не будет. Это значит, что в shared_ptr нам нужно хранить либо то либо другое и в рантайме понимать что у нас сейчас, и в зависимости от этого правильно себя вести.

В классе shared_ptr есть приватная структура ControlBlock. Функция make_shared должна создавать этот ControlBlock, а затем с помощью него создать сам shared_ptr. Для этого у shared_ptr есть приватный конструктор, который работает только
для функции make_shared.

// Дополним shared_ptr
template <typename T>
class shared_ptr {
private:
	T* ptr;						// Храним указатель на объект
	size_t* count;					// Указатель на счётчик	

	struct ControlBlock {				// Контрол блок
		T value;
		size_t count;
	};

	template <typename U, typename... Args>		// Делаем функцию make_shared дружественной
	friend shared_ptr<U> make_shared(Args&&...);

	shared_ptr(ControlBlock* cp);			// TODO

public:
	shared_ptr(T* ptr)
		: ptr(ptr), count(new size_t(1)) {} 	// В конструкторе shared_ptr динамически выделяем count.

	shared_ptr(const shared_ptr& other)		// Копи конструктор
			: ptr(ptr), count(count) {
		++*count;
	}
	
	~shared_ptr() {
		if(!count)				// Проверяем что указатель count непустой
			return;
		
		--*count;				// Уменьшаем счётчик
		if(!*count) {				// Если счётчик равен 0
			delete count;
			delete ptr;
		} 
	}
};


// Реализуем функцию make_shared

template <typename T, typename... Args>
shared_ptr<T> make_shared(Args&&... args) {
	auto* p = new shared_ptr<T>::ControlBlock{ T(std::forward<Args>(args)...), 1 };	// Создаём контрол блок
	return shared_ptr<T>(p);					
}

Мы должны поддерживать оба сценария: и если shared_ptr создали с помощью обычного конструктора, и если shared_ptr создали с помощью make_shared. У нас появлется проблема: в ControlBlock в поле T value мы создаём и храним сам объект, а не
указатель на него, а при использовании обычного конструктора, объект создаётся вне класса shared_ptr, а в конструктор передаётся указатель на него. Получается при использовании обычного конструктора мы не можем создать ControlBlock, т.к.
объект уже создан и нам нечем инициализировать поле T value. make_shared создаёт ControlBlock который создаёт и объект и счётчик, в то время как обычный конструктор shared_ptr создаёт только счётчик, а используем мы внешний объект, и нам
не понятно как создать ControlBlock. 

В видосе была предложена идея выделять память под sizeof(T) + 4 чтобы сразу после объекта хранить счётчик, однако оператор new не гарантирует что объекты будут созданы рядом с друг другом, а также это может не работать с кастомными
аллокаторами.

Как одно из решений проблемы мы можем зашить bool в счётчик последним битом, чтобы у нас не было лишнего третьего поля и sizeof(shared_ptr) был 16 а не 24 бита, однако это не очень эффективно. Кстати sizeof настоящего std::shared_ptr 
равен 16, поскольку он хранит всего два указателя.

Одно из решений проблемы: первый указатель T* ptr мы оставляем, а второй указатель size_t* count мы просто будем делать nullptr, в случае когда у нас есть ControlBlock. Если у нас первый указатель не nullptr а второй nullptr, то значит 
shared_ptr был создан через ControlBlock, а в случае с ControlBlock мы знаем какой оффсет числа от начала ControlBlock. Важный момент: почему T* ptr мы хотим сохранить полем? Для того, чтобы доступ к объекту был быстрым, поскольку 
самая популярная опция shared_ptr это его разыменование. 

Т.е. мы заводим T* ptr в любом случае, а size_t* count либо nullptr либо нет, если он nullptr, то мы понимаем, что у нас ControlBlock, и счётчик лежит рядом с объектом. Однако это временное решение.


### 
Оффтоп.
Была ещё одна причина чтобы добавить функцию make_unique: представим что у нас где то в коде есть функция которая принимает первым параметром unique_ptr, а ещё что-то:

f(unique_ptr<int>(new int(5)), g());

Здесь есть подвох: вычисление аргументов функции оно не упорядоченно, и оно до версии C++17 было неупорядоченно настолько, что могли прерываться вычисления и начинать вычислять другие, например, если вторым параметром у меня 
ещё вызов какой-то функции, то компилятор В ТЕОРИИ может вычислять выражение в таком порядке: сначала сделать new int, потом вычислить g(), и затем вызвать конструктор unique_ptr. Это плохо, потому что g() может бросить исключение. 
Т.е. если мы создаём unique_ptr напрямую, а не через make_unique, то мы можем напороться на такое. Если кто-то прервал исполнение между ситуацией когда мы создали new int и когда вернули в unique_ptr, то мы можем проиграть, ведь наш
unique_ptr не защитил нас от утечки памяти. Поэтому в C++14 добавили make_unique. 

С помощью make_unique и make_shared мы защищаемся от таких сценариев, потому что если написать здесь 

f(make_unique<int>(5), g());

то здесь уже никто не ворвётся, функция если выполнится, то целиком. 

В C++17 компилятору запретили так беспорядочно выполнять вычисления. 

Конец оффтопа
### 

Комментарий под видео 46:
В лекции ошибка. В ControlBlock на самом деле лежит не T, а T*. При вызове std::make_shared мы действительно делаем одну аллокацию сразу под shared_ptr и под T. Таким образом, мы экономим аллокацию + ещё выигрываем в скорости из-за 
cache локальности.

"под shared_ptr и под T" - имеешь в виду под control block и под T? А в чем профит хранить в контрол блоке указатель, а не сам T?

1. - имеешь в виду под control block и под T?
- да
2. -  А в чем профит хранить в контрол блоке указатель, а не сам T?
- T* хранится и в shared_ptr, и в ControlBlock (таким образом, мы делаем одно разыменование, если хотим получить T). Это нужно, чтобы корректно delete'ить объекты с множественным наследованием без виртуальных деструкторов.

есть подробно на youtube:
CppCon 2019: Arthur O'Dwyer “Back to Basics: Smart Pointers”

а узнал я про это на одном из собесов)




_____________________________________________

Понимание std::weak_ptr: поверхностный вариант

std::weak_ptr — это, по сути, std::shared_ptr, который не увеличивает счетчик ссылок. Он определяется как умный указатель, который содержит несобственную ссылку, или ослабленную 
ссылку, на объект, управляемый другим std::shared_ptr. Этот умный указатель полезен для решения некоторых раздражающих проблем, которые нельзя решить с помощью необработанных 
указателей.


СОЗДАНИЕ

Вы можете создать std::weak_ptr только из std::shared_ptr или другого std::weak_ptr. Например:
std::shared_ptr<int> p_shared = std::make_shared<int>(100);
std::weak_ptr<int>   p_weak1(p_shared);
std::weak_ptr<int>   p_weak2(p_weak1);

В приведенном выше примере p_weak1 и p_weak2 указывают на одни и те же динамические данные, принадлежащие p_shared, но счетчик ссылок не растет.


ПРИМЕНЕНИЕ

std::weak_ptr является своего рода инспектором для std::shared_ptr от которого он зависит. Вы должны сначала преобразовать его в std::shared_ptr с помощью метода lock() если вы 
действительно хотите работать с реальным объектом:

std::shared_ptr<int> p_shared = std::make_shared<int>(100);
std::weak_ptr<int>   p_weak(p_shared);
// ...
std::shared_ptr<int> p_shared_orig = p_weak.lock();
//

Конечно, p_shared_orig может быть нулевым в случае, если p_shared был удален в другом месте.


std::weak_ptr РЕШАЕТ ПРОБЛЕМЫ

С помощью std::weak_ptr очень легко решить проблему висящих указателей — тех, которые указывают на уже удаленные данные. Он предоставляет метод expired(), который проверяет, был ли 
объект, на который ссылается ссылка, уже удален. Если expired() == true, исходный объект был где-то удален, и вы можете действовать соответствующим образом. Это то, что вы не можете 
сделать с необработанными указателями.

Как я уже говорил, std::weak_ptr также используется для разрыва циклической ссылки. Давайте вернемся к примеру Player, приведенному выше, и изменим переменную-член с std::shared_ptr 
companion на std::weak_ptr companion. В данном случае мы использовали std::weak_ptr для устранения запутанного владения. Фактически имкющиеся динамически выделяемые данные остаются в 
основном теле, в то время как каждый Player теперь имеет слабую ссылку на них. Запустите код с этим изменением, и вы увидите, что деструктор вызывается дважды, правильно.


_____________________________________________
std::weak_ptr

Как и в любой системе, которая пытается заниматься сборкой мусора, у нас могуть быть циклические зависимости. Представим что мы пытемся сделать красно-чёрное дерево на shared_ptr. Мы такие умные, давайте никогда не использовать 
сишные указатели, будем всегда использовать умные указатели. У нас будут вершины и вместо Node* везде будут shared_ptr<Node> чтобы никогда не страдать от утечек памяти. И тут мы сталкнёмся с новой интересной проблемой: чтобы удалить
такое дерево, нам недостаточно будет вывести его корень из области видимости, потому что на каждую ноду указывают её дети снизу. Если у нас структура данных такова, что есть циклические зависимости, то ничего не удалится. Нода же 
считает что она не должна удаляться пока кто-то на неё указывает. Мы храним дерево как корень этого дерева, и вот мы вывели корень из области видимости, и по идее мы хотим чтобы всё дерево схлопнулось и удалилось, но этого не произойдёт,
потому что у нас на ноды ссылки ещё и снизу идут, и получается что все ноды друг на друга ссылаются, и несмотря на то, что мы потеряли ссылку на верхнюю ноду, у нас дерево не удалилось, у нас циклические зависимости между нодами. Поэтому
нам нужен ещё один умный указатель std::weak_ptr (Слабый указатель).

Слабые указатели  это терминалогия из области сборки мусора. Когда работает сборщик мусора (garbage collector) у него тоже есть сильные и слабые ссылки. Слабые ссылки или слабый указатель в терминах C++ это указатель, который не 
учитывается при подсчёте ссылок, т.е. этот указатель смотреть на объект может и достать объект через такой указатель можно, но при подсчёте количества ссылок он не учитывается. И это решает проблему циклических ссылок, нам нужно просто
чтобы в каждом цикле хоть один указатель был слабым, в частности если мы пишем дерево, то нужно делать ссылки сверху вниз нужно делать shared_ptr, а сниху вверх weak_ptr, чтобы ссылки от детей на родителей не влияли на подсчёт ссылок, 
и тогда всё дерево схлопнется, когда у нас умрёт корень. Слабым называется, потому что он бессилен защитить кого-то от удаления.

Какой мы ожидаем от него функционал? Мы можем создать weak_ptr от shared_ptr:

int main() {
	auto p = std::shared_ptr<int>(new int(5));		// Здесь shared_ptr завладел указателем
	auto p2 = p;					// Теперь у нас два shared_ptr указывают на один и тот же объект.
	auto p3 = p;					// Тепреь три shared_ptr указывают на один и тот же объект. Здесь p == p2 == p3 а все они указывают на 5

	p2 = new int(8);				// Теперь p и p3 указывают на один объект(5), а p2 на другой(8).

	auto p4 = std::move(p);				// p = nullptr, p2 указывает на 8, p3 и p4 указывают на 5
	
	std::weak_ptr<int> wp = p3;
	p3.reset();					// Теперь p3 это nullptr.
}

После p3.reset() p3 стал nullptr, однако wp всё ещё валиден потому что у нас было два указателя p3 и p4 которые указывали на new int(5), пока p4 жив, wp ещё валиден и можно через него посмотреть и получить 5. 

А как через weak_ptr получить объект? Особенность weak_ptr в том, что его нельзя разыменовать, в отличии от shared_ptr, потому что это несовсем семантически корректное действие. Из weak_ptr можно получить sheard_ptr, т.е. можно попросить
weak_ptr дать нам shared_ptr на тоже, на что указывает weak_ptr. Эта операция называется lock(), которая создаёт новый экземпляр shared_ptr, указывающий на тот же объект что и weak_ptr. Если при этом объект уже был уничтожен, то создастся 
пустой shared_ptr.

wp.lock();

Так же у weak_pt есть ещё метод expired, который проверяет жив ли ещё объект под weak_ptr. А ещё у shared_ptr и у weak_ptr есть метод use_count, которы возвращает число счётчика.

Вопрос: как реализовать expired? Как проверить жив ли объект под weak_ptr? Если count равен 0 , то обращение к count это UB, поскольку как только count становится равным 0, shared_ptr уничтожает counter. И тут возникает новая проблема: как
weak_ptr понять что объект бы удалён, если проверить счётчик на равенство 0 плохой вариант, ведь shared_ptr уничтожит всё вместе с контрол блоком и счётчиком, как только счётчик станет равным нулю, и тогда разыменование станет UB. 

Правильное решение такое: счётчиков должно быть не один а два. И на самом деле есть shared_count, а есть weak_count, и тот count который у нас был раньше это shared_count. Т.е. в ControlBlock у нас должно быть два счётчика. Но если у нас 
не было ControlBlock, то теперь не совсем понятно нужно ли в самом shared_ptr добавлять новый счётчик, но мы не хотим добавлять ещё один счётчик, мы хотим чтобы чтобы sizeof(shared_ptr) оставался 16. И это наводит на некоторую новую 
мысль, что нам нужна ещё одна новая структура. На самом деле мы тоже в любом случае будем называть эту структуру ControlBlock, только мы сделаем разновидность ControlBlock. Т.е. у нас будет всего один указатель на структуру, просто в одном
случае у нас будет структура ControlBlock, в которой хранится всего лишь два счётчика, а вдругом случае у нас будет структура ControlBlockWithObject (название условное) в котором хранится объект и два счётчика. 

Поскольку ControlBlockWithObject это частный случай ControlBlock, мы можем использовать наследование. Теперь разберём два наших случая: что shared_ptr создался от конструктора, и второй случай от функции make_shared. Если shared_ptr
создан через конструктор, то мы храним указатель на настоящий объект  T* ptr, а ещё храним указатель на контрол блок ControlBlock* count. Если shared_ptr создан от make_shared, то мы храним указатель на объект T* ptr, а указатель 
ControlBlock* count делаем nullptr, и теперь мы понимаем если указатель на контрол блок равен nullptr, то на самом деле счётчики лежат перед объектом T. Т.о. мы обошлись без каких либо дополнительных полей.

В weak_ptr мы храним тоже самое, тот же указатель на объект, и указатель на тот же самый контрол блок.  В деструкторе weak_ptr нам нужно проверять правда ли shared_count и weak_count уже нули, и если они нули, то удаляем контрол блок. А
в деструкторе shared_ptr нам теперь не всегда нужно делать delete count, а лишь иногда, потому что shared_ptr не должен всегда удалять счётчики, он должен удалять счётчики если только увидел что weak_count стало равно нулю. В деструкторе
shared_ptr нам нужно отдельно проверить стал ли равен нулю shared_count, и если равен, то вызвать деструктор T. А потом нужно проверить стал ли нулём ещё и weak_count, и если он тоже стал равен нулю, то удаляем контрол блок и освобождаем
память. Но если shared_count стал равен нулю, а weak_count ещё нет, то нам надо не удалять счётчик, а это в частности означает, что если у нас был большой контрол блок вместе с объектом, то память из под него не нужно освобождать. И это 
недостаток функции make_shared, если у нас огромный объект и был shared_count и weak_count, и мы назаводили на него weak_ptr, а потом мы все shared_ptr умерли, когда умирает последний shared_ptr он видит что weak_count ещё не ноль, 
вызывает деструктор T в этом контрол блоке, но не освобождает память из под контрол блока, т.е. он убивает поле делая ему деструктор, но два числа остаются жить в этой структуре. Т.е. он посути разрушает надстройку ControlBlockWithObject над
основным контрол блоком, он как бы уничтожает эту часть T value, но остаётся базовая часть ControlBlock, но память то была выделена единым куском, поэтому память под T не освобождается если мы создались через make_shared пока мы не 
уничтожим все weak_ptr. Поскольку мы выделяли через new, мы не можем освободить этот лишний промежуток памяти.


// Дополним shared_ptr
template <typename T>
class shared_ptr {
private:
	T* ptr;						// Храним указатель на объект
	ControlBlock* count;					// Указатель на счётчик	

	struct ControlBlock {				// Обычный контрол блок
		size_t shared_count;			// Счётчик сильных ссылок
		size_t weak_count;			// Счётчик слабых ссылок
	};

	template <typename U>				// Почему он шаблонный рассказано далее 
	struct ControlBlockWithObject: ControlBlock {	// Контрол блок с объектом
		U value;
	};

	template <typename U, typename... Args>		// Делаем функцию make_shared дружественной
	friend shared_ptr<U> make_shared(Args&&...);

	shared_ptr(ControlBlock* cp);			// TODO

public:
	shared_ptr(T* ptr)
			: ptr(ptr), count(new size_t(1)) { 	// В конструкторе shared_ptr динамически выделяем count.
		
		if constexpr (std::is_base_of_v<enable_shared_from_this<T>, T>)  {	// Это условие объясняется дальше
			ptr->sptr = *this;					// Мы имеем доступ у этому полю потому что enable_shared_from_this объявил класс shared_ptr дружественным
		}
	}

	shared_ptr(const shared_ptr& other)		// Копи конструктор
			: ptr(ptr), count(count) {
		++*count;
	}
	
	~shared_ptr() {
		if(!count)				// Проверяем что указатель count непустой
			return;
		
		--*count;				// Уменьшаем счётчик
		if(!*count) {				// Если счётчик равен 0
			//delete count;		// Больше не нужно этого делать
			delete ptr;
		} 
	}
};





###
Оффтоп: недостатки std::make_shared

https://habr.com/ru/articles/509004/


_____________________________________________
enable_shared_from_this

Представим ситуацию: у нас есть структура S и в ней есть какой нибудь метод который возвращает указатели на объекты этой структуры. У нас может возникнуть ситуация когда мы захотим получить shared_ptr, который указывал на нас же.
Допустим у нас в программе владение объектами заданы через shared_ptr, и мы хотим взять и получить shared_ptr на себя же, например чтобы вернуть его наружу или положить в какой нибудь контейнер. Как нам из структуры S достать shared_ptr
на неё же, если мы знаем что эта структура S задана через shared_ptr.

struct S {
	std::shared_ptr<S> getObject() {
		//return std::shared_ptr<S>(this);  // Это неправильно	
	}
};

Мы не можем написать return std::shared_ptr<S>(this), потому что мы создадим второе семейство shared_ptr от того же сишного указателя и всё сломается. Нам нужно как то уметь получить доступ к shared_ptr на себя, при этом не создавая новое
семейстово shared_ptr. Для этого в STL существует класс std::enable_shared_from_this. Этот класс самый популярный пример паттерна CRTP в STL. Чтобы у нас была возможность получать в классе shared_ptr на себя, нам нужно унаследоваться
от класса std::enable_shared_from_this<С шаблонным параметром нашего типа (В данном случае S)>.

Это наследование даёт то, что у нас появляется метод shared_from_this(), который и даёт нам shared_ptr на себя.

struct S: public std::enable_shared_from_this<S> {
	std::shared_ptr<S> getObject() {
		//return std::shared_ptr<S>(this);  // Это неправильно
		return shared_from_this();	
	}
};

Что такое std::enable_shared_from_this и как это реализовать? Очивидно эта структура имеет метод shared_from_this(). Мы можем хранить shared_ptr на T и возвращать его, однако вопрос чем и когда нам его инициализировать. 

template <typename T>
struct enable_shared_from_this {
	shared_ptr<T> sptr;				// Чем и когда инициализировать?

	shared_ptr<T> shared_from_this() const {
		return sptr;
	};

	enable_shared_from_this() {}

	template <typename U>			// Объявляем класс shared_ptr дружественным
	friend class shared_ptr;
};

Нам нужно исправить конструктор shared_ptr. Когда мы уже создали объект S, и начинаем его оборачивать в shared_ptr, вот тогда то мы этому полю shared_ptr<T> sptr в классе enable_shared_from_this присвоим нас. В стандартном 
конструкторе shared_ptr мы хотим сказать, что если T это enable_shared_from_this, то полю sptr нужно присвоить нас. Т.е. мы проверяем является ли enable_shared_from_this родителем нашего класса S. Для этого можно использовать мета функцию
std::is_base_of_v которая распознаёт и приватное и множественное неоднозначное наследование, даже через промежуточных наследников.

template <typename T>
class shared_ptr {
	// ...
	shared_ptr(T* ptr)
			: ptr(ptr), count(new size_t(1)) { 	
		
		if constexpr (std::is_base_of_v<enable_shared_from_this<T>, T>)  {	
			ptr->sptr = *this;			// Мы имеем доступ у этому полю потому что enable_shared_from_this объявил класс shared_ptr дружественным
		} 
	}
}

Также мы должны предусмотреть случай когда структуру S, унаследуемую от enable_shared_from_this, создали просто так, без shared_ptr. Смысла в таком действии нет, однако предусмотреть это стоит. Если shared_from_this вызван на объекте,
который не владел shared_ptr, то бросается исключение std::weak_ptr.


Есть у нас ещё проблема которую мы не учли: как вообще такой объект будет уничтожаться? Структура S наследник enable_shared_from_this, им владело сколько то shared_ptr, и вот последний shared_ptr умирает. В какой момент структура S 
будет уничтожена? Если в полях хранить shared_ptr<T> sptr то у нас опять возникает проблема от которой мы недавно спасались, у нас имеется shared_ptr который указывает на нас же, мы так никогда не уничтожимся, мы не должны хранить поле
класса enable_shared_from_this поле указателя shared_ptr на себя, потому что получается что мы сами же и закольцевались, у нас получается что счётчик никогда не упадёт до нуля, и тогда мы никогда не удалим эту структуру. Поэтому здесь в
полях enable_shared_from_this нужен weak_ptr, а возвращать уже shared_ptr созданный из этого weak_ptr.

template <typename T>
struct enable_shared_from_this {
	weak_ptr<T> wptr;				
	//...
}


###
Оффтоп: Можно ли написать так?

struct Base {};
struct Derived: Base {};

int main() {
	auto p = make_shared<Derived>();
	
	shared_ptr<Base> bp  = p;
}

Так можно написать, однако у нас пока что нет такого конструктора. Нам нужно научиться поддерживать создание shared_ptr от shared_ptr другого типа, если он наследник нашего типа. Мы должны уметь shared_ptr<Base> от shared_ptr<Derived>.
Аналогично с weak_ptr и unique_ptr, а это в частности означает, что в контрол блок не обязательно хранит T, он может хранить U, где U это наш наследник. И более того, мы же в shared_ptr храним указатель на T, но допустим у нас 
множественное наследование mother father и son, и создав shared_ptr на father, нам присвоили shared_ptr на сына. Этот T будет указывать в начало отца, но если мы до этого договаривались что у нас счётчики лежат перед началом объекта,
то это будет не совсем верно. Теперь нам нужно ещё учитывать что начало настоящего объекта может быть не там, куда указывает наш указатель. Получается у нас в контрол блоке может храниться U, а не T. Контрол блок шаблонный, и вот это
U м.б. нашем наследником. Но в shared_ptr указатель мы храним всё ровно на T, соответсвтенно мы понимаем, что начало объекта не там, где мы думаем, поэтому нам нужно понять как правильно сдвинуть указатель чтобы получить счётчики.


###
Оффтоп 2: Полезные функции с наследованием.

Вообще то хочется, чтобы с умными указателями можно было делать всё тоже, что и с обычными указателями, в частности, имея указатель на U, мы могли бы получать указатель на T через какие то функции.
Есть такие функции как std::static_pointer_cast, std::dynamic_pointer_cast, std::const_pointer_cast, std::reinterpret_pointer_cast. Это довольно простые в реализации функции, вот например реализация std::dynamic_pointer_cast:

template <class T, class U>
std::shared_ptr<T> dynamic_pointer_cast(const std::shared_ptr<U>& r) noexcept {
	if (auto p = dynamic_cast<typename std::shared_ptr<T>::element_type*>(r.get()))
		return std::shared_ptr<T>(r, p);
	else
		return std::shared_ptr<T>();
};

Мы просто разыменовываем shared_ptr, достаём тип элемента, делаем ему динамик каст и создаём shared_ptr от двух параметорв: другой shared_ptr и указатель. И этот конструктор создаёт shared_ptr, который разделяет владение, просто смотрит
на него как на другой тип, т.е. мы так можем создать shared_ptr на mother из shared_ptr на father и у нас будут два указателя в разные места, но объект будет всё ещё один (Лекция 47 21.50).


### Оффтоп 3: Что еще можно реализовать из STL?

function, variant



_____________________________________________
Идеома Type erasure (Стерание типа)

Мы можем создать shared_ptr с кастомным делитером. Разберёмся с делитером. Допустим мы хотим научиться создавать shared_ptr с кастомным делитером и аллокатором.

template < class Y, class Deleter >
shared_ptr( Y* ptr, Deleter d );

У нас конструктор shared_ptr с шаблонным параметром Deleter, но это не шаблонный параметр самого shared_ptr. У shared_ptr и weak_ptr только один шаблонный параметр. Решили что дополнительный шаблонный параметр shared_ptr это перебор.
Тем не менее у shared_ptr есть конструктор принимающий Deleter и возникает вопрос: а как это работает? Что нужно хранить? нам нужно каким то образом поддержать нестандартный делитер, при том, что мы не знаем заранее его тип. Но хуже
того, мы можем создать shared_ptr без делитера, а потом присвоить ему друго shared_ptr, у которого делитер был другим, ведь если у нас shared_ptr на int, и int это единственный шаблонный параметр shared_ptr, нам ничего не мешает 
завсети сначала обычный shared_ptr на int, потом завсети другой shared_ptr на int с нестандартным делитером, и присвоить первому shared_ptr второй shared_ptr. И теперь они должны оба владеть вторым int с нестандартным делитером, т.е.
первый shared_ptr должен каким то образом сохранить себе тот делитер, но он заранее даже не знает какой тип будет у этого делитера, как он это должен сделать? С аллокатором таже самая проблема. 

Сделать интерфейс (общую структуру) для делитера и аллокатора, тем самым обязав наследовать все делитеры и аллокакторы от одного и того же это плохая идея, заставлять делать людей наследование это не очень правильно, потому что в 99%
случаях мы не хотим нестандартный делитер и из-за этого не хочется его таскать с собой постоянно, и нестандартный аллокатор тоже, но тем не менее если он тебе вдруг понадобился, хочется чтобы ты его незаметно умел подменять.

Мы хотим научиться в рантайме подменять делитер на делитер другого типа. Тут мы приходим к совершенно новой идеи - Идеома Type erasure. Мы сейчас попробуем научиться в объекте хранить разные типы, динамически подменяя их. Это ровно
то, что нам нужно научиться делать для shared_ptr. Это нам много где поможет, например в std::function нужно сделать тоже самое, ведь std::function это класс который умеет в рантайме подменять себя на другой тип, главное чтобы круглые 
скобочки были определены с такими же параметрами. И ещё одно место где это полезно это аллокаторы, есть такой полиморфик аллокатор, он тоже основан на этом. Чтобы у нас контейнер от разных аллокаторов это не были разные типы 
контейнеров, и нельзя одному присвоить другой, можно просто сделать тип аллокатора, так называемым полиморфик аллокатором и это будет общий тип, но в реальности под ним могут быть разные аллокаторы.

Сейчас мы познакомимся с типом std::any. Следующий код компилируется. Из std::any можно достать то что в нём лежит, правда для этого нужно скастовать с помощью std::any_cast и при касте нужно назвать тип. Только нужно кастовать к ссылке,
потому что как и всегда иначе будет копия. Важно помнить что C++ это язык со статической типизацией.

#include <iostream>
#include <any>
#include <vector>

int main() {
	std::any a = 5;
	std::cout << std::any_cast<int&>(a) << '\n';

	a = "abc";
	std::cout << std::any_cast<const char*&>(a) << '\n';

	a = 3.14;
	std::cout << std::any_cast<double&>(a) << '\n';

	std::vector<int> v{1, 2, 3};
	a = v;
	std::cout << std::any_cast<std::vector<int>&>(a)[0] << '\n';
}

Объекты копируются в any, поэтому в данном случае у нас создаётся двое объектов:

std::vector<int> v{1, 2, 3};	// Первый вектор
a = v;			// Создание нового (второго) вектора

v[0] = 5;			// Изменение только в первом векторе, во втором всё останется как было.


Если мы не отгадаем тип и назовём не тот:

a = 3.14;
std::cout << std::any_cast<int&>(a) << '\n';	// Вместо double пишем тип int

то будет runtime error, будет exception std::bad_any_cast. 

Также можно навестить const 

a = 3.14;
std::cout << std::any_cast<const double&>(a) << '\n';

Если подставить auto при касте то будет ошибка type_dedaction, но можно подставить decltype:

a = 3.14;
std::cout << std::any_cast<decltype(d)>(a) << '\n';


###############################
Реализация std::any

Мы можем хранить void*, а также у std::any должен быть конструктор от любого типа. Самое интересное это деструктор any, в нём нужно удалить правильно, в зависимости то, что в нём лежало.

Реализовать деструктор можно простым и сложным способом. Начнём с простого, и именно простой способ реализован в shared_ptr. В языке уже есть механизм, который уже это делает за нас и это виртуальные фукнции. Ведь по сути именно это
и делают виртуальные функции, когда мы заводим полиморфный объект, для него за нас сохраняется таблица виртуальных функций, в которой в том числе хранится что сделать когда объект копируется, что сделать когда объект удаляется,
что делать когда объект и т.д.

class any {		// Сам класс не шаблонный
private:
	void* ptr;

public:
	template <typename T>
	any(const T& value): ptr(new T(value)) {}

	~any() {
	
	}
};

Идеома Type erasure заключается в следующем: мы храним структуру Base, и ещё шаблонную структуру Derived, которая хранит T. Но структура Base у нас будет полиморфной. В этом и заключается решение: в классе any мы храним просто 
указатель на Base. Мы хотим уметь делать Derived от value. В конструкторе any мы создаём Derived с шаблонным праметром T  от нашего value, а указатель Base* ptr у нас на Base. т.е.  мы проинициализировали указатель на Base указателем
Derived от T, но это наследник, значит всё нормально. Теперь в деструкторе any мы делаем delete ptr. Когда мы делаем delete ptr, сначала вызывается деструктор, потом освобождается память, но какой деструктор вызывается? Тот, который 
написан в таблице виртуальных функций, но поскольку у нас виртуальное наследование, там написан правильный деструктор т.е. там написан деструктор Derived. Деструктор Derived сам по себе тривиальный, но вызов деструктора Derived
неизбежно влечёт за собой уничтожение полей Derived, потому что так написано в таблице виртуальных функций, после деструктора отрабатывают деструкторы полей, т.о. у нас реализовано хранение и уничтожение объектов любого типа
и подмена этих объектов в runtime вот таким хитрым трюком. Если удалить строку virtual ~Base() = 0, то в деструкторе будет вызываться деструктор Base а не Derived. За счёт этой строчки у нас поддерживается таблица виртуальных функций.

class any {		// Сам класс не шаблонный
private:
	struct Base {
		virtual ~Base() = 0;	// Виртуальный деструктор
	};

	template <typename T>
	struct Derived: public Base {
		T value;
		Derived(const T& value): value(value) {}
		Derived(T&& value): value(std::move(value)) {}
		~Derived() = default;
	};

	Base* ptr;		// Храним указатель на Base

public:
	template <typename T>
	any(const T& value): ptr(new Derived<T>(value)) {}
	
	~any() {
		delete ptr;
	}
};

Ещё один интересный вопрос: как скопировать any? Когда мы копируем any мы хотим создать новый полноценный объект(deap copy), если у нас any хронит вектор, то когда мы копируем any, должен скопироваться и вектор, а не должен 
создасться второй указатель на этот же вектор, иначе у нас будет двойное владение и как следствие мы удалим один объект два раза. 

Добавим в Base ещё одну функцию getCopy(). 



class any {		// Сам класс не шаблонный
private:
	struct Base {
		virtual  Base* getCopy() const = 0;	
		virtual ~Base() = 0;			// Виртуальный деструктор
	};

	template <typename T>
	struct Derived: public Base {
		T value;
		Derived(const T& value): value(value) {}
		Derived(T&& value): value(std::move(value)) {}
		~Derived() = default;

		Base* getCopy() const override {	// Функция копирования
			return new Derived(value);
		}
	};

	Base* ptr;		// Храним указатель на Base

public:
	template <typename T>
	any(const T& value): ptr(new Derived<T>(value)) {}
	
	any(const any& other): ptr(other.ptr->getCopy()) {}  // Функция копирования

	~any() {
		delete ptr;
	}
};


Реализуем any_cast(). any_cast() должен быть другом any.

template <typename T>
T any_cast(any& a) {
	auto* p = dynamic_cast<any::Derived<std::remove_reference_t<T>>*(a.ptr);
	if(!p) {
		throw std::bad_any_cast();
	}
	return p->value;
}


Эта идеома называется Type erasure (Стерание типа), мы за указателем на родителя прячем шаблонного наследника и за счёт механизма виртуальных функций, мы теперь в рантайме можем подменять тип того, что реально у нас храниться.


###############################
Возвращаемся в shared_ptr

Проблема такая: нам нужно в shared_ptr в рантайме подменять делитер и аллокатор. (оффтоп: В стандартном shared_ptr есть слово virtual, поэтому многие компании любят писать свой shared_ptr).

Зачем вообще shared_ptr иногда нужен нестандартный аллокатор. Потому что shared_ptr сам иногда делает new size_t и вот на этот new ему может быть нужен нестандартный аллокатор. А ещё нужен нестандартный делитер. 
Если мы создаём shared_ptr от готового указателя с нестандартным делитером, что это значит?

template <class Y, class Deleter>
shared_ptr(Y* ptr, Deleter d);

Это значит что мы хотим вместо delete ptr вызвать этот Deleter, а этот new т.е. каунтер выделить всё ровно стандартным способом.

Что если мы создаём shared_ptr с нестандартным делитером и нестандартным аллокатором? 

template <class Y, class Deleter, class Alloc>
shared_ptr(Y* ptr, Deleter d, Alloc alloc);

Это значит что мы опять вместо delete ptr сделать Deleter, а new уже выделить нестандартным аллокатором, и когда удаляем счётчик вызывать deallocate, а не delete. Если мы создаёмся не через make_shared, то нам возможно понадобятся
кастомные и делитер и аллокатор, а если создаёмся через make_shared, то нам бывает нужен нестандартный аллокатор, но уже не бывает нужным нестандартный делитер, аллокатор нестандартный нужен, а делитер нет, потому что если мы 
создаёмсся через make_shared, то мы точно являемся RAII над new, make_shared эта штука которая выделяет нам объект, значит в конце его надо удалить, а не сделать чтото другое. Только если объект создан не через make_shared, тогда нам
может быть нужен нестандартный делитер, а если мы создались через make_shared, то делитер уж точно стандартный, но вот аллокатор всё таки может быть нестандартный.

Итак у нас есть два случая, они отличаются следующим: В первом случае, при создании shared_ptr с помощью обычного конструктора, у нас м.б. и нестандартный делитер и нестандартный аллокатор, а во втором случае, при создании shared_ptr с
помощью функции make_shared, у нас делитер точно стандартный, и только аллокатор м.б. нестандартный, но в этом случае у нас ещё лежит value.

Теперь нам не нужен этот трюк с присваиванием count = nullptr, поскольку теперь мы в любом случае храним указатель на какой то контрол блоко, но мы можем в рантайме проверять это ControlBlockRegular или ControlBlockMakeShared. Мы в 
рантайме можем подменять один shared_ptr на другой, с другим контрол блоком. Мы храним указатель на контрол блок, но помимо этого мы храним её и указатель на сам объект для быстрого доступа к нему.

В контрол блоках мы пишем соответствуюущие конструкторы, мы также делаем виртуальные функции getCopy() для создания копий этих контрол блоков, мы также поддерживаем мув контрол блока и т.д.

template <typename T>
class shared_ptr {
private:
	T* ptr;						// Храним указатель на объект
	BaseControlBlock* count;				// Указатель на счётчик	

	struct BaseControlBlock {				// Обычный контрол блок
		size_t shared_count;			// Счётчик сильных ссылок
		size_t weak_count;			// Счётчик слабых ссылок
		
		virtual ~BaseControlBlock = 0;		// Добавляем виртуальный деструктор
	};

	template <typename U, typename Deleter, typename Alloc>	// Обычный контрол блок
	struct ControlBlockRegular: BaseControlBlock {
		Deleter del;
		Alloc alloc;
	};

	template <typename U, typename Alloc>	// Контрол блок с объектом		
	struct ControlBlockMakeShared: BaseControlBlock {	
		U value;
		Alloc alloc;
	};


###############################
allocate_shared

Представим что мы хотим создасться с нестандартным аллокатором. У нас есть функция allocate_shared. Она делает shared_ptr от T, но принимает аллокатор и аргументы. Допустим мы попросили создать shared_ptr с нестандартным аллокатором, 
тогда нужно создать контрол блок с нестандартным аллокатором и сохранить туда этот аллокатор. Т.е. нужно на некотором аллокаторе создать контрол блок, и в сам этот контрол блок записать этот аллокатор. Нам нужно создать 
ControlBlockMakeShared с параметрами T, Alloc, но сам контрол блок нужно аллоцировать на аллокаторе. Но это аллокатор на T, а нам нужно получить из него аллокатор на ControlBlockMakeShared. Для этого нам нужно сдедлать rebind.

template <typename T, typename Alloc, typename... Args>
shared_ptr<T> allocate_shared(const Alloc& alloc, const Args&&... args) {
	using BlockAlloc = typename std::allocator_traits<Alloc>::rebind_alloc<ControlBlockMakeShared<T, Alloc>>;	// Делаем rebind 
	BlockAlloc ba = alloc;									// Создаём аллокатор на блок из нашего аллокатора
	auto* ptr = ba.allocate(1);									// Аллоцируем память
	ba.construct(ptr, 1, 0, std::forward<Args>(args)..., alloc);						// ptr, shared_count, weak_count, аргументы, аллокатор (Это конструктор ControlBlockMakeShared, мы его не неаписали)
	return ...; // TODO shared_ptr от соответствующих параметров
}

###############################
Деструктор контрол блока

Как это всё будет уничтожаться в деструкторе контрол блока? У нас есть два случая, когда у нас последним умирает shared_ptr, и второй когда последним умирает weak_ptr. Когда у нас умирает последний shared_ptr, но weak_ptr ещё живы, то
нам нужно на аллокаторе позвать дестрой от T, но память пока не деаллоцировать. А когда у нас умирает последний weak_ptr, нужно вызвать метод контрол блока, который удалит всю память. т.е.  у нас аллоктаор лежит в контрол
блоке, нам нужно из контрол блока достать этот аллокатор, который удалит сам контрол блок. Т.е. нам нужно из аллокатора который лежит в контрол блоке, достать аллокатор на контрол блок (создать из аллокатор от T аллокатор на контрол блок),
и этим аллокатором удалить этот контрол блок. В какой то момент в реализации этой логики может возникнуть ситуация, что нам захочется написать delete this или alloc.deallocate(себя), т.е. мы из контрол блока можем захотеть деалоцировать 
указатель, которым мы же и являетесь, и это нормальный код, это не UB, при условии, что мы после этого никогда не будем пользоваться своими полями. Т.е. delete this писать можно, если это последнее действие которое мы делаем в методе, и 
после этого мы никогда не пользуемся своими полями.



_____________________________________________
Заключительные заметки и мысли об умных указателях


Мне нравятся умные указатели. Должен ли я навсегда избавиться от new/delete?

Иногда вы действительно хотите полагаться на двойников new/delete, например:
когда вам нужно кастомное удаление, как мы видели ранее, когда мы добавили поддержку массивов в std::shared_ptr;
когда вы пишете собственные контейнеры и хотите вручную управлять памятью;
с помощью так называемой конструкции in-place, более известной как placement new: новый способ создания объекта на уже выделенной памяти. Более подробная информация здесь.


Работают ли умные указатели медленнее, чем обычные?

Согласно различным источникам (здесь и здесь), производительность умных указателей должна быть близка к производительности необработанных указателей. Небольшое снижение скорости может
 присутствовать в std::shared_ptr из-за внутреннего подсчета ссылок. В целом, есть некоторые накладные расходы, но они не должны сделать код медленным, если только вы не будете 
постоянно создавать и уничтожать умные указатели.


Рациональное обоснование std::make_unique и std::make_shared

Этот альтернативный способ построения умных указателей дает два преимущества. Во-первых, он позволяет нам забыть о ключевом слове new. При работе с умными указателями мы хотим 
избавиться от гнусной комбинации new/delete, верно? Во-вторых, это делает ваш код защищенным от исключений. Рассмотрим вызов функции, принимающей на вход два умных указателя, 
следующим образом:

void function(std::unique_ptr<A>(new A()), std::unique_ptr<B>(new B())) { ... }

Предположим, что new A() выполняется успешно, но new B() выбрасывает исключение: вы ловите его, чтобы возобновить нормальное выполнение программы. К сожалению, стандарт C++ не 
требует, чтобы объект A был уничтожен, а его память высвобождена: память тихо утекает, и нет способа ее очистить. Обернув A и B в std::make_unique, вы будете уверены, что утечка не 
произойдет:

void function(std::make_unique<A>(), std::make_unique<B>()) { ... }

Дело в том, что std::make_unique<А> и std::make_unique<В> теперь являются временными объектами, а очистка временных объектов правильно указана в стандарте C++: их деструкторы будут 
вызваны и память освобождена. Поэтому, если есть возможность, всегда предпочитайте выделять объекты с помощью std::make_unique и std::make_shared.



______________________________________________________________________________________
Константные ссылки

В константыне ссылки (в отличии от не константных) можно инициализировать через rvalue. Они продливают время жизни этим объектам, до тех пор пока не закончиться время жизни 
самой ссылки, но работает это только внутри функций, когда мы объявляем локальные переменные. Если мы таким образом пытаемся продлить жизнь полю класса, то это не работает.

struct C {
	const int& r;
	
	C(int& y): r(5){} 	// UB
}

int main() {
	C c;
}



______________________________________________________________________________________
Указатели на члены (Pointers to members)

В C++ можно делать указатели на переменные и указатели на функции. Вопрос, а нельзя ли сделать указатель на поле или метод класса? Можно:

Указатели на поля:

Struct S {
	int x;
	double y;	
};

int main() {
	int S::* p = &S::x;	// Указатель на поле x в классе S
	S s;
	std::cout << s.*p; 	// Достать из объекта класса поле x
}

p - это просто число хранящее сдвиг от начала структуры. Имея объект, можно достать поле по этому указателю. Точка со звездой (.*) - это отдельный оператор.

Представим что у нас есть не объект, а указатель на него.

int main() {
	int S::* p = &S::x;	// Указатель на поле x в классе S
	S s;
	std::cout << s.*p; 	// Достать из объекта класса поле x

	S* ps = &s;
	std::cout << ps->*p;	// Достать поле через указатель на класс (->* тоже отдельный оператор) 
}

Зачем это нужно? Пример: Представим что у нас есть функция обхода графа, а в графе есть рёбра. Рёбра обладают многими разными свойствами, но в том числе у рёбер есть поле
начало и конец, потому что это ориентированные рёбра. Нам нужно сделать обход графа, но этот обход нужно сделать иногда в прямую сторону, а иногда обратно. Но мы не хотим 
функцию обхода ребра писать дважды. Для того чтобы функция независила от стороны движения, мы вместо того чтобы принимать просто указатель на перемнные поля и ссылки на них,
мы принимаем именно Указатели на члены,  и в зависимости от того, у нас обход назади или вперёд, мы в эту функцию передём либо начало и конец правильном порядке либо в 
обратном порядке.


Указатели на методы:

struct S {
	int x;
	void f(int z) {
		std::cout << x + z;
	}
};

int main() {
	S s{1};
	void (S::* pf)(int) = &S::f;	// Указатель на метод класса. void - возвращаемый тип, pf - имя переменной, int - параметр
	
	(s.*pf)(3);			// .* менее приоритетно чем (), поэтому .* нужно пиcать в скобках

	S* ps = &s;			// Указатель на объект класса	
	(ps->*pf)(4);			// Вызов метода с помощью указателя на объект класса
}

Зачем это нужно? Например Qt очень активно использует указатели на методы. 



______________________________________________________________________________________





















