Определение указателя:
Синтаксис указателя: тип_данных* название_указателя; 
int* p;
Такой указатель может хранить только адрес переменной типа int.
Пустой указатель: int* p{nullptr};

Получение адреса и оператор &:
С помощью операция & можно получить адрес некоторого объекта, например, адрес переменной. 
Затем этот адрес можно присвоить указателю:
int number {25};
int *pnumber {&number}; // указатель pnumber хранит адрес переменной number
cout << "number addr: " << pnumber << endl; //Адрес переменной number
cout << "pnumber addr: " << &pnumber << endl;//Адрес указателя pnumbe

Получение значения по адресу (*):
Но так как указатель хранит адрес, то мы можем по этому адресу получить хранящееся там значение, то есть значение 
переменной number. Для этого применяется операция разыменования * ("indirection operator" / "dereference operator"). 
Результатом этой операции всегда является объект, на который указывает указатель.
int number {25};
int *pnumber {&number};
cout << "Address = " << pnumber<< endl;//Получаем адрес number
cout << "Value = " << *pnumber << endl;//Получаем значение number

Значение, которое получено в результате операции разыменования, можно присвоить другой переменной:
int n1 {25};
int *pn1 {&n1}; // указатель pn1 хранит адрес переменной n1
int n2 { *pn1}; // n2 получает значение, которое хранится по адресу в pn1
cout << "n2 = " << n2 << endl;  // n2=25

И также используя указатель, мы можем менять значение по адресу, который хранится в указателе:
int x = 10;
int *px = &x;
*px = 45;
cout << "x = " << x << endl;     // 45

Адрес указателя
Указатель хранит адрес переменной, и по этому адресу мы можем получить значение этой переменной. Но кроме того, указатель, как и любая переменная, сам имеет адрес, по которому 
он располагается в памяти. Этот адрес можно получить также через операцию &:
int a {10};
int *pa {&a};
std::cout << "address of pointer=" << &pa << std::endl;        // адрес указателя
std::cout << "address stored in pointer=" << pa << std::endl;  // адрес, который хранится в указателе - адрес переменной a         
std::cout << "value on pointer=" << *pa << std::endl;          // значение по адресу в указателе - значение переменной a

int* const - константный указатель на nt
const int* - указатель на const int
const int* const - константный указатель на const int



______________________________________________________________________________________
Константы и указатели



Указатели НА константы

Указатели могут указывать как на переменные, так и на константы. Чтобы определить указатель на константу, он тоже должен объявляться с ключевым словом const:

const int a {10};
const int *pa {&a};
std::cout << "address=" << pa << "\tvalue=" << *pa << std::endl;

Здесь указатель pa указывает на константу a. Поэтому даже если мы захотим изменить значение по адресу, который хранится в указателе, мы не сможем это сделать, например так:

*pa = 34; // Ошибка

В этом случае мы просто получим ошибку во время компиляции.

Возможна также ситуация, когда указатель на константу на самом деле указывает на переменную:

int a {10};
const int *pa {&a};
std::cout <<"value=" << *pa << std::endl;     // value=10
a = 22;
std::cout <<"value=" << *pa << std::endl;     // value=22
//*pa = 34;     			      // так делать нельзя

В этом случае переменную отдельно мы сможем изменять, однако по прежнему изменить ее значение через указатель мы не сможем.

Через указатель на константу мы не можем изменять значение переменной/константы. Но мы можем присвоить указателю адрес любой другой переменной или константы:

const int a {10};
const int *pa {&a};     			// указатель указывает на константу a
const int b {45};
pa = &b;                			// указатель указывает на константу b
std::cout <<"*pa = " << *pa << std::endl;     	// *pa = 45
std::cout <<"a = " << a << std::endl;     	// a = 10 - константа a не изменяется



###########################

Константный указатель

От указателей на константы надо отличать константные указатели. Они не могут изменять адрес, который в них хранится, но могут изменять значение по этому адресу.

int a {10};
int *const pa {&a};
std::cout << "value=" << *pa << std::endl;      // value = 10
*pa = 22;                                       // меняем значение
std::cout << "value=" << *pa << std::endl;      // value = 22
   
int b {45};
// pa = &b;         так нельзя сделать



###########################
Константный указатель на константу

И объединение обоих предыдущих случаев - константный указатель на константу, который не позволяет менять ни хранимый в нем адрес, ни значение по этому адресу:

int a {10};
const int *const pa {&a};
 
//*pa = 22;  так сделать нельзя
 
int b {45};
// pa = &b;  так сделать нельзя 



###########################
Резюме:
const int a {10};

const int *pa {&a}; // Указатели НА константы. Могут указывать как на переменные, так и на константы. Нельзя изменять значение переменной/константы (*pa = 34). Можем присвоить
		    // 	   адрес любой другой переменной или константы (pa = &b).

int *const pb {&a}; // Константный указатель. Слово const переместилось вправо от int. Не могут изменять адрес, который в них хранится, но могут изменять значение по этому адресу.

const int *const pc {&a}; // Константный указатель на константу. const и слева и справа от int. Не позволяет менять ни хранимый в нем адрес, ни значение по этому адресу.



Когда-то где-то вычитал (у Страуструпа может, не помню) чтобы легче читать код и определятся с синтаксисом при написании (запомнить в общем), нужно читать конструкцию справа налево:

const int* — указатель(*) на целую(int) константу(const)
int *const — константный(const) указатель(*) на целое(int)

Мои наблюдения: (Короче, перед каким словом стоит const, то и const):

Читайте справа налево, начиная от имени указательной переменной.
const int и int const — эквивалентные способы обозначить int-константу

const int *pa {&a}; // const перед типом данных int, значит сами данные const, значит *pa это указатель на константу. (pa) это указатель(*) на на целую(int) константу(const)

int *const pb {&a}; // Звёздочка указателя находится перед const, а сам const перед именем указателя pb, значит сам указатель const, значит это Константный указатель. (pb) это константный(const) указатель(*) на целое(int).

const int *const pc {&a}; // const везде, значит это Константный указатель на константу. pc это константный(const) указатель(*) на целое(int) которое тоже константа(const)


##########################################

const слева от звёздочки и const спарва от звёздочки имеет разный смысл.

int const* 
const int* pc = p; - это тоже самое что и первый вариант. тут константой является int, а указатель нет

int* const cp = p; - а тут указатель является константым а int нет

Если const справа от * то указатель константа, если const слева от *, то то что под указателем константа.



______________________________________________________________________________________
Сложное объявление 

int* a[10]; - массив из 10 указателей на int. Сначала читаем то что с права, потом то что слева.
int(*b)[10]; - указатель на массив из 10 int. Читае то что в скобках, потом то что спарва, потом то что слева.

void (*pf)(int); - указатель на функцию, которая принимает int а возвращает void.

void (*pfa[10])(int); - массив из 10 указателей на функцию которая принимает int и возвращает void.

void (*(*pff[10])(int))(int); - массив из 10 указателей на функцию, которая принимает int, а возвращает другую функци, которая принимает int а возвращает void.
Как это читать:
Правило такое: иди вправо пока можешь, затем иди влево.
pff[10] - массив из 10 
*pff[10] - указателей (Справа скобка закрывается, поэтому там нечего читать. Поэтому читаем слева.)
(*pff[10])(int) - на функцию, которая принимает int (Вышли из скобочек и видим скобочки справа. Если есть круглые скобочки справа значит это фунция.)
*(*pff[10])(int) - и возвращает указатель на (читаем слева)
(*pff[10])(int))(int) - функцию, которая принимает int (Вышли из скобочек и видим скобочки справа. Если есть круглые скобочки справа значит это фунция.)
void (*(*pff[10])(int))(int) - и возвращает void. (читаем слева)


int& f(int); - просто функция, которая принимает int и возвращает ссылку на int

int (&f)(int); - ссылка на функцию, которая принимает int и возвращает ссылку на inf



______________________________________________________________________________________
Умные указатели

https://habr.com/ru/companies/piter/articles/706866/
Мне нравится рассматривать умные указатели как упаковки, в которых хранятся динамические данные. На самом деле это просто классы, которые оборачивают обычный указатель в свои недра и 
перегружают операторы -> и *. Благодаря этому трюку умный указатель имеет тот же синтаксис, что и обычный указатель. Когда умный указатель выходит из области видимости, срабатывает 
его деструктор и происходит очистка памяти. Эта техника называется Resource Acquisition Is Initialization (RAII): класс оборачивает динамический ресурс (файл, сокет, подключение к 
базе данных, выделенная память, ...), который должным образом удаляется/закрывается в своем деструкторе. Таким образом, вы гарантированно избежите утечки ресурсов.


Типы умных указателей в современном C++:

std::unique_ptr — умный указатель, владеющий динамически выделенным ресурсом;
std::shared_ptr — умный указатель, владеющий разделяемым динамически выделенным ресурсом. Несколько std::shared_ptr могут владеть одним и тем же ресурсом, и внутренний счетчик ведет 
	их учет;
std::weak_ptr — подобен std::shared_ptr, но не увеличивает счетчик.

Возможно, вы также слышали о std::auto_ptr. Это вещь из прошлого, теперь не рекомендуемая к использованию: забудьте о ней.


######################

Понимание std::unique_ptr: одиночный вариант

std::unique_ptr владеет объектом, на который он указывает, и никакие другие умные указатели не могут на него указывать. Когда std::unique_ptr выходит из области видимости, объект 
удаляется. Это полезно, когда вы работаете с временным, динамически выделенным ресурсом, который может быть уничтожен после выхода из области действия.


СОЗДАНИЕ

std::unique_ptr<Type> p(new Type); // Создание

Например:
std::unique_ptr<int>    p1(new int);
std::unique_ptr<int[]>  p2(new int[50]);
std::unique_ptr<Object> p3(new Object("Lamp"));

Также можно создать std::unique_ptrs с помощью специальной функции std::make_unique, вот так:
std::unique_ptr<Type> p = std::make_unique<Type>(...размер или параметры...);

Например:
std::unique_ptr<int>    p1 = std::make_unique<int>();
std::unique_ptr<int[]>  p2 = std::make_unique<int[]>(50);
std::unique_ptr<Object> p3 = std::make_unique<Object>("Lamp");

Если есть возможность, всегда старайтесь выделять объекты с помощью std::make_unique.


ПРИМЕНЕНИЕ

Главная особенность этого умного указателя — исчезать, когда он больше не используется.

void compute()
{
    std::unique_ptr<int[]> data = std::make_unique<int[]>(1024);
    /* выполнение некоторых значимых вычислений над вашими данными...*/
} // `data` выходит из области действия здесь: она автоматически уничтожается
int main()
{
    compute();
}

Умный указатель выходит из области видимости, когда функция compute() достигает конца тела. Вызывается деструктор указателя, и память очищается автоматически. Больше ни о чем 
волноваться не нужно.


ОДИН РЕСУРС, ОДИН std::unique_ptr

std::unique_ptr очень ревниво относится к динамическому объекту, который он хранит: невозможно иметь несколько ссылок на его динамические данные. Это сделано специально, и это важная 
особенность std::unique_ptr: на любой ресурс может указывать не более одного std::unique_ptr. Это предотвращает ошибочное многократное удаление указателя. Технически это происходит 
потому, что у std::unique_ptr нет конструктора копирования.

void compute(std::unique_ptr<int[]> p) { ... } 

int main()
{
    std::unique_ptr<int[]> ptr = std::make_unique<int[]>(1024);
    std::unique_ptr<int[]> ptr_copy = ptr; // ОШИБКА! Копирование запрещено
    compute(ptr);  // ОШИБКА! `ptr` передается копией, а копирование не разрешено
}


######################

Понимание std::shared_ptr: конвивиальный вариант

std::shared_ptr владеет объектом, на который он указывает, но, в отличие от std::unique_ptr, он допускает множественные ссылки. Специальный внутренний счетчик уменьшается каждый раз, 
когда std::shared_ptr, указывающий на тот же ресурс, выходит из области видимости. Эта техника называется подсчетом ссылок. Когда последняя из них будет уничтожена, счетчик станет 
равным нулю, и данные будут высвобождены. Умный указатель такого типа полезен, когда требуется обмениваться динамически распределенными данными, точно так же, как это делается с 
обычными указателями или ссылками.

В std::shared_ptr используется два основных счётчика: счётчик сильных ссылок (strong reference count) и счётчик слабых ссылок(weak reference count). 

Счётчик сильных ссылок увеличивается каждый раз, когда новый std::shared_ptr создаётся как копия другогоstd::shared_ptr или когда объект присваивается std::shared_ptr. Этот счётчик 
уменьшается, когда std::shared_ptr уничтожается или когда его значение присваивается другому объекту. Когда счётчик сильных ссылок достигает нуля, объект, на который указывает 
std::shared_ptr уничтожается.

Счётчик слабых ссылок используется вместе с указателем std::weak_ptr, который может ссылаться на объект, управляемый std::shared_ptr, но не увеличивая счётчик сильных ссылок. Слабые
ссылки не предотвращают удаления объекта, к которому они имеют доступ, т.к. не участвуют в владении объектом. Счётчик слабых ссылок увеличивается каждый раз, когда создаётся 
std::weak_ptr, указывающий на объект и уменьшается, когда такой std::weak_ptr уничтожается. Когда счётчик сильных ссылок достигает нуля и объект уничтожается, память, выделенная под
сам объект, освобождается, но "control block"(блок управления), содержащий счётчики, сохраняется до тех пор, пока счётчик слабых ссылок также не обнулится. 

СОЗДАНИЕ

std::shared_ptr<Type> p(new Type);

Например:
std::shared_ptr<int>    p1(new int);
std::shared_ptr<Object> p2(new Object("Lamp"));

Существует альтернативный способ создания std::shared_ptr, использующий специальную функциюstd::make_shared: 
std::shared_ptr<Type> p = std::make_shared<Type>(...parameters...);

Это должен быть наиболее предпочтительный способ построения такого рода умных указателей. При вызове этой функции происходит одно выделение памяти для данных и контролирующего блока умного указателя. 
В этом случае контролирующий блок и данные распологаются рядом (Однако это не 100% гаранития, что произойдёт только одно выделение памяти, но скорее всего). А при создании без этой функции (1ый вариант) 
произойдёт два выделения памяти.


ПРОБЛЕМЫ С МАССИВАМИ

До C++17 не было простого способа соорудить std::shared_ptr, хранящий массив. До C++17 этот умный указатель по умолчанию всегда вызывает delete (а не delete[]) на своем ресурсе: вы 
можете создать обходной путь, используя кастомное удаление. Один из многих конструкторов std::shared_ptr принимает в качестве второго параметра лямбду, в которой вы вручную удаляете 
принадлежащий ему объект. Например:

std::shared_ptr<int[]> p2(new int[16], [] (int* i) { 
  delete[] i; // Кастомное удаление
});

К сожалению, нет возможности сделать это при использовании std::make_shared.


ПРИМЕНЕНИЕ

Одна из главных особенностей std::shared_ptr — возможность отслеживать, сколько указателей ссылаются на один и тот же ресурс. Получить информацию о количестве ссылок можно с помощью 
метода use_count().

void compute()
{
  std::shared_ptr<int> ptr = std::make_shared<int>(100);
  // ptr.use_count() == 1
  std::shared_ptr<int> ptr_copy = ptr;   // Сделать копию: с shared_ptr возможно!
  // ptr.use_count() == 2
  // ptr_copy.use_count() == 2, в конце концов, это одни и те же базовые данные.
} // Здесь `ptr` и `ptr_copy` выходят из области действия. Больше никаких ссылок  
  // исходные данные (т.е. use_count() == 0), поэтому они автоматически убираются.
int main()
{
  compute();
}

Обратите внимание, как ptr и ptr_copy выходят из области видимости в конце функции, доводя счетчик ссылок до нуля. В этот момент деструктор последнего объекта обнаруживает, что 
ссылок больше нет, и запускает очистку памяти.


ОДИН РЕСУРСБ МНОГО std::shared_ptr. НЕ ЗАБЫВАЙТЕ О ЦИКЛИЧЕСКИХ ССЫЛКАХ!

Сила множественных ссылок может привести к неприятным сюрпризам. Скажем, я пишу игру, в которой у игрока есть другой игрок в качестве компаньона, например, так:

struct Player
{
  std::shared_ptr<Player> companion;
  ~Player() { std::cout << "~Player\n"; }
};

int main()
{
  std::shared_ptr<Player> jasmine = std::make_shared<Player>();
  std::shared_ptr<Player> albert  = std::make_shared<Player>();

  jasmine->companion = albert; // (1)
  albert->companion  = jasmine; // (2)
}

Логично, не так ли? К сожалению, я только что создал так называемую круговую ссылку. В начале моей программы я создаю два умных указателя jasmine и albert, которые хранят динамически 
создаваемые объекты: назовем эти динамические данные jasmine-data и albert-data, чтобы было понятнее. Затем в (1) я передаю jasmine указатель на albert-data, а в (2) albert хранит 
указатель на jasmine-data. Это все равно что дать каждому игроку компаньона. Когда jasmine выходит из области видимости в конце программы, ее деструктор не может очистить память: все 
еще есть один умный указатель, указывающий на jasmine-data, это albert->companion. Аналогично, когда albert выходит из области видимости в конце программы, его деструктор не может 
очистить память: ссылка на albert-data все еще живет через jasmine->companion. В этот момент программа просто завершается, не освободив память: утечка памяти во всем ее великолепии. 
Если вы запустите приведенный выше фрагмент, то заметите, что ~Player() никогда не будет вызван. Это не такая большая проблема, так как операционная система позаботится об очистке 
памяти за вас. Однако вам не стоит иметь такие круговые зависимости (т.е. утечки памяти) в середине вашей программы. К счастью, на помощь придет последний тип умного указателя.


######################

Понимание std::weak_ptr: поверхностный вариант

std::weak_ptr — это, по сути, std::shared_ptr, который не увеличивает счетчик ссылок. Он определяется как умный указатель, который содержит несобственную ссылку, или ослабленную 
ссылку, на объект, управляемый другим std::shared_ptr. Этот умный указатель полезен для решения некоторых раздражающих проблем, которые нельзя решить с помощью необработанных 
указателей.


СОЗДАНИЕ

Вы можете создать std::weak_ptr только из std::shared_ptr или другого std::weak_ptr. Например:
std::shared_ptr<int> p_shared = std::make_shared<int>(100);
std::weak_ptr<int>   p_weak1(p_shared);
std::weak_ptr<int>   p_weak2(p_weak1);

В приведенном выше примере p_weak1 и p_weak2 указывают на одни и те же динамические данные, принадлежащие p_shared, но счетчик ссылок не растет.


ПРИМЕНЕНИЕ

std::weak_ptr является своего рода инспектором для std::shared_ptr от которого он зависит. Вы должны сначала преобразовать его в std::shared_ptr с помощью метода lock() если вы 
действительно хотите работать с реальным объектом:

std::shared_ptr<int> p_shared = std::make_shared<int>(100);
std::weak_ptr<int>   p_weak(p_shared);
// ...
std::shared_ptr<int> p_shared_orig = p_weak.lock();
//

Конечно, p_shared_orig может быть нулевым в случае, если p_shared был удален в другом месте.


std::weak_ptr РЕШАЕТ ПРОБЛЕМЫ

С помощью std::weak_ptr очень легко решить проблему висящих указателей — тех, которые указывают на уже удаленные данные. Он предоставляет метод expired(), который проверяет, был ли 
объект, на который ссылается ссылка, уже удален. Если expired() == true, исходный объект был где-то удален, и вы можете действовать соответствующим образом. Это то, что вы не можете 
сделать с необработанными указателями.

Как я уже говорил, std::weak_ptr также используется для разрыва циклической ссылки. Давайте вернемся к примеру Player, приведенному выше, и изменим переменную-член с std::shared_ptr 
companion на std::weak_ptr companion. В данном случае мы использовали std::weak_ptr для устранения запутанного владения. Фактически имкющиеся динамически выделяемые данные остаются в 
основном теле, в то время как каждый Player теперь имеет слабую ссылку на них. Запустите код с этим изменением, и вы увидите, что деструктор вызывается дважды, правильно.


######################

Заключительные заметки и мысли об умных указателях


Мне нравятся умные указатели. Должен ли я навсегда избавиться от new/delete?

Иногда вы действительно хотите полагаться на двойников new/delete, например:
когда вам нужно кастомное удаление, как мы видели ранее, когда мы добавили поддержку массивов в std::shared_ptr;
когда вы пишете собственные контейнеры и хотите вручную управлять памятью;
с помощью так называемой конструкции in-place, более известной как placement new: новый способ создания объекта на уже выделенной памяти. Более подробная информация здесь.


Работают ли умные указатели медленнее, чем обычные?

Согласно различным источникам (здесь и здесь), производительность умных указателей должна быть близка к производительности необработанных указателей. Небольшое снижение скорости может
 присутствовать в std::shared_ptr из-за внутреннего подсчета ссылок. В целом, есть некоторые накладные расходы, но они не должны сделать код медленным, если только вы не будете 
постоянно создавать и уничтожать умные указатели.


Рациональное обоснование std::make_unique и std::make_shared

Этот альтернативный способ построения умных указателей дает два преимущества. Во-первых, он позволяет нам забыть о ключевом слове new. При работе с умными указателями мы хотим 
избавиться от гнусной комбинации new/delete, верно? Во-вторых, это делает ваш код защищенным от исключений. Рассмотрим вызов функции, принимающей на вход два умных указателя, 
следующим образом:

void function(std::unique_ptr<A>(new A()), std::unique_ptr<B>(new B())) { ... }

Предположим, что new A() выполняется успешно, но new B() выбрасывает исключение: вы ловите его, чтобы возобновить нормальное выполнение программы. К сожалению, стандарт C++ не 
требует, чтобы объект A был уничтожен, а его память высвобождена: память тихо утекает, и нет способа ее очистить. Обернув A и B в std::make_unique, вы будете уверены, что утечка не 
произойдет:

void function(std::make_unique<A>(), std::make_unique<B>()) { ... }

Дело в том, что std::make_unique<А> и std::make_unique<В> теперь являются временными объектами, а очистка временных объектов правильно указана в стандарте C++: их деструкторы будут 
вызваны и память освобождена. Поэтому, если есть возможность, всегда предпочитайте выделять объекты с помощью std::make_unique и std::make_shared.



______________________________________________________________________________________
Константные ссылки

В константыне ссылки (в отличии от не константных) можно инициализировать через rvalue. Они продливают время жизни этим объектам, до тех пор пока не закончиться время жизни 
самой ссылки, но работает это только внутри функций, когда мы объявляем локальные переменные. Если мы таким образом пытаемся продлить жизнь полю класса, то это не работает.

struct C {
	const int& r;
	
	C(int& y): r(5){} 	// UB
}

int main() {
	C c;
}



______________________________________________________________________________________
Указатели на члены (Pointers to members)

В C++ можно делать указатели на переменные и указатели на функции. Вопрос, а нельзя ли сделать указатель на поле или метод класса? Можно:

Указатели на поля:

Struct S {
	int x;
	double y;	
};

int main() {
	int S::* p = &S::x;	// Указатель на поле x в классе S
	S s;
	std::cout << s.*p; 	// Достать из объекта класса поле x
}

p - это просто число хранящее сдвиг от начала структуры. Имея объект, можно достать поле по этому указателю. Точка со звездой (.*) - это отдельный оператор.

Представим что у нас есть не объект, а указатель на него.

int main() {
	int S::* p = &S::x;	// Указатель на поле x в классе S
	S s;
	std::cout << s.*p; 	// Достать из объекта класса поле x

	S* ps = &s;
	std::cout << ps->*p;	// Достать поле через указатель на класс (->* тоже отдельный оператор) 
}

Зачем это нужно? Пример: Представим что у нас есть функция обхода графа, а в графе есть рёбра. Рёбра обладают многими разными свойствами, но в том числе у рёбер есть поле
начало и конец, потому что это ориентированные рёбра. Нам нужно сделать обход графа, но этот обход нужно сделать иногда в прямую сторону, а иногда обратно. Но мы не хотим 
функцию обхода ребра писать дважды. Для того чтобы функция независила от стороны движения, мы вместо того чтобы принимать просто указатель на перемнные поля и ссылки на них,
мы принимаем именно Указатели на члены,  и в зависимости от того, у нас обход назади или вперёд, мы в эту функцию передём либо начало и конец правильном порядке либо в 
обратном порядке.


Указатели на методы:

struct S {
	int x;
	void f(int z) {
		std::cout << x + z;
	}
};

int main() {
	S s{1};
	void (S::* pf)(int) = &S::f;	// Указатель на метод класса. void - возвращаемый тип, pf - имя переменной, int - параметр
	
	(s.*pf)(3);			// .* менее приоритетно чем (), поэтому .* нужно пиcать в скобках

	S* ps = &s;			// Указатель на объект класса	
	(ps->*pf)(4);			// Вызов метода с помощью указателя на объект класса
}

Зачем это нужно? Например Qt очень активно использует указатели на методы. 



______________________________________________________________________________________





















