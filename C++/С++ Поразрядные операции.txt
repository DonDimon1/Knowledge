Двоичное представление чисел:
Число 13 в двоичной системе = 1101.
13/2=6 остаток 1
6/2=3  остаток 0
3/2=1  остаток 1
1/2=0  остаток 1
Берём остатки и читаем их снизу вверх.1101(в 2ой) = 13(в 10ой).
Обратно: 1101 = 1(3ий бит) 1(2ой бит) 0(1-ый бит) 1(0ой бит).
1*2^3 + 1*2^2 + 0*2^1 + 1*2^0 = 1*8 + 1*4 + 0*2 + 1*1 = 13.

Представление отрицательных чисел
Для записи чисел со знаком в С++ применяется дополнительный код (two's complement), при котором старший разряд является знаковым. 
Если его значение равно 0, то число положительное.
Чтобы получить из положительного числа отрицательное, его нужно инвертировать и прибавить единицу:
3 = 0000 0011. Инвертируем биты: ~0000 0011 = 1111 1100. Прибавляем 1: 1111 1100 + 1 = 1111 1101 = -3(в 10ой).
Бинарная запись числа, которая предваряется символами 0b: unsigned int number{0b0000'1100};   // 12

Операции сдвига
Операции сдвига позволяют сдвинуть битовое представление числа на несколько разрядов вправо или влево.
unsigned int a = 2 << 2;          // 2(в 10ой) = 10(в 2ой) на два разрядов влево = 1000(в 2ой) = 8(в 10ой). Было 10 стало 1000
unsigned int b = 16 >> 3;         // 10000 на три разряда вправо = 10(в 2ой) = 2(в 10ой)
Сдвиг на один разряд влево фактически аналогично умножению на 2, тогда как сдвиг вправо на один раз эквивалентно делению на два.
Обобщим: Сдвиг влево на n аналогичен умножению числа на 2^n, а сдвиг вправо на n разрядов аналогичен делению на 2^n.

Поразрядные операции
&: поразрядная конъюнкция AND(операция И или поразрядное умножение). Возвращает 1, если оба из соответствующих разрядов обоих чисел равны 1.
int b = 6 & 2;// 110 & 010 = 10  = 2(в 10ой)
110
010
010
|: поразрядная дизъюнкция OR(операция ИЛИ или поразрядное сложение). Возвращает 1, если хотя бы один из соответствующих разрядов обоих чисел равен 1.
int a = 5 | 2;// 101 | 010 = 111  = 7(в 10ой)
101
010
111
^: поразрядное исключающее ИЛИ.XOR. Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1.
int c = 5 ^ 2;// 101 ^ 010 = 111 = 7(в 10ой)
101
010
111
~: поразрядное отрицание или инверсия.NOT.Инвертирует все разряды операнда. Если разряд равен 1, то он становится равен 0, 
а если он равен 0, то он получает значение 1.
int d = ~9;// -10

Практическое применение
int value1 {3};  // 0b0000'0011
int value2 {2};  // 0b0000'0010
int value3 {1};  // 0b0000'0001
int result {0b0000'0000};
// сохраняем в result значения из value1
result = result | value1; // 0b0000'0011
// сдвигаем разряды в result на 2 разряда влево
result = result << 2;   // 0b0000'1100
// сохраняем в result значения из value2
result = result | value2;  // 0b0000'1110
// сдвигаем разряды в result на 2 разряда влево
result = result << 2;   // 0b0011'1000
// сохраняем в result значения из value3
result = result | value3;  // 0b0011'1001
std::cout << result << std::endl;   // 57
//Мы сохранили в result 3 числа: value1 {3}, value2 {2} и int value3 {1}.

//Для восстановления данных прибегнем к обратному порядку:
// обратное получение данных
int result {0b0011'1001};
// обратное получение данных
int newValue3 = result & 0b000'0011;
// сдвигаем данные на 2 разряда вправо
result = result >> 2;
int newValue2 = result & 0b000'0011;
// сдвигаем данные на 2 разряда вправо
result = result >> 2;
int newValue1 = result & 0b000'0011;
std::cout << newValue1 << std::endl;   // 3
std::cout << newValue2 << std::endl;   // 2
std::cout << newValue3 << std::endl;   // 1



______________________________________________________________________________________
Составить WORD из двух BYTE

Итак, по сути, у меня есть массив байтов, где индекс 0 Buffer[0]=08 и индекс 1 Buffer[1]=06. Я хочу создать WORD из этих двух BYTE, где результат WORD был равен 0x0806.


Вы бы использовали побитовые операторы и сдвиг битов:

uint16_t result = ((uint16_t)Buffer[0] << 8) | Buffer[1];

Значение Buffer[0]сдвигается на 8 бит влево. Это дает вам 0x0800. Между предыдущим значением и значением выполняется побитовое ИЛИ Buffer[1]. Это устанавливает младшие 8 бит 
в Buffer[1] значение 0x0806.

Всем, кто может использовать этот код в будущем: важно убедиться, что все числа, участвующие в побитовых вычислениях, являются беззнаковыми. В контексте этого ответа Buffer
должен быть указатель на unsigned charили uint8_tкакой-либо другой беззнаковый тип. В противном случае Buffer[1]будет повышен до int, заполнив наиболее важные биты мусором.





