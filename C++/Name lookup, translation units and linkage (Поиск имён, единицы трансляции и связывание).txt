Name lookup, translation units and linkage (Поиск имён, единицы трансляции и связывание)

_____________________________________________
Translation units (Единицы трансляции)

Как мы знаем, процесс сборки состоит из 1) Препроцессинга, 2) компиляции, 3) ассемблирования, 4) линковка, но мы не рассматривали ситуацию когда у нас компилируется параллельно несколько файлов. Часто большие проекты состоят
из многих файлов, например у нас есть a.cpp и b.cpp, и допустим мы их компилируем отдельно, но в каждом из них есть свои #include, и после препроцессинга каждый из этих файлов превращается в какой-то огромный кусок текста, в котором
сначала раскрыты все #include, т.е. все объявления из всех этих #include выписаны (тупо скопированы) в этот файл. Например если у нас в a.cpp заинклюжен какой-нибудь хеддер .h:

#include <vector>
#include "header.h"
a.cpp

то это значит, что у нас в a.cpp в начале подставятся все объявления из заголовочного файла <vector>, который в свою очередь ещё подтянет кучу всяких инклудов и все эти объявления будут прописаны в a.cpp, и потом тоже будут все 
объявления или определения  (смотря что там написано) из "header.h". И в b.cpp тоже самое подтянется, и в итоге у нас в программе (программа это объединение всего того, что мы компилируем вместе) очень много раз может встретится
содержимое файлов <vector> и "header.h". Ну грубо говоря, сколько у нас .cpp инклудят всякие <vector> и "header.h", столько у нас раз и будет повторятся от туда всё то, что там написано. Есть конечно #pragma once, но это другое, если 
мы инклудим рекурсивно т.е. в пределах одного файла инклудим <vector>, который инклудит <iostream>, а ещё кроме этого, мы напрямую инклудим <iostream>, то тогда мы избежим повторного инклуда, но a.cpp и b.cpp инклудят
независимо разные вещи и тут уже #pragma once не решает. a.cpp и b.cpp называют единицами трансляции, и тогда у нас в разных единицах трансляции могут повторяться одни и теже объявления из хеддера. А стало быть, если у нас в этих
хеддерах написаны не только объявления, но и определения, то у нас будет проблема redefenitions (переопределения). Пока мы компилируем всего один файл т.е. только один .cpp и всё у нас такой проблемы не будет, но если мы
компилируем сразу много файлов, то у нас в программе (программа это объединение всего того, что мы компилируем, ровно в одном из файлов должна быть функция main(), которая является точкой входа в программу, а отдельные файлы
которые мы компилируем, например a.cpp и b.cpp называются единицы трансляции) т.е. у нас в программе разные единицы трансляции могут содержать разные определения разных функций, и в одном из едениц трансляции будет функция
main(). Компилятор по отдельности будет компилировать разные единицы трансляции, а когда он их скомпилирует и превратит в объектные файлы a.o и b.o (объектные файлы это по сути исполняемые файлы, только с заглушками вместо 
реальных вызовов функций), тогда начнётся процесс линковки, а линковка это как раз связывание объявлений с определениями. У нас где-то м.б. объявлена какая-то функция, а определена она в другом месте, и линковщик как раз все эти
заглушки превращает в реальные адреса. Линковщик берёт всё то что видит в этих файлах, все объявления и определения, всё это вместе называется символы (все вещи с которыми оперирует линковщик, там функции, переменные
называются symbols (символами)). И вот если у нас в хеддере есть какая нибудь структура:

struct A{};
A a;

и мы заинклудили этот хеддер и в a.cpp и в b.cpp, и когда мы потом попробуем скомпилировать весь проект целиком, мы получим ошибку линковщика про множественное определение A (multiple definition of). Строка A a; это нарушение правил ODR,
потому что в программе определение переменной 'a' встретилось дважды. ODR (One Definition Rule) означает, что каждая сущность в программе должна быть определена ровно один раз, а программа может состоять из множества файлов, и во всей 
программе каждая использованная переменная должна быть определена ровно один раз. Поскольку мы заинклудили хеддер и в 'a' и в 'b', получилось так что определение переменной 'a' встретилось два раза. 

А что если у нас в хеддере был бы какой-то класс? А вот на классы правило не распространяется, ODR для классов работает не так, как для переменных или для функций, в случае переменных и функций, мы можем только один раз определить
их во всей программе. А вот если у нас в программе класс определён несколько раз это не страшно, главное чтобы он был всего один раз определён в каждой единице трансляции, потому что классы мы как раз можем и нужно их определять
в хеддерах, но правило такое, что каждый класс должен быть определён всего один раз в пределах одной единицы трансляции, а в перделах всей программы он м.б. опеределён много раз, но при условии что все определения идентичны, так 
работает ODR для классов. Потому что когда мы будем инклудить <vector> в кучу файлов, у нас в каждом из этих файлов встречается определение класса std::vector, но поскольку это всё идентичные определения, это не ошибка.

Если мы в разных единицах трансляции определим класс с одинаковым объявлением но разным определением, например есть у нас две единицы трансляции, в каждой из которых объявлили структуру A, но по разному её определили. 
Это UB, причём компилятор не в состоянии это диагностировать, такое умеет только линковщик, и то не факт что он с этим справиться, поэтому это UB.


###################################
Зачем разделять на .hpp и .cpp?

Зачем вообще нужны хеддеры? Почему мы вообще разделяем объявление и опеределение? Почему вообще существет линковщик, почему просто не делать всё в одном файле, и например хеддер содержал бы всё вместе и объявление и 
определение и мы просто не инклудим сразу всё? Потому что это очень долго и ужасно неэффективно, потому что как раз за счёт того, что мы инклудим только объявления, а определения лежат где-то в другом месте, мы можем не 
перекомпилировать определения каждый раз, потому компиляция это долгий процесс и когда у нас большой проект, компиляция становится очень долгой, и за счёт того, что мы инклудим только объявления, у нас могут быть все 
определения скомпилированы один раз, и мы к ним только линкуемся и не перекомпилируем их. Это позволяет использовать такую вещь как библиотеки, например у нас есть STL, в ней куча определений и чтобы скомпилировать всю эту
библиотеку нужно очень много времени, и поэтому мы это никогда не делаем, она уже скомпилирована и просто лежит. В этой библиотеке у нас на компах лежат заголовочные файлы с объявлениями, а ещё лежат готовые скомпилированные 
бинарники формата .o с определениями, и когда мы компилируем свой файл, на этапе линковки линковщик вызывается на наш файл, который уже заранее знает где искать библиотечные функции и в каком объектном файле находится нужное
определение, т.е. в нём уже зашиты пути и поэтому линковщик справляется слинковать с уже скомпилированными определениями наших вызовов функций.


###################################
Поговорим про шаблоны

Всё становится интереснее когда появляются шаблоны. Когда у нас есть шаблонный класс или шаблонная функция, мы её в хеддере можем определить. Исходя из правила ODR, нужно определения функций в хеддере не писать, потому 
что, тогда бы за инклудив этот хеддер во многих единицах трансляции, мы бы получили множественное определение одной и той же функции, поэтому опреFделение функций мы пишим в файлах расширения .cpp, а потом линковщик
связывает эти определения с объявлениями и вызовами функций из других файлов .cpp. Однако для шаблонных функций определения пишутся в основном в хеддерах, почему так? Почему с шаблонными функциями нельзя делать точно также как и с 
обычными, почему нельзя у шаблонных функций объявления оставлять в хеддерах, а определение писать в .cpp? Потому что шаблонная функция это как раз не совсем функция, а шаблон для функций) Сама функция инстанцируется только когда мы 
её используем, и поэтому если мы выносим определение шаблона в .cpp, то когда .cpp компилируется, то он не знает какие типы будут использоваться. Т.е. этот .cpp непонятно как компилировать отдельно от его объявления. Чтобы его 
скомпилировать, требуется подставить конкретные типы, и для них сгенерировать определения. Поэтому шаблонные функции мы определяем в хеддерах, а вот когда мы уже их используем в .cpp, компилятор сам генерирует специализации. Существет
такое понятие: "Точка инстанцирования" - это место в коде, куда компилятор как бы неявно подставляет специализацию шаблона, сгенерированную под наш шаблон.

Но что если мы хотим в хеддере написать специализацию шаблона? Вот у нас есть общий шаблон, а мы хотим специализировать его для конкретных типов, и сделать это в хеддере. Тут будет проблема, потому что для специализаций уже
множественное определение опять будет приводи к той же самой ошибке. Если мы написали общую версию шаблона в хеддере, а потом в разных .cpp просто её используем, компилятор неявно инстанцирует и это не считается множественным 
определением, но если мы в хеддере сами ещё напишем явную специализацию к шаблону и определеим её, а потом заинклудим в несколько .cpp, то вот это уже будет считаться множественным определением, потому что это конкретная функций с
конкретными параметрами.

Такая же проблема с функциями, у которых возвращаемый тип это auto, мы не можем их объявить и оставить без определения, потому что компилятору тогда непонятно будет что такое auto.


###################################
extern

Допустим мы напишем в хеддере следующий код, что он будет значить?

struct A{};
extern A a;

Это значит что мы делаем объявление, но не определение. Для переменных слово extern означает что это не определение, а лишь объявление, а определение где-то в другом месте, и пусть компилятор (или ликовщик) его ищет. Допустим у нас 
будет отдельный .cpp, в котором будет написано A a = чему-то, и этот .cpp мы отдельно скомпилируем, тогда наличие этого extern A a; в хеддере не будет ошибкой линковщика, это как будто мы объявили функцию, а её определение находится в 
другом месте.



_____________________________________________
Понятие linkage

linkage это казалось бы линковка, но вообще linkage это такое понятие, которое применимо к именам. В C++ есть names (имена), этим именам соответствуют сущности, т.е. имя может обозначать какую-нибудь сущность (класс, функцию, 
переменную и т.д.). Так вот у имён во-первых есть Storage duration, а ещё есть linkage. Storage duration - это свойство объекта, которое описывает, когда тот попадает в память и когда её освобождает. В C++ существует четыре вида 
storage duration: 
1) автоматическое - Когда управление входит в область видимости объекта (также известную как scope), он размещается в автоматической памяти, зачастую реализованной в виде стека. Когда управление покидает эту область, вызывается 
деструктор и память освобождается.
2) статическое - связана с использованием спецификаторов static и extern. Объекты со статической storage duration создаются при запуске программы и удаляются при её завершении.
3) динамическое - неразрывно связана с использованием ключевых слов new и delete.
4) Storage duration потока - устанавливается спецификатором thread_local. Имеющие эту storage duration объекты создаются при старте потока и удаляются при его завершении.

У каждого имени есть такое свойство называемое linkage, вот что это такое? По-русски это называется связывание. В C++ есть три вида связывания: 1) отсутствие связывания, 2) internal (внутреннее) связывание, 3) external (внешнее)
связывание. 

Сначала поговрим про отсутствие связывания. У каких переменных, функций или классов нет связывания? Допустим у нас есть какое-то имя, которое лежит в каком-то скоупе, вопрос, может ли обращение к этому имени произойти из другого скоупа?
Если ответ может, тогда у этого имени есть linkage (связывание). Т.е. те имена, к котрым можно обратиться не из того скоупа в котором они были объявлены, у них есть связывание. И нет связывания у имён, к которым нельзя обратиться
из скопуа, кроме как из того, где они были объявлены. Например это локальные имена, объявленные в блок-скоупе. Если у нас есть какая-нибудь void f и в ней объявлены int x, static int y и локальный класс C:

void f() {
	int x;
	static int y;		//TODO: Точно ли здесь парвильно написано? Меня напригает static
	class C{};
}

то это всё имена у которых нет никакого связывания, потому что ниоткуда, кроме как изнутри это f обратиться к ним нельзя. А что вообще значит что нет связывания? Это значит что этих имён для линковщика вообще не существует, линковщик
про них ничего не знает. Но если мы внутри скоупа написали бы extern int x например, то вот у него уже будет связывние. Т.е. у имени x появлиось бы связывание, и будет тоже самое, как если бы мы x сделали глобальным. Компилятор понимает
что есть имя x, которое мы хотим чтобы было нам доступно в этом скоупе, но вообще-то это имя откуда-то из другого места, где оно определено в другом скоупе, но мы сделали его в нашем скоупе себе доступным. Ну т.е. допустим у нас был 
другой .cpp в котором глобально был определён int x = 5, а в нашем .cpp никакого глобального x не было, но мы локально написали extern int x, и можем использовать тот другой x.


###################################
external linkage

Это то, что как бы торчит наружу из нашей единицы трансляции. Что это? Например если бы мы просто глобально написали бы какое-то имя, то оно торчит наружу и имеет external linkage. Линковщик его видит как имя торчащее наружу. Тоже
самое если мы глобально объявили какую-нибудь структуру, класс или функцию. Если мы внутри namespace что нибудь объявили глобально, то оно тоже будет external linkage:

// Глобальный скоуп

int x;
struct S{};
void f();

Если у нас есть структура, а в ней есть статическое поле или метод, оно тоже торчит наружу.

struct A {
	static int c;
}


###################################
internal linkage
 
Это имена, которые как-бы доступны между скоупами, но только в одной единице трансляции. Мы можем сделать переменную или функцию глобальную или в namespace с internal linkage вместо external. Для этого нужно написать static. Если мы
напишем static для глобальной переменной или глобальной функции или для переменой или функции внутри namespace скоупе (не в class скоупе, а в namespace скоупе), то у неё будет internal linkage. Это значит что мы к ней обращаться
из других областей видимости можем, но только в пределах одной единицы трансляции. Для линковщика это значит, что символ будет приватным, т.е. символ который ликовщик линкует между разными функциями, но не между единицами трансляции.
Получается static для таких случаев означает иное, не тоже самое что для членов класса.

// Глобальный скоуп
static int x;
static void f();

А как сделать так, чтобы класс был с internal linkage? Чтобы был класс который доступен и виден только в одной единице трансляции и не торчит наружу? Здесь поможет анонимный namespace. Для функций или переменных чтобы сделать их 
internal linkage нужно написать static, а для классов нужно написать анонимный namespace (since C++11):

namespace {			// Анонимный namespace
	struct S{};		// Эта структура internal linkage
}

Т.е. если мы напишем так в .cpp то эта структура будет доступна только в этом .cpp, а если мы так напишем в хеддере, то эта структура будет доступна везде, где мы заинклудим этот хеддер. Написать анонимный namespace в хеддере не значит, 
что когда мы инклудим этот хеддер, мы не будем видить эту структуру, нет мы будем её видить. Т.о. мы можем в разных .cpp назвать структуру одинаково, но они будут разными сущностями для линковщика.

Можно заметить что ключевое слово static во всех трёх случаях имеет разное значение:

Без связывания		|	external linkage		|	internal linkage
			|					|	
void f() {		|	struct A {			|	// Глобальный скоуп
// Локальный скоуп	|		static int c;		|	
	int x;		|	}				|	static int x;
	static int y;	|					|	static void f();
	class C{};	|					|
}			|					|

static применённая к глобальной переменной означает, что она не имеет связывания, static применённая к полю класса означает, что оно имеет external linkage, static применённая к глобальной функции или переменной означает, что оно 
имеет internal linkage.


А что если мы внутри анонимного namespace мы напишем extern к чему нибудь? extern это как бы штука, которая говорит external linkage, но мы внутри анонимного namespace, кто победит? Победит анонимный namespace, потому что всё что
написано внутри анонимного namespace, даже если написано слово extern, всё ровно анонимный namespace спрячет от линкера.


###################################
Исключения

Однако есть и исключения. Например если объявить глобальную константу, то это не тоже самое что объявить глобальную переменную, у константы будет internal linkage, а не external linkage. И также если мы пишем константное статическое
поле класса, то оно тоже internal linkage. 

Для линковщика у external linkage бывают strong и weak. Мы с вами видели пример external weak linkage когда смотрели на переопределение оператора new, там был макрос _LIBCPP_WEAK, это как раз флаг для линковщика, который говорит сделай
пожалуйста weak. weak символ, это который если линковщик встречает второй раз, то он просто перезаписывает этот символ и забывает старое, т.е. линковщик берёт первое попавшиеся определение, он увидел наше оперделение и забил на другое,
а не сказал что у него конфликт из-за нескольких определений. Соответсвтенно strong выдаёт ошибку при конфилкте. strong и weak linkage это тремины линковщика, они к стандарту C++ не имеют отношения.


###################################
inline 

Ключевое слово inline утеряло своё исходное значение. Что такое inline? Его исходный смысл в том, чтобы компилятор попробовал встроить тело этой функции помеченное как inline прямо в ассемблер без вызова функции. Но сейчас данное слово
устарело, и сейчас не рекомендуется к использованию. Побочный эффект слова inline был в том, что если функция inline, то для неё должно быть разрешено нарушение ODR. Вот мы в хеддере написали функицю, и она inline, и мы её как бы 
несколько раз в разные места заинклудили, но она же inline, поэтому как бы не страшно, мы же её всё ровно встраиваем, т.е. слово inline изначально позволяло для inline функций делать исключение из ODR. Если функция inline то ничего
страшно, просто линкер забей, мы всё ровно пытаемся встроить определение этой функции. Типо если у нас inline функция, то она не должна дойти до линкера по задумке и линкер не должен знать про её существование, поэтому мы для неё 
прощаем нарушение ODR. Однако она не гарантированна не доходит до линкера, потому что компилятор иногда не может заинлайнить и она дойдёт до линкера, но линкер всё ровно должен это прощать потому что функция inline. 

Следствие: если у нас в хеддере нужно объявить что-то и определить чтобы линкер не ругался на множественное определение, нужно просто пометить как inline. И это по сути единственное применение inline, которое в C++ осталось актуальным.
Раньше inline по задумке задумывалось как способ встраивать функции, но сейчас компиляторы стали умнее, и побочный эффект этого слова стал его главным применением. 

Есть три главных применения слова inline: 
1) Когда мы объявляем специализацию шаблона в хеддере. Если мы в хеддере объявлем специализацию шиблона и определяем её, а потом инклудим этот хеддер в разные файлы, то у нас получается ошибка множественного определения. Но если мы
написали inline специализацию шаблона, то ошибка множественного определения исчезает. И именно так и нужно писать это правило код стайла, если мы определяем специализацию шаблона в хеддере, то нам нужно писать inline.
2) Для статических полей класса (Since C++17). Если мы объявлем структуру со статическим полем, то мы не можем определить это поле сразу:

struct A
	static int c;		// Так можно
	//static int c = 5;	// Так нельзя. "A::c": статический элемент элемент данных с инициализатором внутри класса должен иметь неизменяемый целочисленный константный тип или должен быть указан как "inline"
}

int A::c = 5;			// Определение лежит отдельно

 Статическую переменноую в классе мы можем только объявить, но чтобы нам определить переменную 'c', нужно вынести из класса и написать int A::c = 5, т.е. определение должно быть отдельно. Т.е. в хеддере должна быть объявлена эта 
переменная static int c, а в .cpp определена с помощью int A::c = 5. Почему так? Потому что если мы напишем в хеддере так: static int c = 5, то это уже не объявление а определение, а значит если бы мы этот хеддер заинклудили в несколько
.cpp, то это было бы множественное определение. Но если написать здесь inline:

struct A {
	inline static int c = 5;
}

то эта проблема исчезает и так становится можно писать. Т.о. мы обходим ODR и имеем возможность инклудить этот хеддер в несколько .cpp.

3) Когда мы в хеддере объявляем глобальную константу. У глобальных констант тип связывания это internal linkage, т.е. эта константа будет отдельно создана в каждом из единиц трансляции. Но если мы пишем inline, то у этой константы тип
связывания станет external weak linkage, и тогда эта константа будет создана всего один раз, а остальные просто её позаимствуют от туда.


###################################
constexpr функции

Что если у нас в хеддере есть constexpr функция, то как насчёт ODR для неё? Ответ: если у нас функция constexpr, то она автоматически inline. Т.е. если у нас переменная constexpr, то она автоматически ещё и const, а если у нас функция
constexpr, то она считается inline. Это нужно для того, чтобы у нас не было проблемы что мы из хеддера заинклудили constexpr функцию в несколько .cpp и у нас не было множественного оперделения.


###################################
Пример с ODR

Несмотря на то, что статические константы можно объявлять сразу в классе и потом использовать сразу, а не выносить их из класса и потом писать определение, но есть понятие просто использования сущности, а есть понятие ODR использования.
В стандарте есть понятие ODR использования (ODR-used) и это сложно объяснить что это значит. Это такое использование, которое требует определения, например взятие адреса. Если мы обращаемся к константе чтобы прочитать из неё значение, мы
её используем, но не ODR-используем, и поэтому для такого использования переменной нам можно и не требовать её определения.

struct S {
	static const int n = 5;		// declaration
};

int x = S::n + 1;			// n not ODR-used

int foo(const int* x) { return *x; }

// const int S::n;			// definition

int y = foo(&S::n) + 1;			// n ODR-used

int main() {}

В данном коде строка static const int n = 5 из-за ключевого слова static является объявлением, но не определением, хотя мы написали = 5, и из-за этого в этом коде мы получаем ошибку линковщика, потому что хоть мы и завели константу и 
даже написали чему равно, мы можем её только использовать, но не ODR-использовать, потому что ODR-использование требует наличие определения. В этом прикол констант, то что мы можем статическую константу объявить и определение нам 
почти никогда не потребуется, потому что обычное использование констант это не ODR-использование. А вот ODR-использование это например когда мы берём адрес от этой константы, тогда нам нужно определение, и если мы разкомментируем
определение const int S::n, то тогда код слинкуется. 

Формально то, что сейчас произошло, это не UB, программа была некорректна с более хитрой формулировкой, нежели UB или просто CE. Потому что компилятор не может задетектить это как CE, но это и не UB, это вот то самое IFNDR (ill-formed, 
no diagnostic required), это ситуация, когда стандарт говорит the program ill-formed, no diagnostic required, т.е. это ситуация, когда код не соответствует стандартам языка, но компилятор не в состоянии выдавать предупреждение или 
ошибку. По сути это означает, что это вероятно ошибка линкера. Если такую программу запустить, то это UB.

Неформально, объект ODR-используется если его значение прочитано (кроме случаев когда это компайл-тайм константа), или записано, или его адрес взят, или ссылка к нему привязана. Ссылка ODR-используется когда она использована, и тот на кого 
она ссылается не известен в компайл-тайме. Функция ODR-используется если сделан вызов этой функции или взят её адрес. Нам не всегда нужно знать определение функции чтобы упоминать эту функцию в своей программе. 


_____________________________________________
Явное инстанцирование шаблонов

Мы говорили о том, что шаблоны обычно определяются в хеддере. Однако есть некоторый синтаксис, который помогает явно инстанцировать шаблон:

template<typename T>
void f(T s) {
	std::cout << s << '\n';
}

template void f<double>(double);	// instantiates f<double>(double)
template void f<>(char);		// instantiates f<char>(char), template argument deduced
template void f(int);			// instantiates  f<int>, template argument deduced

Вот у нас есть шаблонная функция f от T и можно сказать template void f<double>(double), и это заставит компилятор сгенерировать версию f<double> прямо на этом месте. 

Что можно добиться с помощью этого? Можно скрыть определение шаблонных функций от читателя и в хеддере написать только объявление, а в .cpp написать определение, а в конце написать такие явные инстанцирования. Это приведёт к тому, что
компиляция .cpp скомпилирует нам реально версии этого шаблона от таких типов. А попытки вызова этого шаблона от других шаблонов приведёт к ошибке линкера, потому что определения для них нет. Т.о. мы можем одновременно унести 
определение шаблонных функций из хеддера в .cpp, а также ограничить набор типов для которых эти функции могут быть вызваны. Также это помогает уменьшить время компиляции, потому что обычно когда мы неявно инстанцируем шаблон, 
компилятор генерирует за нас это инстанцирование, и каждый раз компилирует его заново, а если мы укажем явное инстаницрование, то тогда мы один раз скомпилируем шаблоны для всех версий которых мы хотим, а для других запретим и всё. 

Также для некоторых шаблонос есть такой синтаксис extern template. Это продолжение этой идеи. Если мы так напишем, то это значит что мы здесь собираемся использовать некоторую версию шаблона от каких-то типов, но при этом мы хотим
чтобы компилятор не инстанцировал эту версию, а чтобы компилятор поверили нам что такая версия шаблона уже где-то инстаницрована с такими типами, и чтобы он не инстанцировал её заново, а просто потом линковищик нашёл бы версию
с нужными аргументами. Т.е. если у нас есть в одном .cpp наинстанцированные версии этого шаблона, то в другом .cpp, если мы знаем что первый .cpp точно будет в проекте, мы можем написать extern template с нужными параметрами и не делать
инстанцирование заново.

Ещё явное инстанцирование шаблона помогает проверить корректен ли этот шаблон с такими шаблонными аргументами. Поскольку шаблоны инстанцируются лениво, и многие CE могут быть не видны.