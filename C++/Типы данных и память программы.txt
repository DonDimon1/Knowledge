Память программы

В C++ можно использовать различные типы объектов, которые различаются по использованию памяти. Так, глобальные объекты создаются при запуске программы и освобождаются при ее завершении. Локальные 
автоматические объекты создаются в блоке кода и удаляются, когда этот блок кода завершает работу. Локальные статические объекты создаются перед их первым использованием и освобождаются при завершении 
программы.

Глобальные, а также статические локальные объекты помещаются в статической памяти, а локальные автоматические объекты размещаются в стеке. Объекты в статической памяти и стеке создаются и удаляются 
компилятором. Статическая память очищается при завершении программы, а объекты из стека существуют, пока выполняется блок, в котором они определены. Когда блок завершает выполнение, то память в стеке, 
отведенная для переменных блока, освобождается. Стоит отметить, что память, выделяемая для стека, имеет ограниченный фиксированный размер.

В дополнение к этим типам в C++ можно создавать динамические объекты. Продолжительность их жизни не зависит от того, где они созданы. Динамические объекты существуют, пока не будут удалены явным образом.
Динамические объекты размещаются в динамической памяти (free store). Это область памяти, не занятая операционной системой или другими загруженными в данный момент программами. Использование динамических 
объектов имеет ряд преимуществ. Во-первых, более эффективное использование памяти - выделяется имеенно столько места, сколько необходимо, а после использования сразу освобождается. Во-вторых, мы можем 
использовать гораздо больший объем памяти, который в ином случае был бы не доступен. Но это и накладывает ограничения: мы должны следить, чтобы все динамические объекты были удалены.

Оператор new выделяет место в динамической памяти для объекта и возвращает указатель на этот объект.
Оператор delete получает указатель на динамический объект и удаляет его из памяти.


______________________________________________________________________________________
Статическая типизация

В C++ статическая типизация означает, что тип данных переменной определяется во время компиляции перед выполнением программы. Это означает, что переменную можно использовать только с 
данными определенного типа, и компилятор гарантирует, что операции, выполняемые с переменной, совместимы с ее типом. Если есть несоответствие, компилятор скорректирует тип данных 
переменной, чтобы он соответствовал другому, если это возможно. Этот процесс известен как Type Conversion. Если компилятору не удастся выполнить преобразование типов, 
Invalid Type Conversionво время компиляции кода возникнет ошибка.

C++ — это статически типизированный язык, а это означает, что он использует статическую типизацию для определения типов данных и выполнения проверки типов во время компиляции. Это помогает обеспечить 
безопасность типов и предотвратить возникновение определенных типов ошибок во время выполнения программы.

Вот простой пример кода, демонстрирующий статическую типизацию на C++:

#include <iostream>

int main() {
    int num = 65;        // 'num' is statically typed as an integer
    double pi = 3.14159; // 'pi' is statically typed as a double
    char c = 'c';        // 'c' is statically typed as a char

    c = num;    // This asssigment would convert num's value to ASCII equivalent character
    num = pi; // This assignment would convert pi's value from double type to int type
    
    std::cout << "The value of num is: " << num << std::endl;
    std::cout << "The value of pi is: " << pi << std::endl;
    std::cout << "The value of c is: "<< c << std::endl;
    return 0;
}

В приведенном выше коде переменная num статически типизирована как int, pi статически типизирована как a double и c статически типизирована как char. Если вы попытаетесь pi присвоить 
значение num, значение 3.14159 будет преобразовано в целое число 3 и присвоено num. Аналогично, когда значение num присваивается c, компилятор преобразует это значение 65 в 
соответствующий код ASCII , то есть A.


______________________________________________________________________________________
Динамическая типизация в C++

C++ известен как статически типизированный язык, что означает, что типы данных его переменных определяются во время компиляции. Однако C++ также предоставляет концепции определенного 
уровня динамической типизации , что означает определение типов данных переменных во время выполнения.

Вот краткий обзор двух способов достижения динамической типизации в C++:

1) void* Указатели

Указатель void*— это универсальный указатель, который может указывать на объекты любого типа данных. Их можно использовать для хранения ссылки на объект любого типа без знания 
конкретного типа объекта.
Пример:

#include <iostream>

int main() {
    int x = 42;
    float y = 3.14f;
    std::string z = "Hello, world!";

    void* void_ptr;

    void_ptr = &x;
    std::cout << "int value: " << *(static_cast<int*>(void_ptr)) << std::endl;

    void_ptr = &y;
    std::cout << "float value: " << *(static_cast<float*>(void_ptr)) << std::endl;

    void_ptr = &z;
    std::cout << "string value: " << *(static_cast<std::string*>(void_ptr)) << std::endl;

    return 0;
}

2) std::any(С++17)
В C++17 появился std::anyкласс, который представляет собой обобщенный типобезопасный контейнер для отдельных значений любого типа.

Пример:

#include <iostream>
#include <any>

int main() {
    std::any any_value;

    any_value = 42;
    std::cout << "int value: " << std::any_cast<int>(any_value) << std::endl;

    any_value = 3.14;
    std::cout << "double value: " << std::any_cast<double>(any_value) << std::endl;

    any_value = std::string("Hello, world!");
    std::cout << "string value: " << std::any_cast<std::string>(any_value) << std::endl;

    return 0;
}
Имейте в виду, что оба void* указателя и std::any влияют на производительность из-за дополнительной проверки типов и приведения типов, которые происходят во время выполнения. Их 
следует использовать осторожно и только в случае крайней необходимости.


______________________________________________________________________________________
Идентификация типа во время выполнения (RTTI)

Идентификация типа во время выполнения (RTTI) — это функция C++, которая позволяет получать информацию о типе объекта во время выполнения программы. Это может быть полезно при 
использовании динамической типизации, когда тип объекта может меняться во время выполнения.

В C++ существует два основных механизма RTTI:

1) typeid оператор

typeid— оператор, возвращающий ссылку на объект типа std::type_info, содержащую информацию о типе объекта. Для использования заголовочный файл <typeinfo> должен быть включен typeid.

Вот пример:

#include <iostream>
#include <typeinfo>

class Base { virtual void dummy() {} };
class Derived : public Base { /* ... */ };

int main() {
    Base* base_ptr = new Derived;

    // Using typeid to get the type of the object
    std::cout << "Type: " << typeid(*base_ptr).name() << '\n';

    delete base_ptr;
    return 0;
}


2) оператор динамического_приведения

dynamic_cast— это оператор приведения типов, который выполняет проверку типа во время выполнения и безопасно понижает базовый указатель или ссылку до производного указателя или ссылки.
Он возвращает значение null или выдает исключение bad_cast (если приведение ссылается) в случае сбоя приведения.

Вот пример:

#include <iostream>

class Base { virtual void dummy() {} };
class Derived1 : public Base { /* ... */ };
class Derived2 : public Base { /* ... */ };

int main() {
    Base* base_ptr = new Derived1;

    // Using dynamic_cast to safely downcast the pointer
    Derived1* derived1_ptr = dynamic_cast<Derived1*>(base_ptr);
    if (derived1_ptr) {
        std::cout << "Downcast to Derived1 successful\n";
    }
    else {
        std::cout << "Downcast to Derived1 failed\n";
    }

    Derived2* derived2_ptr = dynamic_cast<Derived2*>(base_ptr);
    if (derived2_ptr) {
        std::cout << "Downcast to Derived2 successful\n";
    }
    else {
        std::cout << "Downcast to Derived2 failed\n";
    }

    delete base_ptr;
    return 0;
}

Обратите внимание, что использование RTTI может привести к некоторым издержкам производительности, поскольку требует хранения и обработки дополнительной информации, сгенерированной 
компилятором, во время выполнения.

______________________________________________________________________________________
Приведение типов

Приведение типов — это процесс преобразования значения из одного типа данных в другой. В C++ существует четыре различных метода приведения типов:

1) Приведение в стиле C : это синтаксис, унаследованный от C, и он выполняется путем простого помещения целевого типа данных в круглые скобки перед приводимым значением. Пример:

int a = 10;
float b = (float)a;


2) static_cast: это наиболее часто используемый метод приведения типов в C++. Он выполняется во время компиляции, и его следует использовать, когда у вас есть явное преобразование 
между типами данных. Этот тип приведения выполняет проверку во время компиляции и выдает ошибку, если допустимое преобразование между заданными типами невозможно. static_cast обычно 
безопаснее, чем приведение в стиле C, поскольку оно не выполняет небезопасную реинтерпретацию данных и позволяет лучше проверять типы.
Пример:

int a = 10;
float b = static_cast<float>(a);


3) dynamic_cast: этот метод специально используется для безопасного преобразования указателей и ссылок между базовыми и производными классами в иерархии классов. Это тип оператора 
приведения в C++, который используется специально для полиморфизма. 
Пример:

class Base {};
class Derived : public Base {};

Base* base_ptr = new Derived();
Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr);


4) reinterpret_cast: это приведение изменяет тип указателя, ссылки или целочисленного значения. Его также называют побитовым приведением, поскольку оно меняет способ интерпретации 
компилятором базовых битов. это тип приведения в C++, который позволяет изменять тип указателя или целого числа без изменения представления данных. Обычно он используется, когда 
требуемое преобразование слишком низкоуровневое или не поддерживается другими методами приведения, такими как static_cast. Используйте его reinterpret_castтолько в том случае, если у 
вас есть глубокое понимание того, что вы делаете, поскольку это не гарантирует, что полученное значение будет иметь смысл. 
Пример:

int* a = new int(42);
long b = reinterpret_cast<long>(a);


5) const_cast: этот метод приведения позволяет удалять или добавлять константность переменной. Другими словами, он позволяет вам модифицировать объект const или volatile или изменить
указатель или ссылку на тип const или volatile. Это полезно в определенных сценариях, когда вам нужно передать constпеременную в качестве аргумента или когда параметр функции требует 
неконстантного типа, но вы хотите, чтобы переменная оставалась постоянной во всем коде.Обычно это не рекомендуется, но может быть полезно в определенных ситуациях, когда вы не можете 
контролировать константность переменной.
Пример:

const int a = 10;
int* ptr = const_cast<int*>(&a);  // const_cast from const int* to int*
*ptr = 20;  // Not recommended, use with caution



______________________________________________________________________________________
Память программы

В ОЗУ компьютера выделяется место в памяти для нашей программы. Это место памяти делится на 3 области:
1) data - static memory (статическая память). В ней храняться глобальные переменные, переменные объявленные в namespace(не локальные), локальные статические переменные, 
строки литералы, таблицы виртуальных функций и некоторая другая информация, не являющеяся кодом, которая существует в течении всего времени жизни программы.
2) text - непосредственно код нашей программы в двоичном виде (машинный код для процессора).
3) stack - стек (автоматическая память). Здесь хранятся локальные переменные.

Статическая память и стек это разная память. Есть статическая память, есть динамическая и есть стек.

		ОЗУ
	/-----------------------------------------------\
	|						|
	|	Область памяти для нашей программы	|
	|      /---------------------\			|
	|      | data | text | stack |			|
	|      \---------------------/			|
	|						|
	\-----------------------------------------------/

int main() {
	int x = 5; // Переменная будет храниться на стеке
}

Стек работает как структура данных стек. У нас в рантайме процессором поддерживается стекпойнтер изначально указывающий на адрес начало стека. Когда мы вводим новую локальную 
переменную, делается пуш на этот стек. Например мы создали переменную типа int. От начала стека стекпойнтер смещается на 4 байта. Теперь в области памяти между началом и 
адресом стекпойнтера храниться данный int. При создании ещё одного int стекпойнтер смещается ещё на 4 байта. Если мы выходим из области видимости второго int, стекпойнтер 
смещается обратно на 4 байта, и считается что память была очищена.


При вызове функции мы тоже занимаем стек:

void f(int y) {
	std::cout << y + 1 << std::endl;
}

int main() {
	int x = 5;
	f(x);
}

Это примерное понимание работы вызова функции:
В данном случае на стек пушиться переменная x типа int, т.е. стекпойнтер смешается от начала на 4 байта. Далее вызывется функция f. Вызов f означает что нам нужно на стек
теперь положить ещё и переменную y, т.к. y это новая локальная переменная для новой области видимости. Указатель сдвигается ещё на 4 байта. Но это не всё. Когда мы 
вызываем функцию, недостаточно просто положить все локальные переменные на стек, ножно ещё положить адрес возврата. Когда процессор исполняет код и видит вызов функции, 
он понимает на какой адрес ему прыгнуть, чтобы исполнить код этой функции, потому что когда компилятор компилировал код, он вызов этой функции превратил в прыжок на конкретный
адрес, и вызывая функцию процессор знает адрес на которой находиться реализация этой функции (она находиться в области памяти text). Но проблема в том, что когда выходим
назад из функции, негде не записано куда выходить, ведь функцию могли вызывать из разных мест и процессору нужно знать адрес кода для выполнения следующей инструкции. Этот
адресс возврата запоминается на стеке в виде указателя, т.е. этот указатель говорит куда прыгать обратно для дальнейшего выполнения программы. Скорее всего этот указатель
пушиться на стек ещё до переменной y. 

Размер стека фиксирован и равен по умолчанию 8 Мб(на разных системах по разному). У любой программы есть стек. Размер data определяется тем, сколько у нас есть глобальных 
переменных и прочей статической информации. Размер text определяется размером бинарного кода программы.

Стек можно переполнить (stack over flow), если сделать локальных переменных или вызовов функций больше чем 8 Мб. Например бесконечная рекурсия. При переполнении стека 
ОС убивает программу, но происходит это не сразу. Когда мы превзошли разрешённые адреса, начинается UB. Если память свободна то программа продолжить работу, пока не дойдёт 
до занятой памяти и тогда программа умрьёт.


8 Мб бывает недостаточно, и для того чтобы хранить большие данные нужна динамическая память. Динамическая память выделяется в рантайме.

int* p = new int; 

В этот мемент наша программа попросит у ОС дополнительную память размером sizeof(int) (в данном случае) байт вдобавок. Когда ОС выдаст память, нам вернётся указатель на первый
байт из тех, что нам выдали. Для освобождения память:

delete p;

После этого память на которую указывает p больше не наша и за обращение к ней нас могут убить. Поэтому указатель нужно занулить nullptr.

!!!! НЕЛЬЗЯ писать delete p, pp; (В этом случае удалиться только p.) delete (p, pp); тоже нельзя. (В этом случае удалиться только pp.)



Статическа переменна:

void f() {
	static int x = 0;    		// локальная статическая переменная
	std::cout << ++x << "\n";
	f();
}

int main() {
 	f();
}

Статик значит что я прошу чтобы переменная x лежала в области памяти не стековой, а в статической (область data), т.е. чтобы за ней был закреплён один и тот же адресс на всём
протяжении жизни программы. В функции void когда мы в первый раз зайдём в эту функцию переменная x будет проинициализированна 0. Во всех остальных вызовах функции ничего уже
не будет с этой переменной, она уже создана и проинициализированна, а апмять под неё уже была выделена зарание. Это называется локальная статическая переменная. Статическая 
переменная может бытьлюбого размера как и динамически созданная(не зависит от 8Мб т.к. она не на стеке).

int Arr[10'000'000]; // Стек овер флоу
static int Arr2[10'000'000]; // Всё норм поскольку переменная находится в области data и размер выделенной памяти регулируется при компиляции.



______________________________________________________________________________________
Размер структуры(класса). Сколько в памяти занимает класс?

Сколько в памяти занимает произвольная структура?

Зависит от платформы. Допустим у нас x32 и память у нас автоматически выравнивается и она будет кратна 32 битам. Например у нас не будет размер какой то структуры 11 байтам. 
Сайзоф пустого объекта считается 1.




Очень упрощённо размер класса (структуры) это размер всех её полей, с точностью до выравнивания.

Если бы просто в структуре было одно поле типа int, то её размер был бы как и у этого поля int, т.е. 4 байта.
struct S {		// Размер 4 байта		
	int x = 1;					Байты в памяти: 1234
};							Данные:		int|	(| для того чтобы показать что занимаем 4 байта)

Если бы было только одно поле типа double, то и размер структуры был бы размером с типа double, т.е. 8 байт.

struct S {		// Размер 8 байта
	double d = 3.14;				Байты в памяти: 12345678
};							Данные:		double||

Если бы было 2 int то размер был бы 8 байт.
struct S {		// Размер 8 байта		Байты в памяти: 12345678
	int x = 1;					Данные: 	int|int|
	int y = 2;
};

Но если мы сделаем структуру с одним полем int (4 байта) и с одним double (8 байт), то размер будет не 12, а 16 байт.
struct S {		// Но рамер структуры 16 байт, а не 12.
	int x = 1;	// 4 байта 			Байты в памяти: 1234567812345678
	double d = 3.14;// 8 байт			Данные:		int|    double||
};

S s1;
S s2;

S arr[2] = {s1,s2};


В памяти:	
		структура s1    структура s2
Байты в памяти: 12345678123456781234567812345678
Данные:		intt    doubleeeintt    doubleee


Дело в том, что 8ми байтные числа кладутся по адресам, кратным 8. Так же и сама структура(класс) кладётся по адресам, кратным 8ми, для того, чтобы между несколькими 
экземплярами класса не было неиспользованных промежутков(экземпляры шли в притык), например в массиве структур. Однако если бы была структура из 3ёх int, то в этом нет 
необходимости, поскольку int нужно класть по адресам кратным лишь 4, и такие структуры можно класть в массив без выравнивания.


struct S {		// Размер 12 байт		Байты в памяти: 123456781234
	int x = 1;					Данные: 	int|int|int|
	int y = 2;
	int z = 3;
}

S s1;
S s2;

S arr[2] = {s1,s2};


В памяти:	
		структура s1|структура s2    
Байты в памяти: 123456781234567812345678
Данные:		int|int|int|int|int|int|


Вложенные классы:
Обычный класс:
struct S {		// Рамер структуры 24 байт
	int x = 1;	// 4 байта 			Байты в памяти: 123456781234567812345678
	double d = 3.14;// 8 байт			Данные:		int|    double||c
	char c; 	// 1 байт							это char
};

Класс с вложенным классом:

struct S {			// Размер S равен 16 байт, поскольку в структуре S Мы не объявляли новых полей.
	int x = 1;		// 4 байта 
	double d = 3.14;	// 8 байт

	struct SS {
		char c;		// 1 байт
	};
};





______________________________________________________
Операторы привидения типа

Если у вас есть несколько симантических разных типов, хотя  физически они представляются одинаково, то строгая типизация  даёт возможность избежать того, что можно перепутать
порядок где нибудь. Coordinate(double x, double y). Долгота - 55.00 Широта - 37.00 - Москва, Долгота - 37.00 Широта - 55.00 - Иран.

Для таких целей я могу создать отдельный класс для долготы и широты.

struct Latitude {
	double value;

	explicit Latitude(double value) : value(value){} 	// Запрет на неявный вызов конструктора

	explicit operator double() const {			// Оператор приведения типа. Мы разрешили кастовать из Latitude в double. Возвращаемый тип писать не нужно.
		return value;					
	}
};

struct Longitude {
	double value;

	explicit Longitude(double value) : value(value){}
};

Но я хочу чтобы нельзя было, чтобы нельзя неявно создать из double ничего из этого. И я хочу чтобы к double нельзя неявно было прикастовать ничего из этого. (Имеется в виду
оба класса). По умолчанию компилятор будет разрешать неявное преобразование.

explicit не даст создать объект если мы положем тип double а не Latitude или Longitude соответственно.


Обратно: Если мы хотим из Latitude или Longitude получать обратно дабл нам нужно переопределить тип. Чтобы избежать неявного каста мы должны написать explicit. Явный каст это
static_cast. 

Кодстайл - оператор приведения типа лучше делать explicit. Приведение типа даже к bool нужно делать explicit. 














