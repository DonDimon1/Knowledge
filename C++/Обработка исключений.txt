Обработка исключений в C++ — это механизм обработки ошибок, аномалий или неожиданных событий, которые могут возникнуть во время выполнения программы. Это позволяет программе 
продолжать работу или корректно завершать работу при возникновении ошибок, а не внезапно завершать работу.

C++ предоставляет набор ключевых слов и конструкций для реализации обработки исключений:

1) try: определяет блок кода, который следует отслеживать на предмет исключений.
2) catch: указывает тип перехватываемого исключения и блок кода, который должен выполняться при возникновении этого исключения.
3) throw: выдает исключение, которое будет перехвачено и обработано соответствующим блоком catch.
4) noexcept: указывает функцию, которая не генерирует исключения и не завершает программу, если исключение возникает в ее области действия.

Вот пример, демонстрирующий базовое использование обработки исключений:

#include <iostream>

int divide(int a, int b) {
    if (b == 0) {
        throw "Division by zero!"; // Деление на 0
    }
    return a / b;
}

int main() {
    int num1, num2;

    std::cout << "Enter two numbers for division: ";
    std::cin >> num1 >> num2;

    try {
        int result = divide(num1, num2);
        std::cout << "The result is: " << result << std::endl;
    } catch (const char* msg) {
        std::cerr << "Error: " << msg << std::endl;
    }

    return 0;
}

В этом примере мы определяем функцию divide, которая выдает исключение, если b значение равно нулю. В main функции мы используем try блок для вызова divide и вывода результата. 
Если генерируется исключение, оно перехватывается внутри catch блока, который выводит сообщение об ошибке. Таким образом, мы можем корректно обработать ошибку, не допуская сбоя 
программы при попытке деления на ноль. Оператор throw генерирует исключение. Через оператор throw можно передать информацию об ошибке.

При выполнении строки int result = divide(num1, num2); будет сгенерировано исключение, поэтому последующие инструкции из блока try выполняться не будут, а управление перейдет в блок 
catch, в котором на консоль просто выводится сообщение об ошибке. После выполнения блока catch программа аварийно не завершится, а продолжит свою работу, выполняя операторы после 
блока catch.

Синтаксис:

try
{
    инструкции, которые могут вызвать исключение
}
catch(объявление_исключения)
{
    обработка исключения
}

Многоточие в скобках после оператора catch(...) позволяет обработать любое исключение.

Если же исключение не обработано, то вызывается функция std::terminate() (из модуля <exception> стандартной библиотеки C++), которая, в свою очередь, по умолчанию вызывает другую 
функцию - std::abort() (из <cstdlib>), которая собственно и завершает программу.

################
Ключевое слово noexcept, которое при использовании в заголовке функции указывает, что эта функция никогда не будет генерировать исключения. Например:

void print(int argument) noexcept;

Здесь указываем, что функция print() никогда не вызовет исключение. Таким образом, встретив функцию с подобным ключевым словом, можно ожидать, что она не вызовет исключения. 
И соответственно нет необходимости помещать ее вызов в конструкцию try-catch.

______________________________________________________________________________________
Создание объекта исключения

При обработке исключения стоит помнить, что при передаче объекта оператору throw блок catch получает копию этого объекта. И эта копия существует только в пределах блока catch.
Для значений примитивных типов, например, int, копирование значения может не влиять на производительность программы. Однако при передаче объектов классов издержки могут выше. 
Поэтому в этом случае объекты обычно передаются по ссылке, например:

#include <iostream>
 
double divide(int a, int b)
{
    if (b)
        return a / b;
    throw std::string{"Division by zero!"};
}
  
int main()
{
    int x{500};
    int y{};
     
    try
    {
        double z {divide(x, y)};
        std::cout << z << std::endl;
    }
    catch (const std::string& error_message)    // строка передается по ссылке
    {
        std::cout << error_message << std::endl;
    }
    std::cout << "The End..." << std::endl;
}

______________________________________________________________________________________
Обработка и генерация разных типов исключений

Мы можем генерировать и обрабатывать несколько разных исключительных ситуаций. Допустим, нам надо, чтобы при делении делитель (второе число) был не больше, чем делимое (первое число):

#include <iostream>
 
double divide(int a, int b)
{
    if(!b)  // если b == 0
    {
        throw 0;
    }
    if(b > a) 
    {
        throw "The second number is greater than the first one";
    }
    return a / b;
}
 
void test(int a, int b)
{
    try
    {
        double result {divide(a, b)};
        std::cout << result << std::endl;
    }
    catch (int code) 						// Обработка исключения типа int
    {
        std::cout << "Error code: " << code << std::endl;
    }
    catch (const char* error_message)				// Обработка исключения типа const char*
    {
        std::cout << error_message << std::endl;
    }
}
  
int main()
{
    test(100, 20);      // 5
    test(100, 0);       // Error code: 0
    test(100, 1000);    // The second number is greater than the first one
}


########################
Может быть ситуация, когда генерируется исключение внутри конструкции try-catch, и даже есть блок catch для обработки исключений, однако он обрабатывает другие типы исключений:

void test(int a, int b)
{
    try
    {
        double result {divide(a, b)};
        std::cout << result << std::endl;
    }
    catch (const char* error_message)
    {
        std::cout << error_message << std::endl;
    }
}

Здесь нет блока catch для обработки исключения типа int. Поэтому при генерации исключения: throw 0; Программа не найдет нужный блок catch для обработки исключения, и программа 
аварийно завершит свое выполнение.


______________________________________________________________________________________
try-catch и деструкторы

Стоит отметить, что, если в блоке try создаются некоторые объекты, то при возникновении исключения у них вызываются деструкторы. Например:

#include <iostream>
 
class Person
{
public:
    Person(std::string name) :name{ name }
    {
        std::cout << "Person " << name << " created" << std::endl;
    }
    ~Person()
    {
        std::cout << "Person " << name << " deleted" << std::endl;
    }
    void print()
    {
        throw "Print Error";
    }
private:
    std::string name;
};
 
int main()
{
    try
    {
        Person tom{ "Tom" };
        tom.print();    // Здесь генерируется ошибка
    }
    catch (const char* error)
    {
        std::cerr << error << std::endl;
    }
}

В классе Person определяет деструктор, который выводит сообщение на консоль. В функции print просто генерируем исключение. В функции main в блоке try создаем один объект Person и 
вызываем у него функцию print, что естественно приведет к генерарции исключения и переходу управления программы в блок catch. И если мы посмотрим на консольный вывод то мы увидим, 
что прежде чем начнется обработка исключения в блоке catch, будет вызван деструктор объекта Person.

Вывод в консоль:

Person Tom created
Person Tom deleted
Print Error

______________________________________________________________________________________
Немного теории

Если в конструкторе класс выбрасывается исключение, то деструктор для этого объекта не будет вызван, т.к. объект считается не полностью сконструированным, и следовательно 
деструкция считается потенциально опасной. Хоть деструктор для объекта, из которого было выброшено исключение, не вызывается, но все уже созданные и полностью инициализированные
члены объекта будут корректно уничтожены. Т.е. если в вашем объекте есть члены, являющиеся объектами других классов, и для них конструкторы были успешно вызваны до момента выброса 
исключения, то их деструкторы будут вызваны при обработке исключения. Это одна из причин почему важно использовать идеому RAII при работе с ресурсами в C++. Для управлением
ресурсами стоит использовать объекты, которые автоматически освобождают ресурсы при уничтожении (умные указатели).

Бросок исключения из деструктора считается очень плохой практикой, поскольку может нарушить нормальный процесс освобождения ресурсов.  По умолчанию с C++11 деструкторы должны быть 
noexcept. Если исключение бросается из деструктора во время обработки другого исключения (например при раскрутке стека после броска первого исключения), то программа автоматически
вызовет std::terminate(), потому что C++ не позволяет иметь более одного активного исключения одновременно.

  
______________________________________________________________________________________
Вложенные try-catch

Одни конструкции try-catch могут содержать другие. Если исключение возникает во вложенной конструкции try-catch, то программа сначала ищет во вложенной конструкции блок catch, который
обрабатывает нужный тип исключения. Если во вложенной конструкции try-catch такой блок catch не найден, то программа начинает искать аналогичный блок catch во внешей конструкии 
try-catch. Посмотрим на примере.

#include <iostream>
 
double divide(int a, int b)
{
    if(!b)  // если b == 0
    {
        throw "Division by zero";
    }
    return a / b;
}
int main()
{
    try
    {
        try
        {
            int a{10}, b{};
            double result {divide(a, b)};
            std::cout << result << std::endl;
        }
        catch (const char* error)
        {
            std::cout << "Inner execption: " << error << std::endl;
        }
        std::cout << "Inner try-catch finished" << std::endl;
    }
    catch (const char* error)
    {
        std::cout << "External execption: " << error << std::endl;
    }
    std::cout << "External try-catch finished" << std::endl;
}

Здесь функция divide() вызывается во внутренней конструкции try-catch. Оператор throw генерирует исключение, объект которого представляет строковый литерал - тип const char*. 
Во вложенной конструкции try-catch есть такой блок catch, который обрабатывает исключения типа const chat*. И выполнения этого блока catch программа продолжает свой обычный ход 
работы, а блок catch во внешей конструкции try-catch НЕ выполняется. В итоге будет следующий консольный вывод:

Inner execption: Division by zero
Inner try-catch finished
External try-catch finished


###############
Теперь возьмем другую ситуацию - во вложенной конструкции try-catch нет нужного блока catch:

#include <iostream>
 
double divide(int a, int b)
{
    if(!b)  // если b == 0
    {
        throw "Division by zero";
    }
    return a / b;
}
int main()
{
    try
    {
        try
        {
            int a{10}, b{};
            double result {divide(a, b)};
            std::cout << result << std::endl;
        }
        catch (unsigned error)
        {
            std::cout << "Inner execption: " << error << std::endl;
        }
        std::cout << "Inner try-catch finished" << std::endl;   // эта строка не выполняется
    }
    catch (const char* error)
    {
        std::cout << "External execption: " << error << std::endl;
    }
    std::cout << "External try-catch finished" << std::endl;
}

Фактически это тот же самый пример, только теперь блок catch во вложенной конструкции обрабатывает исключения типа unsigned. В итоге, когда будет сгенерировано исключение, вложенная 
конструкция не сможет найти нужный блок catch для обработки исключения типа const char*. Поэтому выполнение выполнение программы переходит в блок catch внешней конструкции try-catch, 
который обрабатывает исключения типа const char*. Поэтому консольный вывод будет другим:

External execption: Division by zero
External try-catch finished


______________________________________________________________________________________
Создание своих типов исключений

Для каких-то специфичных задач мы можем создавать свои типы исключений, что позволяет нам передавать более структурированную и комплексную информацию об ошибке, нежели примитивные 
типы. Например, рассмотрим следующую программу:

#include <iostream>
 
class AgeException // Класс для хранения сообщения об ошибки
{
public: 
    AgeException(std::string message): message{message}{}
    std::string getMessage() const {return message;}
private:
    std::string message;
};
 
class Person
{
public:
    Person(std::string name, unsigned age)
    {
        if(!age||age>110)   // если возраст равен 0 или больше 110
        {
            throw AgeException{"Invalid age"};
        }
        this->name = name;
        this->age = age;
    }
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
private:
    std::string name;
    unsigned age;
};
 
int main()
{
    try
    {
        Person tom{"Tom", 38};      // Корректные данные
        tom.print();
 
        Person bob{"Bob", 1500};    // Некорректные данные
        bob.print();
    }
    catch (const AgeException& ex)
    {
        std::cout << ex.getMessage() << std::endl;
    }
}

Здесь определяется класс Person, в конструктор которого передается имя и возраст пользователя. Однако нам необходимо, чтобы возраст был в некотором разумном диапазоне, например, 
от 1 до 110. И в этом случае в конструкторе класса проверяем переданное значение возраста. Если оно выходит за допустимые пределы, с помощью оператора throw генерируем исключение 
класса AgeException, который чуть выше определен.

throw AgeException{"Invalid age"};

Класс AgeException специально создан, чтобы инкапсулировать исключение, связанное с возрастом человека. Этот класс просто хранит сообщение об ошибке и определяет метод getMessage 
для доступа к нему.

В конструкции try-catch для теста определяем пару объектов Person. При передаче некорректного возраста:

Person bob{"Bob", 1500};

будет генерироваться исключение AgeException, и управление перейдем в блок catch, который обрабатывает данный тип исключений:

catch (const AgeException& ex)
{
    std::cout << ex.getMessage() << std::endl;
}

Чтобы не происходило ненужного копирования объекта исключения, в блок catch объект исключения передается по ссылке.

Соответственно консольный вывод программы будет сдедующим:

Name: Tom       Age: 38
Invalid age


______________________________________________________________________________________
Последовательность обработки исключений базовых и производных классов

При возникновении исключения обработчики catch проверяются в той последовательности, в которой они определены в коде. И если будет найден первый блок catch, параметр которого 
соответствует типу исключения, то он выбирается для обработки исключения. Для исключений, которые являются базовыми типами (а не типами классов), необходимо точное совпадение типа 
исключения с типом параметра в блоке catch. А для исключений-объектов классов при сопоставлении могут применяться неявные преобразования. В этом случае обработчик catch выбирается, 
если

1) Параметр в catch имеет тот же самый тип, что и исключение (const игнорируется)

2) Тип параметра в catch представляет базовый класс для типа исключения или ссылку на базовый класс (const игнорируется)

3) Исключение и параметр в catch представляют указатели, соответственно объект исключения может быть неявно преобразован к типу параметра (const игнорируется)

Поскольку исключения производных классов неявно преобразуются в тип базового класса, то мы можем перехватывать все исключения, которые представляют базовый и производный типы, 
с помощью одного обработчика catch.

#include <iostream>
 
class AgeException // Класс для хранения сообщения об ошибки
{
public: 
    AgeException(std::string message): message{message}{}
    virtual std::string getMessage() const  // виртуальная функция
    {
        return message;
    }
private:
    std::string message;
};
 
class MaxAgeException: public AgeException
{
public: 
    MaxAgeException(std::string message, unsigned maxAge): AgeException{message}, maxAge{maxAge}
    {}
    std::string getMessage() const override // переопределяем виртуальную функцию
    {   
        return AgeException::getMessage() + " Max age should be " + std::to_string(maxAge);
    }
private:
    unsigned maxAge;
};
 
class Person
{
public:
    Person(std::string name, unsigned age)
    {
        if(!age)   // если возраст равен 0
        {
            throw AgeException{"Invalid age"};
        }
        if(age>110)   // если возраст больше 110
        {
            throw MaxAgeException{"Invalid age.", 110};
        }
        this->name = name;
        this->age = age;
    }
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
private:
    std::string name;
    unsigned age;
};
 
int main()
{
    try
    {
        Person bob{"Bob", 1500};    // Некорректные данные
        bob.print();
    }
    catch (const AgeException& ex)
    {
        std::cout << ex.getMessage() << std::endl;
    }
}

Здесь для ситуаций, когда будет превышен максимальный возраст, определен класс MaxAgeException, который наследуется от AgeException, принимает значение максимально допустимого 
возраста и переопределяет функцию getMessage.

Несмотря на то, что в конструкторе класса Person по отдельности генерируются два этих типа исключения

if(!age)   // если возраст равен 0
{
    throw AgeException{"Invalid age"};
}
if(age>110)   // если возраст больше 110
{
    throw MaxAgeException{"Invalid age.", 110};
}

оба типа исключений мы можем обработать, обрабатывая только исключение базового типа - AgeException:

catch (const AgeException& ex)
{
    std::cout << ex.getMessage() << std::endl;
}

Поскольку функция getMessage - виртуальная и переопределена в MaxAgeException, а параметр в catch передается по ссылке, то при вызове этой функции будет выбрана нужная реализация. 
И в данном случае на консоль будет выведено:

Invalid age. Max age should be 110


______________________________________________________________________________________
Раздельная обработка исключений

Иногда может потребоваться выполнить раздельную обработку исключений базовых и производных классов, особенно когда необходимо вызвать какие-нибудь функции производных классов, 
которых нет в базовых. Поскольку объекты исключений могут сопоставляться с параметрами базовых классов в блоке catch, то обработку производных классов надо размещать перед обработкой 
базовых классов. Например, возьмем выше определенные классы Person, AgeException и MaxAgeException и обработаем типы исключений по-отдельности:

void testPerson(std::string name, unsigned age)
{
    try
    {
        Person person{name, age};
        person.print();
    }
    catch (const MaxAgeException& ex)   // сначала обрабатываем исключение производного типа
    {
        std::cout << "MaxAgeException: " << ex.getMessage() << std::endl;
    }
    catch (const AgeException& ex)  // потом обрабатываем исключение базового типа
    {
        std::cout << "AgeException: " << ex.getMessage() << std::endl;
    }
}
int main()
{
    testPerson("Tom", 0);       // AgeException: Invalid age
    testPerson("Bob", 1000);    // MaxAgeException: Invalid age. Max age should be 110
}


______________________________________________________________________________________
Тип exception

Все исключения в языке C++ описываются типом exception, который определен в заголовочном файле <exception>. И при обработке исключений мы также можем использовать данный класс, 
интерфейс которого выглядит следующим образом:

namespace std
{
    class exception
    {
    public:
        exception() noexcept;
        exception(const exception&) noexcept;
        exception& operator=(const exception&) noexcept;
        virtual ~exception(); // Destructor
        virtual const char* what() const noexcept; // возвращает сообщение об исключении
    };
}

Используем данный тип для обработки исключения:

#include <iostream>
 
double divide(int, int);
 
int main()
{
    int x {500};
    int y{};
    try
    {
        double z = divide(x, y);
        std::cout << z << std::endl;
    }
    catch (const std::exception& err)
    {
        std::cout << "Error!!!" << std::endl;
    }
    std::cout << "The End..." << std::endl;
}
  
double divide(int a, int b)
{
    if (!b)
        throw std::exception();
    return a / b;
}

Прежде всего, оператору throw передается объект типа std::exception

throw std::exception();

Если мы хотим отловить исключения типа exception, то нам надо в выражении catch определить переменную этого типа:

catch (const std::exception& err)

То есть здесь err представляет константную ссылку на объект exception. Если мы не собираемся использовать эту переменную в блоке catch, то можно указать просто тип исключения:

catch (std::exception)
{
    std::cout << "Error!!!" << std::endl;
}

С помощью функции what() можно получить сообщение об ошибке в виде строки в С-стиле. Однако непосредственно для типа std::exception он имеет мало смысла, поскольку просто выводит 
название класса. Но в производных классах он может использоваться для вывода сообщения об ошибке.


############################################
Создание производных классов

На основе класса std::exception мы можем создавать свои собственные типы исключений. Например:

#include <iostream>
  
class person_error: public std::exception
{
public:
    person_error(const std::string& message): message{message}
    {}
    const char* what() const noexcept override
    {
        return message.c_str();     // получаем из std::string строку const char*
    }
private:
    std::string message;    // сообщение об ошибке
};
 
class Person
{
public:
    Person(std::string name, unsigned age)
    {
        if(!age || age > 110)    // если age==0 или age > 110
            throw person_error("Invalid age");
        this->name = name;
        this->age = age;
    }
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
private:
    std::string name;
    unsigned age;
};
  
void testPerson(std::string name, unsigned age)
{
    try
    {
        Person person{name, age};   // создаем один объект Person
        person.print();
    }
    catch (const person_error& err) // обработка ошибок, сязанных с Person
    {
        std::cout << "Person error: " << err.what() << std::endl;
    }
    catch (const std::exception&)   // обработка остальных исключений
    {
        std::cout << "Something wrong"<< std::endl;
    }
}
int main()
{
    testPerson("Tom", 38);  // Name: Tom       Age: 38
    testPerson("Sam", 250);  // Person error: Invalid age
}

Здесь определен класс Person, который представляет пользователя. В конструктор класса передается имя и возраст. Однако передаваемое число может превышать разумный возраст или быть 
равно нулю. В этом случае мы генерируем исключение типа person_error:

Person(std::string name, unsigned age)
{
    if(!age || age > 110)    // если age==0 или age > 110
        throw person_error("Invalid age");

Класс person_error унаследован от std::exception, через конструктор получает сообщение об ошибке и хранит его в переменной message:

class person_error: public std::exception
{
public:
    person_error(const std::string& message): message{message}
    {}
    const char* what() const noexcept override
    {
        return message.c_str();     // получаем из std::string строку const char*
    }
private:
    std::string message;    // сообщение об ошибке
};

Для возвращения сообщения нам надо переопределить виртуальную функцию what(). Но проблема заключается в том, что функция возвращает строку const char*, но класс хранит сообщение в 
виде строки std::string. И чтобы получить из std::string значение const char*, у строки вызываем функцию c_str()

return message.c_str();     // получаем из std::string строку const char*

Для теста определена функция testPerson, в которой в блоке try создается объект Person. Конструкция try..catch использует два блока catch для обработки исключений. Первый блок 
обрабатывает исключения производного типа - класса person_error, а последний блок представляет базовый тип exceptionЖ

catch (const person_error& err) // обработка ошибок, сязанных с Person
{
    std::cout << "Person error: " << err.what() << std::endl;
}
catch (const std::exception&)   // обработка остальных исключений
{
    std::cout << "Something wrong"<< std::endl;
}

И в данном случае программа выдаст следующий результат:

Name: Tom       Age: 38
Person error: Invalid age


______________________________________________________________________________________
Типы исключений

Кроме типа exception в C++ есть еще несколько производных типов исключений, которые могут использоваться при различных ситуациях. Основные из них:

runtime_error: общий тип исключений, которые возникают во время выполнения

range_error: исключение, которое возникает, когда полученный результат превосходит допустимый диапазон

overflow_error: исключение, которое возникает, если полученный результат превышает допустимый диапазон

underflow_error: исключение, которое возникает, если полученный в вычислениях результат имеет недопустимое отрицательное значение (выход за нижнюю допустимую границу значений)

logic_error: исключение, которое возникает при наличии логических ошибок к коде программы

domain_error: исключение, которое возникает, если для некоторого значения, передаваемого в функцию, не определен результат

invalid_argument: исключение, которое возникает при передаче в функцию некорректного аргумента

length_error: исключение, которое возникает при попытке создать объект большего размера, чем допустим для данного типа

out_of_range: исключение, которое возникает при попытке доступа к элементам вне допустимого диапазона


-->std::exception
|
|-std::bad_alloc
|			    |--std::domain_error
|-std::bad_cast		    |
|			    |--std::invalid_argument
|-std::bad_typeid	    |
|			    |--std::langht_error
|-std::bad_exception	    |
|			    |--std::out_of_range
|-std::logic_error <--------|
|
|-std::runtime_error <------|
			    |--std::overflow_error
			    |
			    |--std::range_error
			    |
			    |--std::underflow_error


Многие стандартные типы исключений делятся на две группы в зависимости от базового класса - logic_error или runtime_error. Большинство этих типов определено в заголовочном файле 
<stdexcept>.

Типы, основанные на logic_error, предназначены для ошибок, которые могли быть обнаружены до выполнения программы и являются следствием неправильной логики программы. Например, ввызов 
функции с одним или несколькими недопустимыми аргументами или вызов функции-члена для объекта, состояние которого не соответствует требованиям для этой конкретной функции. Вместо 
обработки подобных исключений можно явно проверять допустимость аргументов или состояние объекта перед вызовом функции.

Другая группа, производная от runtime_error, предназначена для ошибок, которые могут быть обнаружены только во время выполнения. Например, исключения, производные от system_error, 
обычно инкапсулируют ошибки, происходящие от вызовов базовой операционной системы, таких как сбой ввода или вывода файла. Доступ к файлам, как и любое взаимодействие с оборудованием, 
всегда может дать сбой, который нельзя предсказать (например, сбои диска, отсоединенные кабели, сбои сети и т. д.).

Конструкция try...catch может использовать несколько блоков catch для обработки различных типов исключений. При возникновении исключения для его обработки будет выбран тот, который 
использует тип возникшего исключения.

При использовании нескольких блоков catch вначале помещаются блоки catch, которые обрабатывают более частные исключения, а только потом блоки catch с более общими типами исключений:

#include <iostream>
  
class Person
{
public:
    Person(std::string name, unsigned age)
    {
        if(name.length() > 11)
            throw std::length_error("Name must be less than 10 chars");
        if(!age || age > 110)
            throw std::range_error("Age must be between 1 and 110");
        this->name = name;
        this->age = age;
    }
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
private:
    std::string name;
    unsigned age;
};
  
void testPerson(std::string name, unsigned age)
{
    try
    {
        Person person{name, age};   // создаем один объект Person
        person.print();
    }
    catch (const std::length_error& ex)
    {
        std::cout << "Length_error: " << ex.what() << std::endl;
    }
    catch (const std::range_error& ex)
    {
        std::cout << "Range_error: " << ex.what() << std::endl;
    }
    catch (const std::exception&)
    {
        std::cout << "Something wrong"<< std::endl;
    }
}
int main()
{
    testPerson("Tom", 38);  // Name: Tom       Age: 38
    testPerson("Gai Yulii Cezar", 42);  // Length_error: Name must be less than 10 chars
    testPerson("Sam", 250);  // Range_error: Age must be between 1 and 110
}

Здесь определен класс Person, в конструктор которого передаем строку-имя и число-возраст пользователя. Но передаваемые данные могут быть некорректными. Например, для допустимого 
возраста установим пределельный диапазон 1-110, а имя не должно быть длинее 11 символов. И в конструкторе проверяем переданные значения и генерируем различные исключения:

Person(std::string name, unsigned age)
{
    if(name.length() > 11)
        throw std::length_error("Name must be less than 10 chars");
    if(!age || age > 110)
        throw std::range_error("Age must be between 1 and 110");
    this->name = name;
    this->age = age;
}

Для теста определена функция testPerson, в которой в блоке try создается объект Person. Конструкция try..catch использует три блока catch для разных типов исключений. Причем последний
блок представляет самый общий тип исключений exception. Второй блок обрабатывает исключения типа range_error, производный от runtime_error. А первый блок обрабатывает исключения типа 
length_error, который является производным от logic_error.

catch (const std::length_error& ex)
{
    std::cout << "Length_error: " << ex.what() << std::endl;
}
catch (const std::range_error& ex)
{
    std::cout << "Range_error: " << ex.what() << std::endl;
}
catch (const std::exception&)
{
    std::cout << "Something wrong"<< std::endl;
}

С помощью функции what() в блоках catch возвращаем информацию об ошибке. И в данном случае программа выдаст следующий результат:

Name: Tom       Age: 38
Length_error: Name must be less than 10 chars
Range_error: Age must be between 1 and 110


______________________________________________________________________________________
Коды выхода

Коды выхода, также известные как «коды возврата» или «коды состояния», представляют собой числовые значения, которые программа возвращает вызывающей среде (обычно операционной 
системе) после завершения выполнения. Эти коды используются для обозначения успеха или неудачи выполнения программы.

0 — это стандартный код выхода для успешного выполнения, тогда как ненулевые коды выхода обычно указывают на ошибки или другие исключительные ситуации. Фактические значения ненулевых 
кодов выхода могут различаться в разных приложениях или системах.

В C++ вы можете вернуть код выхода из mainфункции с помощью returnинструкции или использовать exit()функцию, которая является частью стандартной библиотеки C++.

Пример: использование возврата в main:

#include <iostream>

int main() {
    // Some code here...

    if (/*some error condition*/) {
        std::cout << "An error occurred." << std::endl;
        return 1;
    }

    // More code here...

    if (/*another error condition*/) {
        std::cout << "Another error occurred." << std::endl;
        return 2;
    }

    return 0; // Successful execution
}

Пример: Использование exit() функции:

#include <iostream>
#include <cstdlib>

void some_function() {
    // Some code here...

    if (/*some error condition*/) {
        std::cout << "An error occurred." << std::endl;
        std::exit(1);
    }

    // More code here...
}

int main() {
    some_function();

    // Some other code here...

    return 0; // Successful execution
}

В обоих приведенных выше примерах программа возвращает коды завершения в зависимости от различных ошибок, возникших во время выполнения. Коды 1 и 2 используются для различения двух 
состояний ошибки.

______________________________________________________________________________________
Нарушения доступа (Access Violations)

Нарушение прав доступа — это особый тип ошибки, возникающий, когда программа пытается получить доступ к недопустимой области памяти. В C++ нарушения прав доступа чаще всего вызываются:

1) Разыменование нулевого или недопустимого указателя:

int *p = nullptr;
int x = *p;  // Нарушение доступа: попытка получить доступ к содержимому нулевого указателя

2) Доступ к массиву за пределами границ:

int arr[5] = {1, 2, 3, 4, 5};
int y = arr[5];  // Нарушение доступа: индекс выходит за границы (допустимые индексы 0-4)

3) Чтение или запись в память, освобожденную пользователем или операционной системой:

int* p2 = new int[10];
delete[] p2;
p2[3] = 42;  // Нарушение доступа: запись в память, которая была освобождена

Отладка нарушений прав доступа

Такие инструменты, как отладчики, статические анализаторы и профилировщики, могут помочь выявить нарушения прав доступа в вашем коде. Например:

Microsoft Visual Studio : используйте встроенный отладчик, чтобы определить строку кода, ответственную за ошибку нарушения прав доступа.

Valgrind : популярный инструмент Linux, который обнаруживает утечки памяти и нарушения доступа в ваших программах на C++.

AddressSanitizer : детектор ошибок памяти во время выполнения для C++, который может обнаруживать доступ за пределами границ, утечки памяти и ошибки использования после освобождения.


______________________________________________________________________________________
Теория: зачем нужен вызов throw без аргумента?

Если мы хотим наше исключение перепробросить на уровенть catch выше текущего, то мы вызываем throw без аргумента, в следующий блок try catch.

int main() {
	try {
		try {
			std::cout << "first catch" << std::endl;
			throw 1; 					// Симуляция вызова исключения
		}
		catch (...) {
			throw; 						// В обработке исключения перепробрасываем исключение на вверх
		}
	}
	catch (...) {
		std::cout << "last catch" << std::endl; 		// Обработка исключения
	}
	return 0;
}


______________________________________________________________________________________

