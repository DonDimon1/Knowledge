
Исключение (Exceptions)

Обработка исключений в C++ — это механизм обработки ошибок, аномалий или неожиданных событий, которые могут возникнуть во время выполнения программы. Это позволяет программе 
продолжать работу или корректно завершать работу при возникновении ошибок, а не внезапно завершать работу.

Исключения - это рантайм вещь.

C++ предоставляет набор ключевых слов и конструкций для реализации обработки исключений:

1) try: определяет блок кода, который следует отслеживать на предмет исключений.
2) catch: указывает тип перехватываемого исключения и блок кода, который должен выполняться при возникновении этого исключения.
3) throw: выдает исключение, которое будет перехвачено и обработано соответствующим блоком catch.
4) noexcept: указывает функцию, которая не генерирует исключения и не завершает программу, если исключение возникает в ее области действия.

try catch дорогая по времени операция, тяжелее чем new и delete и вызвов виртуальной функции.

Вот пример, демонстрирующий базовое использование обработки исключений:

#include <iostream>

int divide(int a, int b) {
    if (b == 0) {
	throw std::logic_error("Divide by zero"); 	// Деление на 0
        //throw "Division by zero!"; 	          	// Можно кидать и просто строки
    }
    return a / b;
}

int main() {
    int num1, num2;

    std::cout << "Enter two numbers for division: ";
    std::cin >> num1 >> num2;

    try {
        int result = divide(num1, num2);
        std::cout << "The result is: " << result << std::endl;
    } catch (const char* err) {
	std::cout << err.what();
        //std::cerr << "Error: " << err << std::endl;   // Обработка обычной строки
	
    }

    return 0;
}

В этом примере мы определяем функцию divide, которая выдает исключение, если b значение равно нулю. В main функции мы используем try блок для вызова divide и вывода результата. 
Если генерируется исключение, оно перехватывается внутри catch блока, который выводит сообщение об ошибке. Таким образом, мы можем корректно обработать ошибку, не допуская сбоя 
программы при попытке деления на ноль. Оператор throw генерирует исключение. Через оператор throw можно передать информацию об ошибке.

При выполнении строки int result = divide(num1, num2); будет сгенерировано исключение, поэтому последующие инструкции из блока try выполняться не будут, а управление перейдет в блок 
catch, в котором на консоль просто выводится сообщение об ошибке. После выполнения блока catch программа аварийно не завершится, а продолжит свою работу, выполняя операторы после 
блока catch.

Синтаксис:

try
{
    инструкции, которые могут вызвать исключение
}
catch(объявление_исключения)
{
    обработка исключения
}

Многоточие в скобках после оператора catch(...) позволяет обработать любое исключение.

Если же исключение не обработано, то вызывается функция std::terminate() (из модуля <exception> стандартной библиотеки C++), которая, в свою очередь, по умолчанию вызывает другую 
функцию - std::abort() (из <cstdlib>), которая собственно и завершает программу.

################
Ключевое слово noexcept, которое при использовании в заголовке функции указывает, что эта функция никогда не будет генерировать исключения. Например:

void print(int argument) noexcept;

Здесь указываем, что функция print() никогда не вызовет исключение. Таким образом, встретив функцию с подобным ключевым словом, можно ожидать, что она не вызовет исключения. 
И соответственно нет необходимости помещать ее вызов в конструкцию try-catch.


################

Так же есть 4 оператора которые могут бросить исключения: new, dynamic_cast, throw и typeid.

Попробуем выделить слишком большое кол-во памяти:

try {
	new int[400'000'000'000];
} catch (std::logic_error& err) {
	std::cout << err.what();
}

Получим ошибку:

terminate called after throwing an instance of 'std::bad_alloc'
    what(): std::bad_alloc
Aborted (core dumped)

std::bad_alloc это тип исключения, которое было брошено оператором new.

terminate это стандартная функция, которая автоматически вызывается рантаймом c++, когда программа не может продолжать работу по некоторым причинам(см. c++ reference),
например, если исключение было брошено и не поймано. Эта функция выводит на экран сообщение, почему она была вызвана. После этой функции вызывается функция abort, которая 
просит ОС убить программу с предиктом Aborted, и вот именно тогда на экран выводится сообщение "Aborted (core dumped)".


______________________________________________________
Difference between exceptions and runtime errors

Нужно чётко разграничивать, что является исключением, а что нет, потому что поймать с помощью catch можно тольок то, что является исключением в смысле c++. 

Например, если мы завели вектор и обратились с помощью квадратных скобочек за его пределы, это ошибка с названием segmentation fault.  

int main() {
	std::vector<int> v;
	v[1000000] = 1;		// CE
}

Но если мы обернём это в try, то мы не поймаем исключение, потому что segmentation fault это не исключение.

int main() {
	std::vector<int> v;
	try {
		v[1000000] = 1;	
	} catch (...) {
		std::cout << "Поймал";	// Мы не поймаем это
	}	
}


Или вот ещё пример: Например попробуем поделить на 0 в рантайме:

int main() {
	int x;
	std::cin >> x;

	try {
		std::cout << 5 / x;
	} catch (...) {
		std::cout << "Поймал";	// Мы не поймаем это
	}	
}

Получаем ошибку: Floating point exception (core dumped) 

Т.е. мы получили ошибку но не поймали exception, поскольку это не считается в c++ exception. Ошибка Floating point exception это exception другого уровня. Дело в том что есть
exception уровня c++, а есть exception уровня процессора. В процессоре, когда он делит на 0, у него возникает исключительная ситуация и он зовёт ОС её обрабатывать в самом
процессоре (в железке). И это тоже называется exception, но это совершенно другой exception. Если мы падаем из exception c++, то низкоуровневая наша причина падения это Aborted.
Обращение к вектору по несуществующему индексу, деление на 0 и переполнение стека это всё не exception с точки зрения c++, это exception с точки зрения процессора и try catch 
он не ловятся. А вот обращение через at по индексу ловятся, потому что это exception, кинутый через throw. Вторично усугубляет ситуацию тот факт, что есть в стандартной 
библиотеке есть такой класс под названием std::runtime_error, который является частным случаем std::exception. Но std::runtime_error это далеко не любой рантайм еррор. Т.е. 
получается исключения из c++ мы можем поймать и обработать, а вот низкоуровневые исключения мы поймать не можем. Это важно!

У стандартных исключений есть два больших подвида, это logic_error и runtime_error. logic_error это ошибка в которой мы сами виноваты, а runtime_error ошибка в которой 
пользователь не виноват, просто реально чтото не так пошло.


Какие бывают рантайм ерроры:

3 самые частые низкоуровневые причины: segmentation fault - обращение не к своей памяти, floating point exception - например деление на 0, Aborted - сами попросили себя убить.

Высокоуровневые причины segmentation fault: array out of bounds, stack overflow, nullptr dereference.

Высокоуровневые причины floating point exception: деление на 0.

Высокоуровневые причины Aborted: вызов функции std::abort(), false assertion.


______________________________________________________________________________________
Создание объекта исключения

При обработке исключения стоит помнить, что при передаче объекта оператору throw блок catch получает копию этого объекта. И эта копия существует только в пределах блока catch.
Для значений примитивных типов, например, int, копирование значения может не влиять на производительность программы. Однако при передаче объектов классов издержки могут выше. 
Поэтому в этом случае объекты обычно передаются по ссылке, например:

#include <iostream>
 
double divide(int a, int b)
{
    if (b)
        return a / b;
    throw std::string{"Division by zero!"};
}
  
int main()
{
    int x{500};
    int y{};
     
    try
    {
        double z {divide(x, y)};
        std::cout << z << std::endl;
    }
    catch (const std::string& error_message)    // строка передается по ссылке
    {
        std::cout << error_message << std::endl;
    }
    std::cout << "The End..." << std::endl;
}


####################
Exceptions handling

class A {
	A() {std::cout << "A"; }
	A(const A&) {std::cout << "copy"; }	// Конструктор копирования
	~A() { std::cout << "~A"; }
};

void f(int x) {
	A a;
	if(x == 0) {
		throw a;			// Что происходит в этот момент? Создастся копия или нет?
	}
	
}
int main() {
	try {
		f(0);
	} catch(...) {
		std::cout << "caught!";
	}
}

К сожалению здесь мы никак не можем избежать копирования(если мы не знаем move-семантику), потому что при броске исключения нам нужно локальный объект 'a' снять со стека в 
любом случае. Пока летит исключение, копия объекта 'a' будет храниться в динамической памяти, которую выделит компилятор, пока исключение не будет поймано, или пока мы не выйдем 
из main. После копирования, объекта a удаляется, очищается стек и мы выходим из функции f. После того как catch отрабатывает, уничтожается копия объекта 'a' из дин. памяти.

Это мы поймали с помощью многоточия (...). Но если бы catch выглядил так: 

catch(A a) {
	std::cout << "caught!";
}

то пришлось бы объект скопировать ещё раз. Если мы ловим по значению, то это значит что мы из динамической памяти копируем ещё раз на стек. Если было бы A& то мы бы работали с
динамической памятью, и второго копирования бы не произошло. (0x55 это обычно начало адресов из динамической памяти.) 

Если мы бросили исключение и оно не поймано вплоть до main, то вам не гарантируется вызов деструктора или копиконструктор.


####################
Что происходит если у нас не получилось выделить динамическую память? Если не получилось выделить эту память, то где оно лежит для исключения? Ведь если оператор new отказал в 
выделении динамической памяти и кинул bad_alloc, то где будет храниться этот bad_alloc?

int main() {
	try {
		new int[400'000'000'000];	// std::bad_alloc
	} catch(std::bad_alloc ex) {
		std::cout << &ex << '\n';
	} 
}

Если new кинул исключение, в статической памяти на этот случай заранее зарезервировано место куда положить bad_alloc. Это называется эмёрджинси баффер.


______________________________________________________________________________________
Обработка и генерация разных типов исключений

Мы можем генерировать и обрабатывать несколько разных исключительных ситуаций. Допустим, нам надо, чтобы при делении делитель (второе число) был не больше, чем делимое (первое число):

#include <iostream>
 
double divide(int a, int b)
{
    if(!b)  // если b == 0
    {
        throw 0;
    }
    if(b > a) 
    {
        throw "The second number is greater than the first one";
    }
    return a / b;
}
 
void test(int a, int b)
{
    try
    {
        double result {divide(a, b)};
        std::cout << result << std::endl;
    }
    catch (int code) 						// Обработка исключения типа int
    {
        std::cout << "Error code: " << code << std::endl;
    }
    catch (const char* error_message)				// Обработка исключения типа const char*
    {
        std::cout << error_message << std::endl;
    }
}
  
int main()
{
    test(100, 20);      // 5
    test(100, 0);       // Error code: 0
    test(100, 1000);    // The second number is greater than the first one
}


########################
Может быть ситуация, когда генерируется исключение внутри конструкции try-catch, и даже есть блок catch для обработки исключений, однако он обрабатывает другие типы исключений:

void test(int a, int b)
{
    try
    {
        double result {divide(a, b)};
        std::cout << result << std::endl;
    }
    catch (const char* error_message)
    {
        std::cout << error_message << std::endl;
    }
}

Здесь нет блока catch для обработки исключения типа int. Поэтому при генерации исключения: throw 0; Программа не найдет нужный блок catch для обработки исключения, и программа 
аварийно завершит свое выполнение.



##################################
Приведение типов (multiple catch)

Допустим мы бросаем int, но в обработке его нет, есть другие типы. Что выведется?

int main() {
	try {
		throw 1;
	} catch(double d) {
		std::cout << "double";
	} catch(long long l) {
		std::cout << "long long";
	} catch(...) {
		std::cout << "other";
	}
}

Что будет сейчас?

int main() {
	try {
		throw 1;
	} catch(double d) {
		std::cout << "double";
	} catch(long long l) {
		std::cout << "long long";
	} 
}

Сейчас будет terminate.

По правилам перегрузки в double сконвертировать это нужно сделать конвёршен, в long long нужно сделать промоушен, в а other ничего не нужно конвертировать, поэтому выберется 
other. Когда делается catch не применяются правила перегрузки, и не делается выбор какая конверсия лучше. Просто либо мы поймали такой в точности тип, который бросили, либо нет.
Выбирается первый подходящий catch.

Из этого правила есть одва исключения:

1) Конверсия в const всё таки проделывается. Т.е. если мы бросили не const, а поймали по константной ссылке то так можно.
2) Можно ловить по ссылке на родителя, то что было брошено как наследник. По значению тоже можно.


Пример:

struct Mom {};
struct Son: Mom {};

int main() {
	try {
		Son s;
		throw s;
	} catch(Mom) {
		std::cout << "caught Mom";	// Выберется этот вариант.
	} catch(Son) {
		std::cout << "caught Son";
	} catch(...) {
		std::cout << "other";
	}
}


Пример:
Но что будет в этом случае: мы сделали наследование приватным. Это значит что main не должен знать что Son наследник Mom. Сможет ли теперь main поймать сына как маму?

struct Mom {};
struct Son: private Mom {};			// Приватное наследование.

int main() {
	try {
		Son s;
		throw s;
	} catch(Mom) {
		std::cout << "caught Mom";	// Из main мы теперь не можем никак использовать тот факт, что Son наследник Mom.
	} catch(Son) {
		std::cout << "caught Son";	// Теперь из main выберется этот catch.
	} catch(...) {
		std::cout << "other";
	}
}


Пример:
Что будет при множественном неоднозначном наследовании? Наследование невиртуальное, значит мы имеем две бабушки. Что будет если мы попытаемся поймать сына как бабушку?

struct Granny {};
struct Dad: Granny {};
struct Mom: Granny {};
struct Son: Mom, Dad {};

int main() {
	try {
		Son s;
		throw s;
	} catch(Granny) {			
		std::cout << "caught Granny";	// Granny не поймается
	} catch(Son) {	
		std::cout << "caught Son";	// Поймается Son
	} catch(...) {
		std::cout << "other";
	}
}


Пример:
Приватность ничего не поменяет, результат будет такой же, будет выбран Сын:

struct Granny {};
struct Dad: Granny {};
struct Mom: private Granny {};
struct Son: private Mom, Dad {};


Пример:
Если мы добваим виртуальное наследование, то теперь Granny будет одна а не две, и теперь выберется catch с Granny:

struct Granny {};
struct Dad: virtual Granny {};
struct Mom: virtual Granny {};
struct Son: Mom, Dad {};

Вывод: caught Granny



______________________________________________________________________________________
try-catch и деструкторы

Стоит отметить, что, если в блоке try создаются некоторые объекты, то при возникновении исключения у них вызываются деструкторы. Например:

#include <iostream>
 
class Person
{
public:
    Person(std::string name) :name{ name }
    {
        std::cout << "Person " << name << " created" << std::endl;
    }
    ~Person()
    {
        std::cout << "Person " << name << " deleted" << std::endl;
    }
    void print()
    {
        throw "Print Error";
    }
private:
    std::string name;
};
 
int main()
{
    try
    {
        Person tom{ "Tom" };
        tom.print();    // Здесь генерируется ошибка
    }
    catch (const char* error)
    {
        std::cerr << error << std::endl;
    }
}

В классе Person определяет деструктор, который выводит сообщение на консоль. В функции print просто генерируем исключение. В функции main в блоке try создаем один объект Person и 
вызываем у него функцию print, что естественно приведет к генерарции исключения и переходу управления программы в блок catch. И если мы посмотрим на консольный вывод то мы увидим, 
что прежде чем начнется обработка исключения в блоке catch, будет вызван деструктор объекта Person.

Вывод в консоль:

Person Tom created
Person Tom deleted
Print Error

______________________________________________________________________________________
Немного теории

Если в конструкторе класс выбрасывается исключение, то деструктор для этого объекта не будет вызван, т.к. объект считается не полностью сконструированным, и следовательно 
деструкция считается потенциально опасной. Хоть деструктор для объекта, из которого было выброшено исключение, не вызывается, но все уже созданные и полностью инициализированные
члены объекта будут корректно уничтожены. Т.е. если в вашем объекте есть члены, являющиеся объектами других классов, и для них конструкторы были успешно вызваны до момента выброса 
исключения, то их деструкторы будут вызваны при обработке исключения. Это одна из причин почему важно использовать идеому RAII при работе с ресурсами в C++. Для управлением
ресурсами стоит использовать объекты, которые автоматически освобождают ресурсы при уничтожении (умные указатели).

Бросок исключения из деструктора считается очень плохой практикой, поскольку может нарушить нормальный процесс освобождения ресурсов.  По умолчанию с C++11 деструкторы должны быть 
noexcept. Если исключение бросается из деструктора во время обработки другого исключения (например при раскрутке стека после броска первого исключения), то программа автоматически
вызовет std::terminate(), потому что C++ не позволяет иметь более одного активного исключения одновременно.



______________________________________________________
RAII (Resource Acquisition Is Initalization - Преобретение ресурса - есть инициализация)

Представим такой пример: В функции f мы выделяем какой то ресурс в динамическую память и что начинаем делать. В конце мы не забываем освободить этот ресурс. Но есть проблема:
что если между тем как мы сделали new и сделали delete, кто то из тех, кого мы вызывали кинул исключение? Никто delete за нас не вызовет.   

void g(int y) {
	if(y == 0) {
		throw 1;
	}
}

void f(int x) {
	int* p = new int(x);
	g(*p);
	delete p;
}

int main() {
	f(5);
}


Для того чтобы обойти данную проблемы мы можем использовать ООП. Создадим структуру, которая в конструктор принимает int* и сохраняет его, а в деструкторе освобождает его. 
Теперь вместо использования сырого поинтера, мы будем использовать данную обёртку. И тогда не важно каким способом я выйду из этой функции f, delete будет вызван, потому что,
будут вызваны деструкторы локальных объектов, а значит будет вызван delete.

struct Wrapper {
	int* p;
	Wrapper(int* p) : p(p){}
	~Wrapper() {delete p;}
};

void g(int y) {
	if(y == 0) {
		throw 1;
	}
}

void f(int x) {
	Wrapper w(new int(x));
	g(*p);
}

int main() {
	f(5);
}


Это самое дешёвое решение этой проблемы и оно выглядит правильно. Это называется умный указатель. Есть правда новая проблема такого указателя: что если я хочу этот указатель 
куда то отдать по значению?

struct SmartPtr {
	int* p;
	SmartPtr(int* p) : p(p){}
	~SmartPtr() {delete p;}
	int& operator*() {		// Переопределение оператора *
		return *p;
	}
};

void g(SmartPtr p) {
	if(*p == 0) {
		throw 1;
	}
}

void f(int x) {
	SmartPtr w(new int(x));		// Передаём по значению.
	g(*p);
}

Всё грохнется. При передачи по значению копи конструктор автоматически сгенирируется, а деструктор сделает delete раза по одному указателю, впервый раз в копии, второй раз в
оригинале. Стандартная проблема: delete 2 раза одного и того же поинтера. Получается такой смартпоинтер нельзя копировать. Правило 3 невыполнено. Поэтому просто запрещаем 
копирование:

struct SmartPtr {
	int* p;
	SmartPtr(int* p) : p(p){}
	SmartPtr(const SmartPtr&) = delete;			// Запрет копирования.
	SmartPtr& operator=(const SmartPtr&) = delete;		// Запрет присваивания.
	~SmartPtr() {delete p;}
	int& operator*() {		
		return *p;
	}
};

Для полноценной реализации простейшего указателя добавим шаблонность, чтобы он работал не тольок от int:

template <typename T>
struct SmartPtr {
	T* p;
	SmartPtr(T* p) : p(p){}
	SmartPtr(const SmartPtr&) = delete;			
	SmartPtr& operator=(const SmartPtr&) = delete;		
	~SmartPtr() {delete p;}
	T& operator*() {		
		return *p;
	}
};

void g(SmartPtr<int>& p) {
	if(*p == 0) {
		throw 1;
	}
}

void f(int x) {
	SmartPtr<int> w(new int(x));
	g(*p);
}

Это была реализация класса unique_ptr.


______________________________________________________
Exceptions in constrictors (Исключения в конструкторах)

Представим что есть две структуры A и S. В конструкторе S при особом условии может быть кинуто исключение. Что будет в таком случае? Какие деструкторы вызовутся?

struct A {
	A() {std::cout << "A";}
	~A() {std::cout << "~A";}
};

struct S {
	A a;
	S(int x) {
		std::cout << "S";
		if(x == 0) throw 1;	// Бросаем исключение
	}
	~S() {
		std::cout << "~S";
	}
};

int main() {
	try {
		S s(0);
	} catch(...) {
	
	}	
}

В данном случае вызовется только деструктор A. Деструктор S не будет вызван, т.к. исключение было брошено в конструкторе S, а значит объект s не был сформирован до конца, это 
значит что  деструктор s не должен быть вызван.


Пример:
Если бы у нас было бы вот так, то деструктор A тоже бы не вызвался, и будет утечка памяти:

struct S {
	A* a;				// Поле с использованием сырого указателя
	S(int x) : a(new A()) {
		std::cout << "S";
		if(x == 0) throw 1;	// Бросаем исключение
	}
	~S() {				// Деструктор S не будет вызван,
		std::cout << "~S";
		delete a;		// поэтому a не очиститься, будет утечка памяти.
	}
};

Поэтому если у нас поля это какие то ресурсы, которые мы захватываем, то их тоже нужно оборачивать в RAII смартуказателем, поскольку дестуркторы класса S не вызовется, но 
деструкторы полей этого класса будут вызваны.


Пример:
Представим теперь что и в конструкторе A есть условие по которому может быть брошено исключение. Что произойдёт теперь?

struct A {
	A(int x) {
		std::cout << "A";
		if(x == 0) throw 1;	// Бросаем исключение
	}
	~A() {std::cout << "~A";}
};

struct S {
	A* a;
	S(int x) : a(0) {		// Исключение в списке инициализции
		std::cout << "S";
	}
	~S() {
		std::cout << "~S";
		delete a;
	}
};

int main() {
	try {
		S s(0);
	} catch(...) {
	
	}	
}

В данном случае исключение из класса A будет вылетать не в теле конструктора класса S, а в его списке инициализации, пока мы инициализируем поле a. И что же будет? А что если мы
уже проинициализировали какое то поле?

struct S {
	A a1;				
	A a2;
	A a3;
	S(int x) : a1(1), a2(0), a(2) {	// При инициализации a2 вызовется исключение
		std::cout << "S";
	}
	~S() {
		std::cout << "~S";
	}
};

a1 проинициализировалось успешно, на а2 у нас возникает исключение, а3 ещё не проинициализированно. Какие деструкторы в каком порядке вызовуться?
Вызовутся деструкторы только тех полей, которые уже успели создасться к моменту исключения. 

Как на уровне конструктора S обработать это? Т.е. мы пытаемся создать s, и ошибка возникла при создании какого-то поля s, но я будучи юзером S не знаю ничего про поля, они могут
быть приватными. Я хочу чтобы у меня была возможность на уровне класса S чтото сделать с этой ситуацией, чтобы я понял что за ошибку бросило поле а2. Иными словами я хочу уметь
написать try для списка инициализации.

Такая возможность называется function-try block:


struct S {
	A a1;				
	A a2;
	A a3;
	S(int x) try: a1(1), a2(0), a(2) {	// try перед :
		std::cout << "S";
	} catch(...) {
		std::cout << "caught!";
	}
	~S() {
		std::cout << "~S";
	}
};

Мы можем на уровне класса S поймать исключение из списка инициализации. На самом деле эта конструкция позволяет писать try после любой функции самым последним словом:

void f() try {

} catch(...) {

}


Хорошо но что будет с переменной s, если мы не будем оборачивать её в try в main? Мы поймали исключение, обработали его, вернулись на вверх в main, и что дальше?

int main() {
	S s(0);				// Что с ней будет?			
}

Правило следующее: 

Если мы написали такой function-try block в конструкторе, то throw автоматически делается из него, даже если мы не написали throw.

1) Прежде чем мы входим в любой catch в function-try block в конструкторе, все полностью сконструированные члены и родители уже уничтожены к этому моменту. 
2) Если function-try block находится в делегирующем конструкторе, который вызвал неделегирующий конструктор, а тот отработал полностью, но тело делегирующего конструктора 
бросило исключение, тогда деструктор объекта уже отработал к моменту когда мы входим в catch function-try блока. 
3) К моменту когда мы вошли catch function-try блока в деструкторе, все базовые классы и non-variant members уже уничтожены.
4) UB если мы в catch function-try блока из конструктора или деструктора пытаемся обратиться к родителю или нестатическому полю данного объекта.

Т.е. к моменту входа в catch у нас уже уничтожены все родители и все созданные поля, и даже вызван наш собственный деструктор, если мы вызывались из делегирующего конструктора.

5) Всякий catch в function-try block обязан завершиться броснием исключения. А если там не написано этого, то автоматически считается что throw написано.
6) Не разрешается писать return в catch в function-try block.

Смотри подробнее c++ reference.



______________________________________________________
Exceptions in destructor (Исключения в деструкторах)

Исключения в деструкторах это зло, это совсем плохо. Проблема в том, что деструктор сам по себе мог быть вызван по причине того, что было брошено исключение. И вот тогда это
кранты. Если деструктор вызван в штатной ситуации, это норм, но если мы находимся в деструкторе, и бросаем исключение из деструктора, но сам деструктор вызван по причине того
что уже летело исключение, то тогда стандарт говорит что вызывается функция std::terminate с формулировкой брошено исключение из деструктора.


До C++11 нельзя было бросать искючения из деструктора, если деструктор был вызван по причине летящего исключения. Начиная с C++11 просто нельзя бросать исключения из 
деструктора (с помощью noexcept(false) можно).

Пример:
struct S {
	S(int x) {
		std::cout << "S";
	}
	
	~S() {
		std::cout << "~S";
		throw 1;		// Исключение из деструктора. Был вызван terminate
	}
};

int main() {
	try {
		S s(0);
	} catch (...) {
	
	}
}


Но если мы напишем noexcept(false), то мы можем бросить исключение из деструктора:

struct S {
	S(int x) {
		std::cout << "S";
	}
	
	~S() noexcept(false) {		// Разрешение вызова исключения из деструктора
		std::cout << "~S";
		throw 1;		// Исключение из деструктора. 
	}
};

int main() {
	try {
		S s(0);
	} catch (...) {
	
	}
}

Но если этот деструктор был брошен по причине того, что брошено исключение, и мы стали выскакивать из блока try и должены стали попасть в блок catch, но пока я выскакивал 
из блока try начал вызываться деструктор локального объекта s и он бросил ещё одно исключение, то в такой ситуации всё ровно вызовется terminate.

int main() {
	try {
		S s(0);
		throw 1;
	} catch (...) {
	
	}
}

Если исключение из деструктора бршено по причине что уже летит исключение и мы делаем стек анвининг, вызывается terminate, даже несмотря на то что мы разрешили выбрасывать 
исключения из деструктора.



Допустим мы находимся в деструкторе и мы хотим бросить исключение, но мы не уверены а вдруг уже летит исключение. Мы хотим проверить в данный момент рантайма летит ли уже 
исключение или нет? Для этого в стандартной библиотеке есть функция std::uncaught_exception(). 

struct S {
	S(int x) {
		std::cout << "S";
	}
	
	~S() noexcept(false) {		// Разрешение вызова исключения из деструктора
		std::cout << "~S";
		if(!std::uncaught_exception()) {
			throw 1;		// Исключение из деструктора.
		} 
	}
};

Эта функция реализована компилятором. Она возвращает true если в данный момент рантайма летит исключение.

Начиная с C++17 функция std::uncaught_exception() устарела (deprecated) и её заменила функция std::uncaught_exceptions(). Функция std::uncaught_exceptions() нужна потому что
в C++ возможна ситуация когда летит несколько исключений. Это возможно если в деструкторе написали try и внутри этого try мы вызываем функцию, которая отбросила исключение, но 
при этом в самом деструкторе у нас написано catch, но в момент когда из этой функции летит исключение и прилетает в деструктор, у нас находится одновременно в рантайме 2 
исключения.



______________________________________________________________________________________
Вложенные try-catch

Одни конструкции try-catch могут содержать другие. Если исключение возникает во вложенной конструкции try-catch, то программа сначала ищет во вложенной конструкции блок catch, который
обрабатывает нужный тип исключения. Если во вложенной конструкции try-catch такой блок catch не найден, то программа начинает искать аналогичный блок catch во внешей конструкии 
try-catch. Посмотрим на примере.

#include <iostream>
 
double divide(int a, int b)
{
    if(!b)  // если b == 0
    {
        throw "Division by zero";
    }
    return a / b;
}
int main()
{
    try
    {
        try
        {
            int a{10}, b{};
            double result {divide(a, b)};
            std::cout << result << std::endl;
        }
        catch (const char* error)
        {
            std::cout << "Inner execption: " << error << std::endl;
        }
        std::cout << "Inner try-catch finished" << std::endl;
    }
    catch (const char* error)
    {
        std::cout << "External execption: " << error << std::endl;
    }
    std::cout << "External try-catch finished" << std::endl;
}

Здесь функция divide() вызывается во внутренней конструкции try-catch. Оператор throw генерирует исключение, объект которого представляет строковый литерал - тип const char*. 
Во вложенной конструкции try-catch есть такой блок catch, который обрабатывает исключения типа const chat*. И выполнения этого блока catch программа продолжает свой обычный ход 
работы, а блок catch во внешей конструкции try-catch НЕ выполняется. В итоге будет следующий консольный вывод:

Inner execption: Division by zero
Inner try-catch finished
External try-catch finished


###############
Теперь возьмем другую ситуацию - во вложенной конструкции try-catch нет нужного блока catch:

#include <iostream>
 
double divide(int a, int b)
{
    if(!b)  // если b == 0
    {
        throw "Division by zero";
    }
    return a / b;
}
int main()
{
    try
    {
        try
        {
            int a{10}, b{};
            double result {divide(a, b)};
            std::cout << result << std::endl;
        }
        catch (unsigned error)
        {
            std::cout << "Inner execption: " << error << std::endl;
        }
        std::cout << "Inner try-catch finished" << std::endl;   // эта строка не выполняется
    }
    catch (const char* error)
    {
        std::cout << "External execption: " << error << std::endl;
    }
    std::cout << "External try-catch finished" << std::endl;
}

Фактически это тот же самый пример, только теперь блок catch во вложенной конструкции обрабатывает исключения типа unsigned. В итоге, когда будет сгенерировано исключение, вложенная 
конструкция не сможет найти нужный блок catch для обработки исключения типа const char*. Поэтому выполнение выполнение программы переходит в блок catch внешней конструкции try-catch, 
который обрабатывает исключения типа const char*. Поэтому консольный вывод будет другим:

External execption: Division by zero
External try-catch finished



#####################
Из блока catch мы можем снова бросить исключение. Причём сделать мы это можем без аргумента.

сatch(A& a) {
	std::cout << "caught!";
	throw;				// Просто throw без аргумента.
}


Можно сделать throw и добавить аргумент: 

сatch(A& a) {
	std::cout << "caught!";
	throw a;			// Появился аргумент a
}

Это будет означать что мы хотим ещё раз скопировать этот объект 'a' и создать новый вместо него.

Разница throw с аргументом или без в том, что когда я пишу просто throw без аргуменов я пускаю лететь то что летело, а если мы говорим throw + аргумент, то тот объект, который 
летел (хранился как исключение), он уничтожается и вместо него создаётся новый (возможно уже на новом месте).

Если мы бросили исключение находясь в catch, то это исключение будет обработано только кетчами, которые стоят на уровень выше. Кетчи текущего уровня будут проигнорены.

Пример 1) throw без аргумента: 

int main() {
	try {
		try {
			f(0);
		} catch (A& a) {				// Ловим исключение
			std::cout << "caught!" << &a << '\n';	// Обрабатываем его и получаем адрес a
			throw;					// Бросаем исключение снова. Поскольку throw находится в catch выходим на уровень выше.
		}
	} catch(A& a) {						// Снова ловим исключение
		std::cout << "caught again!" << &a << '\n';	// Снова обрабатываем исключение. Получаем адрес a, он будет точно такой же как и в обработке первого исключения.
	} 
}


Пример 2) throw с аргументом: 

int main() {
	try {
		try {
			f(0);
		} catch (A& a) {				// Ловим исключение
			std::cout << "caught!" << &a << '\n';	// Обрабатываем его и получаем адрес a
			throw a;				// Бросаем исключение снова. Выходим на уровень выше. Происходит копирование объекта a, пердыдущий объект уничтожился.
		}
	} catch(A& a) {						// Снова ловим исключение
		std::cout << "caught again!" << &a << '\n';	// Снова обрабатываем исключение. Получаем адрес a, он будет уже другой, не как в обработке первого исключения.
	} 
}


##########################
Оффтоп 
разница между std::endl и '\n'

std::endl это особоый объект, вывод которого в cout приводит к тому, что очищается буфер вывода. У cout есть буфер. Когда мы чтото кладём в cout, оно не сразу выводится в консоль,
оно выводится пачками, когда он делает флаш буфера. И если мы в cout чтото вводим, и у нас происходит terminate, буфер мужет не успеть очиститься, т.е. std::cout может не успеть
вывести всё на консоль до того как убётся программа.



______________________________________________________________________________________
Создание своих типов исключений

Для каких-то специфичных задач мы можем создавать свои типы исключений, что позволяет нам передавать более структурированную и комплексную информацию об ошибке, нежели примитивные 
типы. Например, рассмотрим следующую программу:

#include <iostream>
 
class AgeException // Класс для хранения сообщения об ошибки
{
public: 
    AgeException(std::string message): message{message}{}
    std::string getMessage() const {return message;}
private:
    std::string message;
};
 
class Person
{
public:
    Person(std::string name, unsigned age)
    {
        if(!age||age>110)   // если возраст равен 0 или больше 110
        {
            throw AgeException{"Invalid age"};
        }
        this->name = name;
        this->age = age;
    }
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
private:
    std::string name;
    unsigned age;
};
 
int main()
{
    try
    {
        Person tom{"Tom", 38};      // Корректные данные
        tom.print();
 
        Person bob{"Bob", 1500};    // Некорректные данные
        bob.print();
    }
    catch (const AgeException& ex)
    {
        std::cout << ex.getMessage() << std::endl;
    }
}

Здесь определяется класс Person, в конструктор которого передается имя и возраст пользователя. Однако нам необходимо, чтобы возраст был в некотором разумном диапазоне, например, 
от 1 до 110. И в этом случае в конструкторе класса проверяем переданное значение возраста. Если оно выходит за допустимые пределы, с помощью оператора throw генерируем исключение 
класса AgeException, который чуть выше определен.

throw AgeException{"Invalid age"};

Класс AgeException специально создан, чтобы инкапсулировать исключение, связанное с возрастом человека. Этот класс просто хранит сообщение об ошибке и определяет метод getMessage 
для доступа к нему.

В конструкции try-catch для теста определяем пару объектов Person. При передаче некорректного возраста:

Person bob{"Bob", 1500};

будет генерироваться исключение AgeException, и управление перейдем в блок catch, который обрабатывает данный тип исключений:

catch (const AgeException& ex)
{
    std::cout << ex.getMessage() << std::endl;
}

Чтобы не происходило ненужного копирования объекта исключения, в блок catch объект исключения передается по ссылке.

Соответственно консольный вывод программы будет сдедующим:

Name: Tom       Age: 38
Invalid age


______________________________________________________________________________________
Последовательность обработки исключений базовых и производных классов

При возникновении исключения обработчики catch проверяются в той последовательности, в которой они определены в коде. И если будет найден первый блок catch, параметр которого 
соответствует типу исключения, то он выбирается для обработки исключения. Для исключений, которые являются базовыми типами (а не типами классов), необходимо точное совпадение типа 
исключения с типом параметра в блоке catch. А для исключений-объектов классов при сопоставлении могут применяться неявные преобразования. В этом случае обработчик catch выбирается, 
если

1) Параметр в catch имеет тот же самый тип, что и исключение (const игнорируется)

2) Тип параметра в catch представляет базовый класс для типа исключения или ссылку на базовый класс (const игнорируется)

3) Исключение и параметр в catch представляют указатели, соответственно объект исключения может быть неявно преобразован к типу параметра (const игнорируется)

Поскольку исключения производных классов неявно преобразуются в тип базового класса, то мы можем перехватывать все исключения, которые представляют базовый и производный типы, 
с помощью одного обработчика catch.

#include <iostream>
 
class AgeException // Класс для хранения сообщения об ошибки
{
public: 
    AgeException(std::string message): message{message}{}
    virtual std::string getMessage() const  // виртуальная функция
    {
        return message;
    }
private:
    std::string message;
};
 
class MaxAgeException: public AgeException
{
public: 
    MaxAgeException(std::string message, unsigned maxAge): AgeException{message}, maxAge{maxAge}
    {}
    std::string getMessage() const override // переопределяем виртуальную функцию
    {   
        return AgeException::getMessage() + " Max age should be " + std::to_string(maxAge);
    }
private:
    unsigned maxAge;
};
 
class Person
{
public:
    Person(std::string name, unsigned age)
    {
        if(!age)   // если возраст равен 0
        {
            throw AgeException{"Invalid age"};
        }
        if(age>110)   // если возраст больше 110
        {
            throw MaxAgeException{"Invalid age.", 110};
        }
        this->name = name;
        this->age = age;
    }
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
private:
    std::string name;
    unsigned age;
};
 
int main()
{
    try
    {
        Person bob{"Bob", 1500};    // Некорректные данные
        bob.print();
    }
    catch (const AgeException& ex)
    {
        std::cout << ex.getMessage() << std::endl;
    }
}

Здесь для ситуаций, когда будет превышен максимальный возраст, определен класс MaxAgeException, который наследуется от AgeException, принимает значение максимально допустимого 
возраста и переопределяет функцию getMessage.

Несмотря на то, что в конструкторе класса Person по отдельности генерируются два этих типа исключения

if(!age)   // если возраст равен 0
{
    throw AgeException{"Invalid age"};
}
if(age>110)   // если возраст больше 110
{
    throw MaxAgeException{"Invalid age.", 110};
}

оба типа исключений мы можем обработать, обрабатывая только исключение базового типа - AgeException:

catch (const AgeException& ex)
{
    std::cout << ex.getMessage() << std::endl;
}

Поскольку функция getMessage - виртуальная и переопределена в MaxAgeException, а параметр в catch передается по ссылке, то при вызове этой функции будет выбрана нужная реализация. 
И в данном случае на консоль будет выведено:

Invalid age. Max age should be 110


______________________________________________________________________________________
Раздельная обработка исключений

Иногда может потребоваться выполнить раздельную обработку исключений базовых и производных классов, особенно когда необходимо вызвать какие-нибудь функции производных классов, 
которых нет в базовых. Поскольку объекты исключений могут сопоставляться с параметрами базовых классов в блоке catch, то обработку производных классов надо размещать перед обработкой 
базовых классов. Например, возьмем выше определенные классы Person, AgeException и MaxAgeException и обработаем типы исключений по-отдельности:

void testPerson(std::string name, unsigned age)
{
    try
    {
        Person person{name, age};
        person.print();
    }
    catch (const MaxAgeException& ex)   // сначала обрабатываем исключение производного типа
    {
        std::cout << "MaxAgeException: " << ex.getMessage() << std::endl;
    }
    catch (const AgeException& ex)  // потом обрабатываем исключение базового типа
    {
        std::cout << "AgeException: " << ex.getMessage() << std::endl;
    }
}
int main()
{
    testPerson("Tom", 0);       // AgeException: Invalid age
    testPerson("Bob", 1000);    // MaxAgeException: Invalid age. Max age should be 110
}


______________________________________________________________________________________
Тип exception

Все исключения в языке C++ описываются типом exception, который определен в заголовочном файле <exception>. И при обработке исключений мы также можем использовать данный класс, 
интерфейс которого выглядит следующим образом:

namespace std
{
    class exception
    {
    public:
        exception() noexcept;
        exception(const exception&) noexcept;
        exception& operator=(const exception&) noexcept;
        virtual ~exception(); // Destructor
        virtual const char* what() const noexcept; // возвращает сообщение об исключении
    };
}

Используем данный тип для обработки исключения:

#include <iostream>
 
double divide(int, int);
 
int main()
{
    int x {500};
    int y{};
    try
    {
        double z = divide(x, y);
        std::cout << z << std::endl;
    }
    catch (const std::exception& err)
    {
        std::cout << "Error!!!" << std::endl;
    }
    std::cout << "The End..." << std::endl;
}
  
double divide(int a, int b)
{
    if (!b)
        throw std::exception();
    return a / b;
}

Прежде всего, оператору throw передается объект типа std::exception

throw std::exception();

Если мы хотим отловить исключения типа exception, то нам надо в выражении catch определить переменную этого типа:

catch (const std::exception& err)

То есть здесь err представляет константную ссылку на объект exception. Если мы не собираемся использовать эту переменную в блоке catch, то можно указать просто тип исключения:

catch (std::exception)
{
    std::cout << "Error!!!" << std::endl;
}

С помощью функции what() можно получить сообщение об ошибке в виде строки в С-стиле. Однако непосредственно для типа std::exception он имеет мало смысла, поскольку просто выводит 
название класса. Но в производных классах он может использоваться для вывода сообщения об ошибке.


############################################
Создание производных классов

На основе класса std::exception мы можем создавать свои собственные типы исключений. Например:

#include <iostream>
  
class person_error: public std::exception
{
public:
    person_error(const std::string& message): message{message}
    {}
    const char* what() const noexcept override
    {
        return message.c_str();     // получаем из std::string строку const char*
    }
private:
    std::string message;    // сообщение об ошибке
};
 
class Person
{
public:
    Person(std::string name, unsigned age)
    {
        if(!age || age > 110)    // если age==0 или age > 110
            throw person_error("Invalid age");
        this->name = name;
        this->age = age;
    }
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
private:
    std::string name;
    unsigned age;
};
  
void testPerson(std::string name, unsigned age)
{
    try
    {
        Person person{name, age};   // создаем один объект Person
        person.print();
    }
    catch (const person_error& err) // обработка ошибок, сязанных с Person
    {
        std::cout << "Person error: " << err.what() << std::endl;
    }
    catch (const std::exception&)   // обработка остальных исключений
    {
        std::cout << "Something wrong"<< std::endl;
    }
}
int main()
{
    testPerson("Tom", 38);  // Name: Tom       Age: 38
    testPerson("Sam", 250);  // Person error: Invalid age
}

Здесь определен класс Person, который представляет пользователя. В конструктор класса передается имя и возраст. Однако передаваемое число может превышать разумный возраст или быть 
равно нулю. В этом случае мы генерируем исключение типа person_error:

Person(std::string name, unsigned age)
{
    if(!age || age > 110)    // если age==0 или age > 110
        throw person_error("Invalid age");

Класс person_error унаследован от std::exception, через конструктор получает сообщение об ошибке и хранит его в переменной message:

class person_error: public std::exception
{
public:
    person_error(const std::string& message): message{message}
    {}
    const char* what() const noexcept override
    {
        return message.c_str();     // получаем из std::string строку const char*
    }
private:
    std::string message;    // сообщение об ошибке
};

Для возвращения сообщения нам надо переопределить виртуальную функцию what(). Но проблема заключается в том, что функция возвращает строку const char*, но класс хранит сообщение в 
виде строки std::string. И чтобы получить из std::string значение const char*, у строки вызываем функцию c_str()

return message.c_str();     // получаем из std::string строку const char*

Для теста определена функция testPerson, в которой в блоке try создается объект Person. Конструкция try..catch использует два блока catch для обработки исключений. Первый блок 
обрабатывает исключения производного типа - класса person_error, а последний блок представляет базовый тип exceptionЖ

catch (const person_error& err) // обработка ошибок, сязанных с Person
{
    std::cout << "Person error: " << err.what() << std::endl;
}
catch (const std::exception&)   // обработка остальных исключений
{
    std::cout << "Something wrong"<< std::endl;
}

И в данном случае программа выдаст следующий результат:

Name: Tom       Age: 38
Person error: Invalid age


______________________________________________________________________________________
Типы исключений

Кроме типа exception в C++ есть еще несколько производных типов исключений, которые могут использоваться при различных ситуациях. Основные из них:

runtime_error: общий тип исключений, которые возникают во время выполнения

range_error: исключение, которое возникает, когда полученный результат превосходит допустимый диапазон

overflow_error: исключение, которое возникает, если полученный результат превышает допустимый диапазон

underflow_error: исключение, которое возникает, если полученный в вычислениях результат имеет недопустимое отрицательное значение (выход за нижнюю допустимую границу значений)

logic_error: исключение, которое возникает при наличии логических ошибок к коде программы

domain_error: исключение, которое возникает, если для некоторого значения, передаваемого в функцию, не определен результат

invalid_argument: исключение, которое возникает при передаче в функцию некорректного аргумента

length_error: исключение, которое возникает при попытке создать объект большего размера, чем допустим для данного типа

out_of_range: исключение, которое возникает при попытке доступа к элементам вне допустимого диапазона


-->std::exception
|
|-std::bad_alloc
|			    |--std::domain_error
|-std::bad_cast		    |
|			    |--std::invalid_argument
|-std::bad_typeid	    |
|			    |--std::langht_error
|-std::bad_exception	    |
|			    |--std::out_of_range
|-std::logic_error <--------|
|
|-std::runtime_error <------|
			    |--std::overflow_error
			    |
			    |--std::range_error
			    |
			    |--std::underflow_error


Многие стандартные типы исключений делятся на две группы в зависимости от базового класса - logic_error или runtime_error. Большинство этих типов определено в заголовочном файле 
<stdexcept>.

Типы, основанные на logic_error, предназначены для ошибок, которые могли быть обнаружены до выполнения программы и являются следствием неправильной логики программы. Например, ввызов 
функции с одним или несколькими недопустимыми аргументами или вызов функции-члена для объекта, состояние которого не соответствует требованиям для этой конкретной функции. Вместо 
обработки подобных исключений можно явно проверять допустимость аргументов или состояние объекта перед вызовом функции.

Другая группа, производная от runtime_error, предназначена для ошибок, которые могут быть обнаружены только во время выполнения. Например, исключения, производные от system_error, 
обычно инкапсулируют ошибки, происходящие от вызовов базовой операционной системы, таких как сбой ввода или вывода файла. Доступ к файлам, как и любое взаимодействие с оборудованием, 
всегда может дать сбой, который нельзя предсказать (например, сбои диска, отсоединенные кабели, сбои сети и т. д.).

Конструкция try...catch может использовать несколько блоков catch для обработки различных типов исключений. При возникновении исключения для его обработки будет выбран тот, который 
использует тип возникшего исключения.

При использовании нескольких блоков catch вначале помещаются блоки catch, которые обрабатывают более частные исключения, а только потом блоки catch с более общими типами исключений:

#include <iostream>
  
class Person
{
public:
    Person(std::string name, unsigned age)
    {
        if(name.length() > 11)
            throw std::length_error("Name must be less than 10 chars");
        if(!age || age > 110)
            throw std::range_error("Age must be between 1 and 110");
        this->name = name;
        this->age = age;
    }
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
private:
    std::string name;
    unsigned age;
};
  
void testPerson(std::string name, unsigned age)
{
    try
    {
        Person person{name, age};   // создаем один объект Person
        person.print();
    }
    catch (const std::length_error& ex)
    {
        std::cout << "Length_error: " << ex.what() << std::endl;
    }
    catch (const std::range_error& ex)
    {
        std::cout << "Range_error: " << ex.what() << std::endl;
    }
    catch (const std::exception&)
    {
        std::cout << "Something wrong"<< std::endl;
    }
}
int main()
{
    testPerson("Tom", 38);  // Name: Tom       Age: 38
    testPerson("Gai Yulii Cezar", 42);  // Length_error: Name must be less than 10 chars
    testPerson("Sam", 250);  // Range_error: Age must be between 1 and 110
}

Здесь определен класс Person, в конструктор которого передаем строку-имя и число-возраст пользователя. Но передаваемые данные могут быть некорректными. Например, для допустимого 
возраста установим пределельный диапазон 1-110, а имя не должно быть длинее 11 символов. И в конструкторе проверяем переданные значения и генерируем различные исключения:

Person(std::string name, unsigned age)
{
    if(name.length() > 11)
        throw std::length_error("Name must be less than 10 chars");
    if(!age || age > 110)
        throw std::range_error("Age must be between 1 and 110");
    this->name = name;
    this->age = age;
}

Для теста определена функция testPerson, в которой в блоке try создается объект Person. Конструкция try..catch использует три блока catch для разных типов исключений. Причем последний
блок представляет самый общий тип исключений exception. Второй блок обрабатывает исключения типа range_error, производный от runtime_error. А первый блок обрабатывает исключения типа 
length_error, который является производным от logic_error.

catch (const std::length_error& ex)
{
    std::cout << "Length_error: " << ex.what() << std::endl;
}
catch (const std::range_error& ex)
{
    std::cout << "Range_error: " << ex.what() << std::endl;
}
catch (const std::exception&)
{
    std::cout << "Something wrong"<< std::endl;
}

С помощью функции what() в блоках catch возвращаем информацию об ошибке. И в данном случае программа выдаст следующий результат:

Name: Tom       Age: 38
Length_error: Name must be less than 10 chars
Range_error: Age must be between 1 and 110



______________________________________________________
Exception safety

Когда у нас разрешены потенциальные исключения нам нужно иметь в виду, что каждая функция которую мы реализовываем может случайно выскочить из своего выполнения не когда 
написано return, а в случайный момент. Представим что мы пишем шаблонный класс над типом T, а тип T он может кидать исключения. И вот мы написали данный код, и обращаемся к чему
то у T и мы должны понимать что всякий раз когда мы к чему-то таком обращаемся, мы можем случайно выйти из своей функции с exception. Код, который написан так, что он при этом
всё ещё корректно работает, называется безопасным относительно исключений. 

Есть разные уровни безопасности относительно исключений (гарантии):
1) Вообще не бывает исключений (Nothrow exception quarantee).

Если исключения бывают, то есть 2 вида безопасности:
2) Strong exception quarantee - говорят, что функция предоставляет сильную гарантию исключений(exception safety), если когда кто-то бросает исключение, эта функция возвращает
всё как было, как будто вы её не вызывали, например std::vector::push_back(). Представим что мы в вектор решаем положить объект типа T, который часто бросается исключениями,
и например он может бросать исключения во время копирования себя. И вот вектор делает реалокацию, и начинает перекладывать объекты. Он переложил половину объектов, и вдруг
очередной i+1 объект бросает исключение. В такой ситуации вектор обязан уничтожить всё то, что он успел скопировать, освободить память, которую он выделил, вернуть size и 
capacity назад, вообщем, вернуть всё как было, как будто мы push_pack() не вызывали. И только после всего этого пробросить исключение наверх. Большинство методов и алгоритмов 
стандартного контейнера дают такую гарантию.

3) Basic exception quarantee - покарйней мере всё остаётся в валидном состоянии, непроисходит никаких утечек инварианты всех объектов нетронуты. При этом не обязательно что мы 
вернулись в исходное состояние до вызова функции, но покарйней мере ничего не разломано и нет UB.

4) Без гарантии исключний(No exception quarantee). Нет никаких гарантий, если мы бросим исключение, то у нас может быть UB.


______________________________________________________
noexcept C++11

Мы можем пометить свою функцию как некидающую исключений. 

void f() noexcept {

}

Этим мы обещаем что мы не будем бросать исключения из этой функции. Именно ИЗ функции. Мы можем бросать исключения находясь в ней, но обязаны их поймать на этом же уровне. В
частности мы можем написать так:

void f() noexcept try{

} catch(...) {

}

Тем самым мы гарантируем сами себе, что всё что брошено на этом уровне поймано здесь же. Если из noexcept функции брошено исключение то будет std::terminate.


Бывает условный noexcept. Представим что мы пишем шаблонную функцию и мы хотим поставить noexcept в зависимости от какого то условия, например если тип T обладает каким то 
свойством, то мы обещаем что не будем кидать исключения, а если не обладает, то мы не обещаем этого. Тогда мы можем написать спецификатор noexcept(компайл тайм услловие).

template <typename T>
void f() noexcept(std::is_reference_v<T>) { 	// Если тип T будет ссылкой то я обещаю что функция будет noexcept, иначе не обещаю.

}

Но часто бывает так, что мы хотим поставить ноуэксептность своей функции, в зависимости от того, является ли ктото другой noexcept. Например мы хотим стать noexcept, только если
функция g является noexcept. Тогда мы можем использовать оператор noexcept. Этот оператор проверяет в компайлтайме является ли данное выражение noexcept.

template <typename T>
void g() {}

template <typename T>
void f() noexcept {}

int main() {
	std::cout << noexcept(g<int>());	// Ответ 0, что означает false, ведь g не noexcept.
}

Этот оператор не вычисляет данное выражение, он просто говорит true или false в зависимости от того, выражение под ним noexcept или нет. Как он понимает это? Если выражение под 
ним это просто вызов функции, то он просто вызов функции помечен noexcept или нет, а если выражение под ним состоит из выводов каких то стандартных операторов, то noexcept 
являются все операторы, кроме new, dynamic_cast, typeid, throw.

Теперь мы можем noexcept поставить в зависимости от условия была ли noexcept функция g.

template <typename T>
void g() {}

template <typename T>
void f() noexcept(noexcept(g<T>())) {}


####################
Почему метод std::vector::at() кидает исключение, а std::vector::operator[] нет?

Почему оператор [] не noexcept ведь он же не кидает исключений? Семантика noexcept не совсем в том, что мы обещаем не кидать исключений, noexcept помечаются функции, которые 
впринципе не могут пойти неудачно. Т.е. когда мы в коде видим noexcept, это правильно понимать, что исключений впринципе не может произойти от этой функции.
Также все деструкторы по умолчанию написаны как noexcept начиная с C++11.


______________________________________________________________________________________
Коды выхода

Коды выхода, также известные как «коды возврата» или «коды состояния», представляют собой числовые значения, которые программа возвращает вызывающей среде (обычно операционной 
системе) после завершения выполнения. Эти коды используются для обозначения успеха или неудачи выполнения программы.

0 — это стандартный код выхода для успешного выполнения, тогда как ненулевые коды выхода обычно указывают на ошибки или другие исключительные ситуации. Фактические значения ненулевых 
кодов выхода могут различаться в разных приложениях или системах.

В C++ вы можете вернуть код выхода из mainфункции с помощью returnинструкции или использовать exit()функцию, которая является частью стандартной библиотеки C++.

Пример: использование возврата в main:

#include <iostream>

int main() {
    // Some code here...

    if (/*some error condition*/) {
        std::cout << "An error occurred." << std::endl;
        return 1;
    }

    // More code here...

    if (/*another error condition*/) {
        std::cout << "Another error occurred." << std::endl;
        return 2;
    }

    return 0; // Successful execution
}

Пример: Использование exit() функции:

#include <iostream>
#include <cstdlib>

void some_function() {
    // Some code here...

    if (/*some error condition*/) {
        std::cout << "An error occurred." << std::endl;
        std::exit(1);
    }

    // More code here...
}

int main() {
    some_function();

    // Some other code here...

    return 0; // Successful execution
}

В обоих приведенных выше примерах программа возвращает коды завершения в зависимости от различных ошибок, возникших во время выполнения. Коды 1 и 2 используются для различения двух 
состояний ошибки.

______________________________________________________________________________________
Нарушения доступа (Access Violations)

Нарушение прав доступа — это особый тип ошибки, возникающий, когда программа пытается получить доступ к недопустимой области памяти. В C++ нарушения прав доступа чаще всего вызываются:

1) Разыменование нулевого или недопустимого указателя:

int *p = nullptr;
int x = *p;  // Нарушение доступа: попытка получить доступ к содержимому нулевого указателя

2) Доступ к массиву за пределами границ:

int arr[5] = {1, 2, 3, 4, 5};
int y = arr[5];  // Нарушение доступа: индекс выходит за границы (допустимые индексы 0-4)

3) Чтение или запись в память, освобожденную пользователем или операционной системой:

int* p2 = new int[10];
delete[] p2;
p2[3] = 42;  // Нарушение доступа: запись в память, которая была освобождена

Отладка нарушений прав доступа

Такие инструменты, как отладчики, статические анализаторы и профилировщики, могут помочь выявить нарушения прав доступа в вашем коде. Например:

Microsoft Visual Studio : используйте встроенный отладчик, чтобы определить строку кода, ответственную за ошибку нарушения прав доступа.

Valgrind : популярный инструмент Linux, который обнаруживает утечки памяти и нарушения доступа в ваших программах на C++.

AddressSanitizer : детектор ошибок памяти во время выполнения для C++, который может обнаруживать доступ за пределами границ, утечки памяти и ошибки использования после освобождения.


______________________________________________________________________________________
Теория: зачем нужен вызов throw без аргумента?

Если мы хотим наше исключение перепробросить на уровенть catch выше текущего, то мы вызываем throw без аргумента, в следующий блок try catch.

int main() {
	try {
		try {
			std::cout << "first catch" << std::endl;
			throw 1; 					// Симуляция вызова исключения
		}
		catch (...) {
			throw; 						// В обработке исключения перепробрасываем исключение на вверх
		}
	}
	catch (...) {
		std::cout << "last catch" << std::endl; 		// Обработка исключения
	}
	return 0;
}


______________________________________________________________________________________

