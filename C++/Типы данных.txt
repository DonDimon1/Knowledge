Память программы

В C++ можно использовать различные типы объектов, которые различаются по использованию памяти. Так, глобальные объекты создаются при запуске программы и освобождаются при ее завершении. Локальные 
автоматические объекты создаются в блоке кода и удаляются, когда этот блок кода завершает работу. Локальные статические объекты создаются перед их первым использованием и освобождаются при завершении 
программы.

Глобальные, а также статические локальные объекты помещаются в статической памяти, а локальные автоматические объекты размещаются в стеке. Объекты в статической памяти и стеке создаются и удаляются 
компилятором. Статическая память очищается при завершении программы, а объекты из стека существуют, пока выполняется блок, в котором они определены. Когда блок завершает выполнение, то память в стеке, 
отведенная для переменных блока, освобождается. Стоит отметить, что память, выделяемая для стека, имеет ограниченный фиксированный размер.

В дополнение к этим типам в C++ можно создавать динамические объекты. Продолжительность их жизни не зависит от того, где они созданы. Динамические объекты существуют, пока не будут удалены явным образом.
Динамические объекты размещаются в динамической памяти (free store). Это область памяти, не занятая операционной системой или другими загруженными в данный момент программами. Использование динамических 
объектов имеет ряд преимуществ. Во-первых, более эффективное использование памяти - выделяется имеенно столько места, сколько необходимо, а после использования сразу освобождается. Во-вторых, мы можем 
использовать гораздо больший объем памяти, который в ином случае был бы не доступен. Но это и накладывает ограничения: мы должны следить, чтобы все динамические объекты были удалены.

Оператор new выделяет место в динамической памяти для объекта и возвращает указатель на этот объект.
Оператор delete получает указатель на динамический объект и удаляет его из памяти.


______________________________________________________________________________________
Статическая типизация

В C++ статическая типизация означает, что тип данных переменной определяется во время компиляции перед выполнением программы. Это означает, что переменную можно использовать только с 
данными определенного типа, и компилятор гарантирует, что операции, выполняемые с переменной, совместимы с ее типом. Если есть несоответствие, компилятор скорректирует тип данных 
переменной, чтобы он соответствовал другому, если это возможно. Этот процесс известен как Type Conversion. Если компилятору не удастся выполнить преобразование типов, 
Invalid Type Conversionво время компиляции кода возникнет ошибка.

C++ — это статически типизированный язык, а это означает, что он использует статическую типизацию для определения типов данных и выполнения проверки типов во время компиляции. Это помогает обеспечить 
безопасность типов и предотвратить возникновение определенных типов ошибок во время выполнения программы.

Вот простой пример кода, демонстрирующий статическую типизацию на C++:

#include <iostream>

int main() {
    int num = 65;        // 'num' is statically typed as an integer
    double pi = 3.14159; // 'pi' is statically typed as a double
    char c = 'c';        // 'c' is statically typed as a char

    c = num;    // This asssigment would convert num's value to ASCII equivalent character
    num = pi; // This assignment would convert pi's value from double type to int type
    
    std::cout << "The value of num is: " << num << std::endl;
    std::cout << "The value of pi is: " << pi << std::endl;
    std::cout << "The value of c is: "<< c << std::endl;
    return 0;
}

В приведенном выше коде переменная num статически типизирована как int, pi статически типизирована как a double и c статически типизирована как char. Если вы попытаетесь pi присвоить 
значение num, значение 3.14159 будет преобразовано в целое число 3 и присвоено num. Аналогично, когда значение num присваивается c, компилятор преобразует это значение 65 в 
соответствующий код ASCII , то есть A.


______________________________________________________________________________________
Динамическая типизация в C++

C++ известен как статически типизированный язык, что означает, что типы данных его переменных определяются во время компиляции. Однако C++ также предоставляет концепции определенного 
уровня динамической типизации , что означает определение типов данных переменных во время выполнения.

Вот краткий обзор двух способов достижения динамической типизации в C++:

1) void* Указатели

Указатель void*— это универсальный указатель, который может указывать на объекты любого типа данных. Их можно использовать для хранения ссылки на объект любого типа без знания 
конкретного типа объекта.
Пример:

#include <iostream>

int main() {
    int x = 42;
    float y = 3.14f;
    std::string z = "Hello, world!";

    void* void_ptr;

    void_ptr = &x;
    std::cout << "int value: " << *(static_cast<int*>(void_ptr)) << std::endl;

    void_ptr = &y;
    std::cout << "float value: " << *(static_cast<float*>(void_ptr)) << std::endl;

    void_ptr = &z;
    std::cout << "string value: " << *(static_cast<std::string*>(void_ptr)) << std::endl;

    return 0;
}

2) std::any(С++17)
В C++17 появился std::anyкласс, который представляет собой обобщенный типобезопасный контейнер для отдельных значений любого типа.

Пример:

#include <iostream>
#include <any>

int main() {
    std::any any_value;

    any_value = 42;
    std::cout << "int value: " << std::any_cast<int>(any_value) << std::endl;

    any_value = 3.14;
    std::cout << "double value: " << std::any_cast<double>(any_value) << std::endl;

    any_value = std::string("Hello, world!");
    std::cout << "string value: " << std::any_cast<std::string>(any_value) << std::endl;

    return 0;
}
Имейте в виду, что оба void* указателя и std::any влияют на производительность из-за дополнительной проверки типов и приведения типов, которые происходят во время выполнения. Их 
следует использовать осторожно и только в случае крайней необходимости.


______________________________________________________________________________________
Идентификация типа во время выполнения (RTTI)

Идентификация типа во время выполнения (RTTI) — это функция C++, которая позволяет получать информацию о типе объекта во время выполнения программы. Это может быть полезно при 
использовании динамической типизации, когда тип объекта может меняться во время выполнения.

В C++ существует два основных механизма RTTI:

1) typeid оператор

typeid— оператор, возвращающий ссылку на объект типа std::type_info, содержащую информацию о типе объекта. Для использования заголовочный файл <typeinfo> должен быть включен typeid.

Вот пример:

#include <iostream>
#include <typeinfo>

class Base { virtual void dummy() {} };
class Derived : public Base { /* ... */ };

int main() {
    Base* base_ptr = new Derived;

    // Using typeid to get the type of the object
    std::cout << "Type: " << typeid(*base_ptr).name() << '\n';

    delete base_ptr;
    return 0;
}


2) оператор динамического_приведения

dynamic_cast— это оператор приведения типов, который выполняет проверку типа во время выполнения и безопасно понижает базовый указатель или ссылку до производного указателя или ссылки.
Он возвращает значение null или выдает исключение bad_cast (если приведение ссылается) в случае сбоя приведения.

Вот пример:

#include <iostream>

class Base { virtual void dummy() {} };
class Derived1 : public Base { /* ... */ };
class Derived2 : public Base { /* ... */ };

int main() {
    Base* base_ptr = new Derived1;

    // Using dynamic_cast to safely downcast the pointer
    Derived1* derived1_ptr = dynamic_cast<Derived1*>(base_ptr);
    if (derived1_ptr) {
        std::cout << "Downcast to Derived1 successful\n";
    }
    else {
        std::cout << "Downcast to Derived1 failed\n";
    }

    Derived2* derived2_ptr = dynamic_cast<Derived2*>(base_ptr);
    if (derived2_ptr) {
        std::cout << "Downcast to Derived2 successful\n";
    }
    else {
        std::cout << "Downcast to Derived2 failed\n";
    }

    delete base_ptr;
    return 0;
}

Обратите внимание, что использование RTTI может привести к некоторым издержкам производительности, поскольку требует хранения и обработки дополнительной информации, сгенерированной 
компилятором, во время выполнения.

______________________________________________________________________________________
Приведение типов

Приведение типов — это процесс преобразования значения из одного типа данных в другой. В C++ существует четыре различных метода приведения типов:

1) Приведение в стиле C : это синтаксис, унаследованный от C, и он выполняется путем простого помещения целевого типа данных в круглые скобки перед приводимым значением. Пример:

int a = 10;
float b = (float)a;


2) static_cast: это наиболее часто используемый метод приведения типов в C++. Он выполняется во время компиляции, и его следует использовать, когда у вас есть явное преобразование 
между типами данных. Этот тип приведения выполняет проверку во время компиляции и выдает ошибку, если допустимое преобразование между заданными типами невозможно. static_cast обычно 
безопаснее, чем приведение в стиле C, поскольку оно не выполняет небезопасную реинтерпретацию данных и позволяет лучше проверять типы.
Пример:

int a = 10;
float b = static_cast<float>(a);


3) dynamic_cast: этот метод специально используется для безопасного преобразования указателей и ссылок между базовыми и производными классами в иерархии классов. Это тип оператора 
приведения в C++, который используется специально для полиморфизма. 
Пример:

class Base {};
class Derived : public Base {};

Base* base_ptr = new Derived();
Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr);


4) reinterpret_cast: это приведение изменяет тип указателя, ссылки или целочисленного значения. Его также называют побитовым приведением, поскольку оно меняет способ интерпретации 
компилятором базовых битов. это тип приведения в C++, который позволяет изменять тип указателя или целого числа без изменения представления данных. Обычно он используется, когда 
требуемое преобразование слишком низкоуровневое или не поддерживается другими методами приведения, такими как static_cast. Используйте его reinterpret_castтолько в том случае, если у 
вас есть глубокое понимание того, что вы делаете, поскольку это не гарантирует, что полученное значение будет иметь смысл. 
Пример:

int* a = new int(42);
long b = reinterpret_cast<long>(a);


5) const_cast: этот метод приведения позволяет удалять или добавлять константность переменной. Другими словами, он позволяет вам модифицировать объект const или volatile или изменить
указатель или ссылку на тип const или volatile. Это полезно в определенных сценариях, когда вам нужно передать constпеременную в качестве аргумента или когда параметр функции требует 
неконстантного типа, но вы хотите, чтобы переменная оставалась постоянной во всем коде.Обычно это не рекомендуется, но может быть полезно в определенных ситуациях, когда вы не можете 
контролировать константность переменной.
Пример:

const int a = 10;
int* ptr = const_cast<int*>(&a);  // const_cast from const int* to int*
*ptr = 20;  // Not recommended, use with caution


______________________________________________________________________________________
Сколько в памяти занимает произвольная структура?

Зависит от платформы. Допустим у нас x32 и память у нас автоматически выравнивается и она будет кратна 32 битам. Например у нас не будет размер какой то структуры 11 байтам. 
Сайзоф пустого объекта считается 1.


























