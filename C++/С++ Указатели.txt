Определение указателя:
Синтаксис указателя: тип_данных* название_указателя; 
int* p;
Такой указатель может хранить только адрес переменной типа int.
Пустой указатель: int* p{nullptr};

Получение адреса и оператор &:
С помощью операция & можно получить адрес некоторого объекта, например, адрес переменной. 
Затем этот адрес можно присвоить указателю:
int number {25};
int *pnumber {&number}; // указатель pnumber хранит адрес переменной number
cout << "number addr: " << pnumber << endl; //Адрес переменной number
cout << "pnumber addr: " << &pnumber << endl;//Адрес указателя pnumbe

Получение значения по адресу (*):
Но так как указатель хранит адрес, то мы можем по этому адресу получить хранящееся там значение, то есть значение 
переменной number. Для этого применяется операция разыменования * ("indirection operator" / "dereference operator"). 
Результатом этой операции всегда является объект, на который указывает указатель.
int number {25};
int *pnumber {&number};
cout << "Address = " << pnumber<< endl;//Получаем адрес number
cout << "Value = " << *pnumber << endl;//Получаем значение number

Значение, которое получено в результате операции разыменования, можно присвоить другой переменной:
int n1 {25};
int *pn1 {&n1}; // указатель pn1 хранит адрес переменной n1
int n2 { *pn1}; // n2 получает значение, которое хранится по адресу в pn1
cout << "n2 = " << n2 << endl;  // n2=25

И также используя указатель, мы можем менять значение по адресу, который хранится в указателе:
int x = 10;
int *px = &x;
*px = 45;
cout << "x = " << x << endl;     // 45

Адрес указателя
Указатель хранит адрес переменной, и по этому адресу мы можем получить значение этой переменной. Но кроме того, указатель, как и любая переменная, сам имеет адрес, по которому 
он располагается в памяти. Этот адрес можно получить также через операцию &:
int a {10};
int *pa {&a};
std::cout << "address of pointer=" << &pa << std::endl;        // адрес указателя
std::cout << "address stored in pointer=" << pa << std::endl;  // адрес, который хранится в указателе - адрес переменной a         
std::cout << "value on pointer=" << *pa << std::endl;          // значение по адресу в указателе - значение переменной a

int* const - константный указатель на nt
const int* - казатель на const int
const int* const - константный указатель на const int



______________________________________________________________________________________
Константы и указатели



Указатели НА константы

Указатели могут указывать как на переменные, так и на константы. Чтобы определить указатель на константу, он тоже должен объявляться с ключевым словом const:

const int a {10};
const int *pa {&a};
std::cout << "address=" << pa << "\tvalue=" << *pa << std::endl;

Здесь указатель pa указывает на константу a. Поэтому даже если мы захотим изменить значение по адресу, который хранится в указателе, мы не сможем это сделать, например так:

*pa = 34; // Ошибка

В этом случае мы просто получим ошибку во время компиляции.

Возможна также ситуация, когда указатель на константу на самом деле указывает на переменную:

int a {10};
const int *pa {&a};
std::cout <<"value=" << *pa << std::endl;     // value=10
a = 22;
std::cout <<"value=" << *pa << std::endl;     // value=22
//*pa = 34;     			      // так делать нельзя

В этом случае переменную отдельно мы сможем изменять, однако по прежнему изменить ее значение через указатель мы не сможем.

Через указатель на константу мы не можем изменять значение переменной/константы. Но мы можем присвоить указателю адрес любой другой переменной или константы:

const int a {10};
const int *pa {&a};     			// указатель указывает на константу a
const int b {45};
pa = &b;                			// указатель указывает на константу b
std::cout <<"*pa = " << *pa << std::endl;     	// *pa = 45
std::cout <<"a = " << a << std::endl;     	// a = 10 - константа a не изменяется



###########################

Константный указатель

От указателей на константы надо отличать константные указатели. Они не могут изменять адрес, который в них хранится, но могут изменять значение по этому адресу.

int a {10};
int *const pa {&a};
std::cout << "value=" << *pa << std::endl;      // value = 10
*pa = 22;                                       // меняем значение
std::cout << "value=" << *pa << std::endl;      // value = 22
   
int b {45};
// pa = &b;         так нельзя сделать



###########################
Константный указатель на константу

И объединение обоих предыдущих случаев - константный указатель на константу, который не позволяет менять ни хранимый в нем адрес, ни значение по этому адресу:

int a {10};
const int *const pa {&a};
 
//*pa = 22;  так сделать нельзя
 
int b {45};
// pa = &b;  так сделать нельзя 



###########################
Резюме:
const int a {10};

const int *pa {&a}; // Указатели НА константы. Могут указывать как на переменные, так и на константы. Нельзя изменять значение переменной/константы (*pa = 34). можем присвоить 
		    // 	   адрес любой другой переменной или константы (pa = &b).

int *const pb {&a}; // Константный указатель. Слово const переместилось вправо от int. Не могут изменять адрес, который в них хранится, но могут изменять значение по этому адресу.

const int *const pc {&a}; // Константный указатель на константу. const и слева и справа от int. Не позволяет менять ни хранимый в нем адрес, ни значение по этому адресу.




Короче, перед каким словом стоит const, то и const: (А походу нет, нужно разобраться в этой теме подробно.)

const int *pa {&a}; // const перед типом данных int, значит сами данные const, значит *pa это указатель на константу.

int *const pb {&a}; // Звёздочка указателя находится перед const, а сам const перед именем указателя pb, значит сам указатель const, значит это Константный указатель

const int *const pc {&a}; // const везде, значит это Константный указатель на константу.




______________________________________________________________________________________
Умные указатели

https://habr.com/ru/companies/piter/articles/706866/
Мне нравится рассматривать умные указатели как упаковки, в которых хранятся динамические данные. На самом деле это просто классы, которые оборачивают обычный указатель в свои недра и 
перегружают операторы -> и *. Благодаря этому трюку умный указатель имеет тот же синтаксис, что и обычный указатель. Когда умный указатель выходит из области видимости, срабатывает 
его деструктор и происходит очистка памяти. Эта техника называется Resource Acquisition Is Initialization (RAII): класс оборачивает динамический ресурс (файл, сокет, подключение к 
базе данных, выделенная память, ...), который должным образом удаляется/закрывается в своем деструкторе. Таким образом, вы гарантированно избежите утечки ресурсов.


Типы умных указателей в современном C++:

std::unique_ptr — умный указатель, владеющий динамически выделенным ресурсом;
std::shared_ptr — умный указатель, владеющий разделяемым динамически выделенным ресурсом. Несколько std::shared_ptr могут владеть одним и тем же ресурсом, и внутренний счетчик ведет 
	их учет;
std::weak_ptr — подобен std::shared_ptr, но не увеличивает счетчик.

Возможно, вы также слышали о std::auto_ptr. Это вещь из прошлого, теперь не рекомендуемая к использованию: забудьте о ней.


######################

Понимание std::unique_ptr: одиночный вариант

std::unique_ptr владеет объектом, на который он указывает, и никакие другие умные указатели не могут на него указывать. Когда std::unique_ptr выходит из области видимости, объект 
удаляется. Это полезно, когда вы работаете с временным, динамически выделенным ресурсом, который может быть уничтожен после выхода из области действия.


СОЗДАНИЕ

std::unique_ptr<Type> p(new Type); // Создание

Например:
std::unique_ptr<int>    p1(new int);
std::unique_ptr<int[]>  p2(new int[50]);
std::unique_ptr<Object> p3(new Object("Lamp"));

Также можно создать std::unique_ptrs с помощью специальной функции std::make_unique, вот так:
std::unique_ptr<Type> p = std::make_unique<Type>(...размер или параметры...);

Например:
std::unique_ptr<int>    p1 = std::make_unique<int>();
std::unique_ptr<int[]>  p2 = std::make_unique<int[]>(50);
std::unique_ptr<Object> p3 = std::make_unique<Object>("Lamp");

Если есть возможность, всегда старайтесь выделять объекты с помощью std::make_unique.


ПРИМЕНЕНИЕ

Главная особенность этого умного указателя — исчезать, когда он больше не используется.

void compute()
{
    std::unique_ptr<int[]> data = std::make_unique<int[]>(1024);
    /* выполнение некоторых значимых вычислений над вашими данными...*/
} // `data` выходит из области действия здесь: она автоматически уничтожается
int main()
{
    compute();
}

Умный указатель выходит из области видимости, когда функция compute() достигает конца тела. Вызывается деструктор указателя, и память очищается автоматически. Больше ни о чем 
волноваться не нужно.


ОДИН РЕСУРС, ОДИН std::unique_ptr

std::unique_ptr очень ревниво относится к динамическому объекту, который он хранит: невозможно иметь несколько ссылок на его динамические данные. Это сделано специально, и это важная 
особенность std::unique_ptr: на любой ресурс может указывать не более одного std::unique_ptr. Это предотвращает ошибочное многократное удаление указателя. Технически это происходит 
потому, что у std::unique_ptr нет конструктора копирования.

void compute(std::unique_ptr<int[]> p) { ... } 

int main()
{
    std::unique_ptr<int[]> ptr = std::make_unique<int[]>(1024);
    std::unique_ptr<int[]> ptr_copy = ptr; // ОШИБКА! Копирование запрещено
    compute(ptr);  // ОШИБКА! `ptr` передается копией, а копирование не разрешено
}


######################

Понимание std::shared_ptr: конвивиальный вариант

std::shared_ptr владеет объектом, на который он указывает, но, в отличие от std::unique_ptr, он допускает множественные ссылки. Специальный внутренний счетчик уменьшается каждый раз, 
когда std::shared_ptr, указывающий на тот же ресурс, выходит из области видимости. Эта техника называется подсчетом ссылок. Когда последняя из них будет уничтожена, счетчик станет 
равным нулю, и данные будут высвобождены. Умный указатель такого типа полезен, когда требуется обмениваться динамически распределенными данными, точно так же, как это делается с 
обычными указателями или ссылками.

В std::shared_ptr используется два основных счётчика: счётчик сильных ссылок (strong reference count) и счётчик слабых ссылок(weak reference count). 

Счётчик сильных ссылок увеличивается каждый раз, когда новый std::shared_ptr создаётся как копия другогоstd::shared_ptr или когда объект присваивается std::shared_ptr. Этот счётчик 
уменьшается, когда std::shared_ptr уничтожается или когда его значение присваивается другому объекту. Когда счётчик сильных ссылок достигает нуля, объект, на который указывает 
std::shared_ptr уничтожается.

Счётчик слабых ссылок используется вместе с указателем std::weak_ptr, который может ссылаться на объект, управляемый std::shared_ptr, но не увеличивая счётчик сильных ссылок. Слабые
ссылки не предотвращают удаления объекта, к которому они имеют доступ, т.к. не участвуют в владении объектом. Счётчик слабых ссылок увеличивается каждый раз, когда создаётся 
std::weak_ptr, указывающий на объект и уменьшается, когда такой std::weak_ptr уничтожается. Когда счётчик сильных ссылок достигает нуля и объект уничтожается, память, выделенная под
сам объект, освобождается, но "control block"(блок управления), содержащий счётчики, сохраняется до тех пор, пока счётчик слабых ссылок также не обнулится. 

СОЗДАНИЕ

std::shared_ptr<Type> p(new Type);

Например:
std::shared_ptr<int>    p1(new int);
std::shared_ptr<Object> p2(new Object("Lamp"));

Существует альтернативный способ создания std::shared_ptr, использующий специальную функциюstd::make_shared: 
std::shared_ptr<Type> p = std::make_shared<Type>(...parameters...);

Это должен быть наиболее предпочтительный способ построения такого рода умных указателей. При вызове этой функции происходит одно выделение памяти для данных и контролирующего блока умного указателя. 
В этом случае контролирующий блок и данные распологаются рядом (Однако это не 100% гаранития, что произойдёт только одно выделение памяти, но скорее всего). А при создании без этой функции (1ый вариант) 
произойдёт два выделения памяти.


ПРОБЛЕМЫ С МАССИВАМИ

До C++17 не было простого способа соорудить std::shared_ptr, хранящий массив. До C++17 этот умный указатель по умолчанию всегда вызывает delete (а не delete[]) на своем ресурсе: вы 
можете создать обходной путь, используя кастомное удаление. Один из многих конструкторов std::shared_ptr принимает в качестве второго параметра лямбду, в которой вы вручную удаляете 
принадлежащий ему объект. Например:

std::shared_ptr<int[]> p2(new int[16], [] (int* i) { 
  delete[] i; // Кастомное удаление
});

К сожалению, нет возможности сделать это при использовании std::make_shared.


ПРИМЕНЕНИЕ

Одна из главных особенностей std::shared_ptr — возможность отслеживать, сколько указателей ссылаются на один и тот же ресурс. Получить информацию о количестве ссылок можно с помощью 
метода use_count().

void compute()
{
  std::shared_ptr<int> ptr = std::make_shared<int>(100);
  // ptr.use_count() == 1
  std::shared_ptr<int> ptr_copy = ptr;   // Сделать копию: с shared_ptr возможно!
  // ptr.use_count() == 2
  // ptr_copy.use_count() == 2, в конце концов, это одни и те же базовые данные.
} // Здесь `ptr` и `ptr_copy` выходят из области действия. Больше никаких ссылок  
  // исходные данные (т.е. use_count() == 0), поэтому они автоматически убираются.
int main()
{
  compute();
}

Обратите внимание, как ptr и ptr_copy выходят из области видимости в конце функции, доводя счетчик ссылок до нуля. В этот момент деструктор последнего объекта обнаруживает, что 
ссылок больше нет, и запускает очистку памяти.


ОДИН РЕСУРСБ МНОГО std::shared_ptr. НЕ ЗАБЫВАЙТЕ О ЦИКЛИЧЕСКИХ ССЫЛКАХ!

Сила множественных ссылок может привести к неприятным сюрпризам. Скажем, я пишу игру, в которой у игрока есть другой игрок в качестве компаньона, например, так:

struct Player
{
  std::shared_ptr<Player> companion;
  ~Player() { std::cout << "~Player\n"; }
};

int main()
{
  std::shared_ptr<Player> jasmine = std::make_shared<Player>();
  std::shared_ptr<Player> albert  = std::make_shared<Player>();

  jasmine->companion = albert; // (1)
  albert->companion  = jasmine; // (2)
}

Логично, не так ли? К сожалению, я только что создал так называемую круговую ссылку. В начале моей программы я создаю два умных указателя jasmine и albert, которые хранят динамически 
создаваемые объекты: назовем эти динамические данные jasmine-data и albert-data, чтобы было понятнее. Затем в (1) я передаю jasmine указатель на albert-data, а в (2) albert хранит 
указатель на jasmine-data. Это все равно что дать каждому игроку компаньона. Когда jasmine выходит из области видимости в конце программы, ее деструктор не может очистить память: все 
еще есть один умный указатель, указывающий на jasmine-data, это albert->companion. Аналогично, когда albert выходит из области видимости в конце программы, его деструктор не может 
очистить память: ссылка на albert-data все еще живет через jasmine->companion. В этот момент программа просто завершается, не освободив память: утечка памяти во всем ее великолепии. 
Если вы запустите приведенный выше фрагмент, то заметите, что ~Player() никогда не будет вызван. Это не такая большая проблема, так как операционная система позаботится об очистке 
памяти за вас. Однако вам не стоит иметь такие круговые зависимости (т.е. утечки памяти) в середине вашей программы. К счастью, на помощь придет последний тип умного указателя.


######################

Понимание std::weak_ptr: поверхностный вариант

std::weak_ptr — это, по сути, std::shared_ptr, который не увеличивает счетчик ссылок. Он определяется как умный указатель, который содержит несобственную ссылку, или ослабленную 
ссылку, на объект, управляемый другим std::shared_ptr. Этот умный указатель полезен для решения некоторых раздражающих проблем, которые нельзя решить с помощью необработанных 
указателей.


СОЗДАНИЕ

Вы можете создать std::weak_ptr только из std::shared_ptr или другого std::weak_ptr. Например:
std::shared_ptr<int> p_shared = std::make_shared<int>(100);
std::weak_ptr<int>   p_weak1(p_shared);
std::weak_ptr<int>   p_weak2(p_weak1);

В приведенном выше примере p_weak1 и p_weak2 указывают на одни и те же динамические данные, принадлежащие p_shared, но счетчик ссылок не растет.


ПРИМЕНЕНИЕ

std::weak_ptr является своего рода инспектором для std::shared_ptr от которого он зависит. Вы должны сначала преобразовать его в std::shared_ptr с помощью метода lock() если вы 
действительно хотите работать с реальным объектом:

std::shared_ptr<int> p_shared = std::make_shared<int>(100);
std::weak_ptr<int>   p_weak(p_shared);
// ...
std::shared_ptr<int> p_shared_orig = p_weak.lock();
//

Конечно, p_shared_orig может быть нулевым в случае, если p_shared был удален в другом месте.


std::weak_ptr РЕШАЕТ ПРОБЛЕМЫ

С помощью std::weak_ptr очень легко решить проблему висящих указателей — тех, которые указывают на уже удаленные данные. Он предоставляет метод expired(), который проверяет, был ли 
объект, на который ссылается ссылка, уже удален. Если expired() == true, исходный объект был где-то удален, и вы можете действовать соответствующим образом. Это то, что вы не можете 
сделать с необработанными указателями.

Как я уже говорил, std::weak_ptr также используется для разрыва циклической ссылки. Давайте вернемся к примеру Player, приведенному выше, и изменим переменную-член с std::shared_ptr 
companion на std::weak_ptr companion. В данном случае мы использовали std::weak_ptr для устранения запутанного владения. Фактически имкющиеся динамически выделяемые данные остаются в 
основном теле, в то время как каждый Player теперь имеет слабую ссылку на них. Запустите код с этим изменением, и вы увидите, что деструктор вызывается дважды, правильно.


######################

Заключительные заметки и мысли об умных указателях


Мне нравятся умные указатели. Должен ли я навсегда избавиться от new/delete?

Иногда вы действительно хотите полагаться на двойников new/delete, например:
когда вам нужно кастомное удаление, как мы видели ранее, когда мы добавили поддержку массивов в std::shared_ptr;
когда вы пишете собственные контейнеры и хотите вручную управлять памятью;
с помощью так называемой конструкции in-place, более известной как placement new: новый способ создания объекта на уже выделенной памяти. Более подробная информация здесь.


Работают ли умные указатели медленнее, чем обычные?

Согласно различным источникам (здесь и здесь), производительность умных указателей должна быть близка к производительности необработанных указателей. Небольшое снижение скорости может
 присутствовать в std::shared_ptr из-за внутреннего подсчета ссылок. В целом, есть некоторые накладные расходы, но они не должны сделать код медленным, если только вы не будете 
постоянно создавать и уничтожать умные указатели.


Рациональное обоснование std::make_unique и std::make_shared

Этот альтернативный способ построения умных указателей дает два преимущества. Во-первых, он позволяет нам забыть о ключевом слове new. При работе с умными указателями мы хотим 
избавиться от гнусной комбинации new/delete, верно? Во-вторых, это делает ваш код защищенным от исключений. Рассмотрим вызов функции, принимающей на вход два умных указателя, 
следующим образом:

void function(std::unique_ptr<A>(new A()), std::unique_ptr<B>(new B())) { ... }

Предположим, что new A() выполняется успешно, но new B() выбрасывает исключение: вы ловите его, чтобы возобновить нормальное выполнение программы. К сожалению, стандарт C++ не 
требует, чтобы объект A был уничтожен, а его память высвобождена: память тихо утекает, и нет способа ее очистить. Обернув A и B в std::make_unique, вы будете уверены, что утечка не 
произойдет:

void function(std::make_unique<A>(), std::make_unique<B>()) { ... }

Дело в том, что std::make_unique<А> и std::make_unique<В> теперь являются временными объектами, а очистка временных объектов правильно указана в стандарте C++: их деструкторы будут 
вызваны и память освобождена. Поэтому, если есть возможность, всегда предпочитайте выделять объекты с помощью std::make_unique и std::make_shared.































