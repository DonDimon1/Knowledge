Многопоточность | Потоки | thread

Когды мы запускаем любую программу, ОС создаёт процесс, который является некой абстрактной оболочкой, которая разграничивает ресурсы этой программы от каких то других программ,
которые выполняются в этой же системе. Процесс сам по себе ничего не делает, но он содержит в себе потоки. Как минимум в процессе должен быть хотябы один поток, потому что в
конкретном потоке происходит выполнение всей той логики программы. Поток определяет последовательность выполнения кода. С помощью создания дополнительных потоков и передачи в 
них части какой то логики программы, мы можем обеспечит выполнение нашего кода не последовательно, а параллельно (асинхронно), таким способом ускорить выполнение нашей программы.
Для этого должны быть в наличии аппаратные ресурсы, поскольку сам поток, его создание и обслуживание тоже требует ресурсов. Поэтому если задача простая и лёгкая, то не имеет 
смысла выделять под неё какой то отдельный поток, даже если есть ресурсы. Но если есть задача, которая требует долго времени для её решения, то выделение такой задачи в 
отдельный поток имеет смысл (в некоторыйх случаях даже на одноядерном процессоре).

#include <thread> 		//Подключаем многопоточность
#include <chrono> 		//Работа со временем (для сравнения времени выполнения).

В библиотеке thread уже встроен функционал библиотеки chrono, поэтому chrono нужно подключать только тогда, когда нам не нужны потоки, а нужно только время.

this_thread::get_id(); 		//Получение индефикатора потока, для того чтобы отличить один поток от другого
this_thread::sleep_for(); 	//Приостанавливает работу текущего потока на определённый период времени.
Например вот так:
this_thread::sleep_for(chrono::milliseconds(1000)); //Преостанавливает работу на 1000 милисекунд (1 секунда)

Пример однопоточной прграммы:
void DoWork() { 									//Эмуляция сложной задачи.
    for (size_t i = 0; i < 10; i++)
    {
        cout << "ID потока = " << this_thread::get_id() << "\tDoWork\t" << i << endl; 	//Инфа о потоке
        this_thread::sleep_for(chrono::milliseconds(1000)); 				//Приостанавливает работу текущего потока на определённый период времени.
    }
}

int main()
{
    setlocale(LC_ALL, "Russian");
    
    DoWork();
    for (size_t i = 0; i < 10; i++)
    {
        cout << "ID потока = " << this_thread::get_id() << "\tmain\t" << i << endl; 	//Инфа о потоке
        this_thread::sleep_for(chrono::milliseconds(500)); 				//Приостанавливает работу текущего потока на определённый период времени.
    }

    return 0;
}

Программа выполняется линейно (последовательно). В main вызывается функция DoWork и пока она не закончит работу, цикл в main после вызова этой функции не начнёт свою работу.


Пример праллельного выполнения этих задач. С многопоточностью для выполнения цикла в main нам не нужно ждать пока выполнится функция DoWork. В этом коде выполнение функции 
DoWork и цикла в main идут параллельно.

void DoWork() { //Эмуляция сложной задачи
    for (size_t i = 0; i < 10; i++)
    {
        cout << "ID потока = " << this_thread::get_id() << "\tDoWork\t" << i << endl; 	//Инфа о потоке
        this_thread::sleep_for(chrono::milliseconds(1000)); 				//Приостанавливает работу текущего потока на определённый период времени.
    }
}

int main()
{
    setlocale(LC_ALL, "Russian");
    
    thread th(DoWork);  					//Экземпляр потока. В параметрах мы указываем указатель на функцию, которая будет выполняться параллельно 
                        					//(не вызываем функцию, а передаём указатель на неё. Имя функции это и есть указать на функцию).

    for (size_t i = 0; i < 10; i++)
    {
        cout << "ID потока = " << this_thread::get_id() << "\tmain\t" << i << endl; 	//Инфа о потоке
        this_thread::sleep_for(chrono::milliseconds(500)); 				//Приостанавливает работу текущего потока на определённый период времени.
    }
	
    th.join(); 										//Позволяет дождаться той задачи, которую мы поставили в отдельном потоке.
    return 0;
}


Когда мы создаём объект th, типа thread, у нас создаётся объект th и создаётся новый системный поток. Этот новый системный поток связан с этим объектом. Для того чтобы избежать
ошибок во время выполнения программы, нам нужно определиться что нам делать с этим потоком и с этим объектом, какое у него должно быть поведение. Для этого существует методы
detach и join.

th.detach(); //Разрыв связи между объектом th и тем потоком, который начал выполняться.

С помощью этого метода мы можем сообщить потоку что он может выполняться самостоятельно, не привязываясь ни к чему. Однако в тот момент, когда заканчивает работу наш основной 
поток в функции main (завершение программы), прекращают работу и все остальные потоки. И тот поток, у которого мы вызвали метод detach, наша программа не будет дожидаться его
завершения. Поток просто закроется, не выполнившись до конца, что может привести к неопределённому поведению программы.


th.join(); //Позволяет дождаться той задачи, которую мы поставили в отдельном потоке.

Важно где нужно вызывать метод join. Если мы вызовем его, сразу после создания нового потока, то мы получим последовательную работу программы (потоков два, но они всё ровно 
будут выполняться последовательно, а не параллельно). Поэтому этот метод нужно вызывать в том месте, где мы хотим, чтобы программа дождалась выполнения этого потока. Когда 
программа доходит до метода join, основной поток тоже блокируется, и ждёт выполнения того потока, который мы создали.



______________________________________________________________________________________
Потоки с параметрами

Запуск функции с параметрами в отдельном потоке.

void DoWork(int a, int b) { 						//Эмуляция сложной задачи
	this_thread::sleep_for(chrono::milliseconds(3000));
	cout << "=========\tDoWork STARTED\t=========" << endl;
	this_thread::sleep_for(chrono::milliseconds(5000));
	cout << "a+b = " << a + b << endl;
	this_thread::sleep_for(chrono::milliseconds(3000));
	cout << "=========\tDoWork STOPPED\t=========" << endl;
}

int main()
{
	setlocale(LC_ALL, "Russian");

	thread th(DoWork,2,3); 						//Поток принимает указатель на функцию, а затем подряд её параметры.
	//DoWork(2, 3); 						//Обычный вариант вызова функции.

	for (size_t i = 0; true; i++)
	{
		cout << "ID потока = " << this_thread::get_id() << "\tmain works\t" << i << endl; 	//Инфа о потоке
		this_thread::sleep_for(chrono::milliseconds(500)); 					//Приостанавливает работу текущего потока на определённый период времени.
	}
	
	th.join();
	return 0;
}



______________________________________________________________________________________
Возврат результата из потока по ссылке

Наша функция не возвращает ничего. Для этого в отдельный поток нужно передать параметр по ссылке. В вызове отдельного потока с функцией, в которой есть параметр который
передаётся по ссылке, этот параметр мы должны указать так: std::ref(параметр). Функция ref(рефференс - ссылка). Задача этой функции создать класс reference_wrapper,
который позволяет нам работать с потоком, т.о. чтобы получить из него результат его работы через ссылку. 


void DoWork(int &a) { 											//Параметр передаётся по ссылке
	this_thread::sleep_for(chrono::milliseconds(3000));
	cout << "ID потока = " << this_thread::get_id() << "=========\tDoWork STARTED\t=========" << endl;
	this_thread::sleep_for(chrono::milliseconds(3000));
	a *= 2;
	cout << "ID потока = " << this_thread::get_id() << "=========\tDoWork STOPPED\t=========" << endl;
}

int main()
{
	setlocale(LC_ALL, "Russian");

	int q = 5;											//Параметр для функции DoWork

	thread t(DoWork, std::ref(q)); 									//Старт отдельного потока с параметром по ссылке.
	

	for (size_t i = 0; i < 8; i++)
	{
		cout << "ID потока = " << this_thread::get_id() << "\tmain works\t" << i << endl; 	
		this_thread::sleep_for(chrono::milliseconds(500)); 					
	}

	t.join();
	cout << q << endl;
	return 0;
}



______________________________________________________________________________________
Лямбда выражения и возврат результата выполнения потока

Допустим нам нужно запустить в отдельном потоке функцию Sum? которая возвращает тип int (не void). Как нам это сделать? Как вытянуть результат из потока? Никак. Для того чтобы 
решить эту проблему нам нужно использовать лямбда функцию (анонимную функцию). Создаём переменную для возврата и новый поток, запускаем в нём лямбда функцию, в контексте которой
указываем ссылку на нашу переменную возврата. В теле этой лямбда функции переменной возврата присваиваем работу функции Sum.


int Sum(int a, int b) {
	this_thread::sleep_for(chrono::milliseconds(3000));
	cout << "ID потока = " << this_thread::get_id() << "=========\tDoWork STARTED\t=========" << endl;
	this_thread::sleep_for(chrono::milliseconds(3000));
	cout << "ID потока = " << this_thread::get_id() << "=========\tDoWork STOPPED\t=========" << endl;
	return a + b;
}
int main()
{
	setlocale(LC_ALL, "Russian");

	int res; 					//Переменная для результата функции Sum, которая запускается в отдельном потоке.
	thread t([&res]() { 				//Создаём новый поток, помещаем в него лямбда функцию. Помещаем переменную res в контекст лямбда функции. 
		res = Sum(2, 5);  			//В теле лямбда функции переменной res присваиваем результат работы функции Sum(её возврат).
	}); 
	
	for (size_t i = 0; i < 10; i++)
	{
		cout << "id потока = " << this_thread::get_id() << "\tmain works\t" << i << endl; 	//инфа о потоке
		this_thread::sleep_for(chrono::milliseconds(500)); 					//приостанавливает работу текущего потока на определённый период времени.
	}
	t.join();
	cout << "Sum res = " << res << endl;								//Вывод результата работы функции Sum
	return 0;
}



______________________________________________________________________________________
Как измерить время выполнения кода

В библиотеке thread уже встроен функционал библиотеки chrono, поэтому chrono нужно подключать только тогда, когда нам не нужны потоки, а нужно только время.

Как узнать сколько времени работает код? Засеч время начала выполнения и конца выполнения, и вычесть разницу.

int main()
{
	setlocale(LC_ALL, "Russian");


	auto start = chrono::high_resolution_clock::now(); 						//Точка начала замера времени.

	for (size_t i = 0; i < 10; i++)
	{
		cout << "id потока = " << this_thread::get_id() << "\tmain works\t" << i << endl; 	//инфа о потоке
		this_thread::sleep_for(chrono::milliseconds(500)); 					//приостанавливает работу текущего потока на определённый период времени.
	}

	auto end = chrono::high_resolution_clock::now();						 //Точка конца замера времени.

	chrono::duration<float> duration = end - start;							//Вычисление времени выполнения кода
	cout << "Время выполнения кода: " << duration.count() << " сек" << endl; 			//Вывод времени выполнения кода в консоль

	return 0;
}



Функционал замера времени засоряет код, поэтому не плохо бы вынести его в отдельный класс.

class SimpleTimer {											//Класс замера времени
public:
	SimpleTimer() { 										//При создании объекта класса мы будем начинать замерять время
		start = std::chrono::high_resolution_clock::now(); 					//Точка начала замера времени.
	}
	~SimpleTimer() { 										//При удалении объекта будем заканчивать и вычислять затраченное время
		end = std::chrono::high_resolution_clock::now(); 					//Точка конца замера времени.
		std::chrono::duration<float> duration = end - start; 					//Вычисление времени выполнения кода
		cout << "Время выполнения кода: " << duration.count() << " сек" << endl; 		//Вывод времени выполнения кода в консоль
	}
private:
	std::chrono::time_point<std::chrono::steady_clock> start, end; 					//Переменные для старта и финиша.

};

int Sum(int a, int b) {
	this_thread::sleep_for(chrono::milliseconds(3000));
	cout << "ID потока = " << this_thread::get_id() << "=========\tDoWork STARTED\t=========" << endl;
	this_thread::sleep_for(chrono::milliseconds(3000));
	cout << "ID потока = " << this_thread::get_id() << "=========\tDoWork STOPPED\t=========" << endl;
	return a + b;
}

int main()
{
	SimpleTimer st; //Просто создаём объект класса, который будет считать время.

	setlocale(LC_ALL, "Russian");

	int res; 							//Переменная для результата функции Sum, которая запускается в отдельном потоке.
	thread t([&res]() { 						//Создаём новый поток, помещаем в него лямбда функцию. Помещаем переменную res в контекст лямбда функции. 
		res = Sum(2, 5);  					//В теле лямбда функции переменной res присваиваем результат работы функции Sum(её возврат).
		});

	for (size_t i = 0; i < 10; i++)
	{
		cout << "id потока = " << this_thread::get_id() << "\tmain works\t" << i << endl; 	//инфа о потоке
		this_thread::sleep_for(chrono::milliseconds(500)); 					//приостанавливает работу текущего потока на определённый период времени.
	}

	t.join();
	cout << "Sum res = " << res << endl;								//Вывод результата работы функции Sum
	return 0;
}



______________________________________________________________________________________
Потоки и методы класса | метод класса в потоке

Каким способом можно передавать методы класса в отдельный поток.

Если нам нужно вернуть значение из метода, который работает в отдельном потоке:

class MyClass {
public:
	int Sum(int a, int b) {							//Метод класса который возвращает a + b
		this_thread::sleep_for(chrono::milliseconds(3000));
		cout << "ID потока = " << this_thread::get_id() << "=========\tDoWork STARTED\t=========" << endl;
		this_thread::sleep_for(chrono::milliseconds(3000));
		cout << "ID потока = " << this_thread::get_id() << "=========\tDoWork STOPPED\t=========" << endl;
		return a + b;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	MyClass m;								//Объект класса.
	int res;								//Переменная для записи результата работы метода класса.

	thread t([&res, &m]() { 						//Передаём в поток лямбда функцию для получения результата(возврата) работы метода.
		res = m.Sum(2, 5);						//Присваиваем res результат (возврат) метода Sum.
	});

	for (size_t i = 0; i < 9; i++)
	{
		cout << "ID потока = " << this_thread::get_id() << "\tmain works\t" << i << endl;
		this_thread::sleep_for(chrono::milliseconds(500));
	}
	
	t.join();
	cout << "RES = " << res << endl;					//Вывод результата.
	return 0;
}


############
Если метод класса ничего не возвращает и ничего не принимает:

class MyClass {
public:
	void DoWork() {
		this_thread::sleep_for(chrono::milliseconds(3000));
		cout << "ID потока = " << this_thread::get_id() << "=========\tDoWork STARTED\t=========" << endl;
		this_thread::sleep_for(chrono::milliseconds(3000));
		cout << "ID потока = " << this_thread::get_id() << "=========\tDoWork STOPPED\t=========" << endl;
	};
};

int main()
{
	setlocale(LC_ALL, "Russian");

	MyClass m;
	int res;				

	//Первый вариант вызова метода через лямбда функцию:
	thread t([&m]() {
		m.DoWork();
	});

	//Второй вариант вызова метода:
	//thread t2(&MyClass::DoWork,m); //Пердостовляем потоку ссылку на объект класса и указываем какой метод мы будем вызывать, 2-ым параметром передать объект класса.

	for (size_t i = 0; i < 9; i++)
	{
		cout << "ID потока = " << this_thread::get_id() << "\tmain works\t" << i << endl;
		this_thread::sleep_for(chrono::milliseconds(500));
	}
	
	t.join();
	return 0;
}


############
Если метод ничего не возвращает, но принимает параметры:

class MyClass {
public:
	void DoWork2(int a) {
		this_thread::sleep_for(chrono::milliseconds(3000));
		cout << "ID потока = " << this_thread::get_id() << "=========\tDoWork STARTED\t=========" << endl;
		this_thread::sleep_for(chrono::milliseconds(3000));
		cout << "DoWork2 значение параметра\t" << a << endl;
		cout << "ID потока = " << this_thread::get_id() << "=========\tDoWork STOPPED\t=========" << endl;
	};
};

int main()
{
	setlocale(LC_ALL, "Russian");

	MyClass m;
	int res;				

	//Первый вариант вызова метода:
	thread t([&m]() {
		m.DoWork2(5);
	});

	//Второй вариант вызова метода:		//Пердостовляем потоку ссылку на объект класса и указываем какой метод мы будем вызывать, 2-ым параметром передать объект класса,
	//thread t2(&MyClass::DoWork2,m, 5); 	//3-им параметром передаём параметр для методка класса.

	for (size_t i = 0; i < 9; i++)
	{
		cout << "ID потока = " << this_thread::get_id() << "\tmain works\t" << i << endl;
		this_thread::sleep_for(chrono::milliseconds(500));
	}
	
	t.join();
	return 0;
}


Коментарии под видео:

Все хорошо, но уточню- вы в лямбду передаете не объект, а копию объекта в этой записи thread t(&MyClass::DoWork, m). Если мы хотим работать с имеющимся объектом, то передавать 
следует по ссылке то есть thread t(&MyClass::DoWork, &m). Это можно проверить выводом адреса m в main и this из вызова метода например вот так: cout << (void*)&m << endl.

Вместо ссылок лучше использовать функции-обертки ref и cref из заголовочного файла functional. Cо ссылками могут возникать проблемы, в ряде случаев компилятор будет ругаться и 
выдавать ошибки. Вот так надо: thread t(&MyClass::DoWork, std::ref(m)).



______________________________________________________________________________________
Что такое mutex | Cинхронизация потоков

Защита разделяемых данных, которые используются разными потоками. Если потоки будут обращаться к разделяемому ресурсу без регламента, то ресурс превратиться в не пойми во что.
Пример ошибки: если один поток удаляет элемент списка, а второй одновременно с первым считывает кол-во всех элементов списка, то получится некорректная информация.
Для синхронизации потоков используются mutex, он указывает что ресурс сейчас занят и ни кто другой не может обратиться к нему ещё. Т.е. пока один поток работает с ресурсом,
другие потоки не могут получить доступ к этому ресурсу, потому что мютекс не даёт этого сделать. Однако по этому, момент синхронизации - это узкое место по скорости нашей
программы (скорость падает), потому что к коду, защищённому мьютексом, может получить доступ только один поток.
 
#include <mutex> //Для использовани mutex

С помощью мьютекса нужно указать ту часть кода, которая должна работать только с одним потоком, чтобы мьютекс её защищал.

У объекта класса мьютекс есть два метода: lock() и unlock(). Где lock() - где доступ закрывается, unlock() - доступ открывается.

Задача: Вывести в консоль два прямоугольника, заполненые * и # соответственно, используя два потока. В этом случае общим ресурсом считается консоль, её нужно защитить, чтобы
данные вывелись корректно.

#include <iostream>							//Работа с консолью
#include <thread> 							//Подключаем многопоточность
#include <mutex> 							//Для использовани mutex

using namespace std;

mutex mtx;

void Print(char ch) {							//Функция для отрисовки прямоугольника
	this_thread::sleep_for(chrono::milliseconds(2000)); 		//Эмуляция тяжёлого кода. Многопоток работает. Здесь получаем выигрыш в производительности.

	mtx.lock();							//Этот участок кода может использоваться только одним потоком.

	for (int i = 0; i < 5; i++){
		for (int i = 0; i < 10; i++){
			cout << ch;
			this_thread::sleep_for(chrono::milliseconds(12));
		}
		cout << endl;
	}
	cout << endl;

	mtx.unlock(); 							//Однопоточный участок кода закончен.

	this_thread::sleep_for(chrono::milliseconds(2000)); 		//Эмуляция тяжёлого кода. Многопоток работает. Здесь получаем выигрыш в производительности.
}

int main()
{
	setlocale(LC_ALL, "Russian");

	//Запуск в одном потоке. Всё работает нормально:
	//Print('*');
	//Print('#');

	//Запуск в двух потоках.
	thread t1(Print, '*');
	thread t2(Print, '#');

	t1.join();
	t2.join();

	return 0;
}

Коментарии под видео:

Участки кода с mutex почти всегда можно оптимизировать, чтобы не было больших задержек. Вот как, например, в этом уроке можно было бы сохранить сначала весь текст прямоугольника
и только потом обращаться к консоли. Если код вызывает слишком большую задержу, то и не грех пожертвовать немного оперативной памятью, я считаю.



______________________________________________________________________________________
lock_guard mutex

lock_guard это класс, задача которого захватить мьютекс в конструкторе, при создании объекта такого класса, и освободить этот мьютекс в деструкторе, в тот момент, когда объект
этого класса будет покидать какую либо область видимости. Т.е. при создании объекта вызывается mutex.lock(), при удалении mutex.unlock(). Это нужно для автоматизации 
освобождения мьютекса (чтобы не забыть заблокировать или разблокировать мьютекс). Если в каком то месте кода, аж до выхода из зоны видимости (например функция), нужно 
использовать мьютекс, то lock_guard идеально для этого подходит. 


#include <iostream>							//Работа с консолью
#include <thread> 							//Подключаем многопоточность
#include <mutex> 							//Для использовани mutex

using namespace std;

mutex mtx;

void Print(char ch) {							//Функция для отрисовки прямоугольника

	lock_guard<mutex> guard(mtx); 					//Автоматически захватывает и освобождает мьютекст

	for (int i = 0; i < 5; i++){
		for (int i = 0; i < 10; i++){
			cout << ch;
			this_thread::sleep_for(chrono::milliseconds(12));
		}
		cout << endl;
	}
	cout << endl;
}

int main()
{
	setlocale(LC_ALL, "Russian");

	//Запуск в одном потоке. Всё работает нормально:
	//Print('*');
	//Print('#');

	//Запуск в двух потоках.
	thread t1(Print, '*');
	thread t2(Print, '#');

	t1.join();
	t2.join();

	return 0;
}

Т.е. объект guard класса lock_guard работает до вызова его деструктора, в нашем случае до конца функции Print. Однако что если защищать мьютексом нам нужно не до конца функции?
1) использовать обычный мьютекс как в уроке выше. 2) использовать скобки:

void Print(char ch) {	//Функция для отрисовки прямоугольника

	this_thread::sleep_for(chrono::milliseconds(2000)); 	//Эмуляция тяжёлого кода. Многопоток работает

	{
		lock_guard<mutex> guard(mtx); 			//Автоматически захватывает и освобождает мьютекст

		for (int i = 0; i < 5; i++){
			for (int i = 0; i < 10; i++){
				cout << ch;
				this_thread::sleep_for(chrono::milliseconds(12));
			}
			cout << endl;
		}
		cout << endl;
	}							//Конец зоны видимости lock_guard

	this_thread::sleep_for(chrono::milliseconds(2000)); 	//Эмуляция тяжёлого кода. Многопоток работает

}



______________________________________________________________________________________
recursive_mutex | Рекурсивный мьютекс

Если нам по какой то причине нужно несколько раз выполнить захват мьютекса.

mutex m;

m.lock();
//m.lock(); //Два раза один и тот же мьютекс нельзя схватить, это приведёт к ошибке.

m.unlock();


Рекурсивный мьютекс можно захватывать столько раз, сколько нам нужно.

recursive_mutex rm;

rm.lock(); 
rm.lock();
rm.lock(); //Не вызовет ошибки

rm.unlock();
rm.unlock();
rm.unlock(); //Нужно освободить столько же раз сколько и захватили.




Пример: вывод в консоль числе в обратном порядке с помощью рекурсии:

void Foo(int a) { 							//Рекурсивная фун. выводящая числа в обратном порядке.
	cout << a << " ";		

	this_thread::sleep_for(chrono::milliseconds(200));

	if (a <= 1) {
		cout << endl;
		return;
	}
	a--;
	Foo(a);
}

int main()
{
	setlocale(LC_ALL, "Russian");

	thread t1(Foo,10);						//Мы ни как не синхронизируем потоки поэтому в консоли будет рандомный вывод. Это плохо.
	this_thread::sleep_for(chrono::milliseconds(200));
	thread t2(Foo,10);						//Вывод: 10 9 10 8 9 7 8 6 7 5 6 4 5 3 4 2 3 1 2

	t1.join();
	t2.join();
	return 0;				
}



Попробуюем синхронизировать потоки через обычный мьютекс:

mutex m;

void Foo(int a) { 							//Рекурсивная фун. выводящая числа в обратном порядке.
	m.lock();							//Заблокировать поток. Во втором заходе рекурсии поток уже заблокирован. Вызов ошибки.
	cout << a << " ";

	this_thread::sleep_for(chrono::milliseconds(200));

	if (a <= 1) {
		cout << endl;
		m.unlock();						//Разблокировать поток
		return;
	}
	a--;
	Foo(a);								//Вызывается функция во второй раз
	m.unlock(); 							//Разблокировать поток
}



Поэтому для рекурсии нам нужен рекурсивный мьютекс:

recursive_mutex rm; 							//Рекурсивный мьютекс

void Foo(int a) { 							//Рекурсивная фун. выводящая числа в обратном порядке.
	rm.lock();							//Блокируем поток при каждом заходе в рекурсию.
	cout << a << " ";

	this_thread::sleep_for(chrono::milliseconds(200));

	if (a <= 1) {
		cout << endl;
		rm.unlock();						//Разблокировать поток при условии выхода из рекурсии.
		return;
	}
	a--;
	Foo(a);
	rm.unlock(); 							//Разблокировать поток при каждом выходе из рекурсии.
}

int main()
{
	setlocale(LC_ALL, "Russian");

	thread t1(Foo,10);
	this_thread::sleep_for(chrono::milliseconds(200));
	thread t2(Foo,10);

	t1.join();							//В результате получим: 10 9 8 7 6 5 4 3 2 1
	t2.join();							//			10 9 8 7 6 5 4 3 2 1
	return 0;
}


Коментарии под видео:
Не знаю писали ли кто то уже или нет. Можно упростить код с помощью
lock_guard lg(rm); // В 17 стандарте тип мьютекса сам задедьюсится
И не нужны будут оба вызова unlock

точнее lock_guard<recursive_mutex> lg(rm);

А почему нельзя обычный мьютекс разблочить перед вызовом функции, а не после нее, вроде бы все также корректно отрабатывает

Потому что второй поток может успеть занять полностью разлоченный мьютекс и влезть в вывод. И так дальше до самого конца - кто кого перегонит после разлока перед вызовом новой 
функции. Если же поставить разлок в конце, то все разлоки произойдут по сути друг за другом, и только тогда второй поток сможет занять мьютекс




______________________________________________________________________________________
unique_lock mutex | unique_lock vs lock_guard

lock_guard захватывае мьютекс сразу при создании объекта такого класса, и отпускает при вызове деструктора lock_guard. Однако если нам нужно захватить только часть кода, 
использовавние lock_guard может быть не удобным и не оптимальным. Примеры:

		Обычный mutex										lock_guard	

void Print(char ch) {							|	void Print(char ch) {
									|
	Здесь оптимально параллельное вычислениею			|		Здесь оптимально параллельное вычислениею
	Здесь и используется парралельное вычисление.			|		Здесь и используется парралельное вычисление.
									|		
	mutex1.lock();							|		lock_guard<mutex> guard(mtx);
									|
	Здесь только в одном потоке.					|		Здесь только в одном потоке.
	Здесь и есть один поток.					|		Здесь и есть один поток.
									|
	mutex1.unlock();						|		
									|
	Здесь оптимально параллельное вычисление			|		Здесь оптимально параллельное вычисление.
	Здесь и используется парралельное вычисление.			|		Но здесь код продолжает идти в одном потоке
}									|	}


Проблему lock_guard решает unique_lock. Он может по разному работать в момент создания объекта этого класса. Он может сразу при создании вызвать метод lock() у мьютекса, так 
может этого и не делать. В момент выхода unique_lock из зоны видимости, он так же освобождает мьютекс, так же как и lock_guard.


mutex mtx;

void Print(char ch) {								//Функция для отрисовки прямоугольника

	this_thread::sleep_for(chrono::milliseconds(2000)); 			//Эмуляция тяжёлого кода. Многопоток работает

	unique_lock<mutex> ul(mtx); 						//Захват мьютекса

	for (int i = 0; i < 5; i++) {
		for (int i = 0; i < 10; i++) {
			cout << ch;
			this_thread::sleep_for(chrono::milliseconds(12));
		}
		cout << endl;
	}
	cout << endl;

	ul.unlock();								//Освобождение мьютекса

	this_thread::sleep_for(chrono::milliseconds(2000)); 			//Эмуляция тяжёлого кода. Многопоток работает
}

int main()
{
	setlocale(LC_ALL, "Russian");

	//Запуск в двух потоках.
	thread t1(Print, '*');
	thread t2(Print, '#');

	t1.join();
	t2.join();

	return 0;
}



Так же мьютекс можно захватить в любом месте программы. Для unique_lock нужно вторым параметром прописать политику, для того чтобы мьютекс на захватился при создании объекта ul.

void Print(char ch) {								//Функция для отрисовки прямоугольника

	unique_lock<mutex> ul(mtx, std::defer_lock); 				//Создание объекта unique_lock без захвата мьютекса.

	this_thread::sleep_for(chrono::milliseconds(2000)); 			//Эмуляция тяжёлого кода. Многопоток работает
	
	ul.lock(); 								//Захват мьютекса.

	for (int i = 0; i < 5; i++) {
		for (int i = 0; i < 10; i++) {
			cout << ch;
			this_thread::sleep_for(chrono::milliseconds(12));
		}
		cout << endl;
	}
	cout << endl;

	ul.unlock();								//Освобождение мьютекса

	this_thread::sleep_for(chrono::milliseconds(2000)); 			//Эмуляция тяжёлого кода. Многопоток работает
}




______________________________________________________________________________________







