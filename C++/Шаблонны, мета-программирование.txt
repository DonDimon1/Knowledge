Шаблоны в C++ — это мощная функция, позволяющая писать общий код, то есть вы можете написать одну функцию или класс, которые могут работать с разными типами данных. Это означает, что 
вам не нужно писать отдельные функции или классы для каждого типа данных, с которым вы хотите работать.

______________________________________________________________________________________
Идея шаблонов и базовые примеры

template <typename T> и template <class T> это одно и тоже кроме возможно одного заковырестого случая. По кодстайлу шаблонные параметры называть с большой буквы.

1) Шаблон функции:

Чтобы создать функцию шаблона, вы используете ключевое слово template, за которым следуют параметры типа или заполнители, заключенные в угловые скобки <>. Затем вы определяете свою
функцию, как обычно, используя параметры типа для указания универсальных типов.

template <typename T>
void swap(T& x, T& y){
	T t = x;
	x = y;
	y = t;
}


Вот пример простой шаблонной функции, которая принимает два аргумента и возвращает больший из двух:

template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

Чтобы использовать эту функцию, вы можете явно указать параметр типа:

int result = max<int>(10, 20);

Или вы можете позволить компилятору определить тип за вас:

int result = max(10, 20);



2) Шаблонный класс:

template <typename T>
class vector {
   	T* arr;
	size_t sz;
	size_t cap;
};

Аналогичным образом вы можете создавать классы шаблонов, используя ключевое слово template. Вот пример простого класса шаблона, который представляет пару значений:

template <typename T1, typename T2>
class Pair {
public:
    T1 first;
    T2 second;

    Pair(T1 first, T2 second) : first(first), second(second) {}
};

Чтобы использовать этот класс, вам необходимо указать параметры типа при создании объекта:

Pair<int, std::string> pair(1, "Hello");



3) Шаблонный using (C++11)
Например у нас есть очень длинный тип, и мы хотим для любого T определить алиас этоготипа (другое название).

template <typename T>
using mymap = std::map<T, T, std::greater<T>>; 	// std::greater - компоратор, который сравнивает на больше
mymap<T> m;


4) Шаблонные переменные (C++14)
Для произвольного типа T можно определить переменную или константу, которая для разных T будет значить разное.


##################################
При указании разных типов будет CE
template <typename T>
void swap(T& x, T& y){
	T t = x;
	x = y;
	y = t;
}

int main() {
	int a = 0;	
	long b = 1;
	swap(a, b); // CE, компилятор не понимает что в качестве T int, или long?
}


Тут не применяется правило что типо конверсия long в int хуже чем конверсия int в long. Сначала компилятору нужно решить для каких T ему сгенирировать версию swap, для разных
типов код асемблера будет разный. 

Шаблоны это кодогенерация, нужно воспринимать шаблоны не как готовый код, а как такой паттерн, по которому компилятор должен сгенирировать код. Т.е. функция swap это не 
реальный код, а паттерн по которому компилятор в дальнейшем будет генирировать код для разных типов T. То для каких T компилятору сгенирировать swap, это вопрос первой 
стадии компиляции, которая выполняется до всех, которые мы обсуждали ранее, до перегрузки, до выбора имён (т.е. это не препроцессинг). 

Можно подсказать компилятору какую версию генирировать, указав шаблонный аргумент T явно:

template <typename T>
void swap(T x, T y){
	T t = x;
	x = y;
	y = t;
}

int a = 0;
long long b = 1;
swap<long long>(a, b);


Когда мы имеем дело с классами, нам обычно нужно явно указывать шаблонный аргумент, например: vector<int> v, в качестве T мы ставим int. Для всякого T генирируется свой
класс. Если мы сделаем 5 векторов например от int, double, char, float, string, это всё 5 разных классов, компилятор просто накопипастит код вектора 5 раз. 


______________________________________________________
Перегрузка шаблонных функций

template <typename T>	// У нас есть шаблонная функция
void f(T x){}

void f(int x) {}	// А также её перегрузка с типом int

int main() {
	int x = 0;
	f(x);		// Что выберется? 
}

Ответ: выберется вторая версия с типом int. Почему мы хотим, чтобы это работало именно так? Здесь работает правило частоное лучше общего. Если у нас есть инструкция как 
действовать в общем случае, а ещё есть частная инструкция, которая говорит что если случай конкретный действуй иначе, то предпочитается частная инструкция.


На самом деле, генерация шаблонных версий делается не полностью до выбора версии. Если у нас есть выбор между шаблонной версией и нешаблонной, то это решение компилятору 
нужно принять раньше, до того как он начнёт генирировать шаблонную версию. Компилятор понимает что под этот вызов f подходит как шаблонная версия, и он может сгенирировать
T = int, и подходит нешаблонная и он может ничего не генирировать, и просто выбрать версию от int, тогда он предпочтёт второй вариант. Но если частная версия не так хорошо
подходит как общая, то он предпочтёт общую версию T = int.

Есть два правила как действует компилятор:
1) частоное лучше общего
2) но несмотря на это точное соответствие лучше, чем какой нибудь каст.

Т.е. если компилятор способен сгенирировать шаблонную версию так, что там будет идеальное соответсвтие типа, то это лучше чем выбрать частную версию но сделать хоть какое
привидение типа.

template <typename T>	
void f(T x){
	std::cout << 1;
}

void f(long long x) {
	std::cout << 2;
}	

int main() {
	int x = 0;
	f(x);		// Сейчас выберется 1.
}



##########################################
Мы можем указать шаблонный параметр явно:

template <typename T>	
void f(T x){
	std::cout << 1;
}

void f(int x) {
	std::cout << 2;
}	

int main() {
	int x = 0;
	f<int>(x);		// Сейчас выберется 1.
}

Если я явно указываю шаблонный параметр, тем самым я обязываю компилятор выбрать какую то шаблонную версию, даже если есть частная перегрузка с нужным типом.



#################################################
Можем указывать шаблонный аргумент по умолчанию:

template <typename T = int>	
void f(T x){
	std::cout << 1;
}

У нас может быть шаблонный аргумент, который если явно не указан, то компилятор должен подставить конкретный (в нашем случае int).

По переданным аргументам в функцию компилятор иногда может сам понять, что за тип ему передали без явного указания. Когда я указываю шаблонные аргументы при вызове функции, 
я могу указывать не все, он применяет только те, которые я указал первые по списку, а остальные пытается вывести сам.
Например:

template <typename U, typename T>	
U f(T x){
	std::cout << 1;
	return x;
}

void f(int x) {
	std::cout << 2;
}

int main() {
	int x = 0;
	int g = f<int>(x);	// Говорим что <int> это тип U, а x с типом int это тип T x в функции f.
}

Мы указываем что в функции f typename U это тип int, т.е. в функции f возвращаемый тип это int. Какой тип T он должен угадать сам, и он сможет догадаться, поскольку T это 
переданный аргумент, с уже заданным типом. Но вот если мы поменяем U и T местами, тогда это уже CE, поскольку он не может догадаться какой теперь возвращаемый тип:

template <typename T, typename U>	
U f(T x){				// U непонятно какой тип
	std::cout << 1;
	return x;
}

void f(int x) {
	std::cout << 2;
}

int main() {
	int x = 0;
	int g = f<int>(x);		// CE
}



########################
 1) Какая функция вызовется?

template <typename T>
void f(T& x) {		// Аргумент по ссылке
	std::cout << 1;
}


template <typename T>
void f(T x) {		// Аргумент по значению
	std::cout << 2;
}

int main() {
	int x = 0;
	f(x);		// Вызываем функцию от int x = 0;
}


Ответ: Будет CE, call of overloaded f(int&) is ambiguous.

 2) А вот если мы вызовем функцию с rvalue, то тогда выберется второй вариант.

int main() {
	int x = 0;
	f(1);		// Вывод в консоль 2.
}


 3) А если мы вызовем функцию с константой, тогда будет CE, обе версии одинаково подходят:

template <typename T>
void f(const T& x) {		// Константный аргумент по ссылке
	std::cout << 1;
}

template <typename T>
void f(T x) {			// Аргумент по значению
	std::cout << 2;
}

int main() {
	int x = 0;
	f(1);			// CE
}


 4) Можно принять 1 как в качестве константной ссылки, так и в качестве просто значения, и одно не лучше другого. Анологично CE и в следующем примере:

template <typename T>
void f(const T& x) {		// Константный аргумент по ссылке
	std::cout << 1;
}


template <typename T>
void f(T& x) {			// Аргумент по значению
	std::cout << 2;
}

int main() {
	f(1);			// CE
}


______________________________________________________________________________________
Специализация шаблонов классов Template specializations.

Иногда вам может потребоваться особое поведение для определенного типа данных. В этом случае вы можете использовать специализацию шаблона. Это может быть полезно, если вы хотите 
оптимизировать поведение или предоставить конкретную реализацию для определенного типа, не влияя на общее поведение шаблона для других типов.

Представим что мы реализуем шаблонный класс (например вектор). Всё хорошо, но мы хотим чтобы для какого то конкретного T этот класс был не таким, как для всех остальных,
например чтобы вектор bool был не таким как всё остальное, а именно чтобы вектор bool хранил не массив bool, а массив char, но при этом в нём когда мы записываем элемент,
он менял соответствующий бит в массиве, а не целый байт. Мы можем это добиться путём специализации шаблона.


Существует два основных способа специализации шаблона:

1) Полная специализация. Это происходит, когда вы предоставляете конкретную реализацию для определенного типа или набора типов.

2) Частичная специализация. Это происходит, когда вы предоставляете более общую реализацию для подмножества типов, соответствующих определенному шаблону или условию.


#####################################
Полная специализация класса (Full specializations):

Полная специализация шаблона позволяет предоставить конкретную реализацию или поведение шаблона при использовании с определенным набором параметров типа.

Чтобы создать полную специализацию шаблона, вам необходимо определить конкретный тип, для которого должна произойти специализация. Синтаксис выглядит следующим образом:

template <> 			//Indicates that this is a specialization
className<specificType>

Пример 1):

template <typename T>						// Общий шаблонный класс
class MyContainer {
public:
    void print() {
        std::cout << "Generic container." << std::endl;
    }
};

template <>							// Полная специализация класса для типа int
class MyContainer<int> {
public:
    void print() {
        std::cout << "Container for integers." << std::endl;
    }
};

int main() {
    MyContainer<double> d;
    MyContainer<int> i;

    d.print(); // Output: Generic container.
    i.print(); // Output: Container for integers.

    return 0;
}

В этом примере мы определили общий MyContainer класс шаблона вместе с полной специализацией для int типа. Когда мы используем контейнер с типом, вызывается метод int 
специализированной реализации. print Для других типов будет использоваться реализация общего шаблона.

Пример 2):

template <typename T>	// Общий шаблонный класс
class vector {
	T* arr;
	size sz;
	size_t cap;
};

template <>		// Полная специализация класса 
class vector<bool> {
	char* arr;
	size_t sz;
	size_t cap;
}

Т.е. для каких то типов, в нашем случае bool, делаем класс иным, нежели для всех остальных типов.
В угловых скобочках я перечисляю фиксированные аргументы. Они могут быть не конкретными. Т.е. у нас могут быть шаблон от двух аргументов, и мы можем отдельно определить
шаблон от одного аргумента, если эти аргументы одинаковые.



#####################################
Частичная специализация (Partial specialization):

Частичная специализация шаблона — это концепция шаблонов C++, которая позволяет специализировать шаблон для подмножества его возможных аргументов типа. Это особенно полезно, когда вы 
хотите предоставить индивидуальную реализацию для определенной группы типов без необходимости определять отдельные специализации для всех типов в этой группе.

Частичная специализация шаблона достигается путем предоставления специализации шаблона с новым набором параметров шаблона. Этот новый шаблон будет выбран, когда компилятор определит 
типы, соответствующие частичной специализации.

Пример 1) Вот пример кода, демонстрирующий частичную специализацию шаблона:

template <typename T>					// Primary template
struct MyTemplate {
    static const char* name() {
        return "General case";
    }
};


template <typename T>					// Partial specialization for pointers
struct MyTemplate<T*> {
    static const char* name() {
        return "Partial specialization for pointers";
    }
};

template <>						// Full specialization for int
struct MyTemplate<int> {
    static const char* name() {
        return "Full specialization for int";
    }
};

int main() {
    MyTemplate<double> t1; 				// General case
    MyTemplate<double*> t2; 				// Partial specialization for pointers
    MyTemplate<int> t3; 				// Full specialization for int

    std::cout << t1.name() << std::endl;
    std::cout << t2.name() << std::endl;
    std::cout << t3.name() << std::endl;

    return 0;
}

В приведенном выше примере мы определили основной шаблон MyTemplate с одним параметром типа T. Затем мы предоставляем частичную специализацию шаблона для типов указателей, указав 
MyTemplate<T*>. Это означает, что частичная специализация будет выбрана, когда аргумент типа является типом указателя. Наконец, мы обеспечиваем полную специализацию типа, int указав 
MyTemplate<int>. Это будет выбрано, если аргумент типа равен int.


Пример 2):

template <typename T, typename U>	// Общий вариант
struct S {};

// Частичная специализация 
template <typename T>			// В этом префиксе шаблонов я перечисляю те аргументы, которые мне здесь пригодятся для объяснения того, какую специализацию я хочу объявить.
struct S<T, T> {};			// Здесь в <> я описываю метасигнатуру, которая является частным случаем класса выше.

В данном случае мы видим пример частичной специализации. Для любых T и U, S определена общим вариантом, но для любого T, если первый аргумент равен второму, S определена иначе.
Можно написать по разному, например:

template <typename T>	
struct S<int, T> {};	// Для любого T структура с первым аргументом int, определена иначе



Мы можем сделать несколько частичных специализаций:

template <typename T, typename U>	
struct S {};

template <typename T>
struct S <int, T>{};

template <typename T>
struct S <T, int>{};

int main() {
	S<int, int> s;	// CE, ambigous template instantiation (неоднозначаное инстанцированние шаблона)
}

Инстанцированние - это начальная генерации шаблона. 

Компилятору непонятно int подставить в качестве первого аргумента подставить, или в качестве второго. Однако если бы мы имели полную специализацию, без каких либо параметров 
просто от двух int, то компилятор бы предпочёл её:

template <>
struct S <int, int>{};


Так же частичную специализацию можно написать вот так:

template <typename T>	// Обычная версия
struct S {};

template <typename T>	// Для всех типов, являющиеся ссылками сделаем свою версию.
struct S<T&> {};

template <typename T>	// От константного T это третья версия
struct S<const T> {};



#############
Итог:

Полная специализация, это когда template <> мы пишем с пустыми угловыми скобочками, тем самым мы говорим что мы хотим определить частный случай этого шаблона для некоторых
конкретных наборов аргументов, без использования всяких метапеременных T и прочее. Проще говоря реализация шаблона для конкретного типа данных.

Частичная специализация, это когда мы пишем (template), и дальше в угловых скобочках чтото пишем (<typename T>), но потом объявляем класс который уже был выше (struct S),
и просто в угловые скобочки ставим чтото более частное (<int, T>). Частичная специализация повзоляет уточнить поведение шаблона для подмножества типов, но при этом сохранить общую 
реализацию для других случаев. Это полезно, когда нужно специализированное поведение для определённых шаблонных параметров, но не для конкретного типа, как в полной специализации.



______________________________________________________
Специализация шаблонов функций Template specializations.

Представим две шаблонные функции, с одним и двумя разными аргументами. Какая версия выберется?

template <typename T, typename U>	// Версия 1
void f(T, U){
	std::cout << 1:
}

template <typename T>			// Версия 2
void f(T, T){
	std::cout << 2:
}

int main() {
	f(0, 0);			// Вызываемся от двух int
}

Вторая версия более частная чем первая, всё что подходит во вторую версию подходит и в первую, а обратно так не работает. Поэтому в данном случае выбирается вторая версия.


Добавим полную специализацию которая принимает 2 int:

template <typename T, typename U>	// Версия 1
void f(T, U){
	std::cout << 1:
}

template <>				// Версия 3
void f(int, int){
	std::cout << 3:
}

template <typename T>			// Версия 2
void f(T, T){
	std::cout << 2:
}

int main() {
	f(0, 0);			// Вызываемся от двух int
}

В консоль всё ровно выведется 2. Но если мы переставим определение от (int, int) ниже, то:

template <typename T, typename U>	// Версия 1
void f(T, U){
	std::cout << 1:
}

template <typename T>			// Версия 2
void f(T, T){
	std::cout << 2:
}

template <>				// Версия 3
void f(int, int){
	std::cout << 3:
}

int main() {
	f(0, 0);			// Вызываемся от двух int
}

Теперь выведется 3. (Я так полагаю из-за перегрузки функций)



У нас бывает перегрузка функций, а бывает специализация шаблонных функций, и это разные вещи. Для функций, в отличие от классов, существует перегрузка, нельзя переопределить
структуру, с другим количеством шаблонных параметров, а функцию можно. 

void f(T, U){
	std::cout << 1:			// Функция с 2 шаблонными параметрами 			(номер 1)
}

template <typename T>			// Функция с 1 шаблонным параметром			(номер 2)
void f(T, T){
	std::cout << 2:
}

template <>				// Частный случай функции с 1 шаблонным параметром	(номер 3)
void f(int, int){
	std::cout << 3:
}

void f(int, int ){			// Нешаблонная функция					(номер 4)
	std::cout << 4;			
}

int main() {
	f(0, 0);			// Вызываемся от двух int
}

Здесь у нас есть 3 разных версии перегрузки функции f, у одной из которых есть ещё специализация. В данном случае выведется 4, потому что есть шаблонная версия номер 1, есть 
шаблонная версия номер 2, есть обычная версия номер 4 (нешаблонная), а у шаблонной версии номер 2 есть частный случай номер 3. Когда компилятор решает какую версию функции 
ему выбрать, он сначала смотрит на версии перегрузки, а перегрузки здесь 3 (1, 2 и 4). Но у некоторых из них могут быть специализации, в нашем случае у 2 есть специализация, под
номером 3. Тем немение, компилятор, сначало выбирает между версиями перегрузки, какая более предпочтительна, а потом, уже после того как он выбрал версию перегрузки, он 
решает нет ли у неё подходящей специализации.

Сначала у нас делается перегрузка между шаблонами, потом в выбранный шаблон подставляются аргументы, и генирируются нужные версии, потом делается перегрузка между тем, что 
получилось.

Для функцию несуществует понятия частичная специализация, есть только полная специализация, поскольку частичная специализация лишена смысла, так как у функции есть перегрузки.



Под какой функцией мы пишем специализацию, к той функции и будет привязана специализация:

Пример 1:

void f(T, U){
	std::cout << 1:			// Функция с 2 шаблонными параметрами 			(номер 1)
}

template <>				// Специализация функции, написанной над нами (специализация функции номер 1)
void f(int, int){
	std::cout << 3:
}

template <typename T>			// Функция с 1 шаблонным параметром			(номер 2)
void f(T, T){
	std::cout << 2:
}


Пример 2:

void f(T, U){
	std::cout << 1:			// Функция с 2 шаблонными параметрами 			(номер 1)
}

template <typename T>			// Функция с 1 шаблонным параметром			(номер 2)
void f(T, T){
	std::cout << 2:
}

template <>				// Специализация функции, написанной над нами (специализация функции номер 2)
void f(int, int){
	std::cout << 3:
}



______________________________________________________
NTTP 	(Non-type template parameters)

Не только типы могут быть параметрами шаблона, а ещё и числа. Мы можем сделать параметром шаблона число.

#include <array> 			// Массив фиксированного размера

int main() {
	std::array<int, 100> a;		// Здесь 100 это параметр шаблона, но он является числом а не типом (Non-type парметр)
}

Как такое объявлять?

template <typename T, size_t N>
class array {
	T arr[N];
};

int main() {
	std::array<int, 100> a;
}



#######################
Матрица 

template <size_t M, size_t N, typename Field = Rational> 	// Матрица над полем из M строк, N столбцов
class Matrix {};						// Rational это класс рациональных произвольной точности

template <size_t N, typename Field = Rational> 			// Тип квадратная матрица
using SquareMatrix = Matrix<N, N, Field>			// матрица с параметром N на N

int main() {
	std::array<int, 100> a;
	Matrix<5, 5> m;
	SquareMatrix<5> sm;
}

Здесь очень удобно что, эти числа являются параметрами типа, т.е. матрица 4 на 3 и матрица 3 на 4 это разные типы, и они друг с другом с точки зрения кодогенерации никак не 
связаны.

Определим умножение разных матриц. Нам нужно сделать так, что только лишь матрицы соответствующих размеров можно перемножать над одним и тем же полем, а если мы попытаемся 
умножить матрицы несоответствующих размеров то будет CE, потому что компилятор не сможет вывести шаблонные параметры.

template <size_t M, size_t K, size_t N, typename Field>
Matrix<M, N, Field> operator*(const Matrix<M, K, Field>& a, const Matrix<K, N, Field>& b);

Таким образом у классов могут быть числовые параметры, однако эти параметры должны быть известны на этапе компиляции. Например, вот так нельзя делать:

int main(){
	int x = 5;
	Matrix<x, x> m;	// CE
}

Здесь переменная x не является константой, которой можно подставить в шаблон (с const сработает).



#####################
constexpr (C++11)

constexpr означает не просто константу, а константу, известную на этапе компиляции. В шаблоны мы должны передавать именно такие константы.

constexpr int x = 5; 


______________________________________________________
template template parameters

Параметры шаблонов бывают типами (typename), бывают целочисленными (size_t, int и все его вариации, bool, char), а так же бывает третий вид шаблонных параметров: параметры шаблонов
которые сами являются шаблонами.

Например я хочу реализовать стек. Стек будет состоять из какого то типа, и я стек реализую как обёртку над каким то контейнером. Например std stack по сути в себе хранит дек или 
вектор. Так вот мы тоже можем параметром стека сделать вид шаблонного контейнера, который мы хотим принять в качетсве параметра. Т.е. мы можем сделать стек на векторе или стек на 
деке или стек на листе. Для этого можно написать:

template <typename T, template<typename> class Container>
class Stack {
	Container<T> container;
};

Здесь мы написали что вторым параметром шаблона является контейнер, но контейнер это не конкретный тип, это другой шаблон, у которого есть свои шаблонные параметры:
, template - означает что вторым параметром мы передали другой шаблон, дальше открывается угловая скобочка <typename> и перечесляются виды шаблонных параметров(метатипы).

Вот здесь есть одна тонкость, в которой слова template и class имеют разный смысл в упоминании шаблонных параметров: Когда я объявляю параметр шаблонна, который сам является
шаблоном вот здесь может быть важно написать class или typename. До C++17 здесь нужно было писать именно class, начиная с C++17 здесь тоже не важно что писать class или typename.

Здесь Container это не тип, а шаблон, и сам по себе Container это непонятно что, но в Container можно передавать шаблонные параметры. Т.е. Container это некоторый шаблон, с 
шаблонным параметром один тип, и вот его уже можно параметризовать типом уже внутри тела класса.

Мы можем установить его по умолчанию. Однако на самом деле у вектора 2 шаблонных аргумента, второй аргумент по умолчанию это алокатор, и он всегда по умолчанию равен std::allocator 
от T. Он есть у каждого контейнера. Поэтому если мы хотим сделать std::vector пенредать в качестве шаблона, то нам нужно указать 2 шаблонных параметра

template <typename T, template<typename, typename> class Container = std::vector>
class Stack {
	Container<T, std::allocator<T>> container;
};

int main(){
	Stack<int, std::vector> s;
};


______________________________________________________
Вычисление в компалтайме (Basic compile time computations)

Допустим я хочу узнать чему равно 20-ое число Фибоначи:
Мы просим компилятор рекурсивно инстанцировать шаблон шаг за шагом, но у компилятора есть встроенный лимит на глубину шаблонной рекурсии. Т.е. когда он инстанцирует шаблон, ему 
потребовалось инстанцировать другой шаблон, и так шаг за шагом. По умолчинию стоит лимит глубины и если он привышает то получается fatal error. Например: 

template <int N>
struct Fibonacci {
	static constexpr int value = Fibonacci<N-1>::value + Fibonacci<N-2>::value;		// CE
};

int main() {
	std::cout << Fibonacci<20>::value;
}

Для того чтобы это пофиксить нужно написать специализацию:

template <int N>
struct Fibonacci {
	static constexpr int value = Fibonacci<N-1>::value + Fibonacci<N-2>::value;
};

template <>
struct Fibonacci<1> {
	static constexpr int value = 1;
};

template <>
struct Fibonacci<0> {
	static constexpr int value = 0;
};

int main() {
	std::cout << Fibonacci<20>::value;
}

За какую асимптотику это отрабатывает? За линейную. Потому что единожды сгенирировав реализацию для какого то N он потом не генирирует её вторично. В реальности оказалось
сгенирировано 21 класс, поскольку Фибоначи от 0 и от 1 это всё разные типы. Компилятор их всех сгенирировал, и они все единожды были сгенирированы.


#################
2-ое упражнение. Как проверить в компайлтайме является ли число простым за линейное время?

template<int N, int D>
struct IsPrimeHelper {
	static constexpr bool value = N % D == 0 ? false : IsPrimeHelper<N, D-1>::value;
};


template<int N>
struct IsPrimeHelper<N, 1> {
	static constexpr bool value = true;
};

template <int N>
struct IsPrime {
	static constexpr bool value = IsPrimeHelper<aN, N-1>::value;
};

template <>
struct IsPrime<1> {
	static constexpr bool value = false;
};

int main() {
	std::cout << IsPrime<257>::value;
}



Дополнения:
1) Мы можем объявлять шаблонные переменные:

...

template <int N>					// Объявляем шаблонную переменную
const bool is_prime = IsPrime<N>::value;

int main() {
	std::cout << is_prime;				// Обращение к структуре с помощью is_prime без ::value
}

Можно сказать что это метафункция: она принимает int в угловых скобочках а не круглых, и это возвращает мне true или false, смотря какой int я передал и всё это делается в 
компайл тайме.


2) Существует такое ключевое слово static_assert. Есть просто assert, это функция которая падает в рантайме (она вызывает std::abort если условие ложно). static_assert это
функция, которая кидает CE если ей передали false, но ей тоже нужно передать константу времени компиляции.

int main() {
	static_assert(is_prime<257>);			// Вызываем CE если это false.
}

Смысл в том, что например, если матрица неквадратная, нельзя будет вызвать её определитель.



______________________________________________________
Зависимые имена (Dependent name)

Рассмотрим такой пример:

template <typename T>
struct S {
	using A = int;		// Публичный using
};

template <typename T>
void f(){
	S<T>::A* x;		// Из струткуры S достаём тип A
}

int main(){
	f<int>();
}

Здесь будет CE. Объяснение: допишем в код специализацию:

template <typename T>
struct S {
	using A = int;		// A обозначает тип int 
};

template <>			// Добавим специализацию
struct S<double> {
	static const int A = 5; // A обозначает переменную типа int 
}

int x = 0;

template <typename T>
void f(){
	S<T>::A* x;		// Неопределённость declaration or expression???
}

Здесь есть проблема, мой шаблонный класс может иметь специализацию и в одной из версии шаблона имя может обозначать тип, а в другой версии шаблона имя может обозначать 
переменную. И вот компилятор пытается скомпилировтаь шаблонную функцию f, которая обращается к шаблонной структуре S, и в ней к сущности под названием A и видит строчку:
S<T>::A* x; С одной стороны это может быть int* x и это дикларейшен, с другой стороны это может быть 5 * x и это экспрешен, в зависимости от T. В данном случае A это зависимое
имя, то чем является A зависит от T, но T это шаблонный параметр, компилятор до подстановки T не может понять что это за конструкция. Поэтому компилятор хочет на стадии 
семантического парсинга, до подстановки всяких T, понять что это за конструкция. Поэтому в стандарте введено следующее правило: во всех таких ситуациях компилятор считает по
умолчанию что это экспрешен. Т.е. все зависимые имена по умолчанию парсятся как выражения, а не как названия типов.

Если закоментировать строчку int x = 0; то такой код даст CE по причине x was not declared in this scope.

Что нужно сделать чтобы компилятор это воспринял как тип а не как имя: Нужно написать typename перед зависимым именем:

template <typename T>
void f(){
	typename S<T>::A* x;		// Неопределённость declaration or expression???
}

Нельзя чтобы в зависимости от T это было то declaration то expression, язык это запрещает.

Но если мы теперь вызовем f<double> то это будет CE  

int main(){
	f<int>();
	f<double>(); // CE no type named A in struct S<double>
}



####################

Что тут теперь написано?

#include <array>

template <typename T>
struct S {
	template <int N>
	using A = std::array<int, N>;	
};

template <>			
struct S<double> {
	static const int A = 5;
}

template <typename T>
void f() {
	typename S<T>::A<10> x;		
}

int main() {
	f<int>();
}

Данный случай можно распарсить как экспрешен A < 10 > x (A меньше 10 больше x). Правда если стоит typename это нельзя так распарсить, однако если бы написали вот так:
typename S<T>::A() <10> x; то это можно было бы распарсить даже если там стоит typename.

Особая боль ситуации заключается в том что слово typename недостаточно здесь, потому что когда мы пишем typename он считает что это название типа, но он всё ещё не считает что
это название шаблона. Слово typename заставляет компилятор думать что это название типа но не шаблона. И чтобы он считал это названием шаблона нужно дописать template.

typename S<T>::template A<10> x;


2 пример:

template <typename T>
struct S {
	template <int N>
	void foo(int) {}	
};

template <typename T>
void bar(int x, int y) {
	S<T> s;
	s.foo<S>(x + y);	// парситься неоднозначно экспрешен или шаблонная функция???
}

int main() {
	bar<int>(2, 3);
}

Строка s.foo < S >(x + y); означает что я взял переменную foo сравнил её с 5, а потом полученный результат сравнил с суммой x + y 
ИЛИ
строка s.foo<S>(x + y); означчает что я вызвал шаблонную функцию с шаблонным параметром 5 от x + y ???

s.foo это может быть переменная а не функция. Это будет эксперешен но у этого будет разный смысл. В данном случае здесь уже никак не обойтись без template:

s.template foo<S>(x + y);	// Это будет компилироваться



##############
Что здесь не так? В чём проблема этого кода?

template <typename T>
struct Base {
	int x = 0;
};

template <>
struct Base<double> {
};

template <typename T>
struct Derived: Base<T> {
	void f() {
		++x;
	}
};

int main(){}

Непонятно что такое x. В зависимости от T, x может то присутствовать то отсутствовать, а может это вообще быть тип, или функция. Когда мы говорим ++x компилятор не понимает что
мы ему говорим, поскольку компилятор не залезает в шаблонного родителя, чтобы посмотреть, что это такое. Это можно починить следующим образом:

++this->x; 

Если мы хотим обратиться к полю шаблонного родителя из наследника, то нам нужно явно указывать this. Так же можно явно указать родителя: ++Base<T>::x;


Компиляция это сложный многостадийный процесс. Есть так называемая Two face translation. Это такой термин, применимый к шаблоном, когда компилятор компилирует шаблоный код, он
это делает в два прохода. Первый проход до того как мы подставили T, второй проход, после того как мы подставили T. До того как мы подставиил T, мы смотрим на синтаксис, на
базовые симантические проверки, на имена независимые от T, но мы не можем полностью проверить всю корректность кода, с точки зрения компиляции, до тех пор, пока T не подставили.
Тем не менее при первом проходе нужно до какой то степени проверить корректнось, чтобы часть ошибок отловить на первой стадии. Но вот вторая стадия, когда мы подставили 
конкретное T, возникают новые ошибки. Именно поэтому когда мы написали например какой нибудь шаблонный контейнер, но пока не использовали его в main(), часть ошибок компиляции
может не найтись, но как только мы инстанцировали в мейне может выпасть ещё куча ошибок компиляции.



______________________________________________________
Metafunctions and type traits.

Шаблоны дают нам возможность писать метафункции. Метафункции это как бы функции от типов. Например можно представить функцию, которая принимает не объекты, а типы и возвращает
их. Простейшая метафункция это проверка равны ли два типа в компайлтайме:

template <typename T, typename U>			// Шаблонная структура
struct is_same {
	static constexpr bool value = false;
};

template <typename T>					// Специализация структуры если T и U одинаковые
struct is_same<T, T> {
	static constexpr bool value = true;
};

// Если типы T и U одинаковые, то выполняется специализация и value становиться true. Если типы T и U разные то выполняется обычный шаблон, и поле value = false;


// Вызов проверки
template <typename T, typename U>			// Просто шаблонная функция
void f(T x, U y) {
	//... 						// Какая то куча действий
	
	// Как нам написать что, Если типы T и U одинаковы то сделай одно, а иначе другое

	// Вариант 1:
	
	/*
	if(typeid(x) == typeid(y)) {} 			// Это работает но это плохо, потому что это рантайм проверка, а нам нужно проверить в компайлтайме. Это безсмысленно,
	*/						// если типы в компайл тайме известны. typeid осмысленны когда у нас x и y полиформны.

	// Вариант 2:
	
	// Мы говорим компилятору что для разных пар T и U, нагенирировал разный код. Когда мы вызываем f от T и U, мы для каждой пары T и U компилятором генерируем свою версию 
	// f. Мы можем сделать так, что в одинх версиях f будет нагенерирован этот код который мы сейчас написали, а в других не будет:
 	
	/*
	if(is_same<T, U>::value) {
		
	}
	*/

	// Однако есть проблема с if. Хоть и условие if(is_same<T, U>::value) известно в компайлтайме, сам этот if всё ровно вычисляться будет в рантайме. Вот чтобы ещё и сам
	// if вычислялся в компайлтайме нужно constexpr прописать после слова if:

	if constexpr (is_same<T, U>::value) {
		x = y;
	}
}

int main() {
	f<int, std::string>(5, "abc");
}

Без constexpr было бы CE. Когда я написал if и поставил какое то условие. В данный момент условие ложно, но код всё ровно компилировать надо, компилятор смотрит и дальше 
компилирует инструкции, это же не важно что это условие можно в компайлтайме проверить, код всё ровно компилировать надо. Так вот constexpr говорит компилятору, что нужно просто
выкинуть этот if из кода и не смотреть на то что внутри него, если это условие ложно, но условие должно быть проверено в компайлтайме. Т.е. если я хочу написать какую то вещь,
которая компилируема только при условии, что выполнено какое то свойство над типами, я могу её обернуть в if constexpr и что находиться под этим if будет компилятором расмотрено
и синтактически распаршено, но семантика того что здесь делается не будет проверена, корректность типов не будет определяться, при условии что if constexpr ложно.


######################
Существует стандарнтая структура сравнения типов C++11:

#include <type_traits>

int main() {
	std::if_same<int, float>;	// Простая мета функция которая по двум типам возвращает bool
}


####################
Бывают метафункции которые по типу возвращают другой тип:

template <typename T>
struct remove_reference {
	using type = T;
};

template <typename T>
struct remove_reference<T&> {
	using type = T;
};

template <typename T>
void f() {
	typename remove_reference<T>::type x;
}


####################
Можно сделать remove_pointer, или remove_const - снимает константность с типа:

template <typename T>
struct remove_const {
	using type = T;
};

template <typename T>
struct remove_const<const T> {
	using type = T;
};

В чём разница между remove_const и const_cast? Это вприницпе разные вещи, мало что общего они имеют между собой.

Аналогично есть функции is_const, is_pointer, is_reference, is_array. Они лежат в заголовочном файле #include <type_traits> C++11

Вот один из type_traits под названием std::conditional

template <bool B, typename T, typename F>
struct conditional {
	using type = F;
};

template <typename T, typename F>
struct conditional <true, T, F>{
	using type = T;
};

Это тернарный оператор только для типов. 


Вывод: не использовать эти структуры в чистом виде, а использовать шаблонные алиасы.


______________________________________________________________________________________
Признаки типа <type_traits>

Признаки типа — это набор классов шаблонов в C++, которые помогают получить информацию о свойствах, поведении или характеристиках типа. Их можно найти в <type_traits> заголовочном 
файле. Используя признаки типа, вы можете адаптировать свой код в зависимости от свойств данного типа или даже применять определенные свойства для параметров вашего типа в коде 
шаблона.

Некоторые общие черты типа:

std::is_pointer: Проверяет, является ли данный тип типом указателя.
std::is_arithmetic: Проверяет, является ли данный тип арифметическим типом.
std::is_function: Проверяет, является ли данный тип типом функции.
std::decay: применяет правила decltype к входному типу (удаляет ссылки, cv-квалификаторы и т. д.).

Применение

#include <iostream>
#include <type_traits>

int main() {
    int a;
    int* a_ptr = &a;

    std::cout << "Is 'a' a pointer? " << std::boolalpha << std::is_pointer<decltype(a)>::value << std::endl;
    std::cout << "Is 'a_ptr' a pointer? " << std::boolalpha << std::is_pointer<decltype(a_ptr)>::value << std::endl;

    return 0;
}

Составление типовых черт
Некоторые черты типа помогают вам составить другие черты или изменить их, например:

std::conditional: Если данное логическое значение истинно, используйте тип A; в противном случае используйте тип B.
std::enable_if: Если данное логическое значение истинно, используйте тип A; в противном случае вложенный тип отсутствует.

Пример:

#include <iostream>
#include <type_traits>

template <typename T>
typename std::enable_if<std::is_arithmetic<T>::value, T>::type find_max(T a, T b) {
    return a > b ? a : b;
}

int main() {
    int max = find_max(10, 20);
    std::cout << "Max: " << max << std::endl;

    return 0;
}

В этом примере find_max функция шаблона определяется только в том случае, если T имеет арифметический тип (например, int, float, double). Это предотвращает непреднамеренное 
использование функции find_maxс неарифметическими типами. В целом, признаки типов — это мощный инструмент для создания более универсального, расширяемого и эффективного кода C++, 
предоставляющий возможность запрашивать и адаптировать ваш код на основе характеристик типа.


______________________________________________________________________________________
Вариативные шаблоны. Шаблоны с переменным количеством аргументов (variadic templates C++11)

Шаблоны с переменным числом аргументов — это функция C++11, позволяющая определять шаблон с переменным количеством аргументов. Это особенно полезно, когда вам нужно написать функцию 
или класс, которые могут принимать разные числа и типы аргументов.

Синтаксис вариативных шаблонов очень прост. Чтобы определить вариативный шаблон, используйте ...обозначение (многоточие):

template <typename... Types>		// Передаём пакет типов. Здесь ... означает что мы объявили пачку типов.
void f(Types.. tx) {			// Распаковка пакета. А здесь ... означает что мы распаковали пачку типов, и это означает что tx теперь пачка переменных.
	
}


В template <typename... Types> Types это пакет типов, особый вид шаблонного архумента, который представляет из себя пачку типов. Эту пачку можно распаковывать. Пакет может быть пустым.  
Этот пакет параметров можно использовать как список переменных параметров шаблона в определении шаблона, а ... говорит компилятору, что типов может быть сколько угодно, пример:

foo<int, double, std::stirng>();


###
Где может стоять ... и что это такое?
1) В объявлении, т.е. при создание пакета:

template <typename... Ts>

Здесь ... означает, что Ts - это не один тип, а набор типов ( Ts = {int, double, std::string} )


2) После имени, т.е. при распаковки пакета

Ts...

Этим мы говорим компилятору, чтобы он взял все элемента пакета Ts по отдельности, например:

template <typename... Ts>
void func(Ts... args) {
}

Если вызвать так:
func(1, 3.14, "hi");

то компилятор увидит так:
void func(int a, double, b, const char* c);


3) Внутри кода - pack expansion, это специальный синтаксис
sizeof...(Ts) // кол-во элементов в пакете


Где ставить ... относительно выражения
Правило: Многоточие ... применяется к тому, что слева от него:
func(args...);

Если args = (a, b, c), то func(a, b, c);

Очень частая ошибка:
func(args)...; // Так нельзя

Так нельзя, потому что ... должен быть частью выражения, а не отдельным оператором.


4) Fold expressions (C++17) - самый частый случай
Об этом в следующей теме.


###
Примеры:
1) Суммирование нескольких аргументов с использованием шаблонов с переменным числом аргументов:

#include <iostream>

// Base case for recursion
template <typename T>
T sum(T t) {
  return t;
}

// Variadic template
template <typename T, typename... Args>
T sum(T t, Args... args) {
  return t + sum(args...);
}

int main() {
  int result = sum(1, 2, 3, 4, 5);  // expands to 1 + 2 + 3 + 4 + 5
  std::cout << "The sum is: " << result << std::endl;

  return 0;
}

2) Класс кортежа с использованием шаблонов Variadic

template <typename... Types>
class Tuple;

// Base case: empty tuple
template <>
class Tuple<> {};

// Recursive case: Tuple with one or more elements
template <typename Head, typename... Tail>
class Tuple<Head, Tail...> : public Tuple<Tail...> {
 public:
  Tuple(Head head, Tail... tail) : Tuple<Tail...>(tail...), head_(head) {}

  Head head() const { return head_; }

 private:
  Head head_;
};

int main() {
  Tuple<int, float, double> tuple(1, 2.0f, 3.0);
  std::cout << "First element: " << tuple.head() << std::endl;
  return 0;
}

Обратите внимание, что показанные примеры предназначены для образовательных целей и могут быть не самыми эффективными и готовыми к использованию реализациями. В C++17 и более поздних 
версиях появились еще более лаконичные способы обработки шаблонов с переменным числом вариантов, например использование выражений свертки.


3) Пример: Представим что мы хотим написать функцию print, которая берёт переменное кол-во параметров, и выводит их по одному в консоль. Здесь нам пригодится шаблонная рекурсия. 
Нужно понимать, что когда я вызываю print от 10 шаблонных параметров, а потом вызываю print от 9, это всё разные принты будут, будет 10 разных версий принт сгенерировано 
компилятором. И мы хотим чтобы принт от 10 шаблонных параметров нам выводил первый из них, и вызывал рекурсивно принт от 9 шаблонных параметров.

Для того чтобы это реализовать, нам нужно откусить голову. Когда люди пишут код с переменным кол-во шаблонных аргрументов, они обычно делают так: они говорят что есть первый 
аргумен Head, и он имеет тип, а есть ещё хвост, который является пакетом оставшихся типов. 

void print() {}						// Без этого CE. Эта функция на случай, если аргументов не осталось.

template <typename Head, <typename... Tail>		// Эта функция подходит для случаем, когда хоть 1 аргумент есть. Пакет может быть пустым, но первый аргумент должен быть всё ровно.	
void print(const Head& head, const Tail&... tail) {	// Константные ссылки нужны для передачи далее без копирования.		
	std::cout << head << ' ';
	print(tail...);
}

int main() {
	print(1, 2.0, "abc");
}

Пустая функция print без аргуметов нужна для рекурсии.


#####################
Упражнение: Давайте напишем метафункцию, которая проверяет, что все типы в пакете одинаковые.

template <typename First, typename Second, typename... Types>
struct is_homogeneous { 
	static constexpr bool value = std::is_same_v<First, Second>
		&& is_homogeneous<Second, Types...>::value;
};

template <typename First, typename Second>
struct is_homogeneous <First, Second> {
	static constexpr bool value = std::is_same<First, Second> 
};


#####################
Оператор sizeof...

Есть встроенный оператор sizeof... и его можно вызывать от пакетов:

std::cout << sizeof...(tail);

Он возвращает в компайлтайме число, равное размеру пакета (Как от пакета переменных, так и от пакета типов.)



______________________________________________________
Выражения свёртки (fold expressions) C++17

В C++17 добавили более крутую функцию. Допустим мы хотим проверить что все типы в пакете это указатели. Мы имеем метафункцию std::is_pointer_v, которая для данного типа 
проверяет указатель ли это или нет.

template <typename ... Types>
struct all_pointers {
	static const bool value = (std::is_pointer_v<Types> && ...);
};

Если у нас есть пакет, то мы можем засунуть его в fold expressions. fold expressions это когда мы берём какой нибудь expressions, в котором фигурирует пакет, и бинарным 
оператором его соединяем просто с многоточием (...). Это всё разворачивается в компайлтайме. Т.е. это означает для всех типов из пакета повтори вот эту штуку через коньюнкицю и.


Реализуем  is_homogeneous с помощью fold expressions:

template <typename Head, typename... Tail>
struct is_homogeneous {
	static const bool value = (std::is_same_v<Head, Tail> && ...);
};


Реализуем print:

template <typename... Types>
void print(const Types&... types){
	(std::cout << ... << types);
}


У fold expressions есть 4 разновидности:

1) ( pack op ... )
2) ( ... op pack )
3) ( pack op ... op init )
4) ( init op ... op pack )

где, pack - пакет, op - оператор, init - инициализатор.

В чём разница между 1) и 2)? Разница в ассоциативносию. Разные операторы имеют разную ассоциативность, кто-то лево ассоциативен, кто-то право ассоциативен. 1) вид выражения
превращается в правоассоциативную штуку. Т.е. написать вариант 1) это тоже самое что написать (E_1 op (... op (E_N - 1 op E_N))), т.е. скобки справа налево расставлены.
2) вариант эквивалентно написанию (((E_1 op E_2) op ...) op E_N).

3) и 4) тоже самое, только с инициализацией.


###
Подробное объяснение 

Возьмём этот код:

template <typename... Ts>
void print(Ts... args) {
	(std::cout << ... << args);
}

Это означает следующий код:

(std::cout << arg1 << arg2 << arg3);


Варианты fold expression
Форма			Что делает
(args + ...)		a + b + c
(... + args)		((a + b) + c)
(f(args), ...)		f(a); f(b); f(c);
(... && args)		логическое И



Реальный пример (из темы аллокаторы / make_shared)

template <typename T, typename... Args>
T* create(Args&&... args) {				// perfect forwarding
	return new T(std::forward<Args>(args)...);	// распаковать каждый аргумент
}

Что тут происходит:
1) typename... Args - создаём пакет типов
Args - это пакет типов, т.е. Args = {тип1, тип2, тип3, ...}
например если
create<MyClass>(10, 3.14, std::string("h1"));
тогда компилятор подставляет:
T = MyClass
Args = { int, double, std::string }

2) Args&&... args
Args... - пакет типов (int, double, std::string)
Args&& - forwarding reference (важно: именно в шаблоне)
Args&&... args - несколько параметров функции
Компилятор видит это так:
T* create(int&& a, double&& b, std::string&& c);
Однако здесь reference collapsing (см. Семантика перемещения):
Что передали	Реальный тип
lvalue x	int&
rvalue 10	int&&


Конкретный пример вызова:
int x = 5;
std::string s = "hi";
auto p = create<MyClass>(x, 10, s);

В этом случае компилятор выводит типы (template argument deduction)
T = MyClass
Args = {
	int&,		// x - lvalue
	int,		// 10 - rvalue
	std::string&	// s - lvalue
}

И после reference collapsing тип параметров функции будет выглядить так:

T* create {
	int& a,
	int&& b,
	std::string& c
}

3) Далее внутри функции разберём по шагам
3.1) std::forward<Args>(args) 
Для каждого аргумента:
---------------------------------------------------
Args		args	std::forward
---------------------------------------------------
int&		a	int&
int		b	int&&
std::string&	c	std::string&
--------------------------------------------------
std::forward сохраняет категорию значения

3.2) А теперь самое важное
std::forward<Args>(args)...

... применяется ко всему выражению std::forward<Args>(args) (потому что выражение стоит слева от ...)
Это означает
std::forward<int&>(a),
std::forward<int>(b),
std::forward<std::string&>(c)

3.3) Подстановка в new T(...)
Компилятор фактически генерирует:
return new MyClass(
	std::forward<int&>(a),
	std::forward<int>(b),
	std::forward<std::string&>(c)
);

А это эквиваленто:
return new MyClass(x, 10, s);
lvalue остались lvalue, rvalue остались rvalue.


###
Некоторые вопросы

1) Почему нельзя писать без ...
Так нельзя: 
return new T(std::forward<Args>(args));
потому что тогда компилятор не узнает сколько элементов в пакете

так тоже нельзя:
return new T(std::forward(args)...);
потому что forward - шаблон, ему нужен тип


2) Зачем вообще всё это:
Без variadic templates пришлось бы писать вот так:

template <typename T>
T* create(int a);

template <typename T>
T* create(int a, double b);

template <typename T>
T* create(int a, double b, std::string c);

А с ...
- любое кол-во аргументов
- идеальная передача
- ноль копий


3) Ментальная модель (ключевая)
Args - это список типов
args - это список переменных
... - это "разверни список поэлементно"

Компилятор 1) берёт пакет, 2) подставляет элементы по одному, и 3) генерирует обычный код


4) Как понять, что именно делает ... в коде:
Задай себе 3 вопроса:
1. Это объявление шаблона? Тогда создаём пакет
2. Это рядом с именем переменной или типа? Тогда это распаковка
3. Это внутри скобок с оператором? Тогда это fold expression


5) Старый C-style ... (ВАЖНО НЕ ПУТАТЬ)
void printf(const char*, ...);
Это другое ...
- нет типов
- нет проверок
- unsafe
- почти никогда не использовать в C++


______________________________________________________
Неочевидное использование шаблоннов

1) Паттерн CRTP 

template <class T>
struct Base {
	
	/* Просто пояснения, это не входит в пример	
	// T x;    Не будет работать
	T* ptr;	// Будет работать
	T& rtf;
	*/
	
	void interface() {
		// ...
		static_cast<T*>(this)->implementation();
		// ...
	}
	
	static void static_func() {
		// ...
		T::static_sub_finc();
		// ...
	}
};

struct Derived : Base<Derived> {
	void implementation();
	static void static_sub_finc();
};

Класс Derived наследуется от Base с шаблонным параметром Derived. Т.о. Base в некотором смысле знает что T это его потомок. С помощью этого паттерна мы можем в каком то смысле 
иметировать поведение виртуальных функций. У нас есть функция interface, определённая у базового класса, которая для разных T она себя ведёт по разному, и мы, обращаясь к 
базовому классу, можем вызвать эту функцию. Но по факту будет делаться static_cast к наследнику и вызываться его реализация. 

Шаблоны это просто генерация кода, т.е. когда я говорю Derived : Base<Derived>, я просто говорю компилятору подставь T = Derived в Base и просто возьми этот кусок кода и 
скопипасть его, но только чтобы вместо T везде напиши Derived.



2) Expression templates

Очень долгое объяснение. Лекция 26 21.40


______________________________________________________________________________________
SFINAE (Отказ от замены не является ошибкой)

SFINAE — это принцип метапрограммирования шаблонов C++, который позволяет компилятору выбирать соответствующую функцию или класс, когда конкретная специализация шаблона терпит неудачу
во время замены. Термин «ошибка замены» относится к процессу, в котором компилятор пытается заменить аргументы шаблона в шаблон функции или шаблон класса. Если замена вызывает ошибку,
компилятор не будет рассматривать эту конкретную специализацию как кандидата и продолжит поиск допустимой.

Ключевая идея SFINAE заключается в том, что если возникает ошибка замены, она молча игнорируется, и компилятор продолжает исследовать другие специализации или перегрузки шаблона. Это 
позволяет вам писать более гибкий и универсальный код, поскольку позволяет иметь несколько специализаций для разных сценариев.

Пример кода
Вот пример, демонстрирующий SFINAE в действии:

#include <iostream>
#include <type_traits>

template <typename T, typename = void>
struct foo_impl {
    void operator()(T t) {
        std::cout << "Called when T is not arithmetic" << std::endl;
    }
};

template <typename T>
struct foo_impl<T, std::enable_if_t<std::is_arithmetic<T>::value>> {
    void operator()(T t) {
        std::cout << "Called when T is arithmetic" << std::endl;
    }
};

template <typename T>
void foo(T t) {
    foo_impl<T>()(t);
}

int main() {
    int a = 5;
    foo(a); // output: Called when T is arithmetic

    std::string s = "example";
    foo(s); // output: Called when T is not arithmetic
}


В этом примере мы определяем две foo_impl специализированные функции на основе логического значения std::is_arithmetic<T>. Первый активируется, если T это арифметический тип, а второй
активен, если T не является арифметическим типом. Затем функция foo вызывает соответствующую foo_implспециализацию на основе результата признака типа.

При вызове foo(a) целого числа выбирается первая специализация, а при вызове foo(s) строки — вторая специализация. Если действующей специализации нет, код не сможет скомпилироваться.






______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Вывод типов auto, decltype(auto)

Начиная с C++11 в язык добавлено слово auto. Мы можем объявлять переменные с типом auto и компилятор сам догадается какой у них тип. Однако стоит помнить что все типы переменных фиксированны и известны на этапе копиляции.

int main() {
	auto x = 5;
}

Чтобы компилятор понял какой тип у переменной, он посмотрит на выражение справа. Этот механизм вывода типа с помощью auto сводится к уже известному нам механизму вывода типа шаблона. Тип который назначается x по сути 
такой же тип как если бы мы написали так:

template <typename T>
void f(T x) {}

int main() {
	int x = 5;
	f(x);
}

Компилятор умеет отгадывать T исходя из того, что мы передали в функцию. auto работает также. Компилятор это понимает потому что формально у каждого експрешена есть тип, для примитивных типов тип определён и зашит в 
стандарт, если это вызов функции то у неё есть возвращаемый тип, вот он и берётся. Однако в данном случае здесь T мы берём по значению, это значит что ссылки будут отброшены. Это главное что нужно знать про auto: он работает
так же как и если бы в шаблонную функцию передавали, в том числе с ссылками.

Если мы хотим сделать ссылку, то нужно указать это явно:

int x = 5;
auto& y = x;		// Написали &

Это будет работать как если бы мы в функцию передавали параметр по ссылке:

template <typename T>
void f(T& x) {}

Т.е. когда мы написали auto& y =  справа чтото, это как если бы мы в функцию передали то что справа по ссылке. 

Так же мы можем сделать так:

auto x = 5;			// тип int
auto& y = x;			// тип int&
const auto& z = y; 		// тип const int&
auto&& t = x;			// тип универсальная ссылка
auto&& t1 = std::move(x);	// тип rvalue-ссылка 


auto&& работает также как и:

template <typename T>
void f(T&& x) {}

Здесь в шаблонной функции T&& это не rvalue, а универсальная ссылка. auto&& работает так же, это не rvalue, а универсальная ссылка. Это второй случай когда двойной амперсанд && работает не как rvalue ссылка. Т.е. это 
попрежнему работает также как и если бы мы в шаблонную функцию передавали по типу T&&, поэтому здесь t это lvalue ссылка на x, несмотря на то что мы написали auto&&, t это lvalue-ссылка, а не rvalue-ссылка, потому что 
произошёл reference collapsing, т.е. навесился дополнительный амперсанд на auto, auto превратилось в int&, и t стал типом int&. Но если бы мы написали так std::move(x) то t стало бы rvalue ссылкой, потому что справа написано
rvalue експрешен, auto превращается в int, auto&& это int&&, получаем t это int&&. 


Представим что у нас есть какая нибудь шаблонная функция, в которую мы принимаем контейнер и мы хотим обойти этот контейнер. Иногда мы можем увидеть такой синтаксис:

template <typename Container>
void f(Container&& container) {
	for(auto&& value : container) {
		// Что-то делаем
	}
}

Почему такой синтаксис иногда лучше чем const auto&, или тем более просто auto, или auto&, ну т.е. когда мы делаем range-based for по какому то контейнеру. Когда мы пишем auto&& мы позволяем обработать как lvalue так и 
rvalue правильно, это работает как универсальная ссылка опять. Этот for по сути синтаксический сахар для обхода по итераторам. Но если у нас в контейнере квадратные скобочки [] могут возвращать rvalue а не lvalue ссылку по 
какой либо причине:

template <typename Container>
void f(Container&& container) {
	for(auto&& value : std::forward<Container>(container)) {
		// Что-то делаем
	}
}

Вот мы приняли контейнер по какой то ссылке, и хотим эту ссылку сохранить, т.е. либо у lvalue, либо у rvalue вызывать квадратные скобочки и т.д., и тогда по такой ссылке мы сохраним вид value, если у нас  был rvalue - мы 
получим rvalue ссылку, если было lvalue - то получим lvalue ссылку. Поэтому обход контейнера по такой штуке бывает иногда лучше. 

Однако стандартные контейнеры всегда возвращают lvalue и у них нет перегрузки по ссылочным квалификаторам и для них это не важно, однако мы можем мувать результат квадратных скобочек. Но если у нас свой контейнер или 
например мы можем обрабатывать функцию которая возвращает нечто у которого есть диапазон begin и end. Допустим у нас там мув итераторы begin и end, и тогда такми синтаксисом мы сможем корректно обработать и lvalue и rvalue:

template <typename Container>
void f(Container&& container) {
	for(auto&& value : func(container)) {
		// Что-то делаем
	}
}


Аналогично если мы напишем так:

auto& a = 0;	// Это будет CE, потому что это lvalue ссылка и её нельзя инициализировать через rvalue.
auto&& a = 0;	// Так будет корректно, потому что справа rvalue, значит auto выведится как int, auto&& выведется как int&& и это будет продление жизни. 


auto можно комбинировать и со звёздочкой *:

auto* p = &x;	// auto это будет int, auto* будет int*. Точно так же как мы принимае T* в шаблонную функцию.

Можно ещё написать так:

int* p = new auto(5);



#########################################
auto можно писать в возвращаемом типе функций:

template <typename T>
auto g(T x) {
	return ++x;
}

int main() {
	auto x = g(1);		// Какой тип будет у x?
}

Какой возвращаемый тип будет у функции g? Будет int а не int&, потому что мы не поставили амперсанд в возвращаемый тип, поэтому мы возвращаем по значению. Если мы поставим ссылку:

template <typename T>
auto g(T x) {
	return ++x;
}

int main() {
	auto& x = g(1);	// Поставили &
}

то будет CE, потому что справа rvalue. Если сделаем так: 

int main() {
	auto&& x = g(1);
}

то всё хорошо, мы сделали продление жизни rvalue. 

Если мы напишем так:

template <typename T>
auto& g(T x) {				// Добавили &
	return ++x;
}

int main() {
	auto&& x = g(1);		
}

то это UB, здесь битая ссылка, потому что x это временный объект функции g, который мы возвращаем по ссылке, и привязываем его к ссылке в main, но объект был временный и мы получили ссылку на временный объект, который был
уничтожен при выходе из функции g. При этом не важно напишем мы так: auto& x = g(1) или так: auto&& x = g(1), это все ровно будет битая ссылка и будет UB. Когда у нас возвращаемый тип просто auto мы создаём копию от возвращаем
её, а когда auto& мы передаём ссылку на локальный объект, который удалиться при выходе из функции g.


Что если мы попытаемся вернуть из функции разные типы, в зависимости от какого-то условия с помощью auto? 

template <typename T>
auto g(T x) {				
	if(x > 0) 
		return 0;		// Тип int
	else
		return 1u;		// Тип unsigned int
}

Здесь будет CE, компилятор не сможет вывести возвращаемый тип функции. Причём не важно что типы приводятся друг к другу, это не важно. 


Что если мы будем использовать if constexpr, который в зависимости от условия будет подставлять один кусок кода или другой кусок кода? 

template <typename T>
auto g() {				
	if constexpr (std::is_same_v<T, int>) 
		return 0;		// Тип int
	else
		return 1u;		// Тип unsigned int
}

int main() {
	g<int>();			// Это будут две разные функции с разными возвращаемыми типами. 
	g<double>();
}

Однако при этом взвращаемое auto тоже должно превратиться в разные типы. Вопрос: что происходит раньше, компилятор попытается понять чему равно auto, или уберает одно из веток if constexpr? Да, это будут две разные функции с 
разными возвращаемыми типами, всё корректно потому что if constexpr преобразовывает код ДО того как компилятор пытается понять что такое auto. При вызове функции g: g<int>(), компилятор сначало поймёт что такое T, затем 
подставит правильный кусок кода в зависимости от условия if constexpr, и затем он поймёт что такое возвращаемое auto.

Но что если мы попытаемся вернуть вызов этой же функции? Компилятор захочет узнать что вернёт g(x).

template <typename T>
auto g(T x) {					
	if constexpr (std::is_same_v<T, int>) 
		return g(x);	// Вместо 0 пишем g(x)
	else
		return 1u;		
}

int main() {
	auto x = 5;
	g(x);
}

На такой случай у компилятора есть защита от бесконечной рекурсии в компайл тайме, пытаясь вычислить что такое auto будет CE. 


trailing return type
Иногда мы пишем auto в возвращаемом типе не для того чтобы компилятор догадался какой возвращаемый тип, а просто для удобства. Иногда возвращаемые типы функций очень длинные и сложные и начиная с C++11 есть такой 
синтаксис, чтобы возвращаемый тип писался после сигнатуры функции а не до неё:

// Обычный синтаксис:
template <typename T>
std::remove_reference_t<T>&& move(T&& value) {
	return static_cast<std::remove_reference_t<T>&&(value);
}

// Новый синтаксис trailing return type:
template <typename T>
auto move(T&& value) -> std::remove_reference_t<T>&&
{
	return static_cast<std::remove_reference_t<T>&&(value);
}

Эти две формы записи эквивалентны. Так просто читабильнее. Здесь должно быть обязательно просто auto, здесь не может быть auto& например. Стрелка это не вывод типа, это просто перенос сигнатуры возвращаемого типа после 
функции а не до неё.


Начиная с C++20 auto можно писать в принимаемых типах функций (в аргументах):

// Старая запись:
template <typename T>
void f(T&& x) {}

// Новая запись
void f(auto&& x) {}

Эти две записи эквивалентны. Написать f(auto x) это всё ровно что написать template <typename T> f(T x), это просто сокращение (синтаксический сахар).

Так же можно делать так:

void f(auto... x) {}

Это будет сокращённая форма записи для template <typename T, typename... Args> void f(Args... args) {}. 


auto также можно писать в параметрах шаблона. У шаблона могут буть числовые параметры int, char, bool и компилятор тоже может определить что бы дали в шаблон:

template <auto N>
struct Example {};

int main() {
	Example<2> ei;		// auto = int
	Example<'a'> ec;		// auto = char
}
						
Начиная с C++20 в параметры шаблона можно передавать не только числа, но об этом потом. 


По сути auto это сокращение для template <typename T> т.е. механизм такой же. Он даже работает в случае с std::initializer_list: 

template <typename T>
void h(T) {}

int main() {
	h({1, 2, 3});		// Так не работает
	auto lst = {1, 2, 3};		// Так работает
}

Шаблонный параметр функции в качестве initializer_list не получается вывести, однако auto переменную фигурные скобочки получается. При этом понятно что если мы сделаем вот так:

auto lst = {1, 2.0, 3};

то мы не можем так сделать, потому что разные типы в initializer_list.


_____________________________________________
decltype (since C++11)

Это ключевое слово позволяет узнать нам тип выражения в компайл тайме, не в рантайме как это делает typeid, а в компайл тайме. decltype это штука, которая в компайл тайме превращается в тип, и то что в скобках означет то, типом чего 
она станет. 

int main() {
	int x = 0;
	decltype(x) y = x;
}

Мы можем про произвольный экспрешен спросить какой у него тип, и вот такой тип в компайл тайме и подставить. 

int main() {
	int x = 0;
	decltype(x) y = x;
	
	std::vector<decltype(y)> v;
}

decltype это штука, которую мы можем подставлять всюду без проблем, где ожидается название типа, и в компайл тайме всё прекрасно развернётся в настоящий тип. В данном случае у нас будет вектор int.

decltype, в отличие от auto, не отбрасывает ссылки, decltype называет нам точный тип.

int main() {
	int x = 0;
	int& y = x;
	decltype(y) z = y;	// Тип z будет int& , а не просто int.
}

Это неочевидно но очень важно. Ссылка от оригинального объекта неотличимы ничем и никто не может их отличить, только decltype умеет отличать ссылки от оригинальных объектов, поскольку он называет точный тип. В данном случае
y от x в рантайме никак не отличим, но в компайл тайме мы можем спросить про x и y с помощью decltype, и он по разному ответит.


Мы можем на decltype навешивать & и const:

int main() {
	int x = 0;
	int& y = x;
	decltype(y) z = y;	
	decltype(x)& t = x;		// Это будет ещё одна ссылка на x
}

В данном случае мы создали 4 разные переменные, однако они обозначают один и тот же int. Два амперсанда тоже можно, однако это уже не унивирсальная ссылка, а rvalue - ссылка.

int main() {
	int x = 0;
	int& y = x;
	decltype(y) z = y;	
	//decltype(x)&& t = x;		// Это CE
	decltype(x)&& t = std::move(x);		// Всё корректно
}

Также мы можем навесить указатель или const на decltype:

int main() {
	int x = 0;
	int& y = x;
	const decltype(y) z = y;	
}

Однако в данном случае decltype от z: decltype(z) это не const int& , а просто int&, потому что const навешивается сверху над decltype, а не под ссылку, а int& const это всё ровно что просто int&. Поэтому const отброситься. Чтобы добавить
const под ссылку нужно делать remove_reference и уже затем добавлять const. 


Лайфхак: Как понять какой тип вывелся decltype? Чтобы нам узнать какой тип у экспрешена или какой тип вывел decltype:

template <typename T>
struct Debug {
	Debug() = delete;
};

int main() {
	int x = 0;
	int& y = x;

	Debug<decltype(y)>();
}

Мы передаём в Debug какой от шаблонный аргумент явно и сейчас мы увидим CE со словами "Не могу создать Debug с таким то шаблонным параметром".

Если мы напишем так:

int main() {
	int x = 0;
	int& y = x;
	decltype(y)& z = y;		// Добавили &
}

то произойдёт reference collapsing, и в итоге будет один амперсанд. 

const можно навеситься на указатель:

int main() {
	int x = 0;
	
	decltype(&x) const p = &x;
	Debug<decltype(p)>();
}

decltype от адреса x: decltype(&x) - это int*, и мы ещё const навесили сверху, должен получиться int* const. Этот const никуда не делся потому что на ссылку сверху навесить const это бессмыслено, а вот на указатель сверху навесить const это
осмыслено. Если мы напишем слева то ничего не поменяется, const всё ровно навеситься на указатель сверху. 


decltype можно брать от производного выражения. Например что если:

int x = 0;
decltype(++x) u = x;
++u
std::cout << x << " " << u;

Вывод в терминал:1 1

decltype не вычисляет выражения под собой, он лишь смотрит на его тип. Это впринципе не может так работать потому что decltype в компайл тайме должен отработать, под decltype ничего не может вычислится. Роль decltype лишь в том,
чтобы посмотреть какой тип был бы, если бы это вычислилось, но вовсе не может впринципе никак вычислится, потому что decltype разворачивается в компайл тайме. Поэтому u это будет ссылка на x. А почему ссылка то а не просто тип?
decltype(++x), где x типа int возвращает ссылку int&, а вот decltype(x++) возвращает значение типа int (при этом x бы не увеличился), потому что в одном случае lvalue, в другом rvalue.  

decltype(std::move(x)) u = x;		// Так будет CE, потому что rvalue ссылку нельзя инициализировать lvalue.	
decltype(std::move(x))& u = x;		// Так будет снова нормально, здесь сработает reference collapsing. 

decltype сохраняет амперсанды, если мы делаем decltype от std::move(), то получаемый тип это int&&, но мы навесили ещё один амперсанд & и тип получился int&. 

Что будет в таком случае, корректно или нет?:

int x = 0;
decltype(throw 1)* p = &x;

Тип выражения у throw 1 это void. Это корректно, это будет void*. Исключения не будет потому что мы находимся в компайл тайме. 

В прошлый раз в указателе decltype возвращал int* , однако сейчас он возвращает просто void. В данном случае у нас decltype возвращает просто void а не указатель void*. Поэтому если мы теперь напишем const у нас будет 
тип const void*, и теперь при добавлении const должен лечь под указатель а не над ним:

int x = 0;
const decltype(throw 1)* p = &x;
Debug<decltype(p)>();

И теперь decltype вывел тип const void*. 



Ещё странный но важный пример - decltype от x в скобках:

int main() {
	int x = 0;
	decltype((x)) y = x;
}

Сейчас y это будет ссылка на int, а не просто int. Дело в том что decltype работает по разному от имён переменных и от експрешенов. По сути это два разных механизма.  CPP Reference: если аргумент не обёрнутый в скобки индификатор
(т.е. имя переменной) или это не обёрнутое в скобки обращение к члену класса, то decltype просто даёт нам тип этого (Это случай decltype от entity). Но если это любое другое выражение, включая выражения в скобочках, то возникают
следующие правила: 
1) Если категория value это xvalue, то тогда decltype навешивает два амперсанда &&.
2) Если категория value это lvalue, то тогда decltype навешивает один амперсанд &.
3) Если категория value это prvalue, то тогда decltype ничего не навешивает. 

Получается формально decltype от выражения ведёт себя по разному, смотря какой вид value у этого выражения. Если мы берём x в скобочках: (x) - это lvalue, но это не просто имя переменной, это експрешен нетривиальный уже, поэтому 
навешивается амперсанд. 

Если мы возьмём такое експрешен:

struct S {
	int x = 0;
};

int main() {
	int x  = 0;
	decltype(S().x) z = x;
}

то тип у z будет int, потому что это обращение к члену класса не обёрнутое в скобочки и это подходит под случай decltype от entity а не от expression. Но если это был бы xvalue експрешен и даже если тип был бы int, то он бы сгенерировал 
int&&, а не int.



Иногда нам может хотеться, чтобы мы из функции возвращали тип, определённый правилам decltype. Представим что у нас есть функция которая принимает контейнер и индекс и мы хотим из этой функции вернуть ссылку на элемент, так
чтобы можно было бы присваивать, т.е. обёртку над обращением по индексу для разных контейнеров. если мы напишем функцию с возвращаемым типом просто auto то это не будет работать, потому что мы возвращаем без амперсандов,
т.е. rvalue, и никакого присваивания не будет:

template <typename Container>
auto getElement(Container& cont, size_t index) {
	return cont[index];
}

int main() {
	std::vector<int> v(5);
	getElement(v, 0) = 1;
}

Если мы поставим амперсанд, это будет работать, мы возвращаем ссылку на элемент, возвращаем с сохранением ссылки и присвоили, но это будет работать невсегда. Это не будет работать с вектором bool. Иногда нам может хотеться 
возвращать из функции то ссылку то не ссылку. Если мы напишем auto или auto& это приведёт к тому, что мы всегда будем возвращать ссылку или не ссылку. Но что если мы хотим возвращать иногда ссылку, а иногда не ссылку, смотря 
какой тип вот у того, что написано после return. В таком случае нам может понадобиться decltype в возвращаемом типе, потому что мы хотим чтобы оно само определилось какой возвращаемый тип, но по правилам decltype а не по 
правилам auto, чтобы он не отбрасывал амперсанды, если они были. На такой случай у нас есть два синтаксиса:

1) Начиная с C++11 синтаксис trailing return type:

template <typename Container>
auto getElement(Container& cont, size_t index)
	-> decltype(cont[index])
{
	return cont[index];
}

Этот синтаксис говорит нам, что компилятор не будет выводить тип с помощью правил auto, он будет выводить тип с помощью правил decltype, т.е. возвращаемый тип будет таким, каким скажем мы, а не таким, каким компилятор сам 
догадался, поэтому возвращаемый тип будет такой, какой у этого выражения: decltype(cont[index]). Почему мы не можем написать это выражение в начале? Потому что формально переменные cont и index ещё не объявлены на момент
написания возвращаемого типа. Т.е. если мы напишем определение возвращаемого типа в начале, то это CE, не понятно что такое cont и index. Но если мы напишем в синтаксисе trailing return type то всё норм. 

2) Начиная с C++14 есть новый синтаксис: decltype(auto):

template <typename Container>
decltype(auto) getElement(Container& cont, size_t index)
{
	return cont[index];
}

Это означает тоже самое что и написано раньше в первом синтаксисе, просто короче. Т.е. decltype(auto) это значит компилятор выведи тип самостоятельно, но по правилам decltype а не просто auto, в частности, не отбрасывая амперсанды.
Такая запись означает что тип будет выведен автоматически из того, что написано после return, но по правила decltype а не по правилам auto.

А теперь внимание кринж. Что будет сейчас?

template <typename Container>
decltype(auto) getElement(Container& cont, size_t index)
{
	return (cont[index]);		// Добавили скобки
}

В кодстайле сказано: никогда не ставьте круглые скобки после return. Это пример демонстрирует почему так не нужно делать. Сейчас всегда будет возвращаться ссылка, даже в случае вектора bool, потому что после return стоит не просто 
выражение, а выражение в скобочках, а выражение в скобочках навешивает амперсанд. cont[index] это prvalue, но когда мы берём это выражение в скобочки оно становиться lvalue. (Лекция 43 1.17.00 непонятно объяснил).

Вот так точно: decltype(auto) можно делать и в объявлениях переменных. 

template <typename Container>
decltype(auto) getElement(Container& cont, size_t index)
{
	decltype(auto) element = cont[index];
	return element;		
}

Здесь написано тоже самое, мы достали элемент и это либо ссылка либо не ссылка в зависимости от того это вектор bool или не bool, и теперь мы возвращаем этот элемент как переменную а не выражение. Сейчас если бы это было 
ссылкой, то и decltype(auto) тоже был бы ссылкой, но если бы это был вектор bool, этот element имеет тип bool reference без амперсанда, значит decltype(auto) от этой штуки имеет тип bool reference без амперсанда, и вернётся bool
reference без амперсанда, но возми это в скобочки и амперсанд добавиться, потому что это выражение а не просто имя переменной, и вот таким образом мы вернём битую ссылку, потому что мы вернём ссылку на локальный объект 
bool reference. От того что мы поставили скобочки после return получилось UB. 


Исправление emplace_back() в векторе:

void emplace_back(auto&&... args) {
	if(sz == cap_) {
		reserve(cap_ > 0 ? cap_ * 2 : 1); 	
	}
	AllocTraits::construct(alloc_, arr_ + sz_, 
		std::forward<decltype(args)>(args)...);
	++sz_;
}

Если мы принимаем по универсальной ссылке то нам также нужно понять что отдать в forward, для этого нужно использовать decltype. Если args изначально был lvalue, то тип args будет с одним амперсандом & и мы в forward отдадим
с одним амперсандом &. Если args изначально приняли rvalue, то в forward мы отдадим тип с двумя амперсандами &&, такого раньше мы не делали, это новый случай. Это первый раз когда у нас происходит reference collapsing когда 
два амперсанда и два амперсанда. Раньше, когда мы принимали Args, мы в forward передавали Args и два амперсанда навешивались на сырой тип, а когда мы принимаем так, мы в forward передаём decltype от args, но там уже два 
амперсанда, однако это тоже правильно работает. 



_____________________________________________
Deducing this (since C++23)

Вообще std::optional это класс из стандартной библиотеки, который может пригодиться на замену exception. Если функция может завершиться неудачно, то с помощью std::optional функция
может либо вернуть T, либо ничего. Так он обходит выделение динамической памяти, при использовании placement new мы понимаем что можем просто на массиве char либо положить value,
либо не положить. Если мы разыменуем optional в котором ничего не лежало, то это UB. 


template <typename T>						// Реализация std::optional C++17
class optional {
	char val[sizeof(T)];
	bool initialized = false;
public:
	optional(const T& newvalue) : initialized(true) {
		new (val) T(newvalue);
	}
	optional() {} 						// optional по умолчанию ничего не делает
	~optional() {
		if(initialized) {
			reinterpret_cast<T>(val)->~T();
		}
	}
	bool has_value() const {				
		return initialized;
	}
	operator bool() const {					// Можно проверить лежит ли чтото в optional, просто скастив его к bool.
		return initialized;
	}
	T& operator*() {					// Вернуть из optional, то что в нём лежит
		return reinterpret_cast<T&>(*val);		
	}
	const T& value_or(const T& other) const {		// Если в optional что то лежит, то верни мне это, а иначе верни константу которую мы передали в параметр.
		return initialized ? reinterpret_cast<T&>(*val) : other;
	}
};


Есть ещё глобальная переменная std::nullopt.  

struct nullopt_t();
nullopt_t nullopt;

Она нужна для того, чтобы optional проинициализировать явно пустым значением.


(Дополнение лекция 44 начало)
В классе std::optional есть оператор звёздочка * и метод value, который возвращает значение. Данный методы нужно реализовывать аккуратно, например оператору * нужно 4 перегрузки. Если мы хотим правильно реализовать optional,
нам нужно писать так:

T& operator*() {					// Обычная версия
	return reinterpret_cast<T&>(*val);		
}

const T& operator*() const {				// Навесили const
	return reinterpret_cast<const T&>(*val);		
}

T&& operator*() && {					// Перегрузка для rvalue-ссылок
	return reinterpret_cast<T&&>(*val);		
}

const T&& operator*() const && {			// Навесили и const и &&
	return reinterpret_cast<const T&&>(*val);		
}

Для метода value тоже имеется 4 перегрузки, однако он кидает исключение если небыло значения:

T& value() & {
	if(!initialized)
		throw std::bad_optional_access();
	else
		return reinterpret_cast<T&>(*val);
}

И таких нам нужно написать ещё 3. Можно сталкнуться с такой проблемой когда пишем например реализацию std::deque, у нас там есть оператор квадратных скобочек [], который нужно отдельно определеить для константного дека и
неконстантного дека. Этот оператор пишется не в одну строчку, он нетривиальный. И нам нужно написать его для const дека и не const дека и разница только в том, что в одном тип у нас возвращаемый тип T&, а в другом const T&.
Можно вызвать одно из другого, но для этого потребуется const_cast. Но ещё нам нужно поддержать для квадратных скобочек виды value, чтобы квадратные скобочки для rvalue возвращали rvalue ссылку, тогда нам нужен не только
const_cast а ещё и move навесить, т.е. у нас опять 4 перегрузки, и чтобы эти перегрузки работали корректно нужно все эти 4 перегрузки по всем видам value. 

Хватит это терпеть, есть ещё один контекст в котором можно использовать auto, это такая фича которая называется Deducing this. Начиная с C++23 Можно писать так:

template <typename Self>					// Self - это просто имя типа
decltype(auto) value(this Self&& self) {
	if(!initialized)
		throw std::bad_optional_access();
	else
		return reinterpret_cast<???>(*self.val);	// Непонятно что нужно написать
}

Т.о. мы одним махом реализовываем все 4 перегрузки. Эта версия метода будет работать и для lvalue-ссылки и для const lvlaue-ссылки и для rvalue и для const rvalue. Синтаксис в аргументе метода означает, что мы хотим this принять по 
такому виду ссылку, смотря от какого типа мы вызвались. Если мы пишем обычный метод класса то по умолчанию Self был бы неявным аргументом, но начиная с C++23 мы можем первым аргументом в метод класса принять Self явно, и
это позволяет нам сказать по какой ссылке мы хотим принять Self, т.о. мы можем не делать перегрузку методов, которые отличаются только видом ссылки Self.

Главаня фишка в том что мы можем написать так:
				
decltype(auto) value(this auto&& self) {
	if(!initialized)
		throw std::bad_optional_access();
	else
		return reinterpret_cast<???>(*self.val);	
}

Здесь в аргументе мы можем написать auto и без амперсандов или с одним или с двумя амперсандами и это будет работать по обычным правилам. Если мы постамим один амперсанд то мы auto выведем как наш тип и на него будет
навешан один &, если два амперсанда то мы сможем вызываться себя как от lvalue, так и от rvalue. Но мы можем не ставить амперсандов впринципе здесь, тогда мы примем себя по значению, это тоже бывает нужно. Представим что
у нас есть класс итератора и мы не хотим себя принимать по ссылке, раньше когда мы писали код мы всегда неявно принимали себя по ссылке и мы ничего не могли с этим сделать, и если у нас класс такой, что его выгоднее принимать
по значению а не по ссылке, то мы никак не можем иизбежать этого, от чего у нас лишнее разыменования. Начиная с C++23 мы можем в себя принять себя по значению. 

Что же нужно написать вместо ???

Есть такая функция forward_like (since C++23). Она работает как forward, только она сохраняет вид value для типа, но сам тип она подменяет.

template< class T, class U >
[[nodiscard]] constexpr auto&& forward_like( U&& x ) noexcept; 

Мы передаём ей U и она возвращает нам U, но с такими же свойствами как и T.  (Короче он тут сам запутался Лекция 44 18.30)

decltype(auto) value(this auto&& self) {
	if(!initialized)
		throw std::bad_optional_access();
	using DesiredType = decltype(std::forward_like<decltype(self)>(std::declval<T>()));
	return reinterpret_cast<DesiredType >(*self.val);	
}

Короче этот пример он привёл зря. Здесь главная проблема в том что тут нет никакого значения типа T чтобы от него вызвать std::forward_like. Нам нужно из ничего нужно получить вещь типа T и для этого есть магическая функция 
std::declval, которая по данному типу даёт нам значение данного типа. Можно считать std::declval это операция обратная std::decltype. Мы взяли нечто типа T сдеали (std::forward_like<decltype(self)>, т.е. сделали T с такой же константностью
и амперсандами как self,  и вот decltype от этого и есть наш желаемый тип. К такому типу мы и кастим value.



_____________________________________________
CTAD - Class Template Argument Deduction

CTAD - это способность компилятора выводить типы шаблонов не только функций, но и классов. Начиная с C++17 мы можем писать:

int main() {
	std::vector v = {1, 2, 3, 4, 5};
}

и не указывать от чего вектор, он сам догадается. Это очень полезная штука, когда нам нужно объявить tuple, пару или кортеж из нескольких элменетов. tuple - это кортеж из нескольких элементов нескольких типов. 

Тут возникает много вопросов и проблем: как именно он догадывается какие аргументы подставить? В данном случае понятно что может быть только int, однако:

int main() {
	std::vector v2(5);
}

Будет CE потому что непонятно какой тип мы имеем ввиду. 

Есть ещё более кринжовый пример: представим что у нас есть вектор из int и мы говорим:

int main() {
	std::vector v = {1, 2, 3, 4, 5};

	std::vector v2{v.begin(), v.end()};
}

У нас есть уже вектор v, и тут мы решили создать второй сектор от таких параметров. Как вы думаете v2 это будет вектор из чего? Это будет вектор из итераторов на вектор int. Потому что скобочки фигурные а не круглые. Когда мы пишем 
фигурные скобочки, тогда в приоритете конструктор от initializer_list, а этот конструктор понимает из чего создать вектор глядя на то, что в initializer_list, поэтому получиться вектор из итераторов. 

Ну и вообще часто бывает так, что мы не хотим чтобы CTAD выводил тот тип, который он бы вывел автоматически.

Если мы всё таки напишем круглые скобки, то у нас будет вектор из int:

std::vector v2(v.begin(), v.end());	// v2 - это ветор из int

А как он догадался? У вектора есть шаблонный конструктор от пары произвольных типов. Т.е. у вектора есть шаблонный конструктор от input iterator it1, input iterator it2, и вот мы создали вектор, не указав ему шаблонные параметры, 
от двух каких то вещей одинакового типа, но это не подходит ни в один из нешаблонных конструкторов вектора, т.е. это не конструктор вектора от числа или списка значений. Каким же образом вектор догадался от чего он должен 
создсться, если мы передали ему просто каких то два шаблонных типа. 

У вектора прописаны специальные правила, как выводить тип своего шаблонного аргумента в такой ситауции - это называется explicit template deduction guides (Явные правила шаблонного вывода). В случае Class Template Argument 
Deduction мы можем для своего типа написать кастомные правила как вывести тип аргумента шаблонного класса, если передали чтото. В случае вектора там написано, что если ему передали два шаблонных аргумента одинакового типа и 
это не подошло ни по до что выше, то он просто делает то что написано - он считает что T это typename iterator_traits от этого типа :: value_type. Это пишеться так:

template <typename T>
struct vector {
	template <typename Iter>	// Шаблонный конструктор
	vector(Iter, Iter) {}
};


// Пишем explicit template deduction guides	
template <typename Iter>			
vector(Iter, Iter -> vector<typename std::iterator_traits<Iter>::value_type>

Это пригодиться нам если мы будем реализовывать свой tuple. например когда мы создаём tuple от пары, мы не хотим писать явно tuple<T1, T2>, но мы не хотим чтобы если мы создаём tuple от пары то это был tuple с шаблонным
параметром Pair<T1, T2>, нет мы хотим чтобы был tuple с параметрами T1, T2, поэтому например у tuple есть такой template deduction guides: tuple от std::pair от T1, T2 это всё ровно что tuple от T1, T2.

Начиная с C++20 Template Argument Deduction работает даже для using (элиесов), а не только для классов.


###########################
Агрегатная инициализация

Представим что у нас есть:

template<typename T, typename U>
struct S {
	T x;
	U y;
};

int main() {
	S s{1, 2.0};
}

Справится ли CTAD с таким выводов типов? Мы запустили агрегатную инициализацию структуры, не указав шаблонные аргументы. Да справится, но только начиная с C++20. 


Агрегатная инициализация наследования:

struct A {};
struct B {};

template<typename T, typename U>
struct S: T, U {};

int main() {
	S s {A(), B()};
}

Начиная с C++20 с помощью агрегатной инициализации можно инициализировать не только поля, но и родителей, и это работает настолько хорошо, что он даже догадывается какие у нас должны быть родители. В C++17 это не работает,
однако мы можем обойти эту проблему написав deduction guide:

template<typename T, typename U>
struct S: T, U {};

template<typename T, typename U>
S(T, U) -> S<T, U>;

Теперь это скомпилируется и с C++17, но с C++20 эти deduction guide стали ненужны, потому что компилятор умеет догадываться сам какие у нас родители, исходя из переданных аргументов. 


Представим что у нас несколько разных типов.

template<typename... Args>
struct S: Args... {};

int main() {
	S s {A(), B()};
}

Можем ли мы наследоваться от переменного числа? Да можем, причём это можно ещё с C++11. Мы можем писать распаковку параметров шаблона писать здесь, и т.о. начиная с C++20 мы можем создавать структуру, которая является 
наследником от всех переданных нами аргументов, и компилятор сам догадается от каких параметров шаблона. Это полезная фича. На typename... Args мы тоже можем написать deduction guid:

template<typename... Args>
struct S: Args... {};

template<typename... Args>
S(Args...) -> S<Args...>;



_____________________________________________
std::tuple and structured bindings.

Оффтоп:
Задание: Для закрепления материала можно попробовать реализовать std::tuple.

У tuple есть deduction guides (их 5 штук): 

template<class T1, class T2>			
tuple(std::pair<T1, T2>) -> tuple<T1, T2>;			// Если мы создаём tuple от пары, то это tuple от <T1, T2>

template<class Alloc, class... UTypes>				// Если мы создаём tuple от параметров std::allocator_arg_t, аллокатор Alloc, и набор типов UTypes..., то это просто tuple от этих типов, а аллокатор не является шаблонным
tuple(std::allocator_arg_t, Alloc, UTypes...) -> tuple<UTypes...>;		// параметром tuple.

template<class Alloc, class T1, class T2>				
tuple(std::allocator_arg_t, Alloc, std::pair<T1, T2>) -> tuple<T1, T2>;

std::allocator_arg_t - это тег, который нужен для того, чтобы отличить один конструктор от другого. Любой такой тип, который имеет в конце _t - это всегда тег. Если мы первым параметром передали этот аргумент, то т.о. перегрузка понимает,
что мы собираемся следующим аргументом передать объект аллокатора. std::allocator_arg_t это фейковая пустая структура. Это нужно для того, если мы хотим tuple от нестандартного аллокатора. Если бы мы не передали сначала 
std::allocator_arg_t а сразу бы передали аллокатор, то компилятор бы посчитал что аллокатор должен быть частью tuple, а так он поймёт что аллокатор это отдельная структура. 
Конец оффтопа.


У нас есть класс std::tuple который является по сути кортежем. Это обощение пары, но на переменное кол-во типов:

int main() {
	std::tuple<int, double, char> t {1, 2.0, 'a');
}

Теперь зная, что мы умеем выводить шаблонные аргументы, мы можем не писать явно от каких типов tuple, и он сам догадается от каких он типов. 

Мы можем брать по индексу элемент tuple, для этого есть внешняя функция std::get() с шаблонным параметром N принимающая tuple (но это не метод tuple):

int main() {
	std::tuple<int, double, char> t {1, 2.0, 'a');
		
	auto& d = std::get<1>(t);
}

1 - это компайл тайм константа, а в параметр передаём tuple. 1 - это компайл тайм константа (константа времени компиляции) т.е. мы не можем подставить переменную, если бы мы могли подставить переменную, то мы бы не могли знать 
тип во времени компиляции.

Какой возвращаемый тип у функции std::get? Как правильно объявить функцию std::get? Чтобы объявить эту функцию нам нужно использовать decltype(auto), потому что её возвращаемый тип такой: у нас есть пакет типов и нам нужно
достать из него k-ый по счёту тип и он то и будет возвращаемым. Но при этом нам нужно уметь сохранить вид value, потому что например если мы скажем так:

auto& d = std::get<1>(std:move(t));

то это не должно скомпилироваться. У нас get должна работать правильно, в завсисимости от вида value переданного tuple. Если мы передавали ей rvalue tuple, то он должна вернуть rvalue ссылку, соотетсвтенно если мы передали ей
константный tuple, то она должна вернуть константную ссылку, а если мы передали const rvalue tuple, то она должна вернуть const rvalue ссылку. 

Мы можем написать и так, тогда мы сделаем просто копию:

auto d = std::get<1>(std:move(t));

Понятно что если мы объявили ссылку, то если мы поменяем d мы поменяем и элемент tuple, потому что мы получили ссылку на элемент tuple, а не копию:

std::tuple<int, double, char> t {1, 2.0, 'a');
auto& d = std::get<1>(t);	// d это сслыка
d = 3.14;

std::cout << std::get<1>(t);	// Теперь 3.14 а не 2.0


Что будет если мы напишем так:

auto&& d = std::get<1>(t);	// Теперь это универсальная ссылка.

Теперь это универсальная ссылка, теперь она будет правильной независимо от того что стоит справа: const, не  const, lvalue, rvalue - эта ссылка станет правильным видом ссылки в зависимости от того, какой справа был tuple.  

auto&& d = std::get<1>(std:move(t));	// rvalue-ссылка на double
d = 3.14;				// d это тоже ссылка просто она rvalue, но от этого она не перестаёт быть ссылкой. d это теперь другое название для поля tuple, просто инициализировать можно через rvalue.

Теперь d это rvalue-ссылка на поле tuple.  С t ничего не случилось, мы просто скастили t к rvalue-ссылке на tuple, а потом сделали get первого элемента. get нам просто вернул rvalue-ссылку на соответсвтующий элемент tuple, с остальными 
элементами tuple тоже ничего не случилось. Но если бы мы написали так:

auto d = std::get<1>(std:move(t));	// Без амперсандов

d теперь не ссылка, и теперь мы бы мувнули из этого элемента tuple в d. Средний элемент tuple теперь опустел, его данные перешли в d, остальные элементы tuple не изменились.  


#################
Structured bindings (C++17)

Structured bindings (структурированные привязки) — это фича C++17, которая позволяет удобно и читаемо разбирать составные объекты (tuple, pair, struct, array) на отдельные переменные за одну строку. До C++17 для этого использовали 
std::tie или std::get, что было verbose и неудобно. Structured bindings сделали код гораздо чище.

Что если мы хотим распаковать tuple? Мы можем обратиться к конкретному элменту tuple, но мы можем хотеть как бы сразу распаковать tuple и сказать: пусть x, y, z это соответственно 1-ый, 2-ой и 3-ий элементы tuple. Для этого мы 
можем написать:

std::tuple<int, double, char> t {1, 2.0, 'a');
auto [x, y, z] = t;			// Structured bindings (since C++17)

И теперь x это 1, y это 2.0, z это 'a',  причём их типы автоматически выведены у них всех. Однако сейчас мы сделали копии, но если бы мы написали auto&:

std::tuple<int, double, char> t {1, 2.0, 'a');
auto& [x, y, z] = t;

и тогда бы x это была ссылка на 1-ый элемент tuple, y это 2-ая ссылка на элемент tuple, z на 3-ий и типы под ссылкой вывелись. А можно было бы написать auto&&:

std::tuple<int, double, char> t {1, 2.0, 'a');
auto&& [x, y, z] = t;

тогда в зависимости от того, справа lvalue или rvalue tuple, у нас были бы либо rvalue-ссылки либо lvalue-ссылки на элементы tuple.

std::tuple<int, double, char> t {1, 2.0, 'a');
auto&& [x, y, z] = std::move(t);
z = 'b';
std::cout << std::get<2>(t);		// Вывод в консоль: b

Последний элемент tuple стал равен 'b', потому что мы сделали на него ссылку.

Такой синтаксис очень полезен когда нам нужно распаковать std::tuple или std::pair. Такое можно увидить в контексте обхода map например:

for(const auto& [key, value]: map) {}	// Это range-based for на максималках

Это будет работать точно также, как если бы мы написали const auto& [key, value] = *it, где it проходит по всем элементам map. Это range-based for на максималках, мы теперь не просто проходим по всем элементам map автоматически 
разыменовывая итератор, но ещё и распаковываем. 

А как это работает? К чему ещё они применимы кроме tuple? К структурам и массиву. тип должен обладать некоторыми свойствами и тогда к нему будет применим Structured bindings, его можно будет распаковыввать. 

У нас есть 3-и вида типов к которым применим Structured bindings: 
1) с array (как с std::Array, так и с сишным array).
2) tuple-like type - это такой тип для которого корректно определена мета-функция std::tuple_size, а также для каждого числа E от 0 до std::tuple_size - 1 определена мета-функция std::tuple_element<i, E>::type (с параметрами это число - i и E,
и наш тип (type), который даёт нужный тип. Т.е. мы можем сделать так, чтобы в нашем собственном класса Structured bindings работал и для него. Для этого нам нужно доопределить для своего класса мета-функции  tuple_size и 
tuple_element для всех соответствующих E, т.е. tuple_element для данного числа должен давать такой тип, который сидит на i-том месте нашего tuple. Тогда наш тип будет считаться  tuple-like type.
3) структура которая допускает агрегатную инициализацию. 	
(Лекция 44 конец).


###
Примеры из chatGPT
1) Разбор std::pair и std::tuple

std::tuple<int, std::string, double> get_person() {
    return {42, "Alice", 3.14};
}
int main() {
    // До C++17: std::tie
    int age;
    std::string name;
    double score;
    std::tie(age, name, score) = get_person();

    // С C++17: structured bindings — красиво и кратко
    auto [age2, name2, score2] = get_person();

    std::cout << name2 << " " << age2 << " " << score2 << '\n';
}


2) Работа с std::pair (например, из map) (range-based for на максималках)

std::map<std::string, int> ages = {{"Alice", 25}, {"Bob", 30}};

for (const auto& [name, age] : ages) {  			// вместо p.first и p.second
    std::cout << name << " is " << age << " years old\n";
}

// Или при insert
auto [it, inserted] = ages.insert({"Charlie", 35});
if (inserted) {
    std::cout << "Charlie added\n";
}


3) Разбор пользовательских структур

struct Point {
    int x;
    int y;
    double z;
};

Point p{10, 20, 3.5};

auto [x, y, z] = p;  // автоматически берёт публичные поля в порядке объявления
std::cout << x << " " << y << " " << z << '\n';


4) Разбор массива или std::array

#include <array>

std::array<int, 3> arr = {1, 2, 3};
auto [a, b, c] = arr;

int native_arr[] = {10, 20, 30};
auto [x1, x2, x3] = native_arr;


###
Важные детали и нюансы 
- auto обязательно (или const auto, auto&, etc.)
auto [x, y] = pair;         // копии
const auto& [x, y] = pair;  // константные ссылки
auto& [x, y] = pair;        // ссылки (можно модифицировать оригинал)

- Количество переменных должно совпадать с количеством элементов, иначе CE.
- Для пользовательских типов работает только с:
1. Публичными полями (как в struct выше)
2. Или если тип поддерживает tuple-like протокол (есть специализация std::tuple_size и std::tuple_element + get<>())

- Можно игнорировать элементы с помощью _ или пустого имени (C++20+):
auto [_, name, score] = get_person();  // игнорируем первый элемент




###############################
Функции хелперы связанные с tuple

Три способа создать tuple из набора значений.

1) Вариант: По аналогии с функцией std::make_pair, есть функция std::make_tuple. Она берёт аргументы и делает tuple из них. Эта функция как и make_tuple нужна для того чтобы не приходилось явно называть аргументы. Когда появилось 
CTAD эта функция как будто бы стала не нужна, мы и так можем в конструктор не писать аргументы, и не писать make_tuple. Тем не менее посмотрим на плохой пример использования make_tuple:

template <typename... Ts>
struct X {
	explicit X(const Ts&... values) : values(std::make_tuple(values...)) {}

	std::tuple<const Ts&...> values;
};

int main() {
	int i = 42;
	auto s = std::string("universe");
	
	auto x = X<int, std:;string>(i, s);

	std::cout << "i = " << std::get<0>(x.value) << '\n';
	std::cout << "s = " << std::get<1>(x.value) << '\n';
}

Это компилируется, но что здесь не так? Что вообще такое tuple от ссылок? - это tuple который хранит ссылки, и мы можем его создать, тогда обращаясь к соответствующему элементу tuple мы будем получать ссылку на на объект. 
Но что происходит когда мы пытаемся создать tuple от ссылок и делаем make_tuple? Какой возвращаемый тип у make_tuple? 

Реализация make_tuple:

template <typename... Types>
auto make_tuple(Types&&... args) -> tuple<std::decay_t<Types>...> {
	return {std::forward<Types>(args)...};
}

Мы создаём tuple из типов с уже отброшенными ссылками и каждый аргумент проинициализировали либо rvalue либо lvalue ссылками. Tuple получается от самих типов а не от ссылок, поэтому получается что когда мы вызываем 
make_tuple, мы теряем амперсанды. Т.е. make_tuple это создание tuple с отбрасыванием ссылок.

В коде выше UB. Мы сказали values(std::make_tuple(values...)) - что здесь произошло? Здесь создался временный tuple из копий, а проинициализировали мы tuple из ссылок. Мы создали tuple из ссылок от tuple оригинальных объектов, 
получилось что мы получили ссылки на временные штуки, которые уничтожились и мы получили битые ссылки. (Короче он здесь сам запутался лекция 45 начало до 13 минуты)


2) Вариант: Чтобы такого не происходило нам нужно использовать функцию std::tie это тоже самое, только ссылки не теряются.

Реализация tie:

template <typename... Types>
auto tie(Types&... args) -> tuple<Types&...> {
	return {args}...;
} 

Она принимает lvalue ссылки и возвращает tuple из ссылок. Т.о. если мы вызываем tie:

template <typename... Ts>
struct X {
	explicit X(const Ts&... values) : values(std::tie(values...)) {}

	std::tuple<const Ts&...> values;
};

то вот здесь уже не будет битых ссылок, потому что мы не создавали временные копии, мы просто реально создали tuple из ссылок. 


3) Вариант: std::forward_as_tuple - она делает tuple из ссылок, только с сохранением вида ссылок. Если std::tie даёт просто набор ссылок, то std::forward_as_tuple даёт нам либо lvalue либо rvalue ссылки. 

Реализация std::forward_s_tuple:

template <typename... Types>
auto forward_as_tuple(Types&&... args) -> tuple<Types&&...> {
	return {std::forward<Types>(args)...};
}


###############################
Несколько примеров с функцией std::tie

Пример 1:

Эта функция очень мощная штука. Представим структуру S с тремя полями. И мы хотим определить лексико-графическое сравнение:

struct S {
	int n;
	std::string s;
	float d;
	
	friend bool operator<(const S& lhs, const rhs) noexcept {
		return std::tie(lhs.n, lhs.s, lhs.d) < std::tie(rhs.n, rhs.s, rhs.d);
	}
};

Над tuple определено сравнение, и мы можем просто сравнение над своей структуры сделать как tie 3-ёх полей < чем tie от других 3-ёх полей. Т.о. они сравняться как tuple. Т.е. мы заменили сравнение своей структуры на сравнение tuple. 
Поскольку это tie, то мы заведём ссылки а не копии. 

Пример 2:

У нас есть set или map и там есть функция insert которая вставляет в них значение. Эта функция защищает пару - итератор куда вставили, и bool вставили или нет. Что мы можем сделать? 

int main() {
	std::set<S> set_of_s;
	S value{42, "Test", 3.14};
	std::set<S>::iterator iter;	
	bool is_inserted;

	// Unpack a pair:
	std::tie(iter, is_inserted) = set_of_s.insert(value);
	assert(is_inserted);
}

У нас есть две переменные: итератор и bool и мы можем одной строкой присвоить им двоим с помощью: std::tie(ссылка на итератор, ссылка на is_inserted) = результат вставки. Теперь iter и is_inserted присваивается результат. Мы здесь 
завели временный tuple, содержащий ссылку на итератор и ссылку на bool, и этому tuple сделалось присваивание, тем самым поменялся и итератор и bool.

Это не Structured bindings. Structured bindings это когда мы объявляем две новые переменные, а если у нас уже есть две существующие переменные и мы хотим им разом присвоить, тогда мы используем std::tie.
Если у нас есть несколько переменных и функция которая возвращает tuple, мы хотим сразу всем этим переменным присвоить соответствующий элемент tuple, тогда мы используем std::tie от набора этих переменных тем самым создаётся
tuple из ссылок и тем самым каждой переменной присваивается соответствующий элемент tuple. 

Пример 3:

Structured bindings and std::tie

auto position = [](int w) {return std::tuple(1 * w, 2 * w); };

auto [x, y] = position(1);
assert(x == 1 && y == 2);
std::tie(x, y) = position(2);	// reuse x, y whith tie
assert(x == 2 && y == 4);

Здесь мы используем std::tie со Structured bindings. Сначала мы объявляем auto [x, y] = position(1), потом std::tie т этих вещей, и потом присвоили ему результат снова.

Пример 4:

У нас разрешены неявные конверсии.

std::tuple<char, short> coordinates(6, 9);
std::tie(x, y) = coordinates;
assert(x == 6 && y == 9);

У нас есть std::tuple из char и short, а x и y это int. И во мы делаем std::tie от x и y и присваиваем им coordinates. У нас есть tuple в котором есть две ссылки на int, и мы решаем присвоить этому другой tuple, в котором первый элемент 
char, а второй short. Почему это не CE и неявные конверсии прокатывают? По сути у нас уже создан tuple, в котороместь поле int& и другое поле int&. Отныне они ведут себя неотличимо от оригинальных int, т.е. мы можем присвоить одному
char другому short и всё заработает.  


###############################
Ещё немного про std::tie

1) В стандартной библиотеке есть структура std::ignore_t и её единственный экземпляр называется std::igonre. 

struct ignore_t {
	template <typename U>		// Шаблонный оператор присваивания
	void operator=(const U&) {}	
};


Также в STL есть стандартная переменная std::ignore. Она хороша тем, что её можно присвоить что угодно, и ничего не произойдёт. Это действительно полезно, например если нам нужно в какой-то функции явно сказать, что мы не 
используем какой-то из параметров, то мы можем написать std::igonre и присвоить свою переменную. Это еще один способ явно сказать что мы не используем какой-то из парамтров. 1-ый способ это просто не дать ему имя, а 2-ой дать ему имя 
но написать std::ignore = этот параметр. Однако изначально std::ignore была придумана для такого:

std::set<S> set_of_s;
S value{42, "Test", 3.14};
std::set<S>::iterator iter;	

// Unpack a pair:
std::tie(iter, std::ignore) = set_of_s.insert(value);

Так мы говорим, что ничему не хотим присваивать второй элемен пары. Т.е. если например если у нас есть какая то функция, которая возвращает нам pair или tuple, и мы хотим забрать в какую-то переменную только первый элемент контейнера, 
а второй проигнорировать, тогда нам поможет std::ignore. (Он отлично помогает при пользовании интерфейсами).


Начиная с C++23 или C++26 в Structured bindings можно писать переменные _ (знак подчёркивания) несколько раз. Если нам кто-то возвращает tuple а мы делаем Structured bindings и хотим использовать только некоторые элементы из этого 
tuple, то для того чтобы проигнорировать элементы мы можем назвать их _, и компилятор разрешит в одной области видимости иметь несколько переменных с именем _ при условии что мы не будем их использовать:

auto position = [](int w) {return std::tuple(1 * w, 2 * w); };

auto [x, _, _] = position(1);


2) Класс std::piecewuse_construct_t и его единственный экземпляр std::piecewuse_construct. Это просто тег, и он нужен для того, чтобы в одном из конструкторов пары уметь создавать элементы пары по отдельности. Например мы хотим создать пару,
причём мы сразу хотим сразу создать и первый элемент пары и второй, мы не хотим создавать временный промежуточные объекты чтобы потом куда то их мувать или форвордить, мы хотим сразу их емплейснуть и первый кусок и второй и создать
из них пару. Но если мы в конструктор пары передаём список аргументов первого и список аргументов второго, то как он поймёт из каких аргументов создавать первый элемент, а из каких второй. Для этого у нас есть тег std::piecewuse_construct
который если мы передали первым аргументом, то следующим аргументом будет ожидаться tuple, из которого будет создан первый элемент пары, а вторым аргументом будет ожидаться второй tuple, из которого будет создан второй элемент
пары. 

Это пригождается когда мы хотим что нибудь положить в std::map. В map есть метод emplace. В этот метод нам нужно передать std::pair<Ключ, значение>, но мы хотим и ключ и значение сконструировать наместе. Тогда мы можем сделать так:

std::map<std::string, std::string> m;
m.emplace(std::piecewuse_construct, 		// Тег
	  std::forward_as_tuple("c"),		// tuple аргументов, из которых мы создадим ключ (первый элемент пары)
	  std::forward_as_tuple(10, "c"));	// tuple аргументов, из которых мы создадим значение (второй элемент пары)


_____________________________________________
Краткая идейная реализация std::tuple

Как реализовать tuple, какие поля у него должны быть, что хранить в нём? Мы не можем использовать контейнеры с индерекциями, потому что мы хотим чтобы всё лежало на стеке, а не в динамической памяти. Одно из возможных решений 
выглядит так: 

template <typename... Types>
struct tuple;

// Специализация
template <typename Head, typename... Tail> // Класс принимает 1 объязательный шаблонный аргумент и ещё какой то пакет
class tuple {
private:
	Head head;	// Храним голову
	tuple<Tail...> tail;	// и tuple из остальных

	template <size_t N,  typename... Types>		// Функцию get делаем другом
	fruend decltype(auto) get(tuple<Types...>&);
	
	// Конструктор 
};

// Специализация для пустого tuple
template<>
struct tuple<> {};

В конструкторе мы просто конструируем Head от Head и Tail... от Tail... с использованием std::froward.

Как реализовать функцию get? Сначала ответим на вопрос: почему функция get не является методом tuple, а является внешней функцией? Давайте представим что get был бы метом класса, тогда:

template <typename... Types>
void f() {
	std::tuple<Types...> t;	// Все типы создаются по умолчанию
	t.get<1>();
}

Что здесь не так? Здесь t это зависимое имя (dependent name), и если мы хотим позвать метод get, то нам нужно писать так:

t.template get<1>();

Если бы get был бы методом класса tuple, то всякий раз вызывая его от шаблонного tuple, нам бы приходилось писать t.template get а не просто t.get. Поэтому get это внешняя функция (писать буедт не удобно).


Реализация get:

template<size_t N, typename... Types>		// get для lvalue tuple
decltype(auto) get (tuple<Types...>& t) {
	if constexpr (N == 0) {
		return t.head;
	}
	else {
		return get<N - 1>(t.tail);
	}
}

Нам нужен ещё get для rvalue tuple, const lvalue tuple и для const rvalue tuple. Можно ли эти 4 функции get объединить в 1? Тут нужна чуть более сильная шаблонная магия чем мы с вами изучали, поскольку если мы будем принимать параметр по
универсальной ссылке сюда, то мы начёнм принимать не только tuple. Главная проблема в том, что у нас нет синтаксиса принятия сюда универсальную ссылку, которая принимала бы только tuple. Главная проблема универсальных ссылок в том,
что либо мы принимаем вообще любой тип, либо это не универсальная ссылка. И поэтому чтобы универсальной ссылке принимать не любые типы, нам нужно знать ещё некоторые вещи, которые ограничивают набор принимаемых типов, 
например std::enable_if или requers (C++20) (но сейчас не об этом).


###############################
Оффтоп: std::enable_if. Представим что у нас много конструкторов. Нам иногда нужно умееть некоторые версии перегрузок выключать из множества рассматриваемых версий, т.е. нам не просто нужно чтобы компилятор передпочитал другую
версию, нам нужно чтобы он какую то из версий не рассматривал вообще, потому что если бы он её оставил, то она по правилу вывода версий была бы предпочтительнее, но она могла бы не сработать. Для этого есть std::enable_if. 

У нас есть структура и в ней есть два конструктора от typename Integer другой от typename Floating. Мы хотим чтобы если тип относиться к целочисленным, то рассматривался бы только первая перегрузка, а если тип относиться к дробным, то 
рассматривалась вторая перегрузка.

struct T {
	enum {int_t, float_t} type;
	
	// Первая перегрузка
	template<typename Integer,  std::enable_if_t<std::is_integral<Integer>::value, bool> = true>
	T(Integer) : type(int_t) {}

	// Вторая перегрузка
	template<typename Floating,  std::enable_if_t<std::is_floating_point<Floating>::value, bool> = true>
	T(Floating) : type(float_t) {}
};

первый параметр  std::enable_if_t: std::is_integral<Integer>::value - компайл тайм проверяемое условие, второй параметр - bool. Это всё некоторый тип которому мы по умолчанию присваиваем значение true: = true>

std::enable_if это такая структура, которая первым параметром принимает bool, а вторым параметром принимает некоторый тип (по умолчанию void), и если bool это false, то std::enable_if это пустая структура, а если bool это true, то в теле этой
структуры написано type = T который мы передали вторым:

template <bool B, class T = void>
using enable_if_t = typename enable_if<B,T>::type;		// using. B это условие, T это тип (В нашем случае тип = bool).

template <bool B, class T = void>
struct enable_if {};					// Если bool это false то это пустая структура

template <class T>
struct enable_if <true, T> { typedef T type; };		// Если bool это true

Что это значит? Мы передаём в enable_if  в первый параметр некторое value: std::is_integral<Integer>::value (это bool), а вторым параметром тип который равен bool:

std::enable_if_t<std::is_integral<Integer>::value, bool>

Если условие std::is_integral<Integer>::value верно, то в using enable_if_t  = typename enable_if< наше условие которое = true, наш тип T который в данном случае равен bool>;  Получается если наше условие верно, то enable_if_t это просто bool:

std::enable_if_t<std::is_integral<Integer>::value, bool> = true 	// это всё bool, и этому bool мы присвоили true по умолчанию. Т.е. это превратиться в bool если условие std::is_integral<Integer>::value верно. Если же это условие не верно, то в std::enable_if
не будет никакого type, и тогда это будет не корректный тип, но есть такое правило, что тогда эта версия просто выключится из множества рассматриваемых версий перегрузки поскольку тип некорректен. И это не будет CE,это просто будет версия,
которая не рассматривается. 

Короче если мы хотим чтобы какой то из конструкторов не попал в множество версий для перегрузки если какое то условие ложно, то мы пишем так.

Конец оффтопа
###############################


Есть у нас ещё и такая функция: tuple_cat - это конкатенация tuple. Мы берём переменное кол-во tuple и делаем один tuple. Проблема tuple_cat в том, что мы хотим взятьнесколько тюплов и составить из них один, но вот какой будет возвращаемый 
тип? 

struct tuple_cat_tag {};			// Тег для tuple_cat

// Специализация tuple_cat от первого пустого tuple.
template <typename... Us>
auto tuple_cat(tuple<> t, tuple<Us...>& u) {
	return u;
}

// tuple_cat от двух тюплов
template <typename... Ts, typename... Us>
auto tuple_cat(tuple<Ts...>& t, tuple<Us...>& u) {	// для lvalue
	return tuple(tuple_cat_tag(), t.head, tuple_cat(t.tail, u));	
}

Здесь мы откусываем по одному элементу от первого tuple пока он не опустеет. Тег нужен для того, чтобы мы попали в специальный приватный конструктор, который бы первое и второе поле инициализировал тем что мы дали непосредственно.
Это решение плохо тем что мы много раз копируем tuple, мы бы хотели сделать это напрямую. 





_____________________________________________
###################################
_____________________________________________
SFINAE и шаблонное мета-программирование

Мы хотим научиться писать метафункции. Какие то мы уже умеем писать: например проверка равенства двух типов, или является ли тип ссылочным, или метафункции преобразовывающие типы, например навестить const на тип или навесить
ссылку на тип. Но есть метафункции которыми мы пользовались, но не умеем их реализовывать, например: проверка является ли тип копи констрактибл или мув констрактибл, является ли типб наследником другого, является ли тип классовым, или
является ли тип полиморфным. Все эти вещи нужно научиться реализовывать.

_____________________________________________
Базовые примитивы шаблонного мета-программирования

Какие у нас есть базовые примитивы? Например тождественная метафункция type_identity, которая просто возвращает тот тип, который ей и дали:

template <typename T>
struct type_identity {
	using type = T;
};

template <typename T>
usnig type_identity_t = typename type_identity<T>::type;

####
Реализуем true_type и false_type:

template <typename T, T x>
struct integral_constant {
	static constexpr T value = x;
};

template <bool b>
using bool_constant = integral_constant<bool, b>;

using true_type = bool_constant<true>;
using false_type = bool_constant<false>;


Благодаря тому что у нас есть bool_constant, true_type, false_type, мы можем проще реализовывать, некоторые тайп треки. Для примера реализуем is_lvalue_reference. Для всех типов мы делаем наследование от false_type, однако для случая
ссылок мы делаем специализацию с наследованием от true_type. Т.е. is_lvalue_reference для всех типов = false, но для настоящих lvalue reference это true. Также доопределеяем is_lvalue_reference_v.
 
template <typename T>
struct is_lvalue_reference: false_type{};		// Наследование

template <typename T>
struct is_lvalue_reference<T&>: true_type{}; 	// Специализация

template <typename T>
using is_lvalue_reference_v =  is_lvalue_reference<T>::value;	// Также доопределеяем is_lvalue_reference_v

###
Оффтоп: Комментарий под видео:
using is_lvalue_reference_v вместо using нужно inline constexpr bool.
Конец оффтопа
### 

Также мы можем делать коньюнкицю и дезьюнкицю и другие приколы. Когда у нас есть несколько метафункций, каждая из которой возвращает true или false, то мы можем определить коньюнкцию над ними. Мы предпологаем, что все эти
types, это тоже мета функции и у них тоже должно быть value.

template <typename... Types>
struct conjuction {
	static constexpr bool value = (Types::value && ...);
};

Это работает только для мета функций у которой есть value. Однако у такой реализации есть один недостаток. Настоящий std::conjuction реализован так:

template <class...> struct conjuction : std::true_type {};			// Неспециализированная реализация conjuction это просто наследница std::true_type.
template<class B1> struct conjuction<B1> : B1 {};				// Специализаци для одного аргумента, это просто он сам (этот элемент).
template<class B1, class... Bn>						// Специализация для случая больше одного аргумента. Это в зависимости от условия bool(B1::value) либо conjuction<Bn...> (от остальных аргументов), либо B1.
struct conjuction<B1, Bn...>
	: std::conditional_t<bool(B1::value), conjuction<Bn...>, B1> {};

Несмотря на то, что казалось бы что можно реализовать conjuction через fold expression, он реализован путём откусывания начального куска списка типов. Почему первая реализация через fold expression хуже чем эта? В стандарте есть требование:
Если в каком то шаблонном аргументе было false (bool(Bi::value) == false), тогда инстанцирование conjuction от таких типов (conjuction<B1, ..., Bn>::value), не потребует инстанцирование Bj::value for j > i. Не вычисление, а именно инстанцирование.
Т.е. компилятору не придётся делать шаблонную подстановку в тело шаблона. Когда мы с вами вызываем std::conditional_t и он понимает что условие bool(B1::value) это false, то он не будет делать шаблонную подстановку в conjuction<Bn...>,
т.е. он не инстанцирует тело conjuction, он просто увидит объявление conjuction есть с такими шаблонными аргументами, но он не будет подставлять их туда и смотреть что получается, поскольку в таком контексте ему не требуется инстанцировать
класс conjuction с таким набором шаблонных аргументов, ему достаточно лишь убедиться что он существует, но тело класса инстанцировать не нужно, а достаточно просто вернуть B1. В случае же fold expression, компилятору потребовалось бы 
инстанцировать все value, и делать шаблонную подстановку во все множетели. Тоже самое с std::disjunction и std::negation. 

Важно что это всё метафункции над типами, а не просто функции. 

###
Оффтоп: Инстанцирование (англ. instance - создание экземпляра чего-то) - процесс порождения специализации.
Конец оффтопа.
###


_____________________________________________
SFINAE

SFINAE это магический трюк, который позволит нам реализовать почти все остальные метафункции.

SFINAE - Substitution Failure Is Not An Error (Сбой подстановки не является ошибкой).  Когда компилятор выбирает перегрузку, он пытается подставить шаблонный тип не в определение, а в объявление функции. Если в момент подстановки T в 
объявление у него получается некорректный тип, то это не ошибка компиляции, а просто он выкидывает эту версию из множества кандидатов на перегрузку и выбирает следующую наилучшию подходящую перегрузку. 

Представим что у нас есть две функции. Одна из них принимает что угодно,  а другая шаблонная и принимает она T.

template <typename T>
auto f(T) -> typename T::value_type {
	std::cout << 1\n;
	return {};
}

void f(...) {			// Принимает что угодно с помощью C-style variadic function. Сишный способ принять переменное число аргументов в функцию (аналог template <typename... Types>)
	std::cout << 2\n;
}

int main() {
	std::vector<int> v;
	f(v);		// Вызываемся от вектора. 
}

Если мы вызываемся просто от ветора, то в консоли получаем 1. Если мы вызываемся ещё и от int
	
int main() {
	std::vector<int> v;
	f(v);		// Вызываемся от вектора. 

	f(0);		// Вызываемся от 0
}

то получаем в консоли такой результат:

1
2

Как это работает? Почему мы получили не CE, а просто 2. Это нетривиально.  Первая версия предпочтительнее, потому что она принимает один аргумент произвольного типа, а вторая версия принимает произвольное число аргументов 
произвольных типов. По правилу частное предпочтительнее общего, луче выбрать первую версию. Но у неё старнный возвращаемый тип, т.е. он зависит от T и при некоторых T, он некорректный тип, потому что например у int нет никакого
value_type. Тогда компилятор работает правилу SFINAE. Это работает на уровне выбора версии перегрузки: компилятор решает какая версия перегрузки предпочтительнее, он видит шаблонные версии и нешаблонные. Он пытается подставит T
в объявление функции и проверить всё ли корректно, и если нет, то он выкидывает эту версию из множества версий для перегрузки, и выбирает оставшиеся.  

Важно! SFINAE работает только в объявлении функции, а не в ёё теле:

template <typename T>
auto f(T) {
	typename T::vaue_type result{};
	std::cout << 1\n;
	return result;
}

то это уже будет CE. Т.е. компилятор смотрит только на объявления а не на тело. Тело функции инстанцируется только после того, как была выбрана версия перегрузки. Когда компилятор решает какую версию перегрузки выбрать, он смотрит 
только на декларейшон. Для выбора версии перегрузки ему не нужно знать возвращаемый тип, он выбирает её только по принимаемому типу и смотрит на объявление, если с объявлением всё ок, то он решил какую версию перегрузки он выберет,
а вот дальше после этого он начинает инстанцировать тело, и если в этот момент возникает такая проблема, то это уже CE и никакого SFINAE не происходит. Возвращаемый тип не влияет на версию перегрузки - это база.

SFINAE работает не только в сигнатуре обычной функции, но ещё и в шаблонной. Например сделаем так, чтобы объявление стало невалидным, в случае если мы передаём не вектор.

template <typename T, typename = T::value_type> // Мы можем не указывать имя шаблонного аргумента, точно также как и не указываем имя обычного аргумента, если мы его нигде не используем.
auto f(T) {
	std::cout << "1\n";
}

template <typename... Types>
void f(Types...) {
	std::cout << "2\n";
}

Мы добавили шаблонный аргумент по умолчанию и верия 1 всё ровно предпочтительнее чем версия 2, но если мы в первую весию передаём int, компилятор увидит, что второй шаблонный аргумент который он должен подставить по умолчанию
(typename fake = T::value_type), невалидный и эта версия отвалиться.



_____________________________________________
std::enable_if

Воспользуевшись этим знанием решим следующую задачу: мы хотим написать две версии функции f по следующему принипу: чтобы одна вызывалась только от integral_types, а другая от всех остальных. У нас есть мета функция std::is_integral, она 
возвращает true для типов int, char, bool, short, long и т.д., а для всех остальных возвращает false. 

template <typename T, 
	typename = std::conditional_t<std::is_integral_v<T>, void, typename T::fake_type>>	// Допустим тип T::fake_type невалидный
auto f(T) {
	std::cout << "1\n";
}

template <typename... Types>
void f(Types...) {
	std::cout << "2\n";
}

int main() {
	std::vector<int> v;
	f(v):
	f(0);
}

Вывод в консоль:
2
2

Т.е. пока что это не работает. Первая версия отваливается, потому тип std::conditional_t с нашими параметрами в любом случае невалидный, потому что шаблонная подстановка T все ровно делается, и компилятор
видит что T::fake_type никогда не существует. Чтобы это сработало, нужно это запрятать внутрь некоторой структуры, чтобы тип был невалидным только если условие нарушено. Если условие нарушено, то ему 
приходится лезть в какой то тип, в котором отсутствует объявление типа (тайп дефенишен), и тогда эта версия отваливается. Такой тип называется std::enable_if.

template <bool B>
struct enable_if {};

template <>
struct enable_if<true> {
	using type = void;	// Что нибудь
};

template <bool B>
using enable_if_t = enable_if<B>::type;

Теперь мы можем написать:

template < typename T, typename = enable_if_t< std::is_integral_v<T> >>		// До C++11 >> парсилось как operator>>
auto f(T) {
	std::cout << "1\n";
}

template <typename... Types>
void f(Types...) {
	std::cout << "2\n";
}

int main() {
	std::vector<int> v;
	f(v):
	f(0);
}

Вывод в консоль:
2
1

Т.е. при вызове вектора у нас выбралась перегрузка 2, а при вызове от типа integral, у нас выбрался перегрузка 1. 

А что если мы хотим, чтобы функция принимала 1 аргумент в любом случае? Просто сейчас мы достигли выбора первой версии, за счет того, что первая предпочтительнее с точки зрения перегрузки, потому что 
первая принимает 1 аргумент, а вторая принимает много аргументов. Мы бы хотели, чтобы они обе принимали только один аргумент, но работало бы также? Логично что хочется написать так:

template < typename T, typename = enable_if_t< std::is_integral_v<T> >>		
auto f(T) {
	std::cout << "1\n";
}

template < typename T, typename = enable_if_t< !std::is_integral_v<T> >>	// Добавиил ! отрицание
auto f(T) {
	std::cout << "2\n";
}

Однако это не сработает, потому что у нас бедет редефенишен (redefinition). Это редефенишен потому что эти две функции отличаются лишь значением шаблонного аргумента по умолчанию. У них одинаковая сигнатура
с точки зрения шаблонной сигнатуры. Как мы не можем переопределить две функции отличающиеся только значением по умолчанию, так мы не можем переопределить две шаблонные функции отличающиеся только значением
шаблонного аргумента по умолчанию.

Мы можем добавить ещё один фиктивный шаблонный параметр по умолчанию:

template < typename T, typename = enable_if_t< !std::is_integral_v<T> >, typename = void>	
auto f(T) {
	std::cout << "2\n";
}

Вывод в консоль:
2
1

Есть ещё один более каноничный способ, здесь нам пригодиться второй шаблонный аргумент в enable_if. На самом деле у enable_if есть второй шаблонный параметр. 

template <bool B, typename T = void>		// Добавили T
struct enable_if {};

template <typename T>				// Добавили T
struct enable_if<true, T> {			// Добавили T
	using type = T;				// Добавили T
};

template <bool B, typename T= void>		// Добавили T
using enable_if_t = enable_if<B, T>::type;	// Добавили T


И тогда правильный способ enable_if такой. Мы не пишем typename =, и отличие возникает лишь в том, чему оно равно, мы второй шаблонный аргумент делаем типа enable_if, только со вторым шаблонным аргументом 
bool, и ему даём значение true. И во второй перегрузке мы делаем тоже самое. Не важно чему равно, важно что это формально разные шаблонные аргументы.

template < typename T, enable_if_t<std::is_integral_v<T>, bool> = true>		
auto f(T) {
	std::cout << "1\n";
}

template < typename T, enable_if_t<!std::is_integral_v<T>, bool> = true>	
auto f(T) {
	std::cout << "2\n";
}

int main() {
	std::vector<int> v;
	f(v):
	f(0);
}

Вывод в консоль:
2
1

Тип enable_if_t<!std::is_integral_v<T>, bool> равен bool. Этот тип является таким видом шаблонного аргумента, что enable_if_t может быть только либо невалидным типом, либо bool. Важно что у этого аргумента значение по умолчанию 
равно bool, и на самом деле не важно что бы напишем true или false, это просто нужно чтобы нам не нужно было явно передавать второй шаблонный аргумент в функцию (это как раз вопрос на понимание enable_if_t). Т.е. у шаблона 
enable_if_t<!std::is_integral_v<T>, bool> = true второй шаблонный аргумент либо невалиден, либо это bool. Мы не даем имя этому шаблонному аргументу потому что мы не собираемся его использовать. bool в конце enable_if_t это просто сахар,
чтобы было чему присвоить значение по умолчанию. Вот в такой сигнатуре это уже корректная перегрузка, потому что здесь формально второй шаблонный аргумент разный (Я так понял мы типо обманываем компилятор, у нас в первой версии 
enable_if_t от такого то параметра, а во второй enable_if_t от другого параметра). А с точки зрения шаблонной сигнатуры это разные типы. 

Когда компилятор видит эти две версии перегрузки он не считает что это редефинишен. Когда мы раньше писали template <typename T, typename = что то, компилятор ещё до стадии подстановки T увидил что это просто редефенишен, что там две 
шаблонных функции, отличающиеся лиш значением шаблонного аргумента по умолчанию, поэтому он запрещает делать такой редефинишен ещё до подстановки T. Теперь у нас не возникает редефенишена на стадии до подстановки шаблонных 
аргументов и поэтому корректно работает SFINAE. Если мы уберем отрицание то у нас будут буквально одинаковые типы, поэтому это будет снова редефенишен.

Т.е. enable_if прячет факт отсутствия типа внутрь. Чтобы понять что такое enable_if, компилятору нужно проинстанцировать enable_if с таким то шаблонным параметром, но он не идет инстанцировать на этапе просто просмотра объявления, а
идёт только когда уже подставляем T.


Если у нас есть две функции с разной сигнатурой, но у них было бы не взаимоисключающие enable_if_t, то у нас не будет redefinition но у нас будет ambiguos call:

template < typename T, enable_if_t<std::is_integral_v<T>, bool> = true>		
auto f(T) {
	std::cout << "1\n";
}

template < typename T, enable_if_t<std::is_same_v<T, int>, bool> = true>	
auto f(T) {
	std::cout << "2\n";
}

Формально это разные сигнатуры, но в момент когда компилятор подставит T, он поймёт что это на самом деле одинаковые функции, в обоих случаях шаблонные аргументы получились одинаковыми, и он не сможет выбрать никакую версию, 
потому что не знает какую предпочесть, и поэтому будет CE. 


Когда шаблоны считаются одинаковыми, а когда нет? (function template equivalence).

template<int I, int J>
A<I+J> f(A<I>, A<J>); // Перегрузка 1

template<int K, int L>
A<K+L> f(A<K>, A<L>); // Тоже самое что и перегрузка 1 (редефинишен)

template<int I, int J>
A<I-J> f(A<I>, A<J>); // Перегурзка 2


_____________________________________________
Реализация прикольных метафункций с помощью SFINAE.

1) Реализация std::is_class. Допустим мы хотим проверить что тип является классом или структурой. Тут нужно сделать уточнение, что есть ещё один тайп трейт std::is_union, который нам нужно исключить: !std::is_union<T>::value. В рамках курса мы 
пока не знаем что такое std::is_union, будем считать что это всегда std::true_type:

namespace detail {
	template<class T>
	//std::integral_constant<bool, !std::is_union<T>::value> test(int T::*);	// Правильная реализация
	std::true_type test(int T::*);					

	template<class>
	std::false_type test(...);
}

template<class T>
struct is_class : decltype(detail::test<T>(nullptr)) {};

struct is это наследник следующего типа: decltype от detail::test<T>(nullptr). Т.е. нужно понять что возвращает функция test с шаблонным параметром T от nullptr, для того чтобы понять от чего унаследоваться, от std::true_type или от std::false_type. У 
функции test есть две версии, одна принимает что угодно в каком угодно количистве: test(...), а другая принимает test(int T::*) - это pointer to member, т.е. указатель на поле типа int от T. Дело в том, что указатели на члены существует только у 
классовых типов, и не существуют у всех остальных. Представим что мы вызываем is_class от T = int. int это класс или нет? Чтобы понять это класс или нет, компилятору нужно унаследоваться от типа decltype(detail::test<T>(nullptr)). Чтобы 
унаследоваться от этого типа, нужно понять какой возвращаемый тип у функции test с шаблонным параметром int от nullptr, и нас есть два варианта от какой версии функции мы можем вызваться, в нашем случае вызваться либо от int::int*, либо 
от чего угодно в каком угодно кол-ве. Но поскольку нельзя сделать int::, первая версия перегрузки отваливается по SFINAE, потому что при попытке подставить T в объявлении std::true_type test(int T::*) получается некорректный тип int::*. Стало быть 
у нас остаётся лишь одна версия test от произвольного кол-ва произвольных аргументов, значит в данном случае возвращаемый тип функции test будет std::false_type, и таким образом структура is_class наследуется от std::false_type, значит у нас 
static const bool value = false.

Теперь, например если T это std::string. Мы опять пытаемся понять что возвращает test<std::string>. В первой перегрузке будет написано int std::string::*, получается мы пытаемся сделать указатель на член класса std::string, который имеет тип int. 
Такой есть. Не важно есть ли реально такой член у класса std::string, важно что тип корректный. Тип T::* int корректнен для любого классового типа T, неважно есть ли такой, вот если бы мы попыталсь взять уже конкретно какой нибудь член класса, 
то он мог бы и не быть типом int, тогда это было бы некорректное присваивание, но мы всегда можем просто назвать такой тип, ведь тип сам по себе является корректным всегда (Лекция 48 1.10.00). Получается обе перегрузки функции test 
являются корректными, теперь вопрос, что предпочтительнее? Поскольку частное всегда предпочтительнее общего, а сигнатура (...) является самой общей что может быть по правилам перегрузки, поэтому сделать конверсию от nullptr к int T::*, 
лучше чем сделать конверсию к многоточию ...  Стало быть возвращаемый тип является std::true_type, мы наследуемся от std::true_type, и тогда у нас static const bool value = true. Т.о. мы определили метафункцию is_class. 

Также нужно доопределить is_class_v:

template <typename T>
using is_class_v = is_class<T>::value;

###
Оффтоп: Комментарий под видео:
using is_class_v вместо using нужно inline constexpr bool.
Конец оффтопа
### 


2) Реализация std::is_polymorphic. Эта метафункция проверяет, что это полиморфный тип, т.е. если в T есть хотябы одна виртуальная функция, то должно быть true, а иначе false. Нам нужно вспомнить одно свойство полиморфных типов, которое 
отличает из в компайл тайме от неполиморфных типов. Это dynamic_cast. dynamic_cast работает в рантайме, но есть некоторое свойство dynamic_cast, которое проверяется в компайл тайме. dynamic_cast иногда выдаёт CE, в каком случае? 
dynamic_cast от неполиморфного типа это CE, кроме случая каста к void* и каста вверх. Если мы попытаемся сделать dynamic_cast вниз между неполиморфными типами то это тоже CE (ну т.е. неполиморфные типы мы умее кастить только вверх). 
На основе этого попробуем реализовать std::is_polymorphic.

namespace detail {
	template<class T>
	std::true_type detect_is_polymorphic (
		decltype(dynamic_cast<const volatile void*>(static_cast<T*>(nullptr)))
	);
	template<class T>
	std::false_type detect_is_polymorphic(...);
} // namsespace detail

template<class T>
struct is_polymorphic : decltype(detail::detect_is_polymorphic<T>(nullptr)) {};

Здесь идея такая же как и в is_class. Мы наследуем is_polymorphic от типа decltype от функции detect_is_polymorphic с шаблонным параметром T вызванной от nullptr, и у нас есть две версии. Одна принимает какой то конкретный тип, а вторая что 
угодно в каком угодно кол-ве.

Разберём случай когда тип полиморфный. Мы пробуем вычислить что за decltype в первой версии перегрузки. Там мы пытаемся nullptr static_cast скастить к T*, а потом dynamic_cast скастить к const volatile void*. nullptr к T* скастить можно, тип этого
будет T*. А дальше мы пытаемся T* скастить dynamic_cast к const volatile void*. Это не всегда можно, если тип не полиморфный, то это CE, dynamic_cast откажется кастить. И поскольку мы находимся под decltype, это будет некоррктный тип, а значит 
это некоррктное объявление, значит у нас нет этой версии перегрузки и остаётся только вторая версия, значит возвращаемый тип будет std::false_type, значит is_polymorphic будет наследоваться от std::false_type. Если бы изначально тип был
полиморфный то dynamic_cast был бы корректный каст, и тогда возвращаемый тип будет std::true_type.


_____________________________________________
Реализация type_traits	(Лекция 49, начало).

Реализуем проверку наличия метода в классе. Когда мы хотели в аллокаторе проверить правда ли аллокатор имеет метод construct с некоторым набором аргументов. (Ищи: "Что такое allocator_traits" в файле "Память программы и типы данных").

template <typename Alloc>
struct allocator_traits {

	template <typename U, typename... Args>
	static void construct(Alloc& alloc, U* ptr, const Args&... args) {
		if constexpr (/* Если Alloc имеет метод construct*/) {		// Пока что так, мы ещё это не умеем писать. 
			alloc.construct(ptr, args...);				
		} else {
			new (ptr) U(args...);
		}
	}
};

Теперь мы сможем реализовать данную проверку с помощью метафункции has_metod_construct от параметров T, Args, которая проверяла бы, правда ли у объекта типа T существует метод с названием construct, от параметров Args. Нам нужно где-то 
взять объект типа T и объекты типа Args, и вызвать у этого объекта эту функцию с такими параметрами. Как нам получить объект типа T, когда у нас нет никакого объекта типа T? Попробуем передать сюда decltype от T по умолчанию, вызвать от
него construct, сделать Args по умолчанию. Это получиться тип void. Также навешиваем * на decltype, и в итоге в test мы принимаем void*. Также у нас должна быть вторая версия.

namespace detail {
	template <typename T, typename... Args>
	std::true_type test( decltype(T().construct(Args()...))* );

	std::false_type test(...);
}
template <typename T, typename... Args>
struct has_method_construct : decltype(detail::test<T, Args...>(nullptr)) {};

template <typename T, typename... Args>
inline constexpr bool has_method_construct_v = has_method_construct<T, Args...>::value;


Данная реализация имеет несколько недостатков. Давайте попробуем протестировать, для этого напишем структуру:

struct S {
	void construct(int, int);
};

int main() {
	static_assert(has_method_construct_v<S, int, int>);		// Проверяем что S имеет метод construct от (int, int).
	static_assert(!has_method_construct_v<S, int, int, int>);       	// Проверяим что S не имеет метод construct от (int, int, int).
};


Компилятор выдаст CE на втором static_assert, хотя должно было вывестить false, т.е. от двух int оно работает, а от трёх нет. Здесь CE потому что у нас есть ошибка в реализации, мы не написали шаблонный префикс у второй версии:

namespace detail {
	template <typename T, typename... Args>
	std::true_type test( decltype(T().construct(Args()...))* );

	template <typenmae...>				// Теперь написали.
	std::false_type test(...);
}

Если не написать шаблонный префикс, то нет второй версии, мы же вызываем test с явным указанием шаблонный аргументов, если вторая версия была нешаблонная, то мы бы не рассматривали эту версию. Важно чтобы вторая версия тоже была
шаблонной, даже несмотря на то, что мы не использовали шаблонный аргумент, а использовали си стайл переменное кол-во аргументов. 


Тут есть ещё пара проблем. Одна из проблем заключается в том, что мы закладываемся на возвращаемый тип construct: если он void то нормально, и даже если он какой-нибудь хороший (например int) то всё нормально.  Но что если мы сделаем 
тип, на который нельзя навешивать звёздочку (*), например тип int&?

struct S {
	int& construct(int, int);
};

Это не CE, но произойдёт static assertion faild, версия отвалилась, поскольку тип получился некорректный, поскольку int&* это некорректный тип. Мы хотим чтобы это работало правильно, не зависимо от того, какой возвращаемый тип у construct. 
std::remove_reference здесь не поможет, в данном случае это будет костыль, всё ровно от того какой будет там тип, будет разное поведение, но мы хотим чтобы возвращаемый тип был не важен. Здесь нам пригодится оператор запятая (,). То что
мы сейчас напишем называется comma trick. 

namespace detail {
	template <typename T, typename... Args>
	std::true_type test( decltype(T().construct(Args()...), nullptr ));	// comma trick

	template <typenmae...>				
	std::false_type test(...);
}

Для чего мы здесь применили оператор запятая? Мы хотим чтобы у нас получилось выражение такого конкретного типа, как нам нужно, но при этом мы хотим чтобы это выражение было корректным или некорректным, в зависимости от 
существования метода construct. Поэтому мы под decltype загнали выражение из двух частей, разделённых оператором запятая, в первой части делается construct, а вторая часть выражения, после запятой, просто константа фиксированного
нужного мне типа, в данном случае nullptr. Тип этого выражения всегда nullptr_t, но выражение либо корректно либо некорректно в зависимости от того, существует ли метод construct. Т.е. за счёт оператора запятая, мы добились того, чтобы 
тип у выражения всегда такой, какой нам нужен, просто если нет метода construct, то выражение некорректно. Эта называется comma trick. 

Теперь у нас если есть метод construct, то мы попадаем в первую версию функции test и вызываемся от nullptr_t, а если нет метода construct, то decltype в первой верии не может вычислить какой тип у выражения, потому что выражение 
некорректно, и соответственно эта версия отваливается по SFINAE, остаётся только вторая версия и получается false_type.


Но есть ещё одна проблема - может не быть конструктора по умолчанию, причём не только у T, а ещё и у Args.

struct S {
	S(int) {}			// Теперь у нас нет конструктора по умолчанию, у нас есть только конструктор от int.
	int& construct(int, int);
};

Теперь будет false в обоих случаях, потому что теперь у S нет конструктора по умолчанию, соответсвтенно в первой версии выражение не корректно не по причине, что нет метода construct, а по причине что T() некоррктный вызов, нет такого
конструктора. Но и у любого из Args может не быть конструктора по умолчанию. Нам нужно как-то получить вещи типа T и типов Args, не имея объектов. Когда мы обсуждали deducing this, мы говорили про то, что есть такая функция 
(не метафункция) std::declval, которая принимает шаблонный параметр T, и возвращает просто объект типа T, при этом она не принимает никаких аргументов.

namespace detail {
	template <typename T, typename... Args>
	std::true_type test(decltype(std::declval<T>()
		.construct(std::declval<Args>()...), nullptr));	

	template <typenmae...>				
	std::false_type test(...);
}

Вопрос: как реализована функция declval? Никак - это правильный ответ (хахахха). У этой функции нет определения, потому что оно и не нужно, ведь эта функция никогда не вызывается в рантайме, у неё предназначение такое, чтобы только под
decltype её использовать. 

template <typename T>	
T declval();			// Небольшой обман, реальная функция выглядит чуть чуть иначе

Эта функция нужна только для мета-программирования. Если мы пытаемся вызвать эту функцию в evaluate constant, т.е. если мы попытаемся вызвать declval не под decltype, или не под sizeof и т.д., короче в контексте, который подразумевает
рантайм вычисление выражения, то мы получаем ошибку линкера. 

Если бы тип T был бы таким, что его его определение компилятору недоступно, или его просто нет, т.е. тип T является incomplete type (неполный тип), то такая реализация declval не сработает, потому что возвращение объекта incomplete type 
из функции, даже если это функция one evaluate constant, это CE (лекция 49 25.40). И ещё момент, если бы T был бы шаблонный тип, то пришлось бы инстанцировать определение шаблонного класса, короче чтобы вернуть T из функции, 
компилятору нужно знать определение T и он бы инстанцировал шаблонный тип, если бы T был бы шаблонным. Настоящая реализация std::declval выглядит так:

template <typename T>	
T&& declval();		// Добавили &&

Когда мы навешиваем &&, это позволяет нам использовать declval, даже с типами, у которых нет определения. declval не требует от типа быть complete type, даже если у нас конструктор приватный, или его нет, или тип вообще не имеет
определения, либо тип нельзя инстанцировать, declval всё ровно должен давать нам сущность с таким же видом value такого же типа, с точностью до наличия ссылки. Два амперсанда а не один, потому что мы хотим сохранить вид value. 
Если бы мы не поставили амперсанды, то это бы работало, но не работало бы для incomplete type.

Но на самом деле реализация выглядит так:

template <typename T>	
typename std::add_rvalue_reference<T>::type declval() noexcept;

Преимущество  std::add_rvalue_reference<T> над T&& в том, что оно работает даже с void.

decltype называется так от слова declared type (объявленный тип), а declval это название которое придумано по аналогии с decltype только наоборот. В каком то смысле declval это операция обратная decltype. decltype это метафункция, 
которая по значению даёт тип этого значения, а declval это функция а не метафункция, которая по типу даёт значение такого же типа. decltype и declval это взаимнообратные операции. По типу получить значение нам нужен declval, а по 
значению получить тип нам нужен decltype.


######################
Реализуем std::is_constructible, std::is_copy_constructible, std::is_move_constructible и т.д.

std::is_constructible это метафункция, которая проверяет можно ли вызвать конструктор T от аргументов Args. std::is_constructible - это мы просто пытаемся вызвать конструктор с нужными аргументами.

Чтобы реализовать например метафункцию std::is_move_constructible нужно по сути сделать тоже самое, что и has_metod_construct, просто проверить что можно вызвать конструктор T от мувнутого T. В случае std::is_copy_constructible, нужно 
просто проверить, что можно вызвать конструктор T, от скопированного T. 

Реализация std::is_copy_constructible:

namespace detail {
	template <typename T>
	std::true_type test(decltype(T(std::declval<T&>()), nullptr));

	template <typename...>
	std::false_type test(...);
}

template <typename T>
struct is_copy_constructible: decltype(detail::test<T>(nullptr)) {};

template <typename T>
const bool is_copy_constructible_v = is_copy_constructible<T>::value;


######################
std::is_nothrow_move_constructible

Ещё одна важная штука, которую мы использовали.

namespace detail {
	template <typename T>
	std::true_type test(
		std::enable_if_t<noexcept(T(std::declval<T>())), decltype(nullptr)>
	);

	template <typename...>
	std::false_type test(...);
}

template <typename T>
struct is_nothrow_move_constructible: decltype(detail::test<T>(nullptr)) {};

template <typename T>
const bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<T>::value;

// Структуры для проверки
struct Good {				// Структура у которой есть мув конструктор и он noexcept
	Good(Good&&) noexcept {}
};

struct Bad {				// Структура у которой есть мув конструктор но он не noexcept
	Bad(Bad&&) {}
};

struct VeryBad {				// Стукрура у которой запрещён мув конструктор
	VeryBad(VaryBad&&) = delete;
};

// Проверим для каждой из структур что is_nothrow_move_constructible работает правильно.

int main() {
	static_assert(is_nothrow_move_constructible_v<Good>);
	static_assert(!is_nothrow_move_constructible_v<Bad>);	// !
	static_assert(!is_nothrow_move_constructible_v<VeryBad>);	// !
}


Есть ещё один способ реализовать is_nothrow_move_constructible - принять nullptr_t, и в возвращаемом типе сделать std::conditional.

template <typename T>
auto test(void*)
	-> std::conditional_t<noexcept(T(std::declval<T>())),  /*и тут хочется написать true_type, false_type*/ >  
);

После std::conditional_t хочется написать true_type, false_type, и это похоже на 
if(условие)
	return true;
else
	return false;

Это можно скорректировать с помощью std::bool_constant, и теперь не нужно std::conditional.

template <typename T>
auto test(void*) -> std::bool_constant<noexcept(T(std::declval<T>()))>;


###
Оффтоп: Обе версии шаблонной функции test являются обычными функциями а не метафункциями, и у них ни у одной нет определения. Мы всё время занимаемся тем, что объявляем какие то функции и не определяем их, и это нормально,
потому что мы не собиремся их вызывать никогда, мы собираемся только под decltype спрашивать какой тип они возвращают. Фигурных скобок нет, мы не собираемся определять их.
Конец оффтопа
###


######################
std::is_base_of

Реализуем метафункцию std::is_base_of, которая проверяет, что один тип является наследником другого. Здесь B - это Base, D - это Derived. Сначала мы должны проверить что B и D это классы.

template <typename B, typename D>
struct is_base_of : std::conjunction<
		std::is_class<B>,
		std::is_class<D>,
		decltype()
	> {};

Обратим внимание что здесь std::conjunction без подчёркивания _v, не std::conjunction_v, а просто std::conjunction, потому что std::conjunction_v это bool, а мы наследуемся от std::conjunction, и нам нужно чтобы в ней был static const 
bool value. И std::is_class без _v, потому что conjunction берётся тоже не от булей, а от метафункций. Это важно.

В detail как всегда должно быть две функции, одна на случай если это наследник, и она должна возвращать true_type, а другая false_type. Но как понять что один тип является наследником другого? Нам нужно попытаться скастить указатель на 
Derived, к указателю на Base. 

namespace detail {
	template <typename B, typename D>
	std::true_type test(B*);

	template <typename...>
	std::false_type test(...);
}

template <typename B, typename D>
struct is_base_of : std::conjunction<
		std::is_class<B>,
		std::is_class<D>,
		decltype(detail::test<B, D>(static_cast<D*>(nullptr)))
	> {};

template <typename B, typename D>
const bool is_base_of_v  = is_base_of<B, D>::value;

// Проверим

struct Base {};

struct Derived: Base {};

int main() {
	static_assert(is_base_of_v<Base, Derived>);
	static_assert(!is_base_of_v<Derived, Base>);
}


Но что если у нас приватное наследование?

struct Derived: private Base {};

Мы хотели чтобы это работало даже в этом случае.  is_base_of должен выдавать true даже если наследование приватное, или при ambiguous (множественное). Однако сейчас будет CE, и не потому что static_assert, а потому что мы пытаемся 
сделать static_cast к приватному родителю, но это CE. Мы говорим decltype от static_cast<D*> к B*, и компилятор решает какую версию перегрузки выбрать. Первая версия перегрузки корректная, и компилятор выбирает её, и после этого проходит 
проверка приватности. Проверка приватности происходит после выбора версии. Но в данном случае static_cast<D*> к B* это нарушение приватности, поэтому это CE, в независимости от того, какой мы ожидаем результат от static_assert. 

Для решения такой проблемы нам нужен ещё один уровень индерекции:

namespace detail {
	template<typename B>
	std::true_type test_ptr_conv(const volatile B*);
	template<typename>
	std::false_type test_ptr_conv(const volatile void*);

	template<typename B, typename D>
	auto test_is_base_of(int) -> decltype(test_ptr_conv<B>(static_cast<D*>(nullptr)));
	template<typename, typename>
	auto test_is_base_of(...) -> std::true_type;	// private or ambiguous base
}

template<typename Base, typename Derived>
struct is_base_of :
	std::integral_const<
		bool,
		std::is_class<Base>::value &&
		std::is_class<Derived>::value &&
		decltype(details::test_is_base_of<Base, Derived>(0))::value
	> {};

Наш результат это decltype(details::test_is_base_of<Base, Derived>(0))::value. Теперь у нас есть две функции test_is_base_of, одна от int, другая от чего угодно, и первая из них имеет возвращаемый тип 
decltype(test_ptr_conv<B>(static_cast<D*>(nullptr))), а вторая std::true_type. Возвращаемый тип первой версии это тоже самое что мы делали раньше, с функцией test (теперь она называется test_ptr_conv), одна принимает const volatile B*, 
а другая const volatile void*, и мы пытаемся вызваться от D*.

В итоге у нас есть два варианта. Разберём случай public одназначного наследования. В decltype(details::test_is_base_of<Base, Derived>(0))::value мы вызывамся от 0, у нас есть версия функции test_is_base_of от int, и от многоточия. Мы 
хотим проверить версию от int, т.к. она предпочтительнее, для этого нам нужно проверить какой у неё возвращаемый тип. Теперь нам нужно понять какой тип вернёт decltype(test_ptr_conv<B>(static_cast<D*>(nullptr))). Мы идём ещё на уровень 
глубже, мы пытаемся понять какой тип был бы если бы мы вызвали функцию test_ptr_conv от D*. У функции test_ptr_conv тоже есть две версии: от B* и от void*, но мы D* - публичный наследник B, значит версия с B* предпочтительнее,  значит 
мы идём в первую версию и возвращаем true_type. Далее проверяем корректно ли выражение decltype(test_ptr_conv<B>(static_cast<D*>(nullptr))). В нашем случае это выражение корректно, потому что мы публичный и однозначный наследник B, 
значит возвращаемый тип true_type, и в итоге мы получае ответ true.

Если мы вообще не наследник, то между версиями функции test_ptr_conv предпочтительнее вторая, потому что сконвертировать D* в B* нельзя, поскольку D не наследник B, и тогда мы возвращаем false_type, значит в итоге мы равны false.

Если мы приватный или ambiguous наследник. Если мы приватный наследник, то мы пытаемся предпочесть первую версию функции test_is_base_of и пытаемся понять тип. Предпочтительнее вызваться от первой версии функции test_ptr_conv,
поскольку мы наследник B, и возвращаемый тип функции test_ptr_conv должен быть true_type, но есть проблема: decltype(test_ptr_conv<B>(static_cast<D*>(nullptr))) получается не корректное выражение из-за приватности, значит SFINAE 
срабатывает, и первая версия функции test_is_base_of отваливается, значит мы попадаем во вторую версию перегрузки этой функции, а у неё написано true_type, true_type потому что мы были наследником, просто приватным наследником и 
значит возвращаемый результат true. Анологично если бы это был ambiguous call, потому что неоднозначность наследования тоже проверяется после выбора версии перегрузки как и приватность наследования. Мы сначала решаем что первая
версия функции test_ptr_conv предпочтительна, а уже потом понимаем что это некорректное выражение из-за приватноси или неоднозначности, и тогда и только тогда мы попадаем во вторую версию функции test_is_base_of, который true_type. 
Мы избегаем CE с помощью SFINAE в первой версии функции test_is_base_of, за счёт того, что мы запрятали случай некорректного выражения на уровень глубже. 


######################
std::is_convertible

Разница между std::is_convertible и std::is_constructible в том, что std::is_constructible не даёт Implicit conversions (неявные преобразования), а std::is_convertible даёт. Т.е. на самом деле std::is_convertible проверяет, что если у
нас есть такая гипотетическая функция test(), которая возвращает To, и написано return std::declval<From>(): To test() { return std::declval<From>(); }, то это должно быть корректно, т.е. мы не вызываем конструктор To от From явно.

Реализация в лекции 50 где-то на 05.00. Ничего подробного там нет. Идейно короче мы как будто создаём функцию, которая принимает To, и в неё отдали как будто From, и вот таким образом мы проверяем неявно конвретируемо ли From в To.


######################
std::commot_type

Мы хотим реализовать такую метафункцию, которая принимает типы, и возвращает тип, общий для них для всех. Общий это такой, к которому они все приводятся. Типо у нас есть сын и дочь, и мы хотим получить мать.

Реализация: мы наследуемся от std::type_identity. std::type_identity это тождественная метафункция, которая по типу возвращает этот же тип. Это нужно для того, чтобы просто не писать явно using type = чтото. Это современный кодстайл.
Этот пример важен, в этом решении заключен весь C++. У нас в языке уже есть механизм, который позволяет для двух данных типов, понять какой общий между ними, в интуитивном нашем понимании, причём этот механизм с нами с самой первой 
лекции, и мы им всё время пользуемся, просто мы сейчас не думаем об этом механизме в контексте этой проблемы.



template <typename... Types>
struct comman_type;

template <typename T>
struct comman_type<T>: std::type_identity<T> {};

template <typename T, typename U>
struct comman_type<T, U>  
    : std::type_identity<
    	decltype(true ? std::declval<T>() : std::declval<U>())
    > {};

template <typename T, typename... Types>		// Специализация для произвольного кол-ва типов
struct comman_type<T, Types...>
    : comman_type<T, comman_type<Types...>::type> {}; 	// Откусываем по кусочку


Вот так можно найти общий тип для двух типов. Неважно что мы написали true, или false, поскольку под decltype выражение не вычисляется, а оценивается только его тип. Тип того, что нам вернёт тернарный оператор, он как бы и будет примерно
интуитивно соответсвтовать тому, что мы называем общим типом для двух данных. Мы не можем наследоваться просто от T, потому что T может быть int. Но к сожалению не все так радужно, тернарный оператор в данном случае работает, но он не на
столько мощьный, на сколько бы нам хотелось. Например если у нас есть сын и дочь и у них общая мама, то он не найдет маму, тернарный оператор так не умеет, т.е. если родителя (мамы) не будет среди переданных типов, а будет только сын и 
дочь, то будет CE, он не найдёт общий тип. То как мы сейчас написали, не может найти общего родителя, если он не присутствует среди перечисленных родителей. Но и на самом дели и std::comman_type этого не может, по той же причине. 
До С++17 std::comman_type был так и реализован.

Что будет если мы передадим comman_type от сына дочери и мамы? Зависит от порядка, потому что если маму передали последней, то мы сначала идём comman_type от дочери и мамы это будет мама, потом от сына и мамы и это будет мама. Но если
мы сделаем comman_type в нашей реализации от мамы сына дочери, то это будет опять CE, потому что мы первым делом попытаемся найти comman_type от сына и дочери и не найдём его.

Наш comman_type сейчас линейный, но можно попробовать реализовать его за квадрат, т.е. стартовать с каждого по очереди, т.е. попробовать от первого по всем пробежаться, потом от второго по всем, от третьего и т.д. и для каждого, идя
в лево и в право, сделать comman_type от соседей и т.д. и это будет охватывать большее число случаев чем исходный comman_type, но всё ещё не все. 

После C++17 comman_type реализовали по другому, но что оказалось не так? comman_type оказался not SFINAE-friendly, т.е. не дружественный относительно SFINAE. Но что такое not SFINAE-friendly?


######
SFINAE-friendly

template <typename T>
auto call_f(const T& t) {							// Эта функция не SFINAE-friendly
	t.f();
}

template <typename T>
auto call_f_if_available_impl(const T& t, int) -> decltype(call_f(t)) {
	call_f(t);
}

template <typename T>
auto call_f_if_available_impl(const T& t, ...) {
	// Do nothing;
}

template <typename T>
auto call_f_if_available(const T& t) {
	call_f_if_available_impl(t, 0);
}

struct WithoutF {};
struct WithF{ void f() const { std::cout << "f() called\n"; }};

int main() {
	std::cout << "WithoutF\n";
	call_f_if_available(WithoutF{});
	td::cout << "WithF\n";
	call_f_if_available(WithF{});
}


Этот пример иллюстрирует что значит быть не SFINAE-friendly. В данном примере функция call_f не SFINAE-friendly, это значит её нельзя использовать в контексте SFINAE. Здесь будет CE со словами: const struct WithoutF has no member named 
f, т.е. у WithoutF нет метода f. Почему это произошло? Потому что компилятор пытается проверить первую версию перегрузки функции call_f_if_available_impl, однако компилятору нужно выключить эту версию если decltype(call_f(t)) 
некорректное выражение. Компилятор инстанцирует объявление функции call_f, но видит возвращаемый тип auto без уточнений, и для того, чтобы понять какой тип возвращает функция call_f, компилятору приходится инстанцировать само тело 
функции call_f. Получается мы не ограничились объявлением, компилятор не пошёл бы инстанцировать тело, если бы он глядя на объявление понял какой возвращаемый тип, но в данном случае глядя на объявление не понятно какой возвращаемый тип,
а значит компилятору нужно лезть в тело и инстанцировать определение функции (в данном случае возвращаемый тип функции call_f это void). Но как только он инстанцирует определение, случается CE, потому что аргумент t в данном случае это
WithoutF{}, и мы пытаемся вызвать функцию t.f(), т.е. WithoutF{}.f(), но у WithoutF{} нет функции f(). Т.е. функция call_f не SFINAE-friendly и её нельзя использовать в SFINAE контексте.

Как исправить это? Как сделать так, чтобы call_f был SFINAE-friendly. В данном случае просто поставить void вместо auto в объявлении функции call_f не поможет, т.к. тогда decltype(call_f(t)) будет корректным выражением и компилятор 
выберет первую версию перегрузки функции call_f_if_available_impl, однако в теле функции call_f_if_available_impl опять идёт вызов функции call_f(t), после которго опять будет вызов функции t.f(), а в нашем случае это опять CE. Нам 
нужно, чтобы по объявлению функции call_f можно было понять что её нельзя вызывать с парамторм t, для этого напишем так:

template <typename T>
auto call_f(const T& t) -> decltype(t.f(), void()) {	 // void() по умолчанию XD. Теперь это SFINAE-friendly				
	t.f();
}

void() с круглыми скобочками это потому что просто void это тип, а нам нужно выражение типа void (также можно написать throw 1). Если мы напишем просто void то это будет синтаксическая ошибка, потому что под decltype написано не 
выражение, нам нужен объект, а мы написали тип.


######
Так в чём заключается not SFINAE-friendliness в нашей реализации comman_type? Допустим мы хотим использовать comman_type в SFINAE контексте, т.е. мы хотим сделать перегрузку по принципу существует ли comman_type или нет. Сделать мы это
можем так: у нас есть функция foo, которая принимает typename my_common_type<T, int>::type y, а есть также функция foo, которая принимает всё что угодно. Если мы попробуем в такой функции вызвать std::string, то будет CE.

template <class... T> struct my_common_type;

template <typename... T>
using my_common_type_t = typename my_common_type<T...>::type;

template <class T>
struct my_common_type<T> {
	using type = std::decay_t<T>;
};

template <class T, class U>
struct my_common_type<T, U> {
	using type = std::decay_t<decltype(true ? std::declval<T>() : std::declval<U>())>;	
};

template <class T, class U, class... V>
struct my_common_type<T, U, V...> {
	using type = my_common_type_t<my_common_type_t<T, U>, V...>;
};

template <typename T>
void foo(T x, typename my_common_type<T, int>::type y) {};

void foo(...) {}

int main() {
	foo(std::string("hello"), std::string("world"));
}

Почему сейчас CE? operands to ?: have different types 'std::__cxx11::basic_string<char>' and 'int', т.е. нет common_type для int и std::string, и это CE, но мы хотели бы чтобы это было бы SFINAE, а это оказалось CE. Получилось что у 
common_type нет, если нет общего типа, то my_common_type невалиден, нет типа type в my_common_type. Мы вызваем typename my_common_type<T, int>::type y и происходит CE, потому что типа type нет. Но почему это не SFINAE, если тип
некорректный, почему не выбралась вторая версия перегрузки функции foo? Чтобы компилятору понять корректен ли этот тип, ему нужно проинстанцировать шаблон my_common_type_t с параметрами std::string, int и проинстанцировать определение
класса, и когда он это делает он падает, потому что определение с такими шаблонными параметрами инстанцировать нельзя.

Тем не менее если использовать std::common_type вместо нашего my_common_type это не будет CE, а будет выбираться вторая версия функции foo. Правильная реализация common_type лекция 50 44.40. Там рассказано, что в настоящей реализации 
завернули вычисление на уровень глубже как в std::is_base_of. Мы делаем так, чтобы компилятор не инстанцировал шаблонные классы, в которых были бы невалидные типы.


######################
Заключение по type_traits

Есть некоторые type_traits, которые нельзя реализовать на C++ стандартными средствами, некоторые type_traits просто зашиты в компилятор, например std::is_standart_layout, это вещь, которая проверяет что T, это standart layout type, 
т.е. это либо скалярный тип, либо standart layout class type, либо массивы таких типов, либо cv-qualified версии таких типов. То что мы разобрали что некоторые type_traits можно реализовать руками, не значит что все type_traits можно
реализовать руками.



_____________________________________________
Constraints and requirements (since c++20) (Ограничения и требования) (Это тот момент когда перевод на русский звучит кринжово)

В C++20 появилась возможность нормально писать требования к типам на входе в функции. Как раньше нам нужно было писать, если мы хотели, чтобы наш тип поддерживал что-нибудь, например, мы хотим чтобы следующая версия функции f работала
только для классовых типов:

template <typename T, typename = std::enable_if_t<std::is_class_v<T>>>
void f(const T& x) {
	std::cout << 1;
}

А если бы мы хотели такую же функцию, но для неклассов, то это ещё хуже:

template <typename T, std::enable_if_t<std::is_class_v<T>, bool> = true>
void f(const T& x) {
	std::cout << 1;
}

template <typename T, std::enable_if_t<!std::is_class_v<T>, bool> = true>
void f(T x) {									// На примитивные типы разумно не делать константную ссылку.
	std::cout << 2;
}

Это перегрузка по признаку класс это или не класс. Так мы делали раньше перегрузку. Начиная с C++20, если мы хотим сказать, что наша функция применима только для типов, которые удовлетворяют некоторому тайп трейту, мы можем использовать
ключевое слово requires

//template <typename T, typename = std::enable_if_t<std::is_class_v<T>>>	// Старый синтаксис

template <typename T>								
requires std::is_class_v<T>							// Новый синтаксис. Он называется Requires clause.
void f(const T& x) {
	std::cout << 1;
}

Теперь попробуем вызывать f не от класса, и посмотреть что будет:

int main() {
	f(0);
}

Ошибка CE: constraints not satisfied. Компилятор показывает нам на requirement и сказал что constraints not satisfied. Вот это вот как раз называется constraints, т.е. ограничания на типы, которые мы можем навешивать на функции.
Синтаксис requires std::is_class_v<T> называется Requires clause. Мы можем писать requires перед после шаблонного заголовка перед сигнатурой функции, а так же после сигнатуры функции перед открываением фигурной скобочки:

template <typename T>															
void f(const T& x) 
requires std::is_class_v<T>
{
	std::cout << 1;
}


Что писать в requires? В requires должно быть какое-то булевское выражение, но компайл тайм вычислимое, потому что это компайл тайм проверки. С помощью конъюнкции мы можем потребовать несколько требований:

template <typename T>															
void f(const T& x) 
requires std::is_class_v<T> && std::is_copy_constructible_v<T>
{
	std::cout << 1;
}

int main() {
	f(std::uinque_ptr<int>(new int));
}

Выдаст ошибку constraints not satisfied, и укажет на std::is_copy_constructible_v<T>, т.е. какой именно элемент конъюнкции оказался ложным.



Что если мы захотим сделать перегрузку? Допустим мы захотели сделать две функции, первую ту же самую, а вторую, для типов которые не классы, напишем например std::is_integral_v<T>

template <typename T>															
void f(const T& x) 
requires std::is_class_v<T> && std::is_copy_constructible_v<T>
{
	std::cout << 1;
}

template <typename T>
requires std::is_integral_v<T>	
void f(const T& x) {
	std::cout << 2;
}

Вот представим что мы вызываемся сначала от от std::string, а затем от int, будет ли это корректно работать? У этих функций одинаковая сигнатура.

int main() {
	std::string s = "abc";
	f(s):
	f(0);
}

Да это будет корректно работать, но на самом деле ответ нетривиальный. Чтобы это работало, ножно чтобы компилятор, несмотря на одинаковые сигнатуры, умел различать функции по requires. У этих функций полностью одинаковая сигнатура, и
шаблонный префикс, и набор аргументов абсолютно одинаковые, и раньше мы не могли писать две разные функции, у которых полностью одинаковые сигнатуры. Т.е. чтобы это работало, нам нужно либо переопределить понятие что такое сигнатура
функции, либо разрешить наличие функций с одинаковыми сигнатурами. Когда мы раньше пытались с std::enable_if сделать аналогичную штуку, у нас так просто это не работало, мы писали typename =, typename = и программа падала, поскольку 
сигнатура была одинаковая. Однако requires вшили в язык прям на очень очень начальной стадии выбора версии. requires проверяется до того, как происходит разрешение перегрузки и до того, как происходит инстанцирование шаблона, т.е.
вообще до всего по сути, requires вообще проверяется на стадии поиска имён. requires является с точки зрения компилятора не какой-либо вещью, которая позволяет выбрать версию перегрузки и не чем-то, что он может инстанцировать. Для
компилятора обе функции выше как будто с разными названиями, т.е. это не то чтобы функции с разными сигнатурами, это как бы функции с разными названиями. С точки зрения перегрузки это функции с одинаковой сигнатурой, но с точки 
зрения поиска имён, это как будто функции с разными названиями.

requires учитывается в перегрузке в том плане, что наличие requires лучше, чем отсутствие requires:

// Случай 1
template <typename T>															
void f(const T& x) 
requires std::is_class_v<T> && std::is_copy_constructible_v<T>
{
	std::cout << 1;
}

template <typename T>		// Мы удалили requires, но всё скомпилировалось	
void f(const T& x) {
	std::cout << 2;
}

int main() {
	std::string s = "abc";
	f(s):
	f(0);
}

Если мы сделаем два requires, из которых оба подходят,

// Случай 2
template <typename T>															
void f(const T& x) 
requires (2+2=4)			// Поменяли requires 
{
	std::cout << 1;
}

template <typename T>
requires true				// Поменяли requires
void f(const T& x) {
	std::cout << 2;
}

то: будет CE со словами что это неоднозначный requirement. Если мы напишем так:

// Случай 3
template <typename T>															
void f(const T& x) 	
requires std::is_class_v<T>		// Поменяли requires
{
	std::cout << 1;
}

template <typename T>
requires true		
void f(const T& x) {
	std::cout << 2;
}

Здесь у нас оба requirement получились true, и здесь снова CE, потому что на стадии перегрузки компилятор не умеет различать requires. Компилятор умеет на стадии перегрузки считать что наличие requirement это лучше чем его отсутствие 
(как в случае 1), и если подходят оба версии, то он выбирает ту, которую с requirement, но если на стадии перегрузки он видит, что у него есть две функции с одинаковой сигнатурой и обеих функций есть requirement, то он не умеет выбирать 
более строгий requirement, поэтому для него это просто две разные функции с одинаковой сигнатурой, поэтому перегрузка ломается. Поэтому если у нас один requirement частный случай другого requirement, они не взаимоисключающие, но у 
обеих функций есть requirement, то перегрузку по такому принципу сделать неполучится. Вот если они взаимоисключающие, то получится, а если невзаимоисключающие, то неполучится, компилятор не понимает какая версия является более 
частной:

// Случай 4
template <typename T>															
void f(const T& x) 	
requires std::is_class_v<T>		
{
	std::cout << 1;
}

template <typename T>
requires std::is_class_v<T> && true	// Вместо true можно подставить например std::is_copy_constructible_v<T>, и всё ровно будет CE.	
void f(const T& x) {
	std::cout << 2;
}

здесь CE, потому что комилятор не может выбрать более общую версию. Если мы напишем два одинаковых requirement с одинаковой сигнатурой, то будет редефинишен (если написать requirement с одинаковой стороны от объявления функции,
если с разных то это амбигиус колл).


Ещё один момент. Представим новую функцию g, что выведется?

void g(long x) requires (sizeof(long) == 4) {
	std::cout << 3;
}

void g(long x) requires (sizeof(long) == 8) {
	std::cout << 4;
}

int main() {
	g(1l);
}

Будет CE: constraints on a non-templated function. Нельзя вешать requires не на шаблонные функции. Если бы комитет разрешил вешать requires не на шаблонные функции, то были бы большие проблемы на стадии линковки, потому requires не 
является частью сигнатуры и если функция нешаблонная, то что делать линкиру? У нас же может быть определение находиться отдельно от объявления для нешаблонных функций и компилятор может не видить определения когда компилирует это. И
если бы мы научились вешать requires на нешаблонные функции, а потом определяли бы их где-то в библиотеке, то когда дело дошло бы до стадии линковки, получалось бы что мы можем подсунуть определение с requirement несоответствующему
исходному requirement в объявлении и линкер не сможет отличить эти ситуации, потому что линкер же ничего не знает про requirement. Поэтому нельзя вешать ограничения на нешаблонные функции.


######################
Мы можем использовать requires не объязательно для типов, например вот функция на случай если N > 10:

template <typename T>
requires N > 10
void f();

Также мы можем вешать requires не только на функции, но и на другие шаблоны, например на классы. Представим что мы сейчас напишем requirement если N < миллиона, то сделаем массив на стеке, а если больше, то на куче:

template <typename T, size_t N>
requires (N <= 1'000'000)
struct array {
	T arr[N];
};

// Реализацию кучи мы не написали

int main() {
	array<int, 10> a;
	array<int, 10'000'000> b;
}


Почему requires гораздо лучше чем std::enable_if? Вообще std::enable_if уже устарел. С приходом constraints and requirements std::enable_if по сути не нужен, потому что всё тоже самое можно написать более простым языком и оно ещё и лучше
работает, а самое главное ошибки компиляции стали гораздо читабельнее, потому что раньше если у нас нарушено какое-то требование к типу, то у нас появлялись огромные ошибки в стиле компилятор не может что-то там инстанцировать или
подставить и сообщение на 250 строк что кандидаты такие то и не один их них не подходит, если мы вызываем какую то операцию которая не поддерживается над типом, например std::sort над std::list. Но если мы написали requirement, то у нас
даже инстанцирование функции не будет, у нас отвалиться requirement на самой ранней стадии и он просто скажет что у нас нет такой операции над нашем типом, из-за чего наша ошибка компиляции будет короче и понятнее.



_____________________________________________
Requires-expressions

Мы сказали что std::enable_if устарел, но представим что мы хотим написать requirement на то, что у типо определена какая нибудь операция, например мы хотим проверить что тип позволяет делать сложение:

template <typename T>
requires // Что здесь написать?
T add(const T& a, const T& b) {
	return a + b;
}

Пока что после requires мы умеем писать только какие то метафункции и компайл тайм сравнения делать,но мы хотим уметь писать проверку что тип поддерживает такие то операции. И для этого у нас есть requires-expressions. У requires есть
другое значение. То что мы наблюдали в пункте выше это было requires clause (спецификатор requires). А есть ещё оператор requires. Мы проверяем поддерживает ли тип T сложение:

template <typename T>
void test() {
	std::cout << requires(T a, T b) { a + b; };
}

int main() {
	test<int>();			// Выведет 1
	test<string>(); 		// Выведет 1
	test<void>();   		// Выведет 0
	test<std::vector<int>>();   	// Выведет 0
}

Мы написали requires expressions, которое на самом деле является булевским выражением, здесь requires является специальным оператором после которого идут круглые скобочки в которые он как бы принимает в себя типы как аргументы, а 
дальше в фигурных скобочках написано нечто, и то что написано в фигурных скобочках проверяется на компилируемость. Теперь чтобы нам использовать это в requires clause нам нужно написать requires два раза:

template <typename T>
requires requires(T a, T b) { a + b; }
T add(const T& a, const T& b) {
	return a + b;
}

Это напоминает noexcept, так же как есть спецификатор noexcept и есть оператор noexcept, также есть спецификатор requires и оператор requires, спецификатор requires это просто элемент синтаксиса при объявлении шаблонной сущности, а 
оператор requires, это штука, которая вычисляется в компайл такйме и возвращает true или false, в зависимости от того, компилируется ли данные операции над данными объектами.

Что можно писать в этих фигурных скобках? Мы можем там писать произвольные выражения и компилятор будет оценивать их на компилируемость. Например:

template <typename T, size_t N>
requires requires(T a) {	
	sizeof(T) == N;		//sizeof(int) == 10 же да? XD
}
void test(const T& a) {}

int main() {
	test<int, 10>(0);
}

Почему это компилируется? Потому что, то что мы пишем в requires, оно не проверяется на истинность, оно проверяется только на компилируемость, это распрастранённая ошибка при написании requires. Если мы здесь напишим какие-то булевские
условия, они не будут проверены на истинность. В данном случае здесь проверено, что то, что будет получено из sizeof(T), будет operator== от того, какой тип имеет N.

Однако внутри этого можно проверить условие на истинность. Внутри requires можно писать другой requires. И это как раз и будет проверкой на истинность условия. Можно написать вложенный requirement:
 
template <typename T, size_t N>
requires requires(T a) {		// Requires expressions
	requires sizeof(T) == N;	// nested requirement		
}
void test(const T& a) {}

У нас бывает 4 типа requirement внутри оператора requires: 
1) Simple requirement т.е. просто выражение с двумя словами requires (тогда проверяется на компилируемость)
2) Nested requirement т.е. это когда мы внутри requires написали слово requires (тогда проверяется на истинность, а не на компилируемость). Если у нас сложный набор requirements, то мы не делаем конъюнкцию через &&, а можем написать 
длинную штуку, в которой есть проверка на компилируемость, а ещё есть проверка на истинность тем самым перечислить их в одном requires. В данном случае код выше не скомпилируется, поскольку теперь проверяется истинность, а не 
компилируемость.

3) Type requirement т.е. когда мы проверяем что некоторый тип существует, т.е. это requirement, который начинается со слова typename. Это не выражение, а проверка типа.

template <typename T, size_t N>
requires requires(T a) {		// Requires expressions	
	requires sizeof(T) == N;	// Sested requirement
	typename T::value_type;		// Type requirement	
}
void test() {}

int main() {
	test<std::vector<int>, 24>();
}

Мы можем писать requires когда у нас есть requires clause, т.е. мы можем писать requires булевское выражение, либо мы можем писать requires expressions, внутри которого мы можем навешивать проверку компилируемости выражений, проверку
наличия типав, а также вложенные requirements проверку истинности каких то выражений. Мы можем объединять в логические выражения вещи после requires clause:

template <typename T, size_t N>
requires 
(N < 50) &&				// Requires clause
requires(T a) {				// Requires expressions	
	requires sizeof(T) == N;	// Sested requirement
	typename T::value_type;		// Type requirement
}
void test() {}

4) Ещё есть Compound requirements, о них говориться в следующей теме.


######################
Допустим мы в функции test хотим завести unordered_map от чего нибудь. Мы захотим проверить что std::hash существует над типом T, как нам это написать, первый или второй вариант?

template <typename T>
requires requires(T a) {				
	//typename std::hash<T>();	// 1-ый вариант
	//std::hash<T>();		// 2-ой вариант
}
void test() {}

Если мы напишем как в 1-ом варианте: typename std::hash<T>(), то это будет верно для всех T, и этот requirement будет выполнен всегда, потому что шаблон std::hash от T существует для всех T, мы же его не инстанцируем. Специализации
могут быть неопределены для некоторых T, но он объявлен для всех T, а поскольку мыне идём инстанцировать его, такой тип будет существовать всегда. 1-ый вариант это проверка существования типа, тип существует в любом случае, есть ли у 
него опеределение или нет, это просто incomplete type, но тип то существует. Получается нам нужно проверить не существование типа, а что его можно создать, ещё и вызвать от a:

template <typename T>
requires requires(T a) {				
	std::hash<T>()(a);		
}
void test() {}



_____________________________________________
Concepts (Концепты)

После прохождения предыдущей темы, должно было возникнуть желание, научиться некоторые наборы requirements объединять в именнованые сущности. Например представим что мы пишем функцию find_if:

template <typename InputIter, typename Predicate>
InputIter find_if(InputIter beg, InputIter end, Predicate p) {
	for(auto it = beg; it != end; ++it) {
		if(p(*it)) {
			return it;
		}
	}
	return end;
}

На самом деле может сложиться ощущение, что как будто объявлениях таких функций, названия таких типов, как InputIter, несёт какой то смысл, хотя формально никакого смысла оно не несёт. Как будто называя шаблонный параметр InputIter мы
чего-то от него ожидаем и единственный способ показать нам, что мы ожидаем input iterator, это правильно назвать шаблонный параметр. И Predicateтоже, т.е. как будто у нас нет языковых средств выразить мысль, что мы не все шаблонные 
параметры хотим сюда принимать, а только определённого вида. Т.е. мы можем их только специально правильно назвать, чтобы намекнуть что он называется InputIter неспроста, не произвольный T сюда отдавай пожалуйста, а только тот,
который удовлетворяет named requirement input iterator. Named requirements это не элемент языка, это элемента мета языка, это просто формальное название. Получается что у нас есть named requirement, но они никак не проверяются, и если 
мы сюда отдадим нечто, что не является input iterator, то мы увидим CE и 100 строк ошибок, компилятор скажет что у нашего типа нет operator*, нооооо есть 50 кандидатов ни один из которых не подошёл и начинает перечислять их (XD). Мы 
хотим чтобы было не так, мы хотим чтобы компилятор бы умел на стадии шаблонной подстановки говорить, что мы подставили сюда тип, не являющийся input iterator. Так давайте научимся писать named requirements.


Конечно мы можем написать так:

template <typename InputIter, typename Predicate>

requires requires (InputIter it, Predicate p) {			// Мы можем писать requires так 
	++it;
	*it;
	p(*it);
}

InputIter find_if(InputIter beg, InputIter end, Predicate p) {
	//...
}

Хорошо, но что если мы пишем sort, там должен быть random access iterator, тогда получается что в requires requires нам нужно перечислить все опреации, которые поддерживает random access iterator, например декримент и т.д. Получается 
если мы определяем все библиотечные функции для random access iterator, то нам перед каждой функцией придётся это повторять. Давайте в конце-концов научимся некторые наборы requirements объединять и давать им названия. Мы хотим сказать,
что вот этот набор requirements будет у нас иметь название, и допустим у нас он будет называться InputIter, и мы будем требовать чтобы эта функция принимала input iterator. Вот такие наборы requirements, объединённые общим названиям,
называются concepts. Мы можем написать так:

template <typename T>
concept InputIterator = 	// А дальше либо какое-нибудь булевское выражение от T, либо requires
requires(T it) {
	++it;
	*it;
};

template <typename It, typename Predicate>
requires InputIterator<It> 			// Требование для It
&& requires(Predicate p, It it) { p(*it); }
It find_if(It beg, It end, Predicate p) {
	//...
}

Здесь It это тип, а InputIterator это concept. Т.о. мы научились некоторые наборы requirements объединять и называть их специальными именами.



Теперь решим проблему с тем, что мы хотим уметь требовать от (в данном случае) ++it, *it и выражения { p(*it); } не просто существование, а ещё быть чему то равным. Для этого у нас есть 4 вид requirement: Compound requirements.
Compound requirements имеет следующий синтаксис: мы можем для выражения написать стрелку (это не оператор стрелка, а специальная другая стрелка), которая позволяет после себя написать concept и проверить что это удовлетворяет некоторому
concept. Как это проверить: Во-первых мы можем переписать многие type_traits на concept, поскольку type_traits и concept почти одно и тоже, например мы можем написать concept same_as (сейчас будет написана неправильная реализация):

template <typename T, typename U>
concept same_as = std::is_same_v<T, U>;

И теперь мы можем сделать Compound requirements:

template <typename T>
concept InputIterator = requires(T it) {
	{++it} -> same_as<T&>;								// Фигурные скобочки потому что без них нельзя распарсить однозначно, потому что стрелка это оператор.
	typename std::iterator_traits<T>::value_type;
	{*it} -> std::convertible_to<template std::iterator_traits<T>::value_type>;	// template поскольку это зависимое имя
};

Здесь same_as это concept от двух аргументов, но когда мы используем concept в Compound requirements, мы первый тип не указываем, вместо него автоматически подставляется тип ++it. Тип того что получилось, должен быть same_as как второй
аргумент шаблона на этой штуке. Мы хотим чтобы ++it нам давал конкретно такой тип T&. В стандартной библиотеке есть готовые концепты, например std::convertible_to, это просто std::is_convertible_t из From в To с дополнительным 
требованием что его можно привести статик кастом.

Что мы можем сделать когда у нас есть какой нибудь концепт? Мы можем использовать сокращённую форму передачи. Вместо того, чтобы писать:

template <typename It, typename Predicate> 
requires InputIterator<It> 

мы можем писать просто template <InputIterator It,typename Predicate>:

template <InputIterator It, typename Predicate>
requires(Predicate p, It it) { p(*it); }
It find_if(It beg, It end, Predicate p) {
	//...
}


Попробуем вместо requires Predicate поставить стандартный концепт std::predicate. У него следующий шаблонный синтаксис: template <class F, class... Args>. Чтобы нам его использовать нам нужно понять, как нам в сокращённой форме сказать,
что мы ожидаем в качестве второго шаблонного параметра какой то Predicate от аргуменов Args. Нам нужно использовать predicate от Args..., а первый аргумент, тот что мы отдали в шаблон, он неявно подставит.

template <InputIterator It, std::predicate<decltype(*std::declval<It>())> Pred>
It my_find_if(It beg, It end, Pred p) {
	for(auto it = beg; it != end; ++it) {
		if(p(*it)) {
			return it;
		}
	}
	return end;
}

int main() {
	std::vector<int> v(10);
	my_find_if(v.begin(), v.end(), [](int x) {return x > 0;});	// Здесь лямбда для удобства
	//my_find_if(v.begin(), v.end(), 4);				// У 4 нет оператора круглые скобочки

Здесь в InputIterator It мы передали концепт с одним шаблонным параметром, он T, которое мы передали в шаблон и протестирует, а если у нас здесь концепт со многими шаблонными параметрами, то он первый подставит неявно, а остальные 
возьмёт вот эти (не совсем понял Лекция 51 51.30). Но если бы мы подставили что нибудь другое, у чего небыло бы оператора круглые скобочки, то это бы не скомпилировалось. Т.е. от предиката компилируется, а от не предиката не 
коспилируется.


Однако это ещё не самая сокращённая форма. В C++20 можно писать auto в принимаемом типе, поэтому можно написать так:

auto my_find_if(InputIterator auto beg, InputIterator auto end, 
		std::predicate<decltype(*beg)> auto p) {
	for(auto it = beg; it != end; ++it) {
		if(p(*it)) {
			return it;
		}
	}
	return end;
}

Мы вместо того, чтобы писать шаблонный перфикс, пишем auto в принемаемом типе, но мы concept накладываем перед auto, т.е. мы говорим не просто auto, InputIterator auto, это значит такой тип, который является input iterator, но сам 
догадайся как он называется. В данном случае такая запись и шаблонный префикс который мы удалили не являются эквивалентными, поскольку теперь разрешается этим типам быть разными, потому что и там и там auto, и они независимые, они
могут вывестись в разные типы. Тоже самое и с предикатом. Чтобы был одинаковый тип нужно сделать так:

auto my_find_if(InputIterator auto beg, decltype(beg) end, 
	//...
}


######################
Concepts Subsumption rules (Правила субсуммирования)

Попробуем заново реализовать std::advance для итераторов. Там была проблема в том, что если итератор поддерживает операцию += то это можно сделать за O(1), а если нет, то нужно инкрементировать в цикле. Раньше мы решали эту проблему тем,
что писали if constexpr, а до того, как изобрели if constexpr, приходилось делать перегрузку, дополнительно вводить функцию helper и передавать дополнительный тег в неё. Но теперь с приходом концептов эта проблема, и все аналогичные ей,
решаются красиво. if constexpr это не плохо, но у этого есть некоторые недостатки, что компилятору приходится все же инстанцировать тело, и инстацнировать часть кода, который можно было бы не инстанцировать. Напишем std::advance по
современному. Мы хотим написать два разных advance, один для input iterator, а другой для random access iterator:

#include <iostream>
#include <concepts>
#include <vector>
#include <list>

template <std::input_iterator Iter>
void my_advance(Iter& iter, size_t n) {		// Для простоты рассматриваем только неотрицательные числа
	for(size_t i = 0; i < n; ++i) {
		++iter;
	}
}

template <std::random_access_iterator Iter>
void my_advance(Iter& iter, size_t n) {		
	iter += n;
}

int main() {
	std::vector<int> v(10);
	auto vit = v.begin();
	my_advance(vit, 5);

	std::list<int> l(10);
	auto lit = l.begin();
	my_advance(lit, 5);
}

Хотелось бы что мы могли так писать, однако это будет неоднозначная перегрузка. Хотелось бы чтобы можно было объяснять, что одни концепты были частным случаем других концептов, но согласно тому что мы обсуждали в прошлом пункте, оно как
будто бы так не работает. Но на самом деле это работает, этот код скомпилируется. В прошлый раз была сказана правда, но не вся. Компилятор не умеет делать перегрузку по requiers, если у нас функции отличаются только по requires, то
перегрузки между ними не получится. Но данный случай это другой случай, тут функции отличаются не requires непосредственно, а именно концептом. Если у нас разные requires expressions то это не сработает, но если у нас разные concepts,
то такую перегрузку делать можно. Если бы её нельзя было бы делать, то смысл во многом потерялся бы. Перегрузка по концептам работает, но только если компилятор способен доказать, что любой тип, удовлетворяющий концепту B, удовлетворяет 
и концепту A. А как он это доказывает? А в каком случае мы должны считать, что один концепт является частным случаем другого? Например, если бы мы написали requires ++it, requires --it и ещё requires ++it --it, это один и тот же
requires или нет? Или например у нас будет так: первый requires ++it && requires --it и второй requires ++it, --it, будет ли это одинаковые requires? Содержательно семантически это один и тот же requires, но синтаксически это два разных
requires, как компилятору быть? Согласно тому, что мы знаем, это разные requires. Если у нас синтаксически разные requires, т.е. если у нас requires одно и requires другое, но их можно было бы объединить в один requires и это было бы то
же самое, компилятор такие преобразования не умеет делать. Но допустим если все концепты расскрыть и посмотреть что за requires получатся, то у нас может быть конъюнкция каких то атомарных requirements, и вот если компилятор видит, что 
синтаксически просто у нас в конъюнкции есть все те requirements, которые есть в другой, но в другой их больше, то можно считать что это subsumption, т.е. этот concept частный случай другого concept.

Есть такое понятие: Partial ordering of constraints. Мы хотим научить компилятор понимать что некоторые constraints, являются частными случаями других. Давайте скажем, что constraint P subsume(является частным случаем) constraint Q, если
м.б. доказано, что P влечёт в Q с точностью до идентичности атомарных constraints. При этом типы и выражения не проверяются на эквивалентность: N > 0 не влечёт N >= 0. Смысл самих constraints он игнорирует, он лишь проверяет, что
синтаксически они одинаковые. Более формально лекция 52 14.50. Атомарные constraint subsume(является частным случаем) другой атомарный constraint если идентичны семантически, пробелы роли не играют, но даже true и 1 < 2 это разные
constraints, вычисление выражений не производится. Возможно в будующем это будет работать более умнее, но пока что это работает только на уровне сложной семантики, в таком примитивном виде. Пример:

template <typename T>
concept Decrementable = requires(T t) { --t; };
template <typename T>
concept RevIterator = Decrementable<T> && requires(T t) { *t; };

Здесь Decrementable это requires(T t) { --t; }, а RevIteratir это Decrementable и requires(T t) { *t; }, в этом случае RevIteratir subsume Decrementable.

Если в одном случае вообще нет концепта, а в другом есть, то предпочтительнее штука с концептом:

template<class T>
void g(T);
template<Decrementable T>	// Предпочтительнее
void g(T);

С помощью этого определим концепты для итератеров:

template <typename T>
concept InputIterator = requires(T x) {
	*x;
	++x;
};

template <typename T>
concept ForwardIterator = InputIterator<T> 
&& requires(T x) {
	x++;
};

template <typename T>
concept BidirectionalIterator = ForwardIterator<T> 
&& requires(T x) {
	--x;
	x--;
};

template <typename T>
concept RandomAccsessIterator = BidirectionalIterator<T> 
&& requires(T x, T y) {
	x - y;
	x < y; x > y; x <= y; x >= y;
	x += 1; x -= 1;
	x + 1; x - 1; 1 + x;
};

Если мы определили концепты так, и затем используем их в сигнатуре функций, то subsumption сработает, потому что, когда компилятор развернёт их в атомарные constraints, он поймёт, что это просто длинная конъюнкция. 

template <InputIterator Iter>
void my_advance(Iter& iter, size_t n) {		// Для простоты рассматриваем только неотрицательные числа
	for(size_t i = 0; i < n; ++i) {
		++iter;
	}
	std::cout << 1;
}

template <RandomAccsessIterator Iter>
void my_advance(Iter& iter, size_t n) {		
	iter += n;
	std::cout << 2;
}

int main() {
	std::vector<int> v(10);
	auto vit = v.begin();
	my_advance(vit, 5);

	std::list<int> l(10);
	auto lit = l.begin();
	my_advance(lit, 5);
}

Но если мы по гулпости определим RandomAccsessIterator не так, а решим перечислить заново все требования, 

template <typename T>
concept RandomAccsessIterator = 
requires(T x, T y) {
	++x; --x; x++; x--;
	*x;
	x - y;
	x < y; x > y; x <= y; x >= y;
	x += 1; x -= 1;
	x + 1; x - 1; 1 + x;
};

то не смотря на то что, мы перечислили все теже требования, это уже не будет считаться subsumption, потому что это другой requires и теперь это не сработает. Отсюда мораль: когда мы определяем свои концепты, обязательно нужно 
использовать subsumption, не нужно заново перечислять требования которые уже есть в других концептах. Если у нас концепт выражается через какие-нибудь другие существующие концепты, обязательно нужно назвать эти концепты, а потом добавить
своё, не нужно писать заново requirement, иначе у нас не будет работать subsumption и не будет работать перегрузка по этим концептам. 

Вопрос на понимание: вот реализация концепта std::same_as:

namespace detail {
	template< class T, class U >
	concept SameHelper = std::is_same_v<T, U>;
}

template< class T, class U>
concept same_as = detail::SameHelper<T, U> && detail::SameHelper<U, T>;
 
Вопрос, почему так сложно? Почему нельзя просто написать concept same_as = std::is_same_v<T, U>? Почему нужно заводить какой-то SameHelper? Если бы мы здесь проверили только std::is_same_v<T, U>, то тогда сравнение в другом порядке бы 
не считалось subsumption, поскольку компилятор не проверят смысл когда проверяет эквивалентность концептов. std::is_same_v<T, U> и std::is_same_v<U, T> это формально разные constraints, и поэтому если бы мы потом написали concept,
который полагается как на коммутативность свойства same_as, то мы бы облажались, поскольку у нас не было этой коммутативности и subsumption не работал. И также во всех концептах, которые коммутативны.


######################
Концепты можно делать не только на типах, можно и на числах. Можно определить concept над size_t N. Упражнение: напишите concept is_prime или is_power_of_two.

Рекурсивные концепты делать нельзя. Это значит, что если мы определяем is_power_of_two, мы должны определять его честно через шаблонную рекурсию, мы не можем его определить через is_power_of_two = 1 ? true : is_power_of_two / 2, так
не работает.

Также запрещено накладывать requirements на концепты, мы не можем определяя концепт наложить requirement на само определение концепта. Т.е. когда мы пишем template <typename T> concept какой = чтото от T, мы не можем сказать
template и тут уже навесить concept, нельзя навесить concept на concept.



