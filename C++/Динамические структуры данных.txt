Динамические структуры данных предназначены для того чтобы удобно хранить наши данные.

Допустим у нас есть обычный массив. При работе программы мы поняли что в нём не хватает места. Чтобы решить эту проблему мы бы создали новый массив с нужным кол-вом ячеек и
скопировали бы в него старые данные, затем добавили новые данные и удалили бы старый массив. Если нам очень часто нужно будет выполнять подобную операцию, то будет создаваться
большая нагрузка на системные ресурсы и плохой оптимизации. Таже самая ситуация если нужно будет удалить элемент.

______________________________________________________________________________________
Односвязный список

Проблему выше могут решить односвязные списки. Элементы обычного массива(его ячейки) это фактически области в памяти, которые физически находятся рядом друг с другом:
Массив это непрерывная область в памяти, мы можем применять арифметику указателей. Элемент односвязного списка это не просто ячейка в памяти, это более сложный контейнер.
Элемент односвязного списка это класс, который содержит два поля: одно содержит адрес в памяти, а другое поле содержит информацию (данные). Адресс нужен для того, чтобы знать
где находится следующий элемент списка, т.е. это указатель на следующий элемент. Т.о. Односвязный список это совокупность элементов, в котором каждый элемент знает адрес 
следующего элемента. Адрес последнего элемента равняется NULL. Элементы этого списка в памяти находятся хаотично, это означает что для работы односвязного списка нам не нужна 
непрерывная область памяти (можем хранить элементы где попало).

Массив: |---||---||---||---||---|
	| 0 || 1 || 2 || 3 || 4 |
	|---||---||---||---||---|

Односвязный список:
		
	|------|					    |-->|------|						
	|адресс|--|			      |-->|------|  |	|адресс|--->NULL
	|------|  |			      |   |адресс|--| 	|------|
	|данные|  |             	      |   |------|      |данные|
	|------|  |             |-->|------|  |   |данные|      |------|
	   0	  |-->|------|  |   |адресс|--|   |------|	    4
	   	      |адресс|--|   |------|	      3
      	   	      |------| 	    |данные|
		      |данные|      |------|
		      |------|          2
		      	  1 

Плюсы односвязного списка: При добавлении или удалении элемента списка не нужно перезаписывать всю информацию как с массивом. Мы просто работаем с адресами элементов. 
Манипулируем с элементами списка очень быстро и просто.
Минус: Быстродействие к получению доступа к конкретному элементу списка. Списки всегда медленнее работают с операцией доступа к данным чем массивы. Операции с последними 
элементами списка работают медленее чем операции с первыми элементами списка.


##############################
Реализация односвязного списка


template<typename T>
class List {								//Шаблонный класс список
public:
	List();								//Конструктор и деструктор организованы вне класса
	~List(); 							//Прототип

	void pop_front(); 						//Метод удаления первого элемента списка.
	void push_back(T data); 					//Метод добавления элемента в конец списка
	void clear(); 							//Метод очистки всего списка
	void push_front(T data); 					//Метод добавления элемента в начало списка
	void insert(T value, int index); 				//Метод добавления элемента в место по индексу 
	void removeAt(int index); 					//Метод удаления элемента по индексу
	void pop_back(); 						//Метод удаления последнего элемента
	int GetSize() { return Size; } 					//Метод возвращающий размер списка
	T& operator[](const int index); 				//Перегружаем оператор [] для получения доступа к элементу
private:
	template<typename T>
	class Node {							//Шаблонный вложенный класс элемента
	public:
		Node *pNext; 						//Адрес (указатель) на следующий элемент.
		T data; 						//Поле с данными.

		//Как работает = T(): Если мы передадим сюда класс, то у класса вызовется просто конструктор по умолчанию.
		//Если передадим какой то примитивный тип данных, то будет присвоено значение по умолчанию этого примитивного типа данных.
		Node(T data = T(), Node *pNext = nullptr) 		//Конструктор узла с параметрами по умолчанию. Мусор в данных нам не нужен.
		{
			this->data = data;				//Сохраняем данные
			this->pNext = pNext;				//Сохраняем адрес на след. элемент.
		}
	};

	int Size; 							//Количество элементов списка.
	Node<T> *head; 							//Указатель на первый элемент списка.
};
template<typename T>							//Кажды раз указываем на то что класс шаблонный
List<T>::List() {							//Конструктор списка 
	Size = 0; 							//Значения при создании первого элемента
	head = nullptr; 						//Значения при создании первого элемента
}
template<typename T>
List<T>::~List() {							//Деструктор списка
	clear(); 							//Вызываем метод очистки всего списка.
}

template<typename T>
void List<T>::pop_front() 						//Метод удаления первого элемента списка.
{									//Самая быстрая операция, поскольку операция ведётся с первым элементом списка
	Node<T> *temp = head; 						// Временная переменная которая хранит адрес нашего head
	head = head->pNext; 						//Тепрь head следующий элемент после старого head
	delete temp; 							//Удаляем старый head
	Size--; 							//Кол-во элементов стало меньше на 1
}

template<typename T>
void List<T>::push_back(T data) 					//Метод добавления элемента в конец списка
{
	if (head == nullptr) { 						//Если список пустой (0 элементов), создаём первый элемент
		head = new Node<T>(data); 				//Создаём первый элемент
	}
	else {								//Если список не пустой
		Node<T> *current = this->head; 				//Создаём временную переменую и присваеваем туда значение первого элемента
		while (current->pNext != nullptr) { 			//Ищем последний элемент списка.
			current = current->pNext; 		//Пока последний элемент не найден, временная переменная current присваивается указатель на следующий элемент.
		}
		current->pNext = new Node<T>(data); 		//Создаём новый элемент и присваиваем старому последнему элементу адрес на новый добавленный последний элемент.
	}
	Size++; 							//Увеличиваем переменную Size каждый раз когда добовляем новый элемент.
}

template<typename T>
void List<T>::clear() 							//Метод очистки всего списка
{
	while (Size) { 							//Пока size != 0
		pop_front(); 						//Вызываем метод удаления первого элемента.
	}
}

template<typename T>
void List<T>::push_front(T data) 					//Метод добавления элемента в начало списка
{
	head = new Node<T>(data, head); 		//С помощью new создаём новый элемент и присваеваем его в head. Старый head становится вторым элементом в списке.
	Size++; 							//Элементов стало на 1 больше
}

template<typename T>
void List<T>::insert(T data, int index) 				//Метод добавления элемента в место по индексу
{
	if (index == 0)	//Если индекс == 0 
		push_front(data); 					//Вызываем метод добавления элемента в начало списка.
	else {								//Иначе
		Node<T> *previous = this->head; 			//Временный указатель типа Node, которому присваиваем значение нашего head.
		for (int i = 0; i < index - 1; i++) //Находим элемент с индексом, предшедствующему индексу в параметрах (index), на место которого мы хотим поместить объект.
		{
			previous = previous->pNext; 			//Указатель на следующий узел нашего списка.
		}
		Node<T> *newNode = new Node<T>(data, previous->pNext); 	//Создаём новый объект, передаём ему данные и у предыдущего элемента берём поле pNext
		previous->pNext = newNode; 				//У предыдущего элемента добавляем в поле pNext добавляем адресс нашего текущего объекта.
		Size++; 						//Элементов стало на 1 больше
	}
}

template<typename T>
void List<T>::removeAt(int index) 					//Метод удаления элемента по индексу
{
	if (index = 0) 							//Если индекс == 0 
		pop_front(); 						//Вызываем метод удаления первого элемента.
	else {     							//Иначе
		Node<T> *previous = this->head; 			//Временный указатель типа Node, которому присваиваем значение нашего head.
		for (int i = 0; i < index - 1; i++) 			//Находим элемент с индексом, предшедствующему индексу в параметрах (index).
		{
			previous = previous->pNext; 			//Указатель на следующий узел нашего списка.
		}
		Node<T> *toDelete = previous->pNext; 			//Указатель на элемент, который нужно удалить.
		previous->pNext = toDelete->pNext; //Элементу, стоящему перед тем элементом, который нужно удалить, записываем адрес элемента, который находится в элементе который нужно удалить, чтобы не потерять связь.
		delete toDelete; 					//Удаляем нужный элемент
		Size--; 						//Элементов стало на 1 меньше
	}
}

template<typename T>
void List<T>::pop_back() 						//Метод удаления последнего элемента
{
	removeAt(Size - 1); 						//Вызываем метод удаления по индексу с параметром равному последнему элементу.
}

template<typename T>
T & List<T>::operator[](const int index) 				//Метод нахождения элемента по индексу и возвращения значения
{
	int counter = 0; 						//Счётчик по который считает в каком конкретном элементе мы сейчас находимся.
	Node<T> *current = this->head; 					//Создаём временную переменую и присваеваем туда значение первого элемента
	while (current != nullptr) { 					//Ищем элемент пока не дойдём до конца
		if (counter == index) 					//Если счётчик равняется нужному индексу
			return current->data; 				//Возвращаем данные из поля data.
		current = current->pNext; 				//Иначе в текущей переменной присваиваем адрес следующего элемента. 
		counter++; 						//Перешли на следующий элемент, поэтому присваиваем + 1 к счётчику.
	}
}

int main()
{
	setlocale(LC_ALL, "Russian");
	List<int> lst;							//Создаём список (объект класса List)
	lst.push_back(5); 						//Добавляем в конец списка новый элемент
	lst.push_back(10);
	lst.push_back(22);

	cout << lst.GetSize() << endl; 					//Вывод кол-ва элементов в списке
	cout << lst[2] << endl; 					//Получаем элемент по индексу 2.
	lst.pop_front(); 						//Удаляем первый элемент
	lst.clear(); 							//Очищаем список полностью.

	lst.push_front(3); 						//Добавляем элемент в начало списка
	lst.push_front(2); 						//Добавляем элемент в начало списка

	lst.insert(4, 1); 						//Добавляем в список элемент в индекс 1 новый узел
	lst.removeAt(1); 						//Удаляем элемент по индексу 1

	lst.pop_back(); 						//Удаляем последний элемент


	return 0;
}


______________________________________________________________________________________
Двусвязный список

Отличие от односвязного списка в том что узел имеет другую структуру. Первое поле указывает на следующий элемент списка, второе поле указывает на предыдущий элемент списка, 
третье поле для хранение информации. Односвязный и двусвязный список применяются в разных ситуациях, между ними нет лучшего. Список связан в обе стороны, это делает более 
быстрыми операции над последними элементами. Теперь находить элемент мы можем не только с начала, но и с конца списка. Самые медленные операции теперь являются операции 
над серединой списка.


         head					
		|-----|				     tail
		|pNext|----|		|--->|-----|
		|-----|    |		|    |pNext|---> NULL	
       NULL <---|pPrev|<-| |		| |--|-----|
		|-----|  | |		| |  |pPrev|
		| DATA|  | |   |-----|  | |  |-----|
		|-----|	 | |-->|pNext|--| |  | DATA|
		   0	 |     |-----|    |  |-----|
			 |-----|pPrev|<---|	2
 			       |-----|
			       | DATA|
			       |-----|
				  1


Так же как и в односвязносм списке в последнем элементе списка поле pNext равняется NULL. В двусвязном списке в первом элементе списка поле pPrev тоже равняется NULL.

Операции добавления или удаления элементов работают также как и в односвязном списке, только теперь нужно учитывать новое поле pPrev, и не забывать связывать и его.


##############################
Моя собственная реализация двусвязного списка, основанная на односвязном списке: Тут ещё можно добавить оптимизацию поиска элемента с начала или конца (сейчас только с начала).

template<typename T>
class List {	//Шаблонный класс список
public:
	List();	//Конструктор и деструктор организованы вне класса
	~List(); //Прототип

	void pop_front(); //Метод удаления первого элемента списка.
	void push_back(T data); //Метод добавления элемента в конец списка
	void clear(); //Метод очистки всего списка
	void push_front(T data); //Метод добавления элемента в начало списка
	void insert(T value, int index); //Метод добавления элемента в место по индексу 
	void removeAt(int index); //Метод удаления элемента по индексу
	void pop_back(); //Метод удаления последнего элемента
	int GetSize() { return Size; } //Метод возвращающий размер списка
	T& operator[](const int index); //Перегружаем оператор [] для получения доступа к элементу
private:
	template<typename T>
	class Node {	//Шаблонный вложенный класс элемента
	public:
		Node *pNext; //Адрес (указатель) на следующий элемент.
		Node *pPrev; //Адрес (указатель) на предыдущий элемент списка.
		T data; //Поле с данными.
		//Как работает = T(): Если мы передадим сюда класс, то у класса вызовется просто конструктор по умолчанию.
		//Если передадим какой то примитивный тип данных, то будет присвоено значение по умолчанию этого примитивного типа данных.
		Node(T data = T(), Node *pNext = nullptr, Node *pPrev = nullptr) //Конструктор узла с параметрами по умолчанию. Мусор в данных нам не нужен.
		{
			this->data = data;		//Сохраняем данные
			this->pNext = pNext;	//Сохраняем адрес на след. элемент.
			this->pPrev = pPrev;	//Сохраняем адрес на пред. элемент.
		}
	};

	int Size; //Количество элементов списка.
	Node<T> *head; //Указатель на первый элемент списка.
	Node<T> *tail; //Указатель на последний элемент списка.
};
template<typename T>//Кажды раз указываем на то что класс шаблонный
List<T>::List() {	//Конструктор списка 
	Size = 0; //Значения при создании первого элемента
	head = nullptr; //Значения при создании первого элемента
	tail = nullptr; //Значения при создании первого элемента
}
template<typename T>
List<T>::~List() {	//Деструктор списка
	clear(); //Вызываем метод очистки всего списка.
}

template<typename T>
void List<T>::pop_front() //Метод удаления первого элемента списка.
{							//Самая быстрая операция, поскольку операция ведётся с первым элементом списка
	Node<T> *temp = head; // Временная переменная которая хранит адрес нашего head
	head = head->pNext; //Тепрь head следующий элемент после старого head
	delete temp; //Удаляем старый head
	Size--; //Кол-во элементов стало меньше на 1
	//Новое добавление
	if (Size == 0) //Если все элементы закончились
		tail = nullptr; //Очищаем указатель на хвост
	else	//Если ещё есть элементы.
		head->pPrev = nullptr; //Очищаем адрес предыдущего элемента
}

template<typename T>
void List<T>::push_back(T data) //Метод добавления элемента в конец списка
{
	if (head == nullptr) { //Если список пустой (0 элементов), создаём первый элемент
		head = new Node<T>(data); //Создаём первый элемент
		tail = head; //(Возможно нужны умные указатели) Указатель хвоста и головы это один и тот же элемент.
	}
	else {	//Если список не пустой	
		//Новая реализация
		Node<T> *newNode = new Node<T>(data); //Создаём новый элемент списка
		tail->pNext = newNode; //Последнему элементу списка присваеваем адрес нового последнего элемента.
		newNode->pPrev = tail; //Новому последнему элементу присваеваем адрес предыдущего элемента.
		tail = newNode; //Новый элемент теперь становиться хвостом.
	}
	Size++; //Увеличиваем переменную Size каждый раз когда добовляем новый элемент.
}

template<typename T>
void List<T>::clear() //Метод очистки всего списка
{
	while (Size) { //Пока size != 0
		pop_front(); //Вызываем метод удаления первого элемента.
	}
}

template<typename T>
void List<T>::push_front(T data) //Метод добавления элемента в начало списка
{
	head = new Node<T>(data, head); //С помощью new создаём новый элемент и присваеваем его в head. Старый head становится вторым элементом в списке.
	if (Size == 0) //Если элементов пока нет
		tail = head; //то хвост и голова это один и тот же элемент.
	else //Если элементы уже есть 
		head->pNext->pPrev = head; //То в адрес старого head прописываем новый head
	Size++; //Элементов стало на 1 больше
}

template<typename T>
void List<T>::insert(T data, int index) //Метод добавления элемента в место по индексу
{
	if (index == 0 || Size == 0)	//Если индекс == 0 или если ещё нет ни одного элемента.
		push_front(data); //Вызываем метод добавления элемента в начало списка.
	else if (index >= Size) //Если пытаемся добавить на место последнего элемента
		push_back(data); //Вызываем метод добавления элемента в конец списка.
	else {				//Иначе
		Node<T> *previous = this->head; //Временный указатель типа Node, которому присваиваем значение нашего head.
		for (int i = 0; i < index - 1; i++) //Находим элемент с индексом, предшедствующему индексу в параметрах (index), на место которого мы хотим поместить объект.
		{
			previous = previous->pNext; //Указатель на следующий узел нашего списка.
		}
		Node<T> *newNode = new Node<T>(data, previous->pNext, previous); //Создаём новый объект, передаём ему данные и поля pNext pPrev.
		previous->pNext = newNode; //У предыдущего элемента добавляем в поле pNext добавляем адресс нашего текущего объекта.
		//if(newNode->pNext != nullptr) //Если элемент, который нужно добавить не последний.
		newNode->pNext->pPrev = newNode; //У следущего элемента определяем поле pPrev.
		Size++; //Элементов стало на 1 больше
	}
}

template<typename T>
void List<T>::removeAt(int index) //Метод удаления элемента по индексу
{
	if (index == 0) //Если индекс == 0 
		pop_front(); //Вызываем метод удаления первого элемента.
	else if (index >= Size - 1) //Если пытаемся удалить последний элемент.
		pop_back(); //Вызываем метод удаления последнего элемента.
	else {     //Иначе
		Node<T> *previous = this->head; //Временный указатель типа Node, которому присваиваем значение нашего head.
		int i = 0;
		for (; i < index - 1; i++) //Находим элемент с индексом, предшедствующему индексу в параметрах (index).
		{
			previous = previous->pNext; //Указатель на следующий узел нашего списка.
		}
		Node<T> *toDelete = previous->pNext; //Указатель на элемент, который нужно удалить.
		previous->pNext = toDelete->pNext; //Элементу, стоящему перед тем элементом, который нужно удалить, записываем адрес элемента, который находится в элементе который нужно удалить, чтобы не потерять связь.
		//if (toDelete->pNext != nullptr) //Если элемент, который нужно удалить не последний.
		toDelete->pNext->pPrev = previous; //Связываем следующий элемент с текущим.
		delete toDelete; //Удаляем нужный элемент
		Size--; //Элементов стало на 1 меньше
	}
}

template<typename T>
void List<T>::pop_back() //Метод удаления последнего элемента
{
	//Старая реализация
	//removeAt(Size - 1); //Вызываем метод удаления по индексу с параметром равному последнему элементу.
	
	//Новая реализация
	Node<T> *temp = tail; // Временная переменная которая хранит адрес нашего tail
	tail = tail->pPrev; //Тепрь tail предыдущий элемент перед старым tail
	delete temp; //Удаляем старый head
	Size--; //Кол-во элементов стало меньше на 1

	if (Size == 0) //Если все элементы закончились
		head = nullptr; //Очищаем указатель на голову
	else	//Если ещё есть элементы.
		tail->pNext = nullptr; //Очищаем адрес следущего элемента
}

template<typename T>
T & List<T>::operator[](const int index) //Метод нахождения элемента по индексу и возвращения значения
{
	int counter = 0; //Счётчик по который считает в каком конкретном элементе мы сейчас находимся.
	Node<T> *current = this->head; //Создаём временную переменую и присваеваем туда значение первого элемента
	while (current != nullptr) { //Ищем элемент пока не дойдём до конца
		if (counter == index) //Если счётчик равняется нужному индексу
			return current->data; //Возвращаем данные из поля data.
		current = current->pNext; //Иначе в текущей переменной присваиваем адрес следующего элемента. 
		counter++; //Перешли на следующий элемент, поэтому присваиваем + 1 к счётчику.
	}
}

int main()
{
	setlocale(LC_ALL, "Russian");
	List<int> lst;	//Создаём список (объект класса List)
	lst.push_back(5); //Добавляем в конец списка новый элемент
	lst.push_back(10);
	lst.push_back(22);

	cout << lst.GetSize() << endl; //Вывод кол-ва элементов в списке
	cout << lst[2] << endl; //Получаем элемент по индексу 2.
	lst.pop_front(); //Удаляем первый элемент
	lst.clear(); //Очищаем список полностью.

	lst.push_front(3); //Добавляем элемент в начало списка
	lst.push_front(2); //Добавляем элемент в начало списка

	lst.insert(4, 1); //Добавляем в список элемент в индекс 1 новый узел
	lst.removeAt(1); //Удаляем элемент по индексу 1

	lst.pop_back(); //Удаляем последний элемент


	return 0;
}



______________________________________________________________________________________
Бинарное дерево

Бинарное дерево - это упорядоченная структура данных. Упорядоченная - всегда отсортированная. Применяется в структуре map библиотеке STL. Является рекурсивной структурой.


							     Корень дерева
						|-----------|
						|    DATA   |
						|-----------|
				 |--------------|LEFT||RIGHT|--------------|
				 |	        |-----------| 	           |
				 |				       	   |
    				 V				       	   V
			|-----------|			                |-----------|
			|    DATA   |			                |    DATA   |
			|-----------|			                |-----------|
	     |----------|LEFT||RIGHT|----------|	     |----------|LEFT||RIGHT|----------|
	     | 		|-----------|	       |	     |          |-----------|	       |
	     |				       |	     |				       |
Листья	     V				       V	     V				       V
       |-----------|			|-----------|  	|-----------|			   |-----------|
       |    DATA   |			|    DATA   |   |    DATA   |			   |    DATA   |
       |-----------|			|-----------|   |-----------|			   |-----------|
   |---|LEFT||RIGHT|---|	    |---|LEFT||RIGHT|   |LEFT||RIGHT|---|	       |---|LEFT||RIGHT|---|
   |   |-----------|   |	    |	|-----------|   |-----------|	|	       |   |-----------|   |
   |		       |	    |		  |	  |		|	       |		   |
   V		       V	    V		  V	  V		V	       V		   V
 NULL		     NULL	   NULL		NULL  	 NULL	       NULL	     NULL		  NULL
						  	  
							 
Листьями считаются узлы, у который и LEFT и RIGHT == NULL.

Пример заполнения бинарного дерева: Допустим корень у нас будет 50. Числа меньшие текущего узла добавляются в левого потомка, а большие в правого. Добавляем числа 45 и 55.
				
				|---50---|
				|	 |
				V	 V
			       45	 55

Допустим теперь добавим число 49. Число 49 меньше 50 значит определяем его в левого потомка. Смотрим дальше: Левый потомок число 45. 49 больше числа 45, значит определяем его
в правого потомка:

				|------50------|
				|	       |
				V	       V
			       45---|	       55
				    |
				    V
				   49

Добавим число 1:

				|------50------|
				|	       |
				V	       V
			    |---45---|	       55
			    |	     |
			    V        V
		            1       49

Получается, что в левой части дерева относительно числа 50 находятся все числа, которые меньше 50, а в правой части, все числа которые больше 50, и так с каждым узлом.

Недостатком двусвязного списка было то, что операции выполняемые в его середине были самые медленные. На бинарное дерево это не распрастроняется. Например нам нужно найти 
число 1. 1 меньше 50, и по этому оно находится в левой части дерева. И какой бы большой не была правая часть, поиск там нам делать не нужно, потому что мы знаем, что там нет
этого числа.

Бинарный поиск можно применять только будучи уверенным, что массив отсортирован. Это его недостаток (особенность).

Добавление элементов в двусявзный список в начало или конец будет быстрее, чем добавление элемента в дерево. Но доступ (поиск) к конкретному элементу у дерева в разы быстрее.



______________________________________________________________________________________
Стек как структура данных

Стек это динамическая структура данных, с особой организацией движения данных: Last in, first out (Последний зашёл, первый вышел). Тот элемент, который был добавлен в стек 
самым последним, мы должны будем извлечь самым первым. Стек гарантирует доступ к данным в обратном порядке их добавления в стек. Со стеком мы всегда взаимодействуем (оперируем)
через его вершину. Вершиной стека, называют самый последний объект, добавленный в стек. Мы его либо добавляем либо убираем.
	
 	   ^ |
	   | |
	   | V
	|  	|
	|	|  Если кладёшь предмет в низ бутылки, и сверху накрываешь ещё предметом, то вытащить ты сможешь сначала только верхний предмет, затем нижний.
Вершина	| <###>	|  Аналогия с патронами из магазина пистолета.
	|	|
	| <###>	|
	|	|
	| <###>	|
	| 	|
	| <###>	|
    Дно	|=======|   С этой стороный стека взаимодействие невозможно.


Поскольку мы всегда оперируем с последним элементом (вершиной стека), мы не можем перебирать все его элементы (итерировать). Поэтому для всей этой структуры вообще не важна
скорость с которой мы будем перебирать её элементы, потому что мы их в принципе не перебираем. Для нас критически важно возможность добавления или удаления элемента.

Для организации стека, мы можем просто урезать функционал односвязного списка, оставив ему только операции с его первым элементом.



______________________________________________________________________________________
Очередь как структура данных

Очередь это обычная очередь. First input - first output (Тот кто первый в очередь встал, тот первый из неё вышел).

		
		-------------------------
	   <---  #1#  #2#  #3#  #4#  #5#  <----
		-------------------------
	Начало очереди			Конец очереди (Самый последний элемент)
    (Самый первый элемент)


Взаимодействовать с очередью мы можем только с её самым первым и самым последним элементом. Мы не можем перебрать все элементы очереди. Так же мы не можем вставить или убрать
элемент из середины очереди. Добавляется элемент всегда в конец очереди, добавить элемент в начало очереди(впереди всей очереди) мы не можем. Очередь гарантирует нам, что 
доступ к элементам мы будем получать в том же порядке, в котором они поступали в очередь. Извлечь элемент мы можем только из начала очереди. Просмотор возможен и первого и
последнего элемента очереди. Итерация по элементам не возможна, поэтому нам важно только лишь операция добавления и извлечения из очереди. Для того чтобы реализовать очередь
может подойти двусвязный список. В нём очень быстро происходят операции добавления в начало и в конец списка.



______________________________________________________________________________________
Очередь с приоритетом и Кольцевая очередь.

Кольцевая очередь - принцип работы точно такой же самый как и у обычной простой очереди, но с небольшим отличием. В обычной очереди из элемента, который находится в начале 
очереди, мы извлекаем данные и затем этот элемент мы исключаем из очереди. В случае кольцевой очереди мы этот элемент не исключаем, мы получаем данные из этого элемента, а
затем, перемещаем его в к онец очереди. Далее получаем данные из следующего элемента и тоже помещаем его в конец очереди, и так по кругу (Очередь имеет зациклинный вид).

	   -->  -->  -->  -->  -->  -->  -->  -->|
	  ^					 |
	  |	-------------------------	 |
	  | <---  #1#  #2#  #3#  #4#  #5#  <---- V
		-------------------------
	 Начало очереди		   Конец очеред



Очередь с приоритетом - порядок извлечения элементов из очереди зависит от преоритета обработки такого элемента. Критерии приоритетности могут быть самые различные. Есть 
несколько вариантов организации очереди с приоритетом. Один из этих вариантов гласит, что элементы в очереди должны быть упорядоченны по приоритетам в момент поступления
элемента в очередь. Типо когда мы добавляем элемент в очередь, он сразу становится в нужном порядке, в соответствие со своим приоритетом. Таким вариантом называется очередь
с приоритетным включением. Существует ещё один вариант: очередь с приоритетным исключением: при таком варианте организации очереди элементы добавляются в очередь просто в 
порядке их поступления и никак там не сортируются, но в момент извлечения мы выбираем элемент, который у нас наиболее приоритетный для обработки. Т.е. разница в том где
выполняется обработка приоритетности.
  
Очередь с приоритетным включением: Допустим приоритет по возрастанию. Нам нужно добавить в очередь элемент с приоритетом 1.


		-------------------------
	   <---  1  1  2  3               <----  1
		-------------------------

Добавляем элемент с приоритетом 1: ## означают куда мы добавили элемент.

		-------------------------
	   <---  1  1  #1#  2  3          <----
		-------------------------

Для каждого приоритета есть своя очередь. В нашем случае при добавлении элемента 1, в очереди уже есть элементы с таким приоритетом, поэтому мы добавляем новый элемент в конец
очереди с приоритетом 1. (Мы не можем его поместить вот так: 1 #1# 1 2 3 или вот так #1# 1 1 2 3).

Добавим в очередь элемент с приоритетом 2: ## означают куда мы добавили элемент.

 		-------------------------
	   <---  1  1  1  2  #2#  3       <----
		-------------------------

Далее наши элементы просто извлекаются из очереди в уже созданном порядке.

######################
Очередь с приоритетным исключением: Элементы добавляются в очередь в порядке их поступления, допустим вот так:


		-------------------------
	   <---  1  3  2  1  2            <----  
		-------------------------

Извлекаем элементы из очереди согласно приоритету: Начинаем просмотр элементов с начала очереди и ищем самый первый приоритетный элемент, который из них всех имеет наивысший
приоритет. В нашем случае этот элемент находится на первом месте, нам повезло:


		-------------------------					      -------------------------
	   <---  #1#  3  2  1  2          <----  Извлекаем элемент из очереди:   <---  3  2  1  2		 <----
		-------------------------					      -------------------------

Далее проводим ту же самую процедуру:

		-------------------------					      -------------------------
	    <---  3  2  #1#  2		  <----  Извлекаем элемент из очереди:	 <---  3  2  2		         <----
		-------------------------					      -------------------------
И опять:

		-------------------------					      -------------------------
	    <---  3  #2#  2		  <----  Извлекаем элемент из очереди:	 <---  3  2		         <----
		-------------------------					      -------------------------

		-------------------------					      -------------------------
	    <---  3  #2#		  <----  Извлекаем элемент из очереди:	 <---  3  		         <----
		-------------------------					      -------------------------

		-------------------------					      -------------------------
	    <---  #3#  		  	  <----  Извлекаем элемент из очереди:	 <---    		         <----
		-------------------------					      -------------------------




______________________________________________________________________________________
Дек | Deque

Дек - Double ended queue - это двусторонняя очередь.

В обычной очереди, элемент который попал в очередь первым, и будет первым обработан. В двусторонней очереди это правило работает в две стороны. Мы можем как добавить элемент
с одной стороны очереди и с другой, так и извелчь элемент и с одной стороны и с другой. В такой очереди нет начала и конца, есть левая сторона дека и правая сторона дека.
Добавляются и извлекаются элементы в порядке очереди. У такой структуры есть подвиды: дек с ограниченным входом и дек с ограниченным выходом. Это такие ситуации, когда у 
одного из концов дека ограничен функционал возможности добавления или извлечения элементов. В библиотеке STL работая с деком мы можем итерироваться по элементам, мы имеем 
доступ ко всем элементам.

Дек в с++ в STL имеет такую структуру: По сути это совокупность нескольких массивов, которые являются некими чанками, и которые между собой связаны по принципу двусвязного
списка. Размер мелких массивов (подструктур) ограничен. Когда в таком маленьком массиве заканчивается место, вместо того чтобы перевыделять область памяти под новый массив и 
туда копировать старые данные, просто создаётся новый массив, и эти два массива связываются между собой ссылками на следующий массив и на предыдущий массив (как в двусвязном
списке, только вместо конкретных элементов будут массивы), и начинает заполнятся новый массив.


	|---||---||---||---||---|  --->  |---||---||---||---||---|   
	|   ||   ||   ||   ||   |  <---	 |   ||   ||   ||   ||   |  
	|---||---||---||---||---|	 |---||---||---||---||---|
 
							      ^|			 |----> |---||---||---||---||---|
							      ||			 ||---- |   ||   ||   ||   ||   |
							      |V			 ||	|---||---||---||---||---|
											 ||
							    |---||---||---||---||---| ---|| 
							    |   ||   ||   ||   ||   | <---|
							    |---||---||---||---||---|

	
Из за того что в структуре присутствуют обычные массивы, получаем прирост скорости в итерации (при поиске элемента). Задержки в скорости будут только при переходе по ссылками
от одного массива к другому. Так же плюс в добавлении и удалении элементов. Но получаем минус в обслуживании этой структуры данных (нужна большая производительность).



______________________________________________________________________________________
Теория: Худший случай поиска в бинарном дереве

Худший случай поиска в бинарном дереве возникает, когда дерево вырождается в свою одностороннюю форму, то есть принимает форму линейного списка (цепочки). Это происходит, когда 
элементы вставляются в дерево в уже отсортированном порядке, или когда каждый следующий элемент меньше (или больше) предыдущего.

Допустим, у нас есть последовательность чисел, которые мы хотим вставить в бинарное дерево поиска: 1, 2, 3, 4, 5. Если вставлять их в указанном порядке, то каждый новый элемент 
будет правым потомком предыдущего, что приведет к следующей структуре дерева:

```
1
 \
  2
   \
    3
     \
      4
       \
        5
```
В этом случае дерево вырождается в своего рода "правую ветку", и для поиска любого значения мы потенциально должны пройти по всем узлам. Например, чтобы найти число 5, нам 
необходимо сделать 5 сравнений.

Почему это плохо

Поиск в сбалансированном бинарном дереве работает за время \(O(\log n)\), где \(n\) — количество узлов в дереве. Это потому что с каждым шагом вглубь дерева количество узлов, 
которые еще предстоит рассмотреть, уменьшается вдвое. Однако, в вырожденном случае, как показано выше, поиск работает за \(O(n)\), так как каждый узел в дереве требует отдельного 
шага проверки.

Как избежать

Для предотвращения вырождения бинарных деревьев используют так называемые сбалансированные деревья поиска, такие как красно-черные деревья или AVL-деревья. Эти структуры данных 
автоматически перебалансируются при каждой операции вставки или удаления, что обеспечивает поддержание высоты дерева порядка \(O(\log n)\) и гарантирует, что операции поиска, 
вставки и удаления будут выполняться за логарифмическое время.

Худший случай поиска в бинарном дереве наступает, когда дерево становится похожим на линейный список, требуя \(O(n)\) времени для поиска элемента. Это случается при неудачном 
порядке вставки элементов. Использование сбалансированных деревьев помогает избежать такой проблемы.



______________________________________________________________________________________
Теория: Всегда ли сложность в деревьях равно log(n)? (Логарифм это дерево)

Сложность поиска в бинарных деревьях зависит от их структуры и баланса. Логарифмическая сложность поиска, то есть \(O(\log n)\), где \(n\) — количество узлов в дереве, достигается 
в идеально сбалансированных бинарных деревьях. Однако это не всегда так, и различные типы бинарных деревьев могут иметь разные характеристики поиска.

Идеально сбалансированные бинарные деревья
Каждый уровень дерева, кроме возможно последнего, полностью заполнен. Это означает, что количество узлов удваивается с каждым новым уровнем. В таком дереве максимальная глубина 
(или высота) \(h\) равна \(\log_2(n+1)\). Поиск, вставка или удаление элемента в таком дереве имеет временную сложность \(O(\log n)\).

Несбалансированные бинарные деревья
Сложность поиска может деградировать до \(O(n)\) в худшем случае. Это может произойти, например, если элементы добавляются в дерево в уже отсортированном порядке, при котором 
каждый новый узел становится правым ребёнком предыдущего. Такое дерево принимает форму "вытянутого списка", и поиск в нём становится по сути линейным поиском.

Сбалансированные бинарные деревья
Для обеспечения логарифмической сложности поиска независимо от порядка вставки элементов разработаны специальные структуры данных, такие как AVL-деревья и красно-чёрные деревья. 
Эти структуры являются самобалансирующимися, то есть они автоматически поддерживают свою структуру таким образом, чтобы глубина дерева оставалась логарифмической относительно 
количества элементов, что обеспечивает поддержание сложности операций на уровне \(O(\log n)\).

Логарифмическая сложность поиска в бинарных деревьях достигается только в сбалансированных деревьях. В несбалансированных деревьях сложность поиска может увеличиться до линейной. 
Поэтому важно выбирать правильный тип дерева или использовать самобалансирующиеся деревья для задач, где предполагается частое добавление и удаление элементов.



______________________________________________________________________________________
Хеш-таблица

Хеш-таблица — это структура данных, которая предоставляет очень быстрые операции вставки, поиска и удаления элементов. Она использует функцию, называемую хеш-функцией, для 
вычисления индекса в массиве (также известном как хеш-массив или бакеты), где фактические значения (или указатели на значения) будут храниться.

Компоненты:

1. Хеш-функция: Преобразует ключи в индексы массива. Хеш-функция должна быть достаточно быстрой и обеспечивать равномерное распределение ключей по массиву, чтобы минимизировать 
количество коллизий.
2. Массив хеш-бакетов: Массив, где каждая ячейка может содержать один или несколько элементов (зависит от метода разрешения коллизий).
3. Метод разрешения коллизий: Коллизия происходит, когда два или более ключей имеют одинаковый хеш. Чтобы решить эту проблему, используются различные методы:

Открытая адресация: Если произошла коллизия, алгоритм ищет следующий свободный слот в таблице. Примеры методов открытой адресации включают линейное исследование, квадратичное 
исследование и двойное хеширование.
Цепочки (связные списки): Каждый элемент массива представляет собой указатель на связный список (или другую структуру данных), содержащий все элементы, соответствующие данному хешу.

Процесс работы:

1. Вставка: Ключ преобразуется в хеш-функцией в индекс. Элемент добавляется в бакет, соответствующий этому индексу. Если происходит коллизия, элемент добавляется согласно выбранному 
методу разрешения коллизий.
2. Поиск: Ключ снова хешируется для получения индекса. Далее происходит поиск элемента в соответствующем бакете. Эффективность поиска зависит от количества коллизий и метода их 
разрешения.
3. Удаление: Аналогично поиску, элемент находится с использованием хеша и затем удаляется из соответствующего бакета или структуры данных.

Рассмотрим простую хеш-таблицу, использующую связные списки для разрешения коллизий:

#include <iostream>
#include <list>
#include <vector>

class HashTable {
private:
    std::vector<std::list<int>> table;
    int numBuckets;

    int hashFunction(int key) {
        return key % numBuckets;
    }

public:
    HashTable(int size) : numBuckets(size), table(size) {}

    void insertItem(int key) {
        int index = hashFunction(key);
        table[index].push_back(key);
    }

    bool searchItem(int key) {
        int index = hashFunction(key);
        for (auto &item : table[index]) {
            if (item == key)
                return true;
        }
        return false;
    }

    void removeItem(int key) {
        int index = hashFunction(key);
        table[index].remove(key);
    }
};

int main() {
    HashTable ht(10);
    ht.insertItem(15);
    ht.insertItem(25);
    std::cout << "Search for 15: " << ht.searchItem(15) << std::endl;
    ht.removeItem(15);
    std::cout << "Search for 15 after removal: " << ht.searchItem(15) << std::endl;
    return 0;
}

Хеш-таблицы являются одной из наиболее эффективных структур данных для реализации словарей и множеств благодаря быстрым операциям вставки, поиска и удаления. Однако их эффективность
сильно зависит от качества хеш-функции и выбранного метода разрешения коллизий.



















