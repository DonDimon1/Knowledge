Библиотека стандартных шаблонов  STL.
Это набор стандартных типичных решений для часто используемых задач.

______________________________________________________________________________________
string

const string& s = "aaaaaaaaaaaaaaaaaaaa";

на стеке создаётся строка которая должна хранить на стеке "aaaaaaaaaaaaaaaaaaaa". Но для оптимизации она на стеке хранит два числа и указатель: число обозначающее размер, 
число обозначающее capacity, и указатель, который указывает на динамическую память, в которой и будут храниться символы "aaaaaaaaaaaaaaaaaaaa". При создании строки она 
вызывает оператор new, для хранения строки с символами в динамической памяти. Т.е. в реальности на стеке лежать всего 24 байта с двумя числами и указателем, а всё остальное 
лежит в динамической памяти.


______________________________________________________________________________________
vector

Вектор это шаблонный динамический массив(коллекция), но только очень прокаченный. При работе с вектором мы должны явно указать с каким типом данных он работает. Подключаем 
с помощью дерективы #include <vector>. 

vector<int> myVector; 			//Инициализация вектора
vector<int> myVector = { 0, 1, 2 }; 	//Вариант инициализации.
vector<int> myVector(20); 		//Инициализация вектора с 20 элементами и все = 0.
vector<int> myVector(20, 1); 		//Инициализация вектора с 20 элементами и все = 1.

myVector.push_back(0); 	//Добавить элемент в конец вектора. Сложность: Амортизированная константа

myVector.size(); 	//Кол-во элементов в векторе

myVector[0] = 1; 	//Обращение к элементу 0. Используя [] мы можем получить доступ за пределы вектора (не проверяем границы вектора).

myVector.at(0) = 0; 	//Обращение к элементу 0. Используя .at проверяет выход за границы вектора. Он никогда не даст нам возможности получить не свои данные.
//Метод at медленнее чем [].

myVector.clear(); 	//Очищаем вектор от всех элементов.

myVector.pop_back(); 	//Удаление последнего элемента вектора. Сложность: константа
	

myVector.capacity(); //Возвращает вместимость (ёмкость) вектора, т.е. сколько элементов в нём может поместиться.
	Если мы хотим добавить новый элемент в массив, массиву каждый раз приходится выделять память для нового массива, переписывать туда старые элементы и добавлять новые 
	элементы (как и в случае с обычным массивом). Это очень накладная операция, и если бы вектор каждый раз делал так, он был бы медленным. Поэтому в векторе при 
	добавлении элемента выделяется память с запасом (т.е. на несколько элементов больше, чем нужно). Количество памяти запаса зависит от определённого коэффициента и от 
	кол-ва уже имеющихся элементов в векторе. Далее перемещаются старые элементы на свои места, добавляется новый элемент. Метод size показывает нам только кол-во имеющихся 
	элементов вектора, а метод capacity кол-во всех выделенных в памяти ячеек (и пустых запасных и заполненных). Т.е. пока у нас есть запас операции выделения новой памяти 
	и копирования старых данных производиться не будут, мы просто будем добавлять новые элементы в зарезервированные ячейки. Это хорошо сказывается на его 
	производительности.

Мы можем самостоятельно управлять этим процессом, указав сколько элементов в запасе (capacity) должно находиться в векторе:

myVector.reserve(10); 		//Указываем ёмкость вектора.
myVector.shrink_to_fit(); 	//Освобождение зарезервированной памяти (например если её слишком много). Создаётся новый массив с меньшим кол-во ячеек и переписали все элементы.

myVector.empty(); 		//Проверка пустой ли вектор. Возвращает true если вектор пустой и false если нет.

myVector.resize(20); 		//Установить кол-во элементов в векторе.

myVector.begin(); 		//Интератор указывающий на начало вектора.
myVector.end(); 		//Итератор указывающий на элемент после последнего элемента (несуществующий).
myVector.cbegin(); 		//Возврат константного итератора
myVector.cend();		//Возврат константного итератора
myVector.rbegin(); 		//Реверс итератор
myVector.rend();		//Реверс итератор



Вставка элемента в конкретное место в векторе:

myVector.insert(it, 999); //1-ый параметр: итератор, который указывает на место вставки нового элемента, 2-ой параметр: значение нового элемента. Сложность: Разная для разных случаев. https://en.cppreference.com/w/cpp/container/vector/insert

Удаления элемента из конкретного места в векторе: 

myVector.erase(it); // Удаление элемента, на который указывает итератор. Сложность: Линейная

Удалить диапазон элементов:

myVector.erase(it, it + 3); //1-ый параметр итератор указывающий на начальный элемент удаления, 2-ой параметр: итератор указывающий на конечный элемент удаления.


В std::vector как и в других стандартных контейнерах нельзя хранить сырые ссылки, хотя при большом желании можно воспользоваться std::reference_wrapper.



______________________________________________________________________________________
Теория: Сложность удаления элемента из начала вектора

Удаление элемента из начала вектора (`std::vector`) считается операцией с высокой вычислительной сложностью из-за особенностей его внутренней реализации. Давайте рассмотрим, почему 
это так.

Внутренняя структура std::vector

`std::vector` хранит свои элементы в непрерывном блоке памяти. Это означает, что элементы расположены друг за другом без промежутков. Такая организация позволяет `std::vector` 
обеспечивать очень быстрый доступ к элементам по индексу, но в то же время накладывает ограничения на операции вставки и удаления.

Удаление элемента из начала

Когда удаляете элемент из начала вектора, все оставшиеся элементы должны быть сдвинуты на одну позицию влево, чтобы закрыть образовавшийся пробел. Это сдвигание является операцией, 
которая требует времени, пропорционального количеству перемещаемых элементов. Таким образом, сложность удаления из начала вектора — `O(n)`, где `n` — количество элементов в векторе 
после удаляемого. Это делает операцию неэффективной, особенно для больших векторов.Пример:

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Удаление первого элемента
    vec.erase(vec.begin());

    // Вывод оставшихся элементов
    for (int x : vec) {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
В этом примере при вызове `vec.erase(vec.begin())`, `std::vector` должен переместить все элементы на одну позицию влево, что требует времени, пропорционального размеру вектора.

Удаление элемента из начала вектора является дорогостоящей операцией, потому что требует перемещения всех остальных элементов, чтобы поддерживать непрерывность блока памяти. В 
отличие от таких структур, как `std::list` или `std::deque`, где удаление из начала занимает константное время, `std::vector` менее подходит для задач, где часто требуется удаление 
элементов из начала или середины коллекции.


______________________________________________________________________________________
Теория: Сложность удаления элемента из конца вектора

Удаление элемента из конца вектора (`std::vector`) обычно является очень эффективной операцией с точки зрения производительности. Это связано с тем, что `std::vector` хранит свои 
элементы в непрерывном блоке памяти, и удаление последнего элемента не требует перемещения других элементов.

Сложность операции

Операция удаления элемента из конца вектора (`std::vector::pop_back()`) имеет константную сложность времени `O(1)`. Это означает, что время, необходимое для выполнения операции, не 
зависит от размера вектора. Вот почему:

1. Нет необходимости перемещать элементы: Поскольку удаляемый элемент находится в конце вектора, не требуется перемещать другие элементы для заполнения пробела.

2. Вызов деструктора: При удалении последнего элемента `std::vector` вызывает деструктор для этого объекта, чтобы корректно освободить любые ресурсы, которыми он может управлять. 
Деструктор вызывается только для одного элемента, поэтому это действие выполняется за константное время.

Пример:


#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {10, 20, 30, 40, 50};

    // Удаление элемента с конца
    vec.pop_back();

    // Вывод оставшихся элементов вектора
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}

В этом примере после вызова `vec.pop_back()`, последний элемент вектора (50) удаляется, и размер вектора уменьшается на один. Эта операция происходит за константное время, и 
последующий вывод показывает состояние вектора после удаления элемента.

Важно отметить, что удаление элемента из конца вектора не приводит к немедленному освобождению памяти, которая была выделена под массив элементов вектора. Вектор управляет своей 
памятью с помощью механизма емкости (`capacity`), которая может оставаться неизменной даже после удаления элементов. Память будет освобождена или уменьшена только тогда, когда 
будет вызван метод `shrink_to_fit` или вектор будет уничтожен.

Хотя сложность `pop_back()` константная, следует помнить, что вызов деструктора для сложных объектов может быть затратным в плане времени выполнения.
Удаление элемента из конца вектора — эффективная операция, занимающая константное время, что делает `std::vector` идеальным выбором для использования в сценариях, когда часто 
требуется добавление или удаление элементов с конца.


______________________________________________________________________________________
Внутреннее устройство класса std::vector (Implementation std::vector)

Реализуем простейшее представление класса vector с методом push_pack().

template <typename T>
class vector {
	T* arr_;
	size_t sz_;						// size
	size_t cap_;						// capacity

	void reserve(size_t newcap) {
		T* newarr_ = new T[newcap];			// Здесь возникает проблема
	}	

	void push_pack(const T& value) {			
		if(sz == cap_) {
			reserve(cap_ > 0 ? cap_ * 2 : 1); 	// Примерно так работает увеличение capacity
		}
	}
};



int main() {
		
}

При реализации метода reserve мы столкнулись с интересной проблемой. Допустим что у нас есть тип:

struct S {
	int x;
	S(int x): x(x){}
};

У данной структуры нет конструктора по умолчанию, однако мы можем создать std::vector из таких структур, но вот в нашей реализации пока это не получиться сделать, потому что у
T может и не быть конструктора по умолчанию. Да и даже если он был, мы не хотим создавать new cap_ объектов. Это одна из важнейших проблем при реализации вектора.
Нам нужно научиться сделать реалокацию, но не создавая при этом столько объектов сколько мы хотим. Когда мы говорим reserve, мы не требуем создать в 2 раза больше объектов,
мы требуем выделить память под столько объектов, и объекты мы будем класть туда по мере надобности. Какже нам выделить память под newcap объектов не создавая их? 

T* newarr_ = reinterpret_cast<T*>(new char[newcap * sizeof(T)]);			// Решаем проблему, однако это не лучший способ.

Но мы не можем себе позволить вызвать new от T, потому что он будет пытаться создать n штук от T, но мы не должны, мы должны выделить чистую память байтов нужного кол-ва, а
дальше её чем то заполнять.

Цифрами будем помечать грабли(ошибки), которые сведетельствуют о неумении реализовывать push_pack().
(28 лекция 34.10)

В (2) у нас UB. Очень важно понять почему это так, почему в строчке (2) UB. Представим вектор из string. Что сейчас такое newarr[index]? Это сырые байты, там нет никокого 
объекта. Мы пытаемся сделать присваивание какой то штуке, которая скастится к ссылке на T, но там нет T ещё, объект ещё не создан, мы не можем присваивать туда ничего. У нас там
чары просто лежат, байты сырые. Мы вызываем оператор присваивания от T к другому T, но в newarr T ещё нет.

template <typename T>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;

	void reserve(size_t newcap) {
		T* newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)]); 	// Решаем проблему, однако это не лучший способ.	(1)Грабля 
		for(size_t index = 0; index < sz_; ++index) {				
			newarr[index] = arr_[index];					// (2) Грабля. В newarr ещё нет никаких объектов, там просто выделена память, а мы уже хотим чтото присвоить.
		}
	}	

	void push_pack(const T& value) {			
		if(sz == cap_) {
			reserve(cap_ > 0 ? cap_ * 2 : 1); 	
		}
	}
};

Можно попробовать копировать память с помощью memcpy, но это не будет работать для ситуации если одно из полей объекта является указателем или ссылкой на другое его поле. Эти
объекты кажутся странными: Вот пример типа, который не переживёт такую реалокацию с помощью memcpy:

struct Strange {
	int x;
	int& r;		// r будет ссылаться на x.
	Strange(int y): x(y), r(x) {}
};

Также например std::string является таким типом. Если у нас какие то элементы вектора ссылаются на другие элементы ввектора это не переживёт релокацию, и не должно, при 
реалокации вектора дропаются указатели и ссылки на все его предыдущие элементы. Но если поле является ссылкой на другое своё же поле, того же объекта, то это должно пережить 
реалокацию. 

Короче нельзя делать memcpy. По сути нам нужно по данному адресу вызвать конструктор данного типа на сырой памяти. Как вызвать конструктор данного типа по данному адресу, зная 
что там пока не лежит никогого объекта? В данном случае нам потребуется языковая конструкция placement new. У оператора new есть, на ряду со стандартной формой new[T], есть ещё
new с параметром (поинтером): new(newarr + index) T(arr[index]); // placement new. Вызвать конструктор данного типа по данному адресу.

Далее нам нужно освободить старый массив. Для этого нам сначало нужно вызвать все деструкторы, причём вызвать их явно. Мы не можем просто вызвать оператор delete: 
delete arr_, поскольку он будет вызывать деструкторы, но в каком кол-ве и по каким адресам? Мы не можем удалить arr_ как будто это массив T, потому что изначально arr_ мы 
выделяли как массим чаров, а не T. Когда мы создавали arr_, мы его также создавали как сырые байты, мы не можем вызвать оператор delete[] на нём, потому что он будет думать,
что это был массив T, но там небыло T. Он будет смотреть на то что он записал слева как на размер этого массива, и пытаться вызвать деструкторы в таком кол-ве, но на самом деле,
там небыло столько объектов. Поэтому нам нужно delete обратно реинтропредкастнуть к char*, а деструкторы нужно вызвать вручную. Также ещё деструкторы нужно вызвать вручную, 
поскольку, reserve мы можем вызывать не только когда у нас sz_ переполнено, мы можем сделать reserve на большее, если у нас массив даже не целеком был заполнен объектами ещё.
И в этом случае мы должны вызвать ровно столько деструкторов, сколько было объектов, а остальная память была ещё незаполнена.

Теперь нам нужно будет поменять размер cap_ и arr_.

template <typename T>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;

	void reserve(size_t newcap) {
		if (newcap <= cap_)							// Если мы делаем reserve на чтото меньшее просто прерываем функцию.
			return;
		
		T* newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)]); 	
		for(size_t index = 0; index < sz_; ++index) {			
			//newarr[index] = arr_[index];	
			new(newarr + index) T(arr[index]); 				// placement new. Вызвать конструктор данного типа по данному адресу.
		}
		
		//delete arr_;								// Так нельзя
		
					
		for (size_t index = 0; index < sz; ++index) {				// Освобождаем старый массив
			(arr_ + index)->~T();						// Вызов деструкторов вручную
		}
		delete[] reinterpret_cast<char*>(arr_);		

		arr_ = newarr;								
		cap_ = newcap;								// Меняем размер
	}	

	void push_pack(const T& value) {			
		if(sz == cap_) {
			reserve(cap_ > 0 ? cap_ * 2 : 1); 	
		}
	}
};


Теперь нехватает exception safety. Напишем безопасный относительно исключений reserve. new здесь может кинуть исключение в нескольких местах:

1) T* newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)]); 
Если new кинет исключение здесь, то ничего страшного не будет, поскольку к этому моменту мы ещё ничего не испортили, потому что память не удалось выделить, мы так наверх и
вылетем с этим исключением bad_alloc.

2) new(newarr + index) T(arr[index]);
placement new сам по себе не кидает исключение, потому что он памяти новой не запрашивает ни у кого, он только вызывает конструктор. Но здесь T может кинуть исключение в 
конструкторе, и вот это самое неприятное. Нам нужно удалить всё то, что мы до этого успели скопировать. Поэтому мы всё это оборачиваем в try. Однако мы не узнаем что такое 
newarr вне try, поэтому newarr мы должны объявить до try, также index объявляем вне try. В блоке catch вызываем деструкторы в кол-ве равному сколько мы успели создать объектов.
Незабываем reinterpret_cast только теперь не к arr_ а к newarr. throw нужен чтобы бросить дальше то, что мы поймали.

Всегда считаем что деструкторы вызывать безопасно, потому что они не кидают исключения, delete так же не кидает исключений.

template <typename T>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;

	void reserve(size_t newcap) {
		if (newcap <= cap_)							
			return;

		size_t index = 0;
		T* newarr = newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)]);	
						
		try {
			T* newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)]); 	
			for(; index < sz_; ++index) {				
				new(newarr + index) T(arr[index]); 				
			}		
		} catch(...) {
			for(size_t oldindex = 0; oldindex < index; ++oldindex) {
				(newarr + oldindex)->~T();
			}
			delete[] reinterpret_cast<char*>(newarr);	
			throw;
		}		
	
		for (size_t index = 0; index < sz; ++index) {				
			(arr_ + index)->~T();						
		}
		delete[] reinterpret_cast<char*>(arr_);		

		arr_ = newarr;								
		cap_ = newcap;								
	}	

	void push_pack(const T& value) {			
		if(sz == cap_) {
			reserve(cap_ > 0 ? cap_ * 2 : 1); 	
		}
	}
};

Мы сделали reserve и вернёлись к push_back. И теперь мы пытаемся положить на новое место новый элемент. А вдруг он кинет исключение? Тогда нам нужно будет всё вернуть как было.
На самом деле push_back выражать через reserv не очень хорошо, потому что push_back должен отличаться от reserve тем, что после цикла с placement new ещё пытаемся не выходя из
этого try, сделать new по newarr + sz_ T(value); И только потом в catch обратно всё кладём.

Такой push_back() сойдёт на троечку, по крайней мере не UB.
Реализация вектора получше находится в теме Аллокаторов.


######################
Есть ещё особый вид вектора - вектор bool. Самое интересное в векторе bool это оператор []. Как реализовать его? Мне нужно чтобы я мог присваивать квадратными скобочками, и 
это меняло один битик в векторе.

Вектор bool от обычного вектора отличается ?


Лайфхак: чтобы узнать какой тип у T (т.е. у v[5]) можно сделать так:

template <typename T>
class Debug {
	Debug(T) = delete;
};

int main() {
	std::vector<bool> v(10);
	v[5] = true;			// Хотим узнать какой тип у v[5]
	Debug d(v[5]);			// CE, но компилятор подсказывает что это за тип - std::_Bit_reference
}

std::_Bit_reference это внутренний тип, который интересно устроен. Квадратные скобочки в векторе от bool должны возвращать этот тип по значению. Не ссылку а копию. Потому что
нам нужен новый объект создать. _Bit_reference будет так устроен, что он будет хранить указатель на ячейку и номер бита в этой ячейке. Так же этот _Bit_reference будет уметь
то, что присваивание ему будет менять эту ячейку. Присваивание bool _Bit_reference меняет под указателем битик по нужному индексу. 

Что делают [] в векторе bool? Они должны вернуть новый объект _Bit_reference. Мы просто создаём _Bit_reference от соответствующей ячейки.

Также у BitReference должен быть оператор неявного каста в bool.

template <>
class vector<bool> {
	char* arr;
	size_t sz_;
	size_t cap_;

	
	struct BitReference {
		char* cell;
		unit8_t index;
		
		BitReference(char* cell, uint8_ index) :
			cell(cell), index(index) {}

		void operator=(bool b) {
			if(b) {
				*cell |= (1 << index);
			} else {
				*cell &= ~(1 << index);
			}
		}

		operator bool() const {					// оператор неявного каста в bool
			return *cell & (1 << index);
		}
	};
public:
	BitReference operator[](size_t index){
		return BitReference(arr_ + index / 8, index % 8);
	};

};

int main() {
	std::vector<bool> v(10);
	v[5] = true;
	Debug d(v[5]);
}

Когда я говорю v[5] = true; что на самом деле происходит: на самом деле v[5] это rvalue. BitReference это новый временный объект, это не ссылка, и ему можно присваивать, и это
присваивание работает как изменение объекта вектора. Это пример ситуации когда rvalue можно и нужно чтото присваивать.

В остальном вектор bool ничем не примечателеню.


____________________
Инвалидация указателей в векторе

Представим такой пример: Что будет?

vector<int> v(10);
int* p = &v[5];
v.push_back(1);		// pointer invalidation
cout << *p;

Правильный ответ будет UB, потому что нельзя ничего вставлять в вектор(в том числе push_back) и после чего разыменовывать указатели на элементы вектора, которые были созданы до
этого. Это явление называется инвалидация указателей. Потому что вектор мог реалоцироваться, и скорее всего так и произошло, потому что когда мы создаём вектор от конкретного 
числа элементов, он ровно столько памяти и выделяет. Когда мы сделали push_back(), capacity вектора стало 20, произошла реалокация, и теперь этот указатель указывает на память,
которая нам больше не пренадлежит.

А что если бы я сделал не указатель а ссылку? Мы завели ссылку на элемент вектора, теперь ref это другое название для v[5].

vector<int> v(10);
int& ref = v[5];
v.push_back(1);		
cout << ref;

Это UB. Произойдёт всё тоже самое, что и с указателем. В данном случае произойдёт reference invalidation (битая ссылка).

Вектор инвалидирует указатели и ссылки на свои элементы после того как вектор был изменён. pop_back() не инвалидирует, кроме того элемента, который удалили. shrink_to_fit 
инвалидирует, потому что релацирует.



______________________________________________________________________________________
Итераторы STL и категории итераторов

В контейнерах list, map уже не получится делать индексацию привычным нам способом поэлементно. Дело в том что индексом в них может быть не обязательно число. Но нам важно иметь
обобщённую итерацию. 

Итератор это такой тип, который позволяет нам делать обход последовательности в различных контейнерах STL. Поведение итераторов очень похоже на поведение указателей и на поведение 
умных указателей. Но сами по себе итераторы не являются указателями, это некая объектная оболочка над указателями, которая позволяет нам себя разыменовывать и инкрементировать, ещё 
сравнивать на равенство друг с другом. Это главные свойства, которыми должен обладать итератор. Обычный указатель это тоже итератор, умный указатель уже не итератор поскольку его 
нельзя инкрементировать. Для разных групп контейнеров в STL итераторы организованы по разному. В любом контейнере должно быть можно обходить итератором.

В каждом стандартном контейнере внутри определён тип Iterator, который позволяет ходить по этому контейнеру, и в зависимости от контейнера он разный по виду.


Итераторы в стандарте подразделяются на категории:
Сейчас мы обсуждаем не конкретные типы в c++, а мета типы (например как отличается структура двусвязный список и его реализация в c++ под названием list)

1) Самый минималистичный итератор называется InputIterator, это итератор умеет только эти базовые свойства. 

2) Частным случаем InputIterator является ForwardIterator. Тип считается ForwardIterator если он считается InputIterator, и вдобавок ещё гарантирует (в отличии от InputIterator), 
что если мы будем ходить по одной и той же последовательности несколько раз, не меняя её, то мы будем видеть одно и тоже.

Пример: Итератор в односвязном списке, он не является BidirectionIterator. 
Контейнеры, которые имеют такие итераторы: forward_list, unordered_set, unordered_map

3) BidirectionIterator вдобавок к ForwardIterator ещё умеет декрементировать (--)
Контейнеры, которые имеют такие итераторы: list, set, map

4) RandomAccessIterator ещё умеет делать += число, -= число, просто умеет складываться с числом, разность двух итераторов, сравнивать на <, >, <=, >=.
Контейнеры, которые имеют такие итераторы: deque

5) (C++17) ContiguousIterator частный случай RandomAccessIterator. Он гарантирует что он эквивалентен указателю, в том смысле что если мы разыменуем итератор, потом обратно
возьмём адрес, прибавим N и снова разыменуем, то это было бы всё ровно, что мы просто к оператору прибавили N и разыменовали. *(& * it + n) == *(it + N)
Т.е. сложение итераторов, это прсто хождение по  памяти на N шагов. В деке это не так, потому что там элементы в памяти лежат неподряд.

Контейнеры, которые имеют такие итераторы: vector, array, любой указатель


Все std алгоритмы принимают итераторы.


##########################
Пример на обычном массиве:

int arr[] = { 2,6,9 };		
cout << arr[1] << endl;		// Доступ ко 2-ому элементу массива (значение 6).
cout << *(arr + 1) << endl; 	// Это тоже доступ ко 2-ому элементу массива (значение 6). Используем разыменование указателя на имя массива + 1. Имя массива это есть указатель 
				// на его первый (индекс 0) элемент. Получается указатель на первый элемент + 1 равен указатель на второй элемент массива.

Работа с итераторами в STL похожа на это.

myVector.begin(); 		//Интератор указывающий на начало вектора.
myVector.end(); 		//Итератор указывающий на элемент после последнего элемента (несуществующий).

vector<int> myVector = {1,9,44,422,676,78}; 	//Инициализация вектора
	
vector<int>::iterator it; 	//Создание итератора vector с типом данных int
it = myVector.begin(); 		//Теперь итератор указывает на первый элемент нашего вектора (связываем итератор с нашим вектором).
cout << *it << endl; 		//Получаем данные через итератор (сейчас в итераторе данные из первого элемента вектора).
*it = 5; 			//Присваиваем новое значение через итератор.
it++; 				//Инкремент итератора означает что мы переходим на следующий элемент вектора.
it += 2; 			//Сдвиг на 2 элемента вправо.
it--; 				//Сдвиг на 1 элемент влево.

for (vector<int>::iterator i = myVector.begin(); i != myVector.end(); i++)
{
	cout << *i << endl;
}
return 0;


Константный итератор. Разрешено только чтение, запись запрещена.

for (vector<int>::const_iterator i = myVector.begin(); i != myVector.end(); i++)
{
	//*i = 5;		//Ошибка, перезапись константы запрещена.
	cout << *i << endl;
}
return 0;

Константый итератор в переменную обычного итератора мы присвоить не можем.


Мы можем итерировать с конца коллекции в начало:

for (vector<int>::reverse_iterator i = myVector.rbegin(); i != myVector.rend(); i++)
{
	cout << *i << endl;
}


Не все итераторы можно перемещать используя арифметику указателей, поэтому существует функция перемещения итератора:

advance(it, 3);  //1-ый параметр: итератор, который нужно переместить, 2-ой параметр: на сколько шагов.



Вставка элемента в конкретное место в векторе:

myVector.insert(it, 999); 	//1-ый параметр: итератор, который указывает на место вставки нового элемента, 2-ой параметр: значение нового элемента.

Удаления элемента из конкретного места в векторе: 

myVector.erase(it); 		// Удаление элемента, на который указывает итератор.

Удалить диапазон элементов:

myVector.erase(it, it + 3); 	//1-ый параметр итератор указывающий на начальный элемент удаления, 2-ой параметр: итератор указывающий на конечный элемент удаления.


#########################
i++ или ++i в for

Разница в использовании префиксного и постфиксного инкремента/декремента для итераторов в том, что в случае префиксного итератора, в теории, просто изменяется состояние объекта, 
и потом он возвращается, а при использовании постфиксного инкремента, состояние также изменяется, но возвращается объект с предыдущим состоянием, т.е. для этого компилятору 
необходимо создать ещё 1 объект. Это влияет на скорость работы. Но, вроде как современные компиляторы уже могут сами оптимизировать подобные случаи, и скорость работы не 
отличается. Но для себя я всё же сделал вывод, что если использование префиксного и постфиксного инкремента не влияет на правильность ответа, то предпочтительно использовать 
префиксный инкремент.

int a = 5;

cout << a++ << endl; //В консоль выведется 5, после того как все операции закончились (в нашем случае вывод в консоль), a присвоется значение 6. (Переменная сначала вывелась, 
		     //затем увеличилась).

cout << ++a << endl; //В консоль выведется 6 сразу (Переменная сначала увеличилась, затем вывелась).


##########################
range-based for

Начиная с C++11 мы для любого элемента в контейнере можем написать так:
set<int> s;
for(int x : s) {

}

Вопрос: Что это формально значит? Что значит : в for? На самом деле это синтаксический сахар. Раньше до C++11 приходилось писать так:

for(std::set<int>::iterator it = s.begin(); it != s.end(); ++it) {
	// И работать в теле цикла с разыменованном it: *it
}

Чтобы в нашем контейнере работал цикл ренч бэйсит фор нужно определить методы begin() и end() и итератор.

При старте цикла, range-based for запоминает(кэширует) изначальные begin и end которые были, и идёт в их границах, независимо от того, что происходит с точки зрения реалокаций.
Запоминает он их для того, что постоянный вызов метода end() может быть дорогостоющим. 


С вектором и деком так делать нельзя:

std::vector<int> v = {1, 2, 3, 4, 5};
for(int& x : v) {
	v.push_back(x);			// UB. Для дека это тоже UB.
}
for(int& x : v){
	std::cout << x;
}



Оффтоп про range-based for:

Перебор всех элементов массива arr

int arr[] = { 5,11,94,99,44 };

for (int var : arr) 			//Перебор всех элементов массива arr
{
	cout << var << endl;
};

этот цикл называется range-based цикл. В каждой итерации этого цикла в переменную var будет скопирован следующий элемент массива (начинаю с 0). Это означает что при изменении
переменной var, элемент коллекции не изменяется. Если нужно изменять элементы коллекции, то нужно передавать элементы по ссылке:

for (int &var : arr) 			//Перебор всех элементов массива arr
{
	var++;
	cout << var << endl;
};

Если нужно передавать элемент по ссылке, но не нужно его его изменять, то нужно указать ключевое слово const:

for (const int &var : arr)
{
	//var++; 			//Не получится
	cout << var << endl;
};


С помощью этого цикла мы можем перебрать контейнер без итератора:

list<int> myList = { 1,99,4,94,799,44,6 };

for (const auto &var : myList)
{
	cout << var << endl;
};


##########################
Как узнать тип который лежит под итератором?

Представим что я пишу итератор.

Имея шаблонный тип InputIterator как мне узнать тип. Вдруг это поледовательность из double или int или string или чтото другое.

Можно написать используя auto, 

template <typename InputIterator>
void findMostOftenNumber(InputIterator begin, InputIterator end){
	auto x = *begin;	
}

однако это может дать неверный результат в некотором случае: Если мы возьмём в векторе bool begin и разыменуем, что мы получим? 

template <typename T>
void f() = delete;

int main() {
	std::vector<bool> vb(10);
	f(*vb.begin());
}

Я же должен уметь по begin присваивать. И должен от этого поменяться вектор от bool. Значит разыменование begin должно давать мне ту самую BitReference, присваивание которой
должно поменять исходный bool (битик). Т.е. для вектора bool это будет некорректным типом, нельзя написать auto, потому что тип разыменованного begin это не всегда то, что 
нужно. Это не всегда тот тип, из которого реально состоит последовательность, это может быть какая нибудь обёртка над ним.

Существует стандартная метафункция для узнавания какой тип лежит под инетратором, а точнее существует целый набор метафункций для узнавания много чего про итератор и называется
это iterator_traits: Нужно писать typename, потому что value_type зависимое имя.

template <typename InputIterator>
void findMostOftenNumber(InputIterator begin, InputIterator end){
	typename std::iterator_traits<InputIterator>::value_type x = *begin;
}

iterator_category позволяет узнать категорию итератора.

std::distance - считает разность итераторов. Считает кол-во шагов которое нужно чтобы дойти от first до last. Если итератор RandomAccessIterator то за O(1), если нет то за O(n).
Реализация функции distance, Нам нужно как то написать: если итератор поддерживает операцию вычетания, то просто вычесть разность и вернуть её, а если нет, то завести цикл и 
посчитать кол-во шагов, которое нам потребовалось чтобы дойти от first к last. Для этого нужно написать условие if constexpr. Если мы напишем без if constexpr, то будет CE
когда мы подставим не RandomAccessIterator, потому что эта строчка будет пытаться компилироваться.

template <ypename Iterator>
typename std::iterator_traits<Iterator>::difference_type
distance(Iterator first, Iterator last) {
	if constexpr (std::is_base_of_v<							// O(1)
			std::random_access_iterator_tag,
			typename std::iterator_traits<Iterator>::iterator_category	
			>) {
		return last - first;
	} 
	int i = 0;
	for(int i = 0; first != last; ++i, ++first);						// O(n)
	return i;
}


std::advance - аналогично действует.

std::prev - функция которая даёт итератор на предыдущий элемент
std::next - функция которая даёт итератор на следующий элемент


Примеры из жизни про итераторы:
Виды итераторов довольно глубокая и достаточно абстрактная идея, применимая не только к C++. Если задуматься, виды итераторов это про то, насколько качественно у нас запомнена
информация. Однако, наличие итераторов это на самом деле большое требование и достаточно большое усложнение. Без итераторов контейнеры можно было бы реализовать гораздо проще. 
Наличие итераторов в каждом контейнере - это требование, которое сильно усложняет реализацию, потому что помнить с итераторами это существенно более сложнее чем просто помнить. 

Например помнить материал семестра по c++ то одно (InputIterator), другое дело это когда мы не просто помним, а ещё можем перечислить в правильном порядке как был рассказан этот
материал, т.е. у нас появляется итератор (ForwardIterator). Ещё сложнее это помнить материал семестра в обратную сторону (BidirectionIterator), и ещё сложнее когда мы помним как
RandomAccessIterator.

Пример 2: 
InputIterator: У нас у каждого есть список чатов в телеге. И про каждого произвольного человека мы можем сказать есть ли у меня с ним чат, переписываемся ли мы с ним. Однако 
мы врядли можем перечислить все свои чаты хоть в каком то порядке, гарантированно не забыв ни про кого. Просто помнить какое то множество вещей это гараздо меньше, чем помнить 
с итератором.

ForwardIterator: С другой стороны, например мы помним стихотворение "У лукоморья дуб зелёный", но если вас спросят как строчка идёт перед строчкой "И 33 витязей прекрасных",
нам придётся линейное время потратить чтобы вспомнить (перебор всех строк до нужной), потому что когда мы учим стихи мы помним их только в одну сторону. Мы не просто помним все
строки по отдельности, мы помним их умея переходить к следующей, но мы не умеем переходить к предыдущей. Уметь переходить к предыдущей это нечто большее.

BidirectionIterator: Мы можем помнить остановки метро. Что после Тульской? Нагатенская. А в обратную сторону Серпуховская. Но мы врядли скажем за O(1) как называется остановка,
находящаяся через 10 остановок от нас, даже если мы помним всю ветку и ездием по ней регулярно.

RandomAccessIterator: Наконец если мы помним информацию прям от O(1).



______________________________________________________________________________________
Реализация итераторов. Const и reverse итераторы.

Как реализовать итератор для своего контейнера? В контейнере должен быть внутренний тип, называющийся Iterator. На примере вектора он будет хранить указатель на T. Так же у него
должны быть методы: конструктор, копи конструктор, присваивание, уничтожаться, свопаться. Также чтобы получить итератор на вектор нужна функции begin() и end().

Как переопределять оператор стрелочка? У неё странный синтаксис: она ничего не принемает. В стандарте есть костыль: если мы переопределяем стрелочку, когда мы пишем:
СвойТип->что_то то берётся наша стрелочка и к тому что она вернула автоматически дописывается ещё стрелочка. Т.е. мы должны вернуть поинтер в чистом виде и компилятор сам 
допишет в него ещё стрелочку. Т.е. переопределение стрелочки тривиально, мы просто возвращаем поинтер и всё.  

template <typename T>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;

public:
	class iterator {
	private:
		T* ptr;
		iterator(T* ptr): ptr(ptr){}			// Конструктор от T* 
	public:
		iterator(const iterator&) = default;		// Копи
		iterator& operator=(const iterator&) = default; // Присваивание

		T& operator*() const {				// Разыменовывание
			return *ptr;	
		}
		T* operator->() const {				// Переопределение стрелочки
			return ptr;
		}

		iterator& operation++() { 			// Инкремент префексный
			++ptr;	
			return this;
		}
		iterator operator ++(int) {			// Инкремент постфиксный
			iterator copy = *this;
			++ptr;
			return copy;
		}		
	};	

	iterator begin() {
		return iterator{arr_};
	}

	iterator end() {
		return iterator{arr_ + sz_};
	}
};


Это всё база. Поговорим о том, как сделать итератор константным, не в смысле что сам итератор константный, а в смысле всё что под ним не должно меняться. Мы хотим сделать так, 
чтобы у нас был аналог указателей на константу в мире итераторов. Т.е. такой вид итератороа, что если мы его берём, то разыменование его даёт нам const T&, а не просто T&. И 
такой итератор тоже должен быть в каждом контейнере и называется он const_iterator. И вот нужно не путать когда сам итератор константный и когда он const_iterator в смысле
как итератор на константу. Когда мы видем const_iterator это означает то что мы получим при  разыменовании будет const, а не сам тератор const. Он выглядит почти также как и 
реализация обычного итератора, только нам нужно сделать указатель на константу и возвращать const_iterator.

template <typename T>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;

public:
	class const_iterator {						
	private:
		const T* ptr;						
		const_iterator (T* ptr): ptr(ptr){}			
	public:
		const_iterator (const const_iterator &) = default;		
		const_iterator & operator=(const const_iterator &) = default; 

		const T& operator*() const {				
			return *ptr;	
		}
		const T* operator->() const {				
			return ptr;
		}

		const_iterator & operation++() { 			
			++ptr;	
			return this;
		}
		const_iterator  operator ++(int) {			
			const_iterator  copy = *this;
			++ptr;
			return copy;
		}		
	};	

	class iterator {
	private:
		T* ptr;
		iterator(T* ptr): ptr(ptr){}			// Конструктор от T* 
	public:
		iterator(const iterator&) = default;		// Копи
		iterator& operator=(const iterator&) = default; // Присваивание

		T& operator*() const {				// Разыменовывание
			return *ptr;	
		}
		T* operator->() const {				// Переопределение стрелочки
			return ptr;
		}

		iterator& operation++() { 			// Инкремент префексный
			++ptr;	
			return this;
		}
		iterator operator ++(int) {			// Инкремент постфиксный
			iterator copy = *this;
			++ptr;
			return copy;
		}		
	};	
};


Глядя на это возникает естественное желание убрать копипасту. Это можно сделать с помощью шаблонов. Как единожды написав тело класса iterator получить и interator и 
const_iterator одним махом? Нам нужно, чтобы в зависимости от параметра IsConst тип был то T* то const T*. Нам поможет std::conditional_t. Для облегчения кода нужно использовать
using для определение типа указателя, типа ссылки и типа по значению. Теперь base_iterator должен быть приватным. И теперь iterator в классе vector это у нас using. 

Теперь нужно поговорить про методы begin() и end(). Эти методы константные или нет? Правильно эти методы нужно определить по разному для константного и неконстантного вектора.
У константного вектора тоже можно вызвать методы begin() и end(), и если например мы вызовем метод begin() то он просто вернёт const_iterator.

Помимо begin() и end(), есть ещё cbegin() и cend(), которые возвращают const_iterator даже для неконстантного контейнера.

Так же теперь нам нехватает одного важного метода, с помощью которого любой итератор неявно преобразовывался в константный итератор, чтобы каст от обычного итератора к конст 
итератору работал неявно, а в обратную сторону нет. Есть два способа: можно сделать через дополнительный конструктор, а можно сделать через оператор приведения типа.
Сделаем с помощью 2-ого способа.

Также сделаем класс vector дружественным классом для класса base_iterator, поскольку конструктор base_iterator приватный.


template <typename T>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;

private:	
	template <bool IsConst>
	class base_iterator {
	public:
		using pointer_type = std::conditional_t<IsConst, const T*, T*>;		// Тип указателя
		using reference_type = std::conditional_t<IsConst, const T&, T&>;	// Тип ссылки
		using value_type = T;							// value_type говорит нам о том, какой тип лежит в контейнере.
	
	private:	
		pointer_type ptr;
		base_iterator(T* ptr): ptr(ptr){}	
		friend class vector<T>;		
	public:
		base_iterator(const base_iterator&) = default;		
		base_iterator& operator=(const base_iterator&) = default; 

		reference_type operator*() const {				
			return *ptr;	
		}
		pointer_type operator->() const {				
			return ptr;
		}

		base_iterator& operation++() { 			
			++ptr;	
			return this;
		}
		base_iterator operator ++(int) {			
			base_iterator copy = *this;
			++ptr;
			return copy;
		}

		operator base_iterator<true>() const {	// Неявное преобразование без конст в конст итератор
			return {ptr};
		}		
	};
public:
	using iterator = base_iterator<false>;		// Итератор
	using const_iterator = base_iterator<true>;	// Константный итератор
	
	iterator begin() {			// begin с обычным итератором
		return {arr_};
	}
	
	iterator end() {			// end с обычным итератором
		return {arr_ + sz_};
	}

	const_iterator begin() const {		// begin с const_iterator
		return {arr_};
	}

	const_iterator end() const {		// end с const_iterator
		return {arr_ + sz_};
	}

	const_iterator cbegin() const {		// cbegin() возвращает const_iterator для любого контейнера (имеется ввиду неконстантного и константного)
		return {arr_};
	}

	const_iterator cend() const {		// cend() возвращает const_iterator для любого контейнера
		return {arr_ + sz_};
	}
};


##################################
Ещё у контейнеров есть такой тип reverse_iterator и const_reverse_iterator. Мы хотим уметь ходить по последовательности и назад, если исходный итератор будет хотя бы 
BidirectionIterator. Чтобы обойти например map или set в обратном порядке нужен reverse_iterator. Просто std::iterator это устаревший тип с C++17(Его больше нет, он безполезен). 
В стантартной библиотеке это отдельный класс std::reverse_iterator, и на самом деле это адаптер над итератором. reverse_iterator шаблонизирован параметром iterator, и это
по сути обёртка над обычным другим итератором, которая берёт все наши действия и разворачивает в обратную сторону. reverse_iterator можно создать от произвольного итератора, и 
он в себе будет хранить этот итератор. Когда мы просим reverse_iterator сделать ++ он просто делает декремент(--) у итератора который лежит в нём, и наоборот. Когда мы делаем
звёздочку или стрелочку, он нам просто возвращает, но возвращает не тот итератор, который лежит, а его минус 1. Зачем минус 1? Чтобы мы когда от end делаем ревёрс, то получаем 
rbegin (rbegin это итератор на end (конец)), когда мы от begin делаем ревёрс мы получаем rend (rend это итератор на место, которое находится перед begin (началом)). 

Т.е.  begin даёт итератор на начальный элемент, end даёт итератор на место, после последнего элемента.
      rbegin даёт итератор на последний элемент, rend даёт итератор на место, которое находится перед начальным элементом.


reverse_iterator в векторе. Самостоятельно реализовывать реверс итераторы не нужно. Достаточно использовать std::reverse_iterator:

using iterator = base_iterator<false>;					// Итератор
using const_iterator = base_iterator<true>;				// Константный итератор
using reverse_iterator = std::reverse_iterator<iterator>;		// Реверс итератор
using const_reverse_iterator = std::reverse_iterator<const_iterator>;	// Константный реверс итератор

Теперь мы умеем ходить взади-вперёд по вектору с помощью итераторов. Так же есть crbegin() и crend(), они ведут себя аналогично как и rbegin() и rend().


______________________________________________________________________________________
Инвалидация итераторов в векторе (Важный пример)
Вернёмся к примеру с инвалидация указателей:

В векторе из-за реалокации у нас может произойти инвалидация ссылки и указателя:
vector<int> v(10);
int& ref = &v[5];
v.push_back(1);		// UB
std::cout << ref;

Если так сделать с деком, то всё будет нормально. А что если в векторе мы так сделаем не с указателем или ссылкой, а с итератором? Можно ли так делать с итераторами? Происходит
ли инвалидация итераторов?

vector<int> v(10);
std::vector<int>::iterator x = v.begin() + 5;	
v.push_back(1);					// UB или нет?
std::cout << *x;				

Ответ: Нет, в векторе так НЕЛЬЗЯ делать, это UB, так же как и в случае ссылок и указателей.


Но ведь мы могли бы в итераторе вектора хранить просто индекс и указатель на сам вектор, чтобы при реалокации не происходило инвалидации. Однако, это плохо, потому что это 
неэффективно. Если бы мы в итераторе хранили указатель на сам контейнер, то разыменование итератора занимало бы 2 разыменования, вместо одного, т.е. сначала разыменовываем 
указатель и получить контейнер, потом разыменовать ещё указатель и получить элемент. Мы хотим, чтобы разыменовать итератор было так же дёшево, как разыменовать указатель. 
Ни в каких итераторах мы не храним указатели на контейнер. Но и на самом деле мы и формально не сможем так сделать, потому что мы не сможем соблюсти одно из требований к 
итератору: Мы должны уметь свопать контейнеры, а итераторы при этом должны оставаться корректными. Поэтому итератры в веторе инвалидируются. 


В деке итераторы тоже инвалидируются! Это довольно глубокое понимание, что в деке указатели и ссылки неинвалидируются, а вот итераторы инвалидируются. Т.е. завести указатель и 
ссылку на элемент дека, а потом положить что-то в дек, указатель и ссылка остануться валидными. А вот завести итератор на элемент дека, и чтото положить в дек, после этого
разыменовывать итератор это UB. Потому что в деке итератор будет состоять из двух указателей на элемент внешнего и элемент винутреннего массива. Нам нужно хранить указатель на 
элемент внешнего(вертикального) массива, но внешний массив может реалоцироваться при push_back() в деке. 

В std::list, std::forward_list, std::map, std::set ничего не инвалидируется никогда, потому что ничего не реалоцируется. В std::set ноды не реалоцируются от того что мы чтото 
добавляем. В них только переставляются поинтеры, они переподвешиваются, но они не реалоцируются сами по себе. 



______________________________________________________________________________________
output iterators and stream iterators.

Допустим мы хотим скопировать элементы одного диапозона в другой с помощью std::copy поэлементно из вектора в массив. Массив размером 10 и вектор размером 5, при чём масси 
заполнен только на первые 5 элементов, остальные 5 элементов пустые. С помощью std::copy мы можем скопировать элементы из вектора в массив. Но можем ли мы скопировать элементы
из массива в вектор?  

#include <algorithm>
#include <vector>

int main() {
	int a[10] = {1, 2, 3, 4, 5};
	std::vector<int> v(5);
	
	std::copy(v.begin(), v.end(), a);	// Так мы можем
	
	std::copy(a, a + 10, v.begin());	// UB	
}

std::copy это просто алгоритм который разыменовывает, присваивает, инкрементирует (и так повторяется по все элементам). Он не делает push_back(). Этот алгоритм ничего не знает
про то, что лежит под итератором, он воспринимает итератор просто как указатель. Если мы передадим ему вектор, он просто начнёт писать за границу этого вектора. Хуже если мы 
передадим ему std::list: в векторе хотябы элементы лежат по порядку в памяти. Но если там list, map или set, то в какой то момент, когда дойдёт до конца.он сделает инкремент 
итератора, и просто по тупому будет дальше разыменовывать и присваивать, но инкремент это же прыжок по указателю, но если конец списка то указатель никуда не ведёт и от nullptr
он упадёт, или же он может быть зацикленный и вести сам на себя, тогда он будет писать в себя же несколько раз. Короче эти итераторы не подходят для того, чтобы по ним писать.
И поэтому они не являются output итераторами.


output итератор, это такой итератор, который гарантирует, что можно его разыменовыват, инкрементировать и присваивать и так делать сколько угодно раз и ничего не сломается.
Он гарантирует корректность, если мы будем писать в него с помощью алгоритмов. Итераторы в контейнерах такими не являются, поэтому нам нужен отдельный вид итераторов.

Пример 1) insert_iterator. Как можно сделать так, чтобы можно было использовать стандартные алгоритмы над контейнерами, чтобы в контейнере писать. Вот мы хотим написать 
std::copy_if который копирует все чётные числа:

bool even(int x) {		// Предикат
	return x % 2 == 0;
}

std::copy_if(a, a + 10, v.begin(), &even);

Но я не могу так напрямую вызывать этото алгоритм, потому что он вызовет UB, потому что будет писать мимо вектора, начиная с какого то момента. Какую обёртку написать над 
вектором, чтобы это корректно работало? Нужно сделать обёртку над итератором вектора, которая предоставляла бы мне интерфейст output итератора. 

Такая обёртка называется back_insert_iterator. Это output итератор, который докладывает в конец элементы в контейнер для которого был сконструирован. 

bool even(int x) {		// Предикат
	return x % 2 == 0;
}

std::copy_if(a, a + 10, std::back_insert_iterator<std::vector<int>>(v), &even);


Реализация класса back_insert_iterator:
Это такая обёртка над итератором, которая хранит ссылку на контейнер, и умеет конструироваться от контейнера. Мы хотим back_insert_iterator реализовать так, чтобы алгоритм, 
который разыменовывает, присваивает, инкрементирует, приводил к тому, что в контейнере делается push_back(). 
Для этого можно сделать такой трюк(сродни трюку с вектором bool): 
Мы определим своему итератору операратор присваивания от value_type контейнера. value_type говорит нам о том, какой тип лежит в контейнере. При инкременте и разыменовании
ничего не делаем. Звёздочка и инкремент возвращают back_insert_iterator (его же).


template <typename Container>
class back_insert_iterator {
	Container& container;
public:
	back_insert_iterator(Container& container): container(container) {}
 
	back_insert_iterator& operator=(const_typename Container::value_type& value) {	// Операратор присваивания от value_type контейнера
		container.push_back(value);
		return *this;
	}

	back_insert_iterator& operator++() {						// Ничего не делаем при префиксномикременте
		return *this;
	}
	back_insert_iterator operator++(int) {						// Ничего не делаем при постфиксном икременте
		return *this;
	}

	back_insert_iterator& operator() {						// Ничего не делаем при разыменовании
		return *this;
	}
};

Чтоже происходит когда мы делаем например так: *it1++ = *it2++; 
1) Делается инкремент, вовращается копия back_insert_iterator, инкремент ничего не делает с back_insert_iterator при этом.
2) Потом делается разыменование, опять ничего не делается с back_insert_iterator. И ему присваивается x value. Мы оператор присваивания определили не от другого итератора, а от
value контейнера. Т.е. итератору мы присваиваем значения элементов в контейнере. И это приводит к тому, что делается push_back(). Т.о. эта обёртка над итератором позволяет нам
вызывать стандартные алгоритмы над контейнерами и класть в них как будто мы пишем и просто идём по массиву, а в реальности мы делаем push_back() в контейнер.


Но писать back_insert_iterator от std::vector неудобно, поэтому есть функция std::back_inserter. Она нужна просто для того, чтобы поменьше писать код:
Реализация:

template <typename Container>
back_insert_iterator<Container> back_inserter(Container& container) {
	return {container};	// Создаёт back_insert_iterator от container
}


Теперь вместо длинной записи мы можем написать так:

bool even(int x) {		// Предикат
	return x % 2 == 0;
}

std::copy_if(a, a + 10, std::back_inserter(v), &even);


Помимо back_inserter есть ещё front_inserter, который делает всё тоже самое только push_front().

И inserter, который принимает не только контейнер, а контейнер и итератор в этом контейнере. Он применим к любому контейнеру, потому что он пишет в середину, т.е. мы можем
inserter отдать связаный список и итератор на элемент в этом связном списке и inserter будет писать по этому итератору туда, т.е. он будет не push_back() делать, а вызывать
метод insert() у данного контейнера по данному итератору.



______________________________________________________________________________________
LIST (Список).

LIST представляет собой реализацию двусвязного списка. Лист это контейнер с данными, в котором эффективно реализована возможность добавления и удаления элемента в коллекцию,
абсолютно в любом месте контейнера (Очень быстро работает с удалением и добавлением элементов). В списке не реализована перегрузка оператора [], предётся использовать 
итераторы. Так же не реализован итератор произвольного доступа (мы не можем сразу получить доступ по какому то конкретному индексу). Лист тоже шаблонный контейнер, как и вектор.

#include <list> 				//Подключаем список

list<int> myList; 				//Создание списка
//list<int> myList = {15,64,77};

myList.push_back(1); 				//Добавление элемента в конец списка. Сложность: константа
myList.push_front(0); 				//Добавление элемента в начало списка Сложность: константа

list<int>::iterator it = myList.begin(); 	//Создаём итератор для перемещения по списку
cout << *it << endl; 				//Вывод первого элемента списка

for (auto i = lst.cbegin(); i != lst.cend(); ++i) //Перебор всех элементов списка
{
	cout << *i << endl;
}

myList.sort(); //Сортировка списка по возрастанию. Сложность: N * log(N)

myList.pop_back(); //Удалить последний элемент списка. Сложность: константа
myList.pop_front(); //Удалить первый элемент списка. Сложность: константа

myList.unique(); //Удаление дубликатов (только последовательных) из списка  Сложность: N - 1

myList.reverse(); //Реверс всего списка. Сложность: Линейная

myList.clear(); //Очистка всего списка от всех элементов. Сложность: Линейная

Вставка элемента в список:
myList.insert(it, 11); //1-ый параметр: итератор, который указывает на место вставки нового элемента, 2-ой параметр: значение нового элемента. Сложность: Константа или линейная, зависит от случая.

Сдвиг итератора:
advance(it, 3); //1-ый параметр: итератор, который нужно переместить, 2-ой параметр: на сколько шагов.

Удаление элемента списка:
myList.erase(it); // Удаление элемента, на который указывает итератор. Сложность: Константа или линейная, зависит от случая.

myList.remove(99); //Удалить элемент со значением 99 Сложность: Линейная

myList.assign(3, 1); //Заполнить список элементами. Перед тем как заполнить лист новыми элементами, старые удаляются. 1-ый параметр: кол-во новых чисел, 2-ой параметр: их значение.

Копирование элементов с заменой на новые
myList.assign(myList2.begin(), myList2.end()); //Копирование из myList2 в myList



______________________________________________________________________________________
std::list interals

Когда list предпочтительнее вектора или дека?
Главный профит std::list это то что он умеет вставлять и удалять из середины за константное время.

Операции list:
Операции гарантированные за O(1):

insert(iterator it, const T& value); 	// Добавить за O(1)
	
erace(iterator if);			// Удаляет значение за O(1)

push_back() и pop_back()		// O(1)

push_front() и pop_front()		// O(1)

size()					// O(1)



Реализация list в stl стиле: 
Допустим у нас есть list в котором имеются 3 вершины. 

Node <====> Node <====> Node
 |			  |
 |			  |
head			tail


template <typename T>
class list {
	struct Node {
		T value;
		Node* next;
		Node* prev;
	};
	
	Node* head;	
	Node* tail;
	size_t sz;
}


Как здесь будет работать итератор? Дело в том что у листа должен быть конец, то что обозначается итератором end(). Здесь это не так очевидно как в векторе, ведь в векторе end() это
указатель на элемента массива следующий за последним. Итератор в себе не хранит указатель на list, он не знает о контейнере. Декремент итератора должен работать сам по себе, 
независимо от контейнера. Это значит что нам нужно декрементировать итератор в том числе и end(), независимо от контейнера. Это говорит о том, чтобы реализовать end() нам нужна
фиктивная нода. Стандратный лист так и устроен.

begin()
 |
 |
Node <====> Node <====> Node
 /\			 /\
 ||			 ||
 \\=====> fakeNode <=====//
	     |
	     |
	    end()

Если мы сделаем ++end() то формально это будет UB, однако скорее всего мы получим begin().

Что если лист пустой? В пустом листе имеется всего лишь 1 нода и это фейк нода. Она является и begin() и end(). Если нода всего лишь одна, то она зациклена сама на себя, т.е. next и 
prev это fakeNode.

begin()   end()
 |	    |
 |	    |
 \----------/
      |
   fakeNode


На самом деле нам не нужно хранить 2 поинтера head и tail, нам достаточно хранить один поинтер beg (от слова begin), потому что мы знаем что end() всегда стоит перед begin(). 
Т.е. чтобы получить end() нужно взять prev от begin(). 

Итератор листа будет хранить просто Node*. 

Следующая проблема: как в fakeNode проинициализировать T value? Нам нечем инициализировать T в fakeNode и мейчас мы не можем избежать этого, потому что там поле типа T. Мы можем 
вместо просто T хранить T*, однако это плохая идея потому что придётся использовать оператор new, который будет использовать алокацию для каждой новой T*. Т.е. new очень медленно 
работает. Лист и так медленный, потому что на каждую вершину он вызывает new заново. Например при методе insert это конечно работает за O(1), но это работает за O(1) в терминах T 
т.е. в терминах уровня абстракции C++. В терминах ОС это вовсе не за O(1) может работать, потому что это требует вызова оператора new, а оператор new требует обращение к менеджеру 
памяти системы, и это недёшево. Поэтому лишние операции с new нам не нужны.

Поэтому мы можем унаследовать Node от FakeNode, так сделано в STL. Предлагается следующая идея: мы сделаем структуру BaseNode (фейковая нода), и всё что она будет содержать это 
указатель на предыдущую ноду и указатель на следующую, а T value не будет. А ещё будет обычная Node, и она будет наследница BaseNode. И в ней, помимо этих двух указателей ещё будет 
лежать T. И теперь наш лист он будет в качестве поля содержать указатель не на Node, а на BaseNode (фейковая нода). Т.е. все ноды они являются частным случаем BaseNode и мы храним
указатель именно на BaseNode, но некоторые ноды настоящие в них лежит T, а в BaseNode не лежит T.

template <typename T>
class list {
	struct BaseNode {
		BaseNode* prev;
		BaseNode* next;
	};
	struct Node: BaseNode{
		T value;
	};
	
	BaseNode* fakeNode;	
	size_t sz;
}


Следующий шаг: Чем изначально должна быть проинициализирована fakeNode? Конструктор листа по умолчанию должен создать ноду, которая указывает сама на себя. 
Требования такие: У каждого листа должна быть своя fakeNode, и у каждого листа должен быть свой begin() и end(), т.е. не общий end() на все пустые листы.  Так же пустой лист не 
должен ничего алоцировать, пока мы туда реально не добавили T. end() и begin() пустого листа должны работать корректно, они определены и равны, но разыменовывать их нельзя. 
Поэтому можно сказать а зачем нам вообще хранить указатель на BaseNode, если BaseNode можно хранить на стеке. Мы просто будем хранить на стеке поле BaseNode, в которой будут два
поля prev и next, которые изначалаьно будут указывать на саму ноду BaseNode. т.е. fakeNode инициализируется своим же собственным адресом. 

...
	BaseNode fakeNode;	
	size_t sz;

public:
	list(): fakeNode {&fakeNode, &fakeNode}, sz(0){};  //{this, this} , т.е. fakeNode инициализируется своим же собственным адресом. 
}

Обратим внимание какой интересный класс у нас получился: у нас поле класса хранит указатели на на это же самое поле. Мы говорили о таких классах, когда реализовывали реалокацию в 
векторе, и почему нельзя использовать memcpy для реалокации вектора. Вот пример такого класса который бы сломался: если бы мы сделали вектор из листов и в нём реалокацию делали 
с помощью memcpy, то вот это бы у нас сломалось, потому что лист в своих полях хранит указатели на свои же поля, и если бы мы делали memcpy то эти указатели ломаются и становятся 
невалидными.


################################
Нетривиальные методы листа.

Метод list.sort(). 
Это не внешнаяя функция, а метод листа. Есть функция std::sort из заголовочного файла алгоритм, которая принимает пару RandomAccses итераторов, и сортирует диапазон, а у листа есть
свой собственный метод sort(). Зачем он нужен? Что будет если вызвать метод sort над листом, т.е. на std::sort(list.begin(), list.end())? Будет CE со словами попытка вызвать оператор
меньше, который не определён (или + или разность). Потому что std::sort внутри себя вызывает операции над итераторами которые подрузамевают что они RandomAccses, а у листа не
RandomAccses итераторы, а BIderectional итераторами. В list.sort() сортировка это мёрдж сорт. 

Метод merge()

Метод splice(it, from, to) - если у нас есть 2 листа, можно вырезать кусок из одного, и вставить в другой. it куда вставить, from начало выреза, to конец выреза. 
Она работает за O(to - form) если это были разные листы, а если это был один и тот же лист, то за O(1).



################################
Интересные особенности forward-list

forward list представляет собой реализацию односвязного списка.

#include <forward_list>  	//Подключаем односвязный список

В forward_list есть многие методы, которые есть в list и Vector, их предназначение одинаковое для всех.

Особенности forward_list: в отличие от обычного list, в forward_list добавлять и удалять элементы мы можем только в начале списка. Есть метод insert_after, который позволяет
вставить элемент в любое место.


for (auto var : fl) 				//Перебор всех элементов списка
	cout << var << endl;

forward_list<int>::iterator it = fl.begin(); 	//Итератор для списка

it++; 						//Переход на следующий элемент
//it--; 					//Не работает, эта операция не перегружена, потому что это односвязный список.

cout << *it << endl;


В forward list есть методы с приставкой after: insert_after, erase_after. А так же методы с приставкой before: before_begin, cbefore_begin. Наличие этих методов объясняется
логикой односвязного списка: В двусвязном списке при работе метода insert(3, 0) этот четвёртый элемент (итерация с 0) становится пятым, а на его место ставится новый элемент.
При односвязном списке такая операция не возможна, потому что старый четвёртый элемент не хранит адрес предыдущего элемента. Именно по этому был добавлен метод insert_after,
в котором новый элемент вставиться не перед указанным в параметре элементом, а после него. erase работает так же.

forward_list<int> fl = {131, 94, 494};

forward_list<int>::iterator it = fl.begin(); 	//Итератор для списка

fl.insert_after(it, 9999);

for (auto var : fl) 				//Перебор всех элементов списка
	cout << var << endl;
 

Метод before_begin ставит итератор на область памяти перед первым элементом (по сути в никуда). Он нужен чтобы получить доступ для методов insert_after и erase_after к первому
элементу списка.


В forward_list нет push_back() и pop_back(), нет метода size(). 

Нет метода insert(), а есть метод insert_after(). Метод insert() позволяет вставить НА тот итератор, который передали (не ЗА
ним, а НА него). Если нужно вставить в начало, то нужно сделать insert(begin()). Если бы insert() работал как вставить после, то непонятно как можно было бы вставить в начало.
А в forward_list мы не можем сделать insert() НА тот итератор, который передали, потому что предыдущий элемент неизвестен, поэтому всё что мы можем сделать в forward_list, это
insert_after() за этим итератором. А чтобы вставить в начало, нужно сделать push_front().
 
Задачи на списки:

1) Самая известаня задача на листы это поиск цикла в односвязном списке (Кролик и черепаха). У нас есть связный список, который возможно зациклен, и нам нужно за O(n) времени и O(1)
памяти понять зациклин ли он, и найти место где он зацикливается. Нам дано начало списка. Она решается алгоритмом Флоида: заводим 2 указателя, и один из них инкрементируем со 
скоростью 1 за итерацию, а второй инкрементируется со скоростью 2 за итерацию. И если они станут равны друг другу то список зациклен, а если какой то из них успеет дойти до конца и 
они не станут равны друг другу, значит список незациклен. 

2) У нас есть односвязный список, а ещё у каждой вершины есть указатель, ведущий на какую то рандомную вершину того же списка, даже на себя саму. Нам нужно скопировать этот список
с сохранением сруктуры указателей за O(n). Решается она так: нужно просто встроить между каждыми двумя вершинами новую вершину и глядя на предыдущую вершину мы ставим указатель туда
же + 1. 

В структуре данных LRUCashe используется связный список.  


################################
Exception safety

Все контейнеры должны быть строго безопасны относительно исключений.
С листом всё просто: если мы пытаемся выделить память и у нас это не получилось, то мы просто выходим. Дальше, если мы пытаемся положить объект и у нас не получилось (конструктор 
кинул исключение), удаляем то что выделили, освобождаем память, возвращаем лист в исходное состояние и выходим.  



______________________________________________________________________________________
array STL

#include <array> //Подключаем массив

array является обёрткой для статического массива (А vector для динамического).

array<int, 4> arr; //Инициализация
Поскольку массив статический, мы не можем не добавить элемент ни удалить.

arr.at(1);
arr.size();
arr.fill(-1); //Заполняет полностью массив числом -1
arr.front(); //Доступ к первому элементу массива
arr.back(); //Доступ к последнему элементу массива



______________________________________________________________________________________
Контейнеры STL и операторы сравнения

У всех контейнеров STL присутствует перегрузка операторов сравнения.

array <int, 4> arr = { 1, 94, 77, 9 };
array <int, 4> arr2 = { 1, 94, 77, 9 };

bool res = (arr == arr2); //res = true.

#####
array <int, 4> arr = { 1, 94, 77, 10 };
array <int, 4> arr2 = { 1, 94, 77, 9 };

bool res = (arr > arr2); //res = true. В arr последний элемент 10 а в arr2 последний элемент 9, поэтому arr > arr2 (Сумма всех элементов arr > чем в arr2).

Главное условие сравнивания контейнеров, это то, чтобы внутри такого контейнера минимальный элемент сам по себе должен иметь перегруженный оператор сравнения.



______________________________________________________________________________________
deque (Дек)

Дек - это двусторонняя очередь. Это некий гибрид вектора и двусвязного списка. По сути дек это двусвязный список векторов, т.е. несколько векторов связаны в один список. 
Дек позволяет сгладить недостатки списка при попытке доступа к конкретному элементу. В списке все элементы разбросанны по всей памяти и переход от одного элемента к другому 
медленный. В векторе все элементы объеденены в непрерывной области памяти, поэтому переход от одного элемента к другому очень быстрый. Получаем скорость итерации выглядит так:
список (медленный) < дек (средний) < вектор (быстрый).

Так же важна скорость доступа, добавления и удаления элемента в начало и в конец коллекции. В двусвязном списке это делается очень быстро по причине самой структуры контейнера.
В векторе приходится перевыделять память заново и копировать все элементы, затем уже добавлять новые, это очень долго. Получаем скорость добавления и удаления элемента выглядит
так: список (быстрый) > дек (средний) > вектор (медленный).

#include <deque> //Двусторонняя очередь

В дек в отличии от vector есть метод push_front. Остальные методы идентичны предыдущим контейнерам. Сложность: константа


______________________________________________________________________________________
внутренности std::deque (internals std::deque)

У дека два отличия от вектора.

1) Дек не инвалидирует указатели и ссылки при добавлении чего-то в дек. Это главное почему именно дек используется под капотом по умолчанию в таких контейнерах как стек, кью,
приорити кью. 
2) Дек умеет делать пуш и поп форнт.

Нам нужно реализовать контейнер, который умеет всё тоже что и вектор, но ещё и пушфронт попфронт, и не инвалидирует указатели и ссылки.


Как реализован стандартный дек:

Заводят массив, который состоит из указателей, изначально они nullptr, но когда в деке чтото появляется, то появляется указатель на настоящий массив. Размер этих массивов 
некоторая константа, ну например N = 32. Горизонтальный(внутренний) массив это массив T, вертикальный(внешний) массив это массив указателей на T. Т.е. на самом деле мы храним массив 
T** arr. Изначально вертикальный(внешний) массив можно сделать из одного элемента, который будет указывать на горизонтальный(внутренний) массив с сырой памятью. В горизонтальном 
(внутреннем) массиве сырая память, поскольку здесь нет изначально объектов типа T. Когда мы создаём дек без аргумента не должна выделятся память вообще, дек должен быть пустым, 
0 аллокаций. Как только мы кладём в него какой нибудь элемент, дек выделяет вертикальный(внешний) массив какой то длинны, и выделяет горизонтальный(внутренний) массив 
(бакет (bucket)). Потом он кладёт в первую ячейку элемент T. В остальных ячейках всё ещё сырая неинициализированная память. Когда мы делаем push_back() горизонтальный массив 
заполняется, в момент когда он будет переполнен, дек создаст второй бакет, и начнёт класть элементы туда. 

					  N = 32
	|---------|             /------------------------\
	| nullptr |
	|---------|		|----|----|----|----|----|
	|   ptr   | --------->  | T0 | T1 |... | T30| T31|
	|---------|		|----|----|----|----|----|
	| nullptr |
	|---------|
	| nullptr |
	|---------|
	| nullptr |
	|---------|


Если мы делаем push_front(), то выделяется новый бакет, и в нём в самую последнюю ячейку кладётся элемент.
Демонстрация метода push_front():

					 
	|---------|             |----|----|----|----|----|
	|   ptr   | --------->	|    |    |    |    | T0 |
	|---------|		|----|----|----|----|----|
	|   ptr   | --------->  | T1 | T2 |... | T31| T32|
	|---------|		|----|----|----|----|----|
	| nullptr |
	|---------|
	| nullptr |
	|---------|
	| nullptr |
	|---------|

Реализовать поведение горизонтальных массивов не получится с помощью вектором из-за недостатка некоторых операций, поэтому их нужно реализовывать с помощью сишных массивов. 
Так же нужно помнить какой номер бакета и какой индекс у нас является началом текущего дека и какой номер бакета и какой индекс является концом текущего дека.

Почему указатели и ссылки не инвалидируются при реалокации? Что вообще такое реалокация дека? Например если у нас закончился последний массив и элементы нам уже некуда класть, 
но мы всё ровно делаем push_back(), то бакеты остаются на своих местах. Мы реалоцируем вертикальный массив с указателями и добавляем в него больше места для новых указателей. 
Указатели на старые массивы остаются. Мы добавляем новый бакет и указатель на него.


	#
	# ----> ____...___#	(Здесь мы делали push_front())
	# ----> ####...####
	# ----> ####...####
	# ----> ####...####	(Здесь мы делаем push_back() но места нет)

	Реалоцируем внешний массив указателей


	#
	#
	# ----> ____...___#
	# ----> ####...####
	# ----> ####...####
	# ----> ####...####
	# ----> #___...____	(Появился новый чистый массив)
	#
	
Чтобы класть элементы на сырую память нужно использовать placement new. Для того чтобы удалить элемент, например pop_front(), нам нужно по этому адресу вызвать деструктор T и 
сдвинуть индекс.

Как работает оператор [] за O(1)? Мы знаем начало и у нас константый размер бакетов. Т.е. когда нам говорят [индекс], мы просто зная размер N и зная индекс начала, пересчитываем
этот индекс в терминах наших координат, и за O(1) понимаем в какой массив по какому индексу нужно обратиться чтобы это был нужный нам элемент. 

Индексация в деке идёт с 0 а не с отрицательного числа. Т.е. если мы положили 10 элементов в дек а потом сделали push_front(), то индекс нового элемента станет 0, а индексы всех 
старых элементов поменяются. Отрицательная индексация в деке запрещена. 

У дека есть почти все методы вектора и даже есть дополнительные, такие как push_front и pop_front. Однако у вектора есть три метода, которые отсутствуют у дека: shrink_to_fit, 
reserve и capacity, т.е. методы связанные с реалокацией у дека отсутствуют.


______________________________________________________________________________________
SET | MULTISET | Ассоциативные контейнеры

SET и MULTISET это два упорядоченных ассоциативных контейнера. Эти контейнеры реализованы на основе бинарного дерева.

std::set это просто map в котором вместо пар хранятся просто константные ключи. Здесь нет [] поскольку нет value.

#include <set> //Подключение бинарного дерева

Здесь нет методов push_back или push_front поскольку структура бинарного дерева очень сильно отличается от списка. Так же нет перегрузки операторов [] и метода at.
Здесь есть метод insert: 

set<int> mySet;

mySet.insert(5); 		//Корень дерева (поскольку добавился первым). Сложность: разная, зависит от случая. В основном логарифмическая по размеру контейнера.
mySet.insert(1);
mySet.insert(12);
mySet.insert(4);
mySet.insert(-1);

for (int var : mySet)
	cout << var << endl; 	//Бинарное дерево упорядоченная структура данных, поэтому в консоль будут выводиться данные в порядке возрастания.

Важная особенность сета, по мимо упорядочивания элементов, это то, что сет не может хранить несколько одинаковых элементов (хранит всегда только уникальные значения). В этом
моменте как раз и есть отличие SET от MULTISET. MULTISET тоже хранит элементы в упорядоченном состоянии, однако позволяет добавлять несколько одинаковых элементов. 
Так же контейнер сет не может изменить элемент, который в нём находится. Это можно обойти тем, что просто удалить старый элемент, и добавить его новое значение заново.


Поиск элемента в сете:

set<int> mySet = {5,45,35,11,86};
	
auto it = mySet.find(10); 	//Если метод find нашёл элемент, он возратит итератор на определённый элемент в сете. Если нет, то итератор вернёт значение, которое будет 
				//указывать на mySet.end() (элемент, который находится после коллекции т.е. в никуда). Сложность: логарифмическая по размеру контейнера.

auto it = mySet.find(11);

В методе find поиск элемента происходит с помощью бинарного поиска.


Удаление элемента в сете:

mySet.erase(5); // Удаления числа 5 из дерева. Сложность: В разных случаях по разному, константа или логарифмическая.

Если элемента нет, а мы попытаемся его удалить, то ничего не произойдёт.

Методы insert и erase возвращают результат своей работы. Метод erase возвращает 1 если получилось удалить и 0 если не получилось. Метод insert возвращает пару значений:
в 1-ом итератор на добавленный элемент после его добавления и 2-ой булева переменная true или false. Если получилось добавить элемент то будет true если нет то false.
Итератор на элемент будет в любом случае.


Для пользования MULTISET нам нужно подключить тот же заголовок #include <set>.

std::multiset - это set который может хранить несколько одинаковых ключей одновременно. С ним нужно работать так же как и с  std::multimap, но кажется что вместо std::multiset 
можно использовать std::map из ключа в int и будет содержательно тоже самое, но места будет занимать меньше.

multiset<int> myMultiset = {1,1,45,35,11,86};

В связи с тем что мультисет может хранить несколько одинаковых элементов в контейнере, в этом контейнере имеет смысл использовать методы lower_bound и upper_bound. 
Это нектороые аналог метода find, которые позволяют искать элемент. Эти методы возвращают итераторы на нужное нам число.

multiset<int> myMultiset = {1,1,45,35,11,86};

auto it1 = myMultiset.lower_bound(1); 	//Найдёт первую единицу, которую найдёт (потому что единица в параметре). Сложность: логарифмическая по размеру контейнера.

auto it2 = myMultiset.upper_bound(1); 	//Найдёт следующий после единицы элемент (который больше его). Поскольку в мультисете все элементы хранятся в упорядоченном состоянии, 
					//то в нашем случае следующий элемент будет 11, а не 1 или 45. Сложность: логарифмическая по размеру контейнера.


auto a = myMultiset.equal_range(1); 	//Возвращает диапазон чисел от lower_bound до upper_bound. В нашем случает вернёт (1,11); Сложность: логарифмическая по размеру контейнера.


Коментарии к видео:
А насчёт этого... Корнем этих классов становится число, которое было добавлено самым первым, так ведь? Т.е, у нас может первым числом добавиться значение -999999999999, а потом
 будут добавляться лишь значения больше, тогда у нас вся левая ветка древа будет пуста? Логично, что да. Есть ли у этих классов функции для сортировки дерева? Ну, или, мб в 
дальнейшем будут какие-то пояснения по этой теме?

Явно, что если корнем дерева будет число, максимально близкое к среднему арифметическому этого дерева, то поиск будет быстрее, чем, если к примеру, корнем будет число 1, и 
числа 2,3,4...100 будут рассортированы в правой ветке. Так, чтобы найти число 51, придётся сделать 50 шагов. А если имеются те же числа, но корнем дерева будет число 50, то для
 нахождения числа 51 придётся сделать всего лишь 1 шаг...

Как-бы всё правильно, но есть одно но: когда мы делаем выбор в пользу того или иного контейнера, то мы хоть как-то представляем себе каким образом туда будуть попадать данные и
если мы предполагаем, что элементы будут записываться всегда или почти всегда по возрастанию, то бинарное дерево может быть и не лучшим выбором. Тут всё зависит от задач. 
Бинарный поиск один из самых быстрых, а в описаной вами ситуации поиск по-умолчанию будет одинаково доглим для любого контейнера

В контейнере stl set используется не обычное бинарное дерево, а сбалансированное. Например, красно-чёрное. После добавления эллемента такое дерево ещё будет балансироваться. 
Таким образом корень может измениться. Пример, который вы привели в комментариях полностью отображает потребность такой балансировки для эффективности.


______________________________________________________________________________________
Теория: set сложность вставки, удаления, поиска

В set сложность вставки, удаления, поиска - логарифмическая
В стандартной библиотеке C++ контейнер `std::set` обычно реализован как бинарное дерево поиска, чаще всего как красно-чёрное дерево. Этот тип дерева является самобалансирующимся, 
что гарантирует, что дерево остаётся относительно сбалансированным после каждой операции вставки или удаления. Благодаря этому, высота дерева поддерживается на уровне \(O(\log n)\),
 где \(n\) — количество элементов в контейнере. Это гарантирует, что основные операции, такие как поиск, вставка и удаление элементов, выполняются за логарифмическое время.

Вставка

Включает в себя несколько шагов:
1. Поиск места для вставки: сначала необходимо определить, где в дереве должен находиться новый элемент, чтобы сохранить свойства упорядоченного дерева.
2. Вставка элемента: после того как место найдено, элемент вставляется в дерево.
3. Балансировка дерева: поскольку `std::set` обычно использует красно-чёрное дерево, после вставки может потребоваться несколько операций для восстановления сбалансированности 
дерева.

Удаление

Требует поддержания свойств бинарного дерева:
1. Поиск элемента для удаления: сначала находится элемент, который должен быть удалён.
2. Удаление элемента: элемент удаляется из дерева, что может включать замену удаляемого узла его потомком, если у узла есть дети.
3. Балансировка дерева: как и при вставке, после удаления может потребоваться несколько операций для восстановления сбалансированности дерева.

Поиск

Выполняется путём сравнения искомого значения с элементами в узлах, начиная от корня и перемещаясь вниз по дереву к листьям. Это поиск делает относительно простым благодаря 
свойствам красно-чёрного дерева, что обеспечивает логарифмическую сложность операции.

`std::set` обеспечивает эффективное управление упорядоченным набором элементов с логарифмической сложностью для операций вставки, удаления и поиска, что делает его подходящим 
выбором для многих задач, где важна скорость выполнения операций с данными в упорядоченном виде.


______________________________________________________________________________________
Теория: Худший случай поиска в бинарном дереве

Худший случай поиска в бинарном дереве возникает, когда дерево вырождается в свою одностороннюю форму, то есть принимает форму линейного списка (цепочки). Это происходит, когда 
элементы вставляются в дерево в уже отсортированном порядке, или когда каждый следующий элемент меньше (или больше) предыдущего.

Допустим, у нас есть последовательность чисел, которые мы хотим вставить в бинарное дерево поиска: 1, 2, 3, 4, 5. Если вставлять их в указанном порядке, то каждый новый элемент 
будет правым потомком предыдущего, что приведет к следующей структуре дерева:

```
1
 \
  2
   \
    3
     \
      4
       \
        5
```
В этом случае дерево вырождается в своего рода "правую ветку", и для поиска любого значения мы потенциально должны пройти по всем узлам. Например, чтобы найти число 5, нам 
необходимо сделать 5 сравнений.

Почему это плохо

Поиск в сбалансированном бинарном дереве работает за время \(O(\log n)\), где \(n\) — количество узлов в дереве. Это потому что с каждым шагом вглубь дерева количество узлов, 
которые еще предстоит рассмотреть, уменьшается вдвое. Однако, в вырожденном случае, как показано выше, поиск работает за \(O(n)\), так как каждый узел в дереве требует отдельного 
шага проверки.

Как избежать

Для предотвращения вырождения бинарных деревьев используют так называемые сбалансированные деревья поиска, такие как красно-черные деревья или AVL-деревья. Эти структуры данных 
автоматически перебалансируются при каждой операции вставки или удаления, что обеспечивает поддержание высоты дерева порядка \(O(\log n)\) и гарантирует, что операции поиска, 
вставки и удаления будут выполняться за логарифмическое время.

Худший случай поиска в бинарном дереве наступает, когда дерево становится похожим на линейный список, требуя \(O(n)\) времени для поиска элемента. Это случается при неудачном 
порядке вставки элементов. Использование сбалансированных деревьев помогает избежать такой проблемы.



______________________________________________________________________________________
Теория: разница между set и unordered_set

https://www.geeksforgeeks.org/set-vs-unordered_set-c-stl/?ref=lbp

Разница:
	      |         set		  | unordered_set
--------------|---------------------------|---------------------
Сортировка    |Сортировка по возрастающему| Нет сортировки
	      |порядку (по умолчанию) 	  |
--------------|---------------------------|----------------------
Реализация    |Самобалансирующееся дерево | Хеш-таблица
	      |двоичного поиска например, |
	      |"Красно-черное дерево".	  |	
--------------|---------------------------|----------------------
время поиска  |	  	log(n)  	  | O(1) -> среднее
	      |				  | O(n) -> Худший случай	
--------------|---------------------------|----------------------			
Время вставки | log(n) + Перебалансировка | O(1) -> среднее
	      |				  | O(n) -> Худший случай
--------------|---------------------------|----------------------
Время удаления| log(n) + Перебалансировка | O(1) -> среднее
	      | 			  | O(n) -> Худший случай


Используйте set, когда:
- 
Нам нужны упорядоченные данные.
- 
Нам нужно распечатать/получить доступ к данным (в отсортированном порядке).

- Нам нужны предшественники/преемники элементов.
- 
Поскольку множество упорядочено, мы можем использовать такие функции, как std::binary_search(), std::lower_bound() и std::upper_bound() для элементов множества. Эти функции нельзя использовать для неупорядоченного_множества().
- 
Дополнительные примеры см. в разделе Преимущества BST над Hash Table. https://www.geeksforgeeks.org/advantages-of-bst-over-hash-table/


Используйте unordered_set, когда:
- 

Нам нужно хранить набор отдельных элементов, и упорядочивание не требуется.
- 
Нам нужен доступ к одному элементу, т. е. без обхода.




______________________________________________________________________________________
MAP | MULTIMAP | Ассоциативные контейнеры

MAP и MULTIMAP схожи с SET и MULTISET, они тоже упорядочены, тоже имеют структуру бинарного дерева, но в отличии от SET и MULTISET которые просто хранят какое то одно значение, 
и строются в виде бинарного дерева логически, контейнеры MAP и MULTIMAP хранят не просто одно значение, а пары состоящие из ключа и значения. Так же как SET и MULTISET, 
MAP и MULTIMAP отличаются по тому же признаку: MAP может хранить только уникальные значения, MULTIMAP может хранить и дубирующие значения. Упорядочивание осуществляется на
основе ключа, а значение к нему просто подвязывается. Как итог мы получаем некий словарь.

#include <map> //Подключение карты

Простая пара:

pair<int, string> p(1, "телефон"); 	//Пара в чистом виде
p.first; 				//Первый элемент пары (1). Это ключ
p.second; 				//Второй элемент пары (телефон). Это данные


Добавление элемента в карту: Параметр insert принимает только уже готовую пару.

myMap.insert(make_pair(1, "телефон")); 		//Метод make_pair создаёт пару Сложность: В разных случаях по разному, амортизированная константа или логарифмическая.

myMap.insert(pair<int, string>(2, "ноутбук")); 	//Ручное создание пары в параметре

myMap.emplace(3, "монитор"); 			//автоматическое добавление нового элемента Сложность: Логарифмическая по размеру контейнера.

Метод insert либо копирует готовый объект, либо перемещает его. Метод emplace просто создаёт объект во время выполнения (он должен работать немного быстрее). В случае добавления
нового элемента с ключём, который уже есть map, новый элемент добавлен не будет. Так же как и в SET, метод insert возвращает пару значений: 1-ый параметр пара по заданному ключу,
2-ой параметр результат добавления (true или false).

auto res = myMap.emplace(4, "ывопатвы"); 	// В нашем случае res равен ((4, "ывопатвы"), true).



Поиск осуществляется методом find по ключу. Этот метод возвращает результатом своей работы итератор, который указывает на пару ключ-значение в map в случае если он смог найти 
элемент с текущим ключём. Если мы пытаемся найти элемент по ключу, которого у нас нет в map, то метод вернёт значение end() (по сути в никуда). 

auto it = myMap.find(3); 			//Поиск элемента по ключу (в нашем случае по ключу 3). Сложность: Логарифмическая по размеру контейнера.

cout << it->first << it->second << endl;	//Вывод значений пары ключ-значение, на который указывает итератор.


if (it != myMap.end()) 				//Чтобы не получить ошибку по выводу несуществующего элемента.
{
	cout << it->first << it->second << endl;
}



Для контейнера map перегружен оператор [].

cout << myMap[3] << endl; 			//Вывод в консоль: монитор




Типы данных для ключа тоже могут быть разными: Например у строк тоже есть перегруженный оператор больше и меньше, поэтому построение бинарного дерева на основании строк тоже
возможно.

map<string, int> myMap;				//Ключ типа string
	
myMap.emplace("Петя", 18);
myMap.emplace("Маша", 22);
myMap.emplace("Саша", 20);

Теперь когда мы хотим обратиться к интексу в нашем map (например в методе find или []), мы должны указывать соответствующий тип данных ключа. 

cout << myMap["Петя"] << endl; 	//Выведется значение 18

Так же с оператором [] мы можем не только получать значение, но и помещать значения в пару.

myMap["Маша"] = 25; 		//Присвоили Маше значение 25

Если мы помещаем значение с ключём, которого ещё нет в map, то данная пара появится в map.

А вот если использовать метод at с ключём которого нет в карте, то новая пара не будет добавлена, а метод at вызовет исключение. 



Удалить элемент из контейнера можно методом erase, положив в параметр ключ элемента, который нужно удалить.

myMap.erase("Саша"); // Сложность: В разных случаях по разному, амортизированная константа или логарифмическая.



multimap работает так же как и map, только multimap может хранить дублирующиеся ключи. Так же в multimap не перегуржен оператор [] и отсутствует метод at.
std::multimap это как map, только там может храниться несколько значений с одинаковым ключём. Главные друзья при работе с std::multimap это lower_bound и 
upper_bound, потому что если у нас несколько значений с одинаковым ключём, то lower_bound укажет на первое такое значение, а upper_bound на значение после последнего значения 
с одинаковым ключём. Таким образом мы можем вычислить диапазон одинаковых значений. 

	1   2   3   4   _
        |               |
   lower_bound 	   upper_bound, 


Ещё есть функция equal_range которая возвращает пару итераторов на lower_bound  и upper_bound. Т.е. как будто мы вызвали и lower_bound и upper_bound одновременно, однако это 
дешевле чем вызвать lower_bound и upper_bound по отдельности, потому что будет всего один спук по дереву, а если мы вызовем их по отдельности то будет два спуска.
 
myMultimap.emplace("Петя", 12);
myMultimap.emplace("Петя", 24);



______________________________________________________________________________________
std::map internals

Это упорядоченный ассоциативный массив ключ-значение. Заприщено хранить два элемента с одинаковыми ключами. По стандарту неучточнено какое дерево (Скорее всего красно-черное). Можно
было бы реализовать на AVL дереве, однако красно-чёрное дерево лучше тем, что там поменьше в среднем поворотов (константное кол-во поворотов). Также в КЧ дереве какие то операции
работают чуть побыстрее но какие то чуть помедленнее чем в AVL. 

Методы за гарантированное O(log n):

pair<iterator, bool> insert(const pair<Key, Value>&) - Получить pair<iterator, bool> - iterator - куда вставили, bool -произошла ли вставка. Если вставка не произойдет (что означет 
что такой ключ уже есть), то iterator вернёт место, где находиться данный ключ, а bool будет false.

erase(Key) - удалить по ключу

iterator erase(iterator) - удалить по итератору

Value& at(Key) - Получить ссылку на значение по ключу

Value& operator[](const Key&) - Получить ссылку на значение по ключу

iterator find(Key) - найти по ключу

size_t count(Key); - Есть такой ключ или нет. 1- был, 0 - небыл



Есть метод at, есть [], есть find. Когда нужно пользоваться и чем конкретно?

Метод at работает по анологии с вектором: либо находит ключ, либо кидает исключение. Так же у метода at есть константая версия, которая возвращяет константую ссылку.
У оператора [] нет константной версии, т.е. нельзя у const map вызывать []. Почему нельзя [] вызывать от const map? Потому что [] не бросают исключения если такого ключа не нашлось,
вместо этого они создают такой ключ со значением по умолчанию. В частности это значит что они потенциально меняют map.
Чтобы что то искать в const map нужно использовать find.


Популярный usecase связанный с map:
Представим код:

if(m.count(1)) {	// Если m с ключом 1 существует
	m[1] = 2;	// то поменять значение
}

Это неочень эффективный код, потмоу что это дважды спуск по дереву, хотя можно было спускаться только 1 раз. m.count() требует O(log n) времени и [] требуют O(log n) по времени.
Для этого полезен метод find, он позволяет сделать всё тоже самое, только в 2 раза быстрее:

if(auto it = m.find(1), it != m.end())	// if с инициализацией C++17
	it->second = 2;			// Под итератором в map лежит пара



#########################
Мини реализация map с красно-чёрным деревом

Здесь тоже нужна какая то нода внутри и нам нужно чтобы итератор умел ходить по дереву, и чтобы был end(), а end() нужно уметь декрементировать. В map Biderectional итераторы. 
Значит end() должна быть фейковой нодой. Фейковая нода будет просто корнем, а всё остальное дерево будет левым ребёнком, а правого ребёнка не будет. Получается FakeNode по построению
будет больше чем любая другая нода, т.е. она стоит правее чем любая нода дерева. Begin() будте самой левой нижней нодой. Если мы начнём итератором идти от Begin() используя инкремент,
то в итоге мы дойдём до end(). Декримент end() приведёт нас в самого правого ребёнка (не считая корня) в дереве. FakeNode отличается от обычное тем, что в ней нет пары. Так же в 
FakeNode не нужен флаг bool red, свойства красно-чёрного дерева можно поддерживать только в основном дереве. 

Для экономии памяти bool red можно запихать в указатель. Мы наблюдали такое являение когда исследовали указатели на виртуальные методы. Поскольку ноды выравнены по 8 и адреса нод 
всегда кратны 8, то у нас есть как минимум 3 свободных бита в конце каждого указателя. Их можно потратить с пользой. Мы можем например в последнем бите parent хранить 0 или 1 в 
зависимости от того красная вершина или чёрная. Так мы сэкономим целых 8 байт, потому что дополнительный bool, добавленный к такой структуре, он же выровниться по 8.

В библиотеке boost у некоторых контейнеров есть шаблонный параметр с помощью которого мы можем выбрать что нам нужно сэкономить память или время. В нашем случае например если мы 
зашиваем этот bool red в последний бит parent, программа немного медленнее от этого работать начинает, потому что нам каждый раз нужно доставать bool из указателя и кастить. Но с 
другой стороны таким способом мы экономим память.


		FakeNode   End()(Корень)
		  /
		 /
	      Node
	       /\
	      /  \
  	   Node  Node   (Декремент end() приведёт сюда)
	    /
	   /
 Begin() Node



template <typename Key, typename Value> // Также есть 3 параметр - компаратор
class map {
	BaseNode* fakeNode;		// Храним фейковую ноду
	BaseNode* begin;		
	size_t sz;
	Compare comp;			// Компаратор
	
	struct BaseNode {
		Node* left;		// Указатели на другие ноды
		Node* right;
		Node* parent;		// Указатель на родителя объязательно, потому что нам нужно уметь ходить итератором по дереву в любую сторону.
	};
	struct Node: BaseNode {
		pair<const Key, Value> kv;	
		bool red;		
	};
};


Почему здесь пара: pair<Key, Value> kv, а не отдельно Key и Value? Потому что когда мы разыменовываем итератор, мы хотим получить и ключ и значение под ним сразу. Но на самом деле 
здесь не просто Key, а const Key. map как и unordered_map хранит в себе пару const Key, Value. const к ключу нужен для того чтобы мы не могли изменить ключ, и тем самым мы не ломали
упорядоченность дерева. От сюда возникают интересные эффекты. 

Есть баг который с этим связан: представим у нас есть один map из (int, string), и мы решаем range_base_for сделать.
Мы умные поэтому решаем что тип назвать правильно и по ссылке:

for(const pair<int, std::string&> p : m) {	// Обход map
	// чтото делаем для всякой пары 
}

Мы можем предположить что здесь нужно писать константную ссылку. Но из за этого мы можем обнаружить что это стало медленно работать. Почему? Потмоу что мы коснст тип не на ту ссылку 
сделали. Мы сделали конст ссылку на тип pair<int, std::string>, а на самом деле тут была пара из pair<const int, std::string>. И чтобы такую ссылку привязать к той, нужно 
скопировать. Ссылка может привязаться только к точности такому типу, что и сама ссылка. Это значит что на каждом шаге, не смотря что мы написали const и &, та пара будет копироваться,
создавая нам временную пару pair<int, std::string>, и с ней мы будем работать. Чтобы это не копировалось, нам нужно не забыть перед int тоже поставить const. 

for(const pair<const int, std::string&> p : m) {	// Обход map
	// чтото делаем для всякой пары 
}

Т.е. из-за того, что мы чуть чуть не точно назвали тип, и всё стало копироваться, вместо передачи по ссылке.

Этот как раз один из примеров, для чего нужно слово auto. 

for(const auto& p : m) {	// Так проще :)

}


Хуже того, из за того что мы забываем const перед ключом, мы можем словить UB (это не в предыдущем примере).



#########################
Как в map найти наименьший ключ, который больше или равен данному ключу?

Например мы не нашли ключ, и теперь мы хотим найти минимальный ключ который больше или равный нашему ключу.

В map есть такие методы как: 
lower_bound(Key) - возвращает итератор на наименьший элемент, больший или равный нашего.
upper_bound(Key) - возвращает итератор на наименьший элемент, строго больший нашего.


#########################
За какую асимптотику работает инкремент итератора и вообще обход map итератором?

Это не такой уж и тривиальный вопрос, ведь один инкремент итератора может требовать логарифмического числа шагов по дереву. 

Отдельно взятый инкремент итератора может отработать за O(log n). В хужшем случае нам придётся подняться от самого нижнего уровня до самого верха. Но если мы проходим весь map от 
начала до конца, то это проходит за линейное время. Потому что в каждую вершину дерева мы не более 3-ёх раз входим и не более 3-ёх раз выходим. (Сверху вниз-влево, с лево на право, 
в права в вверх) Суммарно на каждую из вершин требуется не более 6 операций. Т.о. 6n всего шагов мы делаем за время обхода дерева, поэтому обход всего дерева работает за линейное
время, хотя отдельный инкремент итератора может работать за логарифмическое время.


#########################
Над map нельзя использовать вызывать модифицирующие алгоритмы, не смотря на то что он имеет BiDerectional итератор. Допустим, что будет если мы над map попробуем вызвать 
std::sort(m.begin(), m.end()). Будет CE, по той же причине, что и с list. Или если мы вызовем next_permutation от начала до конца map. next_permutation меняет значания под 
итераторами. Т.е. в какой то момент вызовется присваивание: *it1 = *it2, но в итераторах it лежит пара из const key, value. И за счёт того что там const, у нас ничего не получится
присвоить. Будет CE. 


#########################
У нас в может быть кастомный компоратор:

template <typename Key, typename Value, typename Compare = std::less<Key>>

Кастомный компоратор это функицональный объект, у которого есть оператор круглые скобочки от двух ключей, и он должен работать как меньше, по умолчанию там std::less<Key>.
std::less это функциональный класс, в котором оператор () от двух const Key& и он просто возвращает Key_1 < Key_2. Но мы можем передать нестандартный компаратор, для того 
чтобы например map отсортировать в обратном порядке. Или отсортирован как то по нашему по нашему правилу сортировки.

Если мы в качестве нестандартного компаратора передадим чтото, что не отвечает свойствам строгого порядка, то это UB.


#########################
Exception safety

В целом всё  тоже самое что и у листа. Когда мы добавляем вершину, если конструктор не отработал, то мы удаляем эту вершину, возвращаем дерево в исходное состояние и выходим.
Всё бы ничего но есть один забавный момент, это Compare. Что если у нас компоратор в своём операторе () кидает иногда исключения? Если компоратор кинул исключение во время сравнения
это значит что, нам нужно перестроить дерево обратно и вернуть всё как было, и только потом выйти. Но на самом деле это не проблема, и никакой принципиальной сложности в реализации 
это не добавляет, потому что в красно-чёрном дереве верно следующее утверждение: Нам никогда не нужно делать повороты после сравнений. Если мы делаем сравнение, это значит что мы ещё
ничего не поворачивали, поворачивать мы начинаем только тогда, когда мы уже всё поняли, относительно того кто где находится, и только после этого мы начинаем вращать, причём 
константное кол-во вращений делаем. Но в момент когда мы начали вращать, все сравнения уже выполнены, это значит что если компоратор кинул исключение, в этот момент дерево ещё не
испорчено. Если при erase это происходит, то нам нужно заранее посмотреть кого куда повернуть, и только потом уже начинать переставлять указатели, если мы уже удалили ноду и только
потому начали сравнивать, то тут уже могут быть проблемы.    



______________________________________________________________________________________
std::unordered_map internals since C++11

С английского хэш - это мелко порубить(измельчить) и перемешать.

Хэш таблица - мы хотим создать ассоциативный массив также из ключа в значение, но чтобы среднее время работы запроса, вставки, удаления и поиска было O(1), но при этом мы жертвуем
упорядоченностью. map даёт нам горантированное логарифмическое время работы на все запросы, но при этом он ещё упорядоченно хранит ключи, а unordered_map позволяет нам в среднем
достичь времени работы запросов O(1), но хранит ключи неупорядочно. 

В абстрактной хэш таблице это достигается за счёт того, что мы у нас есть массив размера N и у нас приходят какие то ключи. Мы хотим эти ключи похэшировать, т.е. от каждого 
ключа вычислить хэш-функцию h: из множества ключей Key -> в int. Т.е. ключ превращает в число по какому то сложному закону, так чтобы по получившимуся числу int хорошо бы, 
чтобы исходный ключ Key востановить было трудно. Т.е. это не какое то простое преобразование. Короче мы берём к ключу Key ставим в соответствие какое то детерминированное 
рандомное число int, такое что если ключ Key изменится незначительно, то это число int изменится очень сильно, и не предскажешь как он измениться. Дальше этот ключ мы берём 
например по модулю N, и в ячейку, под номером равным получившимуся этому числу int, мы записываем пару Key, Value. 

	0				             N
	|---|---|---|---|---|---|------------|---|---|
	|   |	|   |	|   |   | Key, Value |   |   |
	|---|---|---|---|---|---|------------|---|---|


Если хэш функция достаточно хорошая, то заполнение массива будет неотличимо от случайного. И тогда можно предположить, что будет редко возникать такая ситуация, что мы два раза 
попадём в одну и туже ячейку, положив разную строку. Т.е. в среднем всё будет нормально.

std::hash<T>() - функциональный объект, он для каждого типа свой. У него есть оператор  круглые скобочки: std::hash<int>()() - это стандартная хэш функция применённая к int.
Стандартная хэш есть от всех стандартныйх типов, и когда мы заводим std::unordered_map из ключа-значения, где ключ это стандартный тип, то у нас просто применяется std::hash от
этого типа.

Если в среднем распределение будет как бы неотличимым от случайного, тогда мы можем сказать что в среднем у нас будет insert, erase, find за O(1) (expected O(1)).

Тонкая вещь: expected O(1) это не тоже самое что амортизированное O(1). Это среднее не то среднее например как в векторе в push_back(), потому что амортизированное O(1) значит то,
что если много раз будем одну и туже операцию повторять, то в среднем одна операция из многих будет занимать O(1). Здесь в expected O(1) не так. Здесь нам может не повезти и все
операции будут долгими, несмотря на то что мы их уже очень много сделали. В expected O(1) среднее берётся не по количеству выполненых операций, а по возможным входам. Если мы 
выберем такую последовательность ключей, что она будет очень неудачной, и что хэш функция будет постоянно попадать в одно и тоже, всё будет очень долго работать, 
std::unordered_map не защищает от этого. Это очень маловероятно, но это возможно, если специально подобрать такую последовательность ключей, поэтому и говорят, что хэш функция
должна быть хорошей, потому что плохую хэш функцию можно сломать. Хорошая хэш функция криптографически безопасная. Криптографически безопасная означает то, что по значению value
вычеслительно трудно, кроме как полным перебором, вычеслить ключ Key который к нему привёл. Если хэш функция криптографически слабая, тогда можно по хэшу вычеслить достаточно 
быстро, те ключи, которые приводят к такому значению хэша, а тогда можно придумать последовательность ключей, которая постоянно попадает в один и тот же хэш и таким образом 
приложение будет зависать.

Вопрос: что делать если два ключа попали в одну и ту же ячейку (два ключа получили одинаковый хэш)? Даже если хэш функция хорошая, нам всё ровно может неповезти в какой то момент.
Данная ситуация называется коллизией. Если там уже лежит такой же ключ, то мы считаем что добавление неудачно, поскольку нельзя хранить два значения с одинаковым ключём. Но что 
делать если ключ индивидуальный, но хэш такой же и мы делаем insert. Т.е. хэш такой же, но ключ другой и в этой ячейку уже что то лежит? 

Здесь есть два принципиально разных подхода:
1) Метод открытой адресации: Это когда мы имеем ещё одну некую функцию, например g, которая каждой ячейке ставит в соответствие какую то другую ячейку. Т.е. для каждой ячейки
в каком то смысле определена следующая ячейка. С выбором реализации этой функции можно много что придумать, однако самое базовое это просто брать буквально следующую ячейку по
номеру в контейнере. Т.е. если мы видем, что текущая ячейка занята, то мы просто идём в следующую, пока мы не найдём свободную ячейку, и кладём значение туда. Однако в этом 
случае автоматически усложняется поиск: когда нам говорят find, мы вступаем на ячейку, и идём к следующим ячейкам пока не увидим пустую, и только тогда уже если мы не нашли, то
мы можем утверждать что ключа небыло. Удаление теперь тоже усложняется: если мы делаем удаление, то нам нельзя просто опустошить ячейку, потому что возможно за ней лежал ключ, к
которму мы могли придти. Теперь при удалении нам нужно не опустошать ячейку, а ставить специальный флажок, что ячейка erasted. Т.е. у нас пустота это не пустота теперь, а наличие 
этого флага, что здесь было удалено. Значения в этой ячейке уже не будет, но при поиске мы будем проходить дальше мимо этой ячейки, потому что за ней может быть лежит то что мы 
ищем. 

Понятно что так долго продолжаться не может, рано или поздно хэш-таблица станет слишком большой, тогда нам придётся увеличить N и сделать рехэш, т.е. переложить все ключи заново в
таблицу за линейное время. N не плохо выбирать так, чтобы они были какими нибудь например простыми числами, например заранее захардкодим последовательность простых чисел каждое из
котоых в 2 или 3 раза больше чем предыдущее, которые когда кол-во ключей в таблице становится слишком большим по сравнению с размером таблицы, например половины от размера таблицы
(это к примеру), мы выбирали следующее простое число и делали рехэш. Простые числа мы выбираем потому что, если мы будем например выбирать степени 2-ки постоянно увеличивающиеся,
то у нас взятие по модулю N оно не особо будет чтото менять и все старые цепочки мы не порушим, а вот при взятии другого простого числа, у нас все старые чепочки разрушаться и мы
всё перемешаем заново рандомным образом и новые цепочки будут гараздо короче. 

Есть много способов как сделать это ещё умнее, например есть хэш кукушки, в который у нас есть одновременно 2-е хэш функции, мы вычисляем первую и вторую, и если хоть на одной из 
мест свободно то мы кладём туда, а если на обоих занято, то мы пытаемся переложить из одного на альтернативное место, чтобы освободить себе место, и т.д. Короче много способов 
есть по решению коллизий.

2) Метод цепочек: Именно так сделано в std::unordered_map. Мы в каждой вершине храним связный список или вектор:

	0				    N
	|---|---|---|---|---|---|---|---|---|
	|   |	|   |	|   |   |   |   |   |
	|---|---|---|---|---|---|---|---|---|
			      |
			    /---\
			    |   | Node
			    \---/
			      |
			    /---\
			    |   |
			    \---/
			      |
			    /---\
			    |   |
			    \---/


Наивная реализация std::unordered_map

Полупсевдо код:
struct Node { // Почти тоже самое что Node красно-чёрного дерева
	pair<const Key, Value> kv;	// Пара ключ-значение
	...
};

vector <forward_list<Node>> arr;


Как теперь у нас работает вставка: мы идём в ячейку, затем проходим по forward_list, если такого ключа ещё нет, то делаем push_front() в forward_list.
В find мы тоже пробегаем по всему forward_list.
erase мы тоже пробегаем по forward_list, и если нашли то удаляем по итератору.

Т.е. в первом приближении можно сказать что unordered_map это vector из forward_list, но это не так. Нам нужно итерироваться по unordered_map. Нам нужно поддержать форвард 
итератор на unordered_map, но этот итератор должен уметь обходить контейнер за O(n), где n это не число бакетов в векторе, а число элементов в контейнере.

Мы не можем обойтись такой конструкцией: vector <forward_list<Node>> arr и поддержать итератор, потому что мы должны обходить unordered_map за O(кол-во лежащих в нём элементов).

Отступление:
В unordered_map есть метод reserve(n) - он грубо говоря этот массив раздувает до такого размера, чтобы в него все элементы легли хорошо без рехэша. Он увеличивает размер массива 
до такого размера, чтобы он смог туда положить n элементов не перевыделяя массив. Как он решает когда перевыделить массив? У него есть такое понятие load_factor и max_load_factor.
double load_factor() - это число, показывающее отношение кол-ва лежащих ключей к размеру этого массива. 
double max_load_factor - это число при привышение которого unordered_map решает что нужно сделать рехэш и переложить все элементы.
Можно сказать ged и set max_load_factor(). Если мы скажем например set_max_load_factor(2) - тогда у нас будет рехеш, если элементов мы положили более чем в 2-а раза больше чем n.
И когда мы вызываем рехэш, он смотрит какого размера у нас max_load_factor(), и подбирает n так, чтобы оно точно было не меньше, чем то, которое с учётом нынешнего 
max_load_factor() позволилио бы не делать рехэш. Например если у нас max_load_factor(2) и мы сделали reserve на миллион то он выберет нам число n не меньше 500 тысяч и + какое то 
эпселонт. Как именно он выбирает число это детали реализации. 

reserve() работает за expected O(n), но за ворст кейс n^2, т.е. ожидаемое время работы O(n), но если у нас был одиногромный бакет размера n, то reserve() будет работать за O(n^2). 

Когда мы делаем reserve(), то мы можем обойтись без пересоздания пар ключ-значение. 


reserve и rehash это две разные функции:

rehash - Рехеширование — это реконструкция хеш-таблицы: все элементы в контейнере > переставляются в соответствии с их хеш-значением в новый набор контейнеров. Этот > может изменить 
порядок элементов в контейнере.
reserve - Устанавливает наиболее подходящее количество блоков в контейнере (bucket_count) > содержать не менее n элементов.


Продолжим:
Представим что мы в unordered_map сделали reserve на миллион и положили туда 5 элементов и потом делаю обход итератором. Мне нужно чтобы это было за 5 шагов, а не за миллион. 
Понятно что в такой реализации: vector <forward_list<Node>> arr, этого не получится сделать. Если бы не итераторы, было бы намного проще, однако stl требует итераторы.
Если нам нужно написать свою хэш-таблицу мы можем написать и с такой реализацией, если нам не нужны итераторы, и это будет проще. Из-за итераторов std::unordered_map работает 
медленнее.


На самом деле нужно сделать один большой форвард лист:

			  //============================\\
			  ||				||
	0		  ||		    N           ||
	|-------|---|---|---|-------|---|---|           ||
	|     	| 3 |	| 1 |       | 2 |   |	Массив  ||
	|-------|---|---|---|-------|---|---|           ||
	         ||                  ||     		||
	 //======//	    //=======//           //====//
	 ||		    ||			  ||
     /---||--------\    /---||--------\       /---||--------\
     |	 \/	   |    |   \/	      |	      |   \/        |
     |	/-\   /-\  |    |  /-\   /-\  |       |  /-\   /-\  |
...--|->| |-->| |--|----|->| |-->| |--|-------|->| |-->| |--|-->...	Список
     |	\-/   \-/  |    |  \-/   \-/  |       |  \-/   \-/  |  
     |	Элементы   |    |	      |       |             |
     \-------------/    \-------------/       \-------------/
	 Бакет		    Бакет  		  Бакет


Теперь мы в ячейках храним указатели (по сути итераторы) на форвард лист. В пределах одного бакета(корзиночки) у нас лежат элементы с разными ключами, но с одинаковым хэшом.

Давайте поймём как работает find(): Когда нам говорят find(), мы идём в наш вектор(массив) и смотрим пустая ли ячейка или нет. В пустой лежит либо fake итератор ли nullptr.
Если в ячейке вектора мы храним просто один итератор на начало бакета то это плохо, потому что мы будем переберать все элементы списка. Но нам нужно понять, что бакет закончился.
Мы можем это понять когда хэш стал другим, но проблемо в том что вычислять хэш это долго. Поэтому в Node мы храним ещё и кэш:

struct Node { 
	pair<const Key, Value> kv;	
	uint64_t hash;			// Храним хэш
	...
};

vector <Node*> arr;			// Вектор 
 
Получается когда хэш поменялся, это означает что бакет закончился. Это не быстрее чем хранить второй итератор на конец бакета, но это решит некоторые проблемы. 


Как работает insert(): Также, мы проходимся по бакету, если там нет этого элемента, то мы просто в конец бакета вставляем этот элемент. Если ячейка в векторе пуста то мы кладём 
элемент в начало списка(форвард листа) и будем ссылаться на него. Он пока что будет единственным элементом бакета.


Как работает erase(): Вроде бы всё просто, но есть вопрос - как удалять начальный элемент бакета? На начальный элемент бакета ссылается предыдущий элемент, но как мы узнаем какой
конкретно, если это форвард лист? У нас есть указатель только на этот элемент, но нет указателя на предыдущий. Здесь есть два пути:
1) Простой путь - просто забить и сделать двусвязный список. Именно так сделано в msvc в реализации stl. Тогда у нас появится указатель на предыдущий элемент и всё просто.
2) llvm, gcc и clang решили не тратить лишний указатель. Представим что у нас есть unordered_set<int>. Хранить два указателя на каждый int это действительно перерасход. Чисто 
из-за того что нам нужно уметь удалять первую ячейку бакета, хранить дополнительный поинтер на каждый int это не правильно. Как сделано в настоящем стандартном unordered_map:
Давайте хранить указатель не на начало нашего бакета, а на конец предшетствующего:

			  //============================\\
			  ||				||
	0		  ||		    N           ||
	|-------|---|---|---|-------|---|---|           ||
	|    	| 3 |	| 1 |       | 2 |   |	Массив  ||
	|-------|---|---|---|-------|---|---|           ||
	          |                  ||     		||
  /---------------/ //===============//                 ||
  |	            ||	               //===============//
  |   	  /---------||--\    /---------||--\       /-------------\
  |   	  |	    \/  |    |         \/  |	   |             |
  |   	  |  /-\   /-\  |    |  /-\   /-\  |       |  /-\   /-\  |
  |   /---|->| |-->| |--|----|->| |-->| |--|-------|->| |-->| |--|-----\      	Список
  |   |	  |  \-/   \-/  |    |  \-/   \-/  |       |  \-/   \-/  |     |
  |   |   |  Элементы   |    |	           |       |             |     |
  |   |   \-------------/    \-------------/       \-------------/     |
  |   |      Бакет		 Бакет  	       Бакет           |
  |   |                                                                |
  |   |                                                                |
  |   |			/-\                                            |
  |   \-----------------| | <------------------------------------------/
  |                     \-/
  |         	     FakeNode
  |                      ^
  |                      |
  \----------------------/


Теперь обход итератором будет работать, просто проходим по форвард листу и всё. 
find() работает так: идём по указателю в ячейке массива, текущую Ноду игнорируем и сразу переходим на следующую вершину, и идём дальше пока не изменится хэш.

insert(): Если мы делаем insert() в начало или конец бакета то всё нормально - мы знаем какой указатель нужно обновить. Проблема если мы делаем insert() и это новый бакет. Если
мы делаем insert() нового бакета, то теперь у нас та ячейка массива которая раньше указывала на начало списка (на фейковую вершину), должна начать указывать на нашу новую вершину,
а наша новая ячейка должна указывать на начало списка (на фейковую вершину). Поскольку мы вызываем insert() как метод хэш-таблицы, мы знаем с чего начинается список (первый 
элемент листа), мы просто посмотрим какая нода первая и какой у неё хэш, по этому хэшу мы пойдём в массив и поймём какой ячейке нужно обновить указатель. Т.е. мы смотрим на старое
начало списка и понимаем какой здесь хэш, затем по этому хэшу переходим на ячейку в массиве(таблице) и понимаем какая ячейка соответствовала этому бакету, затем у этой ячейки 
обновляем указатель на новую ноду списка, которую мы разместили в самом начале списка. Фековая нода теперь указывает на эту новую ноду. А новая ячейка в массиве теперь будет 
указывать на фейковую ноду.


	 		          //============================\\
			          ||				||
	        0		  ||		    N           ||
	        |---|---|---|---|---|-------|---|---|           ||
	        | 4 |   | 3 |   | 1 |       | 2 |   |   Массив  ||
	        |---|---|---|---|---|-------|---|---|           ||
	          |       ||                 ||     		||
  /---------------/       ||   //============//                 ||
  |	                  ||   ||	          //============//
  |          //===========//   ||                 ||
  |          ||                ||                 ||
  |     /----||--\   /---------||--\    /---------||--\    /-------------\
  |     |    \/  |   |	       \/  |    |         \/  |	   |             |
  |     |   /-\  |   |  /-\   /-\  |    |  /-\   /-\  |    |  /-\   /-\  |
  |  /--|-->| |--|---|->| |-->| |--|----|->| |-->| |--|----|->| |-->| |--|-----\      	Список
  |  |  |   \-/  |   |  \-/   \-/  |    |  \-/   \-/  |    |  \-/   \-/  |     |
  |  |  |        |   |  Элементы   |    |	      |    |             |     |
  |  |  \--------/   \-------------/    \-------------/    \-------------/     |
  |  |   Новый            Бакет		     Бакет  	           Бакет       |
  |  |   Бакет                                                                 |
  |  |                                                                         |
  |  |  	         /-\                                                   |
  |  \-------------------| | <-------------------------------------------------/
  |                      \-/
  |          	     FakeNode
  |                       ^
  |                       |
  \-----------------------/


erase(): Если мы удаляем начало или середину бакета то всё нормально. Но как нам удалить последний элемент бакета? Нам нужно удалить последний элемент бакета, но на него указывает
какая-то ячейка из массива. Нам нужно чтобы теперь эта ячейка массива начала указывала на ноду, предыдущей той, которую мы хотим удалить. Для этого мы узнаём какая нода 
предыдущая, за счёт того, что мы уже прошли весь бакет, поскольку чтобы дойти до последней ноды текущего бакета, мы шли от последней ноды предыдущего бакета. Если в нашем бакете
был всего один элемент, то указатель на предыдущий бакет удаляется(nullptr). Для того чтобы узнать какая ячейка ссылается на нашу ноду которую нужно удалить, мы делаем шаг вперёд 
и переходим от неё в начало следующего бакета, считываем хэш, и по этому хэшу переходим на нужную ячейку массива. И теперь обновляем указатель этой ячейки на ноду, предыдущей ноде
которую нужно удалить, и удаляем ноду которую нужно удалить.   


Как делать рехэш? Что если нам нужно переалоцировать весь массив? При выполнении данной операции все бакеты полностью перестроются. По сути при рехэше хэш не меняется, меняется
только ячейка. Бакет меняется потому что хэш берётся по модулю размера. По сути рехэш это последовательный erase а затем insert по новой, мы просто идём по форвард листу и делаем
erase очередного элемента и insert его же в новый массив. Однако это не совсем erase и insert, это продвинутые erase и insert. Мы выцепляем веришну из форвард листа и вставляем
её в новый форвард лист, сохранив все значния, включая указатели, поэтому нам несовсем подходит стандартный форвард лист. Но при этом мы не пересоздаём пару ключ-значение, а это
означает что при рехэше мы НЕ инвалидируем укзатели и ссылки на элементы. В std::unordered_map не инвалидируются указатели и ссылки на элементы при insert и erase (если не был 
удалён тот самый элемент). Это неочивидное свойство. 

Инвалидируются ли итераторы при erase и insert? А что такое итератор в std::unordered_map? По стандарту итераторы в std::unordered_map инвалидируются.
Итератор это просто указатель на ноду. Но как например делать erase() по итератору? erase() по итератору делать тоже легко, потому что erase() это метод unordered_map, а 
unordered_map знает где у него всё и если unordered_map получает erase() по итератору, он сам знает где у него массив и всё это работает работает. Так что в итераторе всё ещё 
можно хранить просто указатель на ноду. Однако после insert() итераторы в std::unordered_map инвалидируется, но я пока не знаю почему хахахх.  
Так же при insert может произойти рехэш, из-за этого форвард лист может перестроиться и порядок элементов может нарушиться. Если произошёл рехэш то дальше итераторы считаются 
невалидными и обращаться к ним некорректно UB, хотя по факту в реализации ничего не мешает пользоваться ими дальше.


exception safety
Объявление класса std::unordered_map:
template <typename Key, typename Value, typename Hash, typename Equal> // typename allocator
В класс std::unordered_map мы можем передать кастомный хэшер(Hash), если мы делаем unordered_map где ключ это наш собственный тип, то нам нужно своя реализация хэша от него. Мы 
либо можем доопределить std::hash от этого кастомного типа и для этого в namespace std дописать специализацию шаблона std::hash. Это один из редких случаем когда нужно чтото
дописывать в namespace std, потому что по стандарту дописывать чтото в namespace std это UB, кроме ограниченного списка случаев, и вот это один из них. Либо написать кастомный хэш
и предать его в unordered_map. Так же мы можем передать кастомный компоратор (Equal). Как в обычно std::map у нас был кастомный оператор меньше, а здесь у нас кастомный оператор 
равно. Когда ключи считаются равными? По умолчанию используется std::equal_to, который просто вызывает == от них, но мы можем задать свой кастомный признак равенства ключей.

Предположим что мы делаем рехэш, то здесь Hash и Equal могут кинуть исключения. Если мы просто делаем insert, erase или find без рехэша то всё нормально, это легко обработается, 
даже если хешер или компоратор кинул исключения, мы ещё ничего не успели вставить, даже если чтото успели алоцировать то мы это удалим. Но что если мы делаем рехэш и пока мы его 
делаем, ктото кидает исключение? А нужен ли нам вообще ктото из них пока мы делаем рехэш, ведь мы храним хеш в ноде. Мы можем ниразу не вызывать хешер пока делаем рехэш, потому 
что мы сохранили хэши для всех нод, и перекладывая их в новый список, мы будем просто по модулю заново брать, но не будем сам хэш вызывать. Компоратор нам тоже не нужен при 
рехэше, потому что нам не нужно сравнивать ключи на равенство, т.к. все ключи так различны заведомо, их не нужно сравнивать. Сравнение нужно когда мы ищем такой ключ при erase 
например, но на момент начала рехеша мы уже могли убедиться что все ключи разные. Т.е. не хешер ни компоратор не доставляют нам проблем если мы делаем рехэш. Конструкторы 
Key, Value при рехэше мы не вызываем тоже, потому что мы только ноды списка переставляем, нам не приходится не копировать не перемещать ни какие Key, Value когда мы делаем рехэш.

В стандарте указаны условия для гарантирования exception safety в std::unordered_map.


______________________________________________________________________________________
Теория: разница между map и unordered_map

https://www.geeksforgeeks.org/map-vs-unordered_map-c/


Разница:
	      |         map		  | unordered_map
--------------|---------------------------|---------------------
Сортировка    |Сортировка по возрастающему| Нет сортировки
	      |порядку ключей 		  |
	      |(по умолчанию) 		  |
--------------|---------------------------|----------------------
Реализация    |Самобалансирующееся дерево | Хеш-таблица
	      |двоичного поиска например, |
	      |"Красно-черное дерево".	  |	
--------------|---------------------------|----------------------
время поиска  |	  	log(n)  	  | O(1) -> среднее
	      |				  | O(n) -> Худший случай	
--------------|---------------------------|----------------------			
Время вставки | log(n) + Перебалансировка | O(1) -> среднее
	      |				  | O(n) -> Худший случай
--------------|---------------------------|----------------------
Время удаления| log(n) + Перебалансировка | O(1) -> среднее
	      | 			  | O(n) -> Худший случай


Используйте std::map, когда:
- 

Вам нужны упорядоченные данные.
- 
Вам придется печатать/получать доступ к данным (в отсортированном порядке).
- 
Вам нужны предшественники/преемники элементов.
- 
Другие примеры смотрите в разделе Преимущества BST над Hash Table. https://www.geeksforgeeks.org/advantages-of-bst-over-hash-table/


Используйте std::unordered_map, когда:
- 

Вам нужно вести подсчет некоторых данных (пример - строки), и упорядочивание не требуется.
- 
Вам нужен доступ к одному элементу, т.е. без обхода.




______________________________________________________________________________________
Stack | Адаптеры контейнеров

В STL существует 3 адаптера: Stack, queue (очередь), priority qoeue(очередь с приоритетом). Их особенность в том, что они не являются самостоятельными контейнерами в STL, они
являются адаптерами для контейнеров.

Принцип Стека: В Стеке тот элемент, который был добавлен в стек самым последним, будет извлечён самым первым (положить в  ящик). Для реализации этого принципа мы можем выбрать 
как базой абсолютно любую динамическую структуру данных (и вектор и лист и дек). И в веторе и в листе и в деке мы можем итерироваться по элементам, добавлять и удалять 
элементы в любом место контейнера. Но если мы поверх всего этого функционала для любого их этих контейнеров, наложим правила стека, ограничим функционал, таким образом мы 
любой из этих контейнеров адаптируем под стек. И разница будет в том, что стек будет по разному себя вести в плане быстродействия, если в его основу был положен тот или иной 
контейнер. В с++ stack, queue, priority qoeue реализованы т.о., что они как бы ограничивают функционал, того контейнера, который был положен в их основу, только лишь теми 
методами, которые доступны в стеке или очереди (в зависимости что выберешь). Получается адаптеры над контейнерами умеют переадресовывать свои методы в методы соответствующего 
контейнера.


#include <stack> //Подключаем стек

stack<int> st;

st.push(1); //Создаёт копию объекта, затем эту копию переносит в коллекцию. Сложность: Равно сложности метода push_back контейнера основы.
st.push(2);

st.emplace(3); //Создаёт объект, который мы помещаем в стек, непосредственно в коллекции (без копировани, значит быстрее). Сложность: Равно сложности метода emplace контейнера основы.

st.size(); // Сложность: константа.

st.empty(); // Сложность: константа.

st.pop(); //Извлекает (удаляет) последний (самый верхний) элемент стека (не возвращает ничего). Сложность: Равно сложности метода pop_back контейнера основы.

st.top(); //Просмотор последнего элемента в стеке (возвращает ссылку на последний элемент, не удаляя его). Сложность: константа.


Прербор всех элементов циколм в стеке не возможен, итараторы тоже не работают, сама идея стека в том, чтобы смотреть только последний элемент.
Но вот вариант перебора всех элементов стека:
while (!st.empty()) {
    cout << st.top() << endl;
    st.pop();		//Удалять нужно полюбому, потому что цикл не успокоится, пока в стеке не останется элементов.
}


Под стек мы можем использовать вектор, лист и дек.

auto a = st._Get_container(); //Возвращает тот сырой контейнер, который был положен в основу стека.
cout << a[1] << endl; 	//Вывод второго элемента из извлечённого контейнера. С помощью этого метода при необходимости мы можем избавиться от всех ограничений стека. Извлечь 
			//оригинальный контейнер, который лежи в основе нашего стека и начань манипулировать с ним без ограничений.


Можно явно указать с каким контейнером будет работать стек:
stack<int, list<int>> st;


std::stack это шаблон, у которого первый параметр T, а второй это шаблонный параметр по умолчанию, который равен std::deque<T> :
template<typename T, typename std::deque<T>>

Второй параметр мы можем изменить на свой Это именно typename а не template. Это не шаблонный шаблонный параметр, а фиксированный тип. Мы бы могли написать стек на шаблонном 
контейнере и вторым параметром шаблона могли бы передавать шаблон а не typename, но тут передаётся именно typename с фиксированным T, потому что у контейнера может быть больше 
одного шаблонного параметра и мы заранее не знаем со сколькими шаблонными параметрами мы будем иметь дело. Можно было бы здесь конечно написать ... передав сюда шаблон с 
переменным кол-вом аргументов, однако вдруг там были бы аргументы разными(типами или числами).



______________________________________________________________________________________
queue | priority queue (очередь, очередь с приоритетом)

Так же как и стек, queue и priority queue являются адаптерами для контейнеров, а не самостоятельными контейнерами (оболочка). Под очередь могут быть адаптированы вектор, лист и
дек. Для очередей нет своей реализации, очереди просто основываются на одном из контейнеров, ограничивая функционал.

#include <queue> //Подключение библиотеки для queue и priority queue

Вектор не может быть основой для обычной очереди (только лист и дек). 

queue<int> q;
queue<int, list<int>> q; //При необходимости в начале указываем ещё и тип контейнера для адаптера. 

q.emplace(1); //Добавить элемент в очередь. Схож с методом push, однако не копирует элемент, а сразу создаёт. Сложность: Равно сложности метода emplace контейнера основы.

q.back(); //Доступ к последнему добавленному элементу в очереди. Получаем ссылку на элемент, можем посмотреть или изменить, но удалить нельзя. Сложность: константа.
q.front(); //Доступ к первому элементу в очереди. Получаем ссылку на элемент. Сложность: константа.

q.empty(); //Проверка на пустоту. Сложность: константа.

q.pop(); //Извлечь элемент (самый первый элемент будет извлечён). Сложность: Равно сложности метода pop_back контейнера основы.

q.size(); //размер очереди. Сложность: константа.

q.swap(); //Обмен содержимого одного адаптера с другим. Сложность: То же, что и базовый контейнер (обычно константа).

q._Get_container(); //Возвращает базовый контейнер, на котором основан адаптер


Очередь с приоритетом не может использовать лист (только вектор и дек). Тут нет метода q._Get_container();

q.top(); //Доступ к самому первому элементу очереди с приоритетом. Сложность: константа.

В STL реализован такой способ работы очереди с приоритетом, что при добавлении элементов, они сразу выстраиваются в очереди, и добавляются в очередь, согласно приоритету.
По умолчанию элементы выстраиваются от большего к меньшему: [0] 99, [1] 56, [2] 7, [3] 4.





______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________


Алгоритмы:

Алгоритмы STL это набор функций, которые призваны решать какие либо типичные задачи. 

В C++ Standard Template Library (STL) алгоритмы — это одна из самых мощных и полезных частей библиотеки. Они находятся в заголовочном файле <algorithm> (а некоторые дополнительные — в `<numeric>`). Всего в стандартной библиотеке 
более 100 алгоритмов!

Полный список всех алгоритмов:
https://en.cppreference.com/w/cpp/algorithm


Вот структурированный и полный обзор самых важных и часто используемых алгоритмов STL (по состоянию на C++20/C++23).



______________________________________________________________________________________
### 1. Неконстантные (изменяющие) алгоритмы

Эти алгоритмы изменяют элементы в диапазоне:



| Алгоритм                  | Что делает                                                                       | Пример использования 
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::copy                 | Копирует элементы из одного диапазона в другой                                   | auto it = std::copy(v.begin(), v.begin() + 5, v2.begin()); // копирует 5 элементов из v в v2
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::copy_if		    | Копирует с условием							       | std::copy_if(v.begin(), v.end(), v2.begin() + 5, [](int x){return x%2==0;}); // только чётные
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::copy_backward	    | Копирует элементы из одного диапазона в другой в обратном порядке,               | std::copy_backward(v.begin(), v.end(), v2.end()); // с конца
|                           | начиная с последнего                                                             |
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::move                 | Перемещает элементы (оставляет исходные в валидном, но неопределённом состоянии) |
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::transform            | Применяет функцию к каждому элементу и записывает результат                      | std::transform(v.begin(), v.end(), v.begin(), [](int x){ return x * x; }); // каждый в квадрат. Преобразование, умножение 
|                           |                                                                                  |                                                                       // на 2 и т.д. 
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::replace, replace_if  | Заменяет значения по значению или по предикату                                   | std::replace(v.begin(), v.end(), 4, 999); 	
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::fill, std::generate  | Заполняет диапазон значением или результатами генератора                         | std::fill(v.begin(), v.begin() + 5, 42);
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::remove, remove_if`   | «Удаляет» элементы (erase-remove idiom)                                          | v.erase(std::remove(v.begin(), v.end(), 5), v.end()); // Удаляем 5; 
|                           |                                                                                  | std::remove_if(v.begin(), v.end(), [](int x){return x > 50;}, 0); // удаляем нечётные
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::unique               | Убирает подряд идущие дубликаты (тоже с erase-remove) (после сортировки!)        | std::sort(v.begin(), v.end()); 
|                           |                                                                                  | v.erase(std::unique(v.begin(), v.end()), v.end()); // убирает подряд идущие дубли
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::reverse              | Разворачивает диапазон                                                           | std::reverse(v.begin(), v.end());
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::shuffle              | Перемешивает элементы (с RNG)                                                    | std::random_device rd;  
|                           |                                                                                  | std::mt19937 g(rd());
|                           |                                                                                  | std::shuffle(v.begin(), v.end(), g);
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::partition            | Разделяет на две группы по предикату                                             | auto is_even = [](int x){ return x % 2 == 0; }; 
|                           |                                                                                  | std::partition(v.begin(), v.end(), is_even); // чётные впереди, порядок внутри групп не сохранён; 
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::stable_partition     | Разделяет на две группы по предикату (stable сохраняет относительный порядок)    | std::stable_partition(v.begin(), v.end(), is_even); // порядок внутри групп сохранён
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::sort                 | Сортировка (быстрая)                                                             | std::sort(v.begin(), v.end()); 
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::stable_sort	    | Сортировка (устойчивая)  							       | std::stable_sort(v.begin(), v.end(), std::greater<>()); // по убыванию, сохраняя порядок равных
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::partial_sort         | Частичная сортировка (первые N элементов)                                        | std::partial_sort(v.begin(), v.begin() + 5, v.end()); // только первые 5 в порядке
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------
| std::nth_element          | Находит n-й элемент по порядку (очень быстро)                                    | std::nth_element(v.begin(), v.begin() + v.size()/2, v.end()); // медиана на своём месте
|---------------------------|----------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------


#########################
Подробнее про некоторые из них

______________________________________________________________________________________
std::copy | sstd::copy_if | Выборка данных по условию

Задача алгоритмов copy_if и copy скопировать все элементы из одной коллекции в другую, чтобы эти коллекции содержали в себе одинаковые элементы и были идентичны.

Синтаксис:
std::copy(Итератор указывающий на место начала копирования, Итератор указывающий на место конца копирования, коллекция в которую нужно копировать).

Каким образом можно выбрать определённое кол-во объектов в новую коллекцию, которые удовлетворяют каким то нашим условиям?

Синтаксис:
copy_if(Итератор указывающий на место начала копирования, Итератор указывающий на место конца копирования, коллекция в которую нужно копировать, предикат).

Пример:
class Person { //Класс студентов
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 						//Функтор предикат
		return p.score > 180;
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	vector<Person> people{								//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150),
		Person("Иван", 199)
	};

	vector<Person> res;								//Вектор для вывода результата
	
	copy_if(people.begin(), people.end(), back_inserter(res), [](const Person &p) { //Копируем элементы коллекции people, которые подходят по нашему предикату(условию), 
		return p.name == "Иван";						//заданному лямбда функцией, в вектор res.
	});
	cout << "Всего элементов:\t" << res.size() << endl;

	for (auto el : res) {
		cout << "Имя:\t" << el.name << "\tбаллы\t" << el.score << endl;
	}
	return 0;
}


______________________________________________________________________________________
std::remove | std::remove_if  удаление элемента по условию

Алгоритмы std::remove  и std::remove_if удаляют все элементы подходящие под условия (даже если есть дублирующие элементы). На самом деле алгоритм std::remove ничего не удаляет. Все подходящие по условию элементы он оставляет в конце 
вектора (после всех неудалённых элементов), и возвращает итератор на позицию за последним не исключённым элементом. По сути мы нужные элементы собираем в одну сторону, а не нужные в другую.

Синтаксис:
std::remove(Итератор указывающий на место начала поиска для удаления, Итератор указывающий на место конца поиска для удаления, элемент который хотим удалить).

Пример:
vector<int> v = { 5,9,1,46,4,9,4 };		//Вектор, в котором нужно удалить число 9
auto res = remove(v.begin(), v.end(), 9);	//Получаем итератор на первый элемент, который нужно удалить. Сейчас в векторе такой порядок: 5,1,46,4,4,9,9 (итератор на 1ой 9).
v.erase(res, v.end()); 				//Удаляем ненужные элементы. Вектор: 5,1,46,4,4


Синтаксис:
std::remove_if(Итератор указывающий на место начала поиска для удаления, Итератор указывающий на место конца поиска для удаления, предикат)

Пример:
Удалим все абитуриенов, баллы которых меньше 150.

class Person { //Класс студентов
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 					
		return p.score > 180;
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	vector<Person> people{								//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150),
		Person("Иван", 199)
	};

	auto res = remove_if(people.begin(), people.end(), [](const Person &p) { 	//Получаем итератор на границу между нужными и ненужными объектами.
		return p.score < 150;
	});

	people.erase(res, people.end());

	/* Второй вариант без промежуточной переменной res:
	people.erase(remove_if(people.begin(), people.end(), [](const Person &p) {
		return p.score < 150;
	});, people.end());
	*/

	cout << "Всего элементов:\t" << people.size() << endl;

	for (auto el : people) {
		cout << "Имя:\t" << el.name << "\tбаллы\t" << el.score << endl;
	}
	return 0;
}



______________________________________________________________________________________
std::unique

Каким образом мы можем решить задачу удаления ПОСЛЕДОВАТЕЛЬНО повторяющихся элементов, в какой либо коллекции. 

#include <algorithm> 

Синтаксис:
std::unique(итератор на начало коллекции, итератор на конец коллекции).

У нас есть массив. Наша задача избавиться от дубликатов, чтобы осталось по одному элементу с уникальным значением.

int arr[] = { 1,2,2,2,5,4,4 };

auto res = std::unique(std::begin(arr), std::end(arr));

std::for_each(std::begin(arr), res, [](int a) { 		//Вывод всех уникальных чисел
	cout << a << endl;
});

Размер статического массива мы не можем изменить, поэтому при выполнении этой функции у нас изменятся только их порядок. Т.е. в начале массива у нас будут уникальные числа, а в
конце ненужные не уникальные. Возвращает итератор на начало ненужных чисел. Изменить кол-во элементов таким способом мы можем только с контейнерами STL:

vector<int> v = { 1,2,2,2,5,4,4 };

auto res = std::unique(std::begin(v), std::end(v));
	
v.erase(res, std::end(v)); 



Алгоритм std::unique_copy схож с std::unique, но во отличие от него он позволяет скопировать элементы в новый контейнер:

Синтаксис:
std::unique_copy(итератор на начало коллекции, итератор на конец коллекции, коллекция куда копировать значения).

std::vector<int> v = { 1,2,2,2,5,4,4 };
std::vector<int> v2;
	
std::unique_copy(std::begin(v), std::end(v), std::back_inserter(v2)); //Копируем в v2 все уникальные числа.


Коментарии под видео:

Если я не прав исправьте меня.
На самом деле при выполнении алгоритма std::unique "нужные"(уникальные) элементы копируются вместо "ненужных"(дубли) по очереди в том порядке как они расположены в контейнере. То 
есть "ненужные" элементы не перемещаются в конец контейнера, а просто заменяются на "нужные". То есть "ненужный" хвост контейнера ПОСЛЕ применения std::unique равен хвосту 
контейнера ДО применения unique. Например, vector<int> v = { 1,2,2,2,4,    4,4,4,8,8,8,5,4,4 } после unique будет выглядеть {1,2,4,8,5, "ненужный" хвост -> 4,4,4,8,8,8,5,4,4}. 
Примерно так же ведет себя алгоритм std::remove.

но он не подходит усли вам нужно сохранить порядок и не работает если числа идут не последоватьльно, тоесть {2,3,5,2,7,6} - 2йки не пропадут) не работает! нужно что б они 
последоватьльно шли)



______________________________________________________________________________________
Отсортировать массив в случайном порядке | std::shuffle | std::random_shuffle

std::shuffle (С++11)


#include <algorithm>
#include <random>
#include <vector>
#include <iostream>

int main() {
    std::vector<int> cards = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // Инициализация генератора
    std::random_device rd;
    std::mt19937 gen(rd());
    
    // Современный способ перемешивания
    std::shuffle(cards.begin(), cards.end(), gen);
    
    for (int card : cards) {
        std::cout << card << " ";
    }
    return 0;
}


Пример с детерминированным перемешиванием

#include <algorithm>
#include <random>
#include <vector>

void deterministic_shuffle() {
    std::vector<int> data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // Фиксированный seed для воспроизводимости
    std::mt19937 gen(42);  // seed = 42
    
    std::shuffle(data.begin(), data.end(), gen);
    // Результат будет одинаковым при каждом запуске
}




##########################
std::random_shuffle



Синтаксис:
std::random_shuffle(итератор на начало коллекции, итератор на конец коллекции).

!!!!
std::random_shuffle УДАЛЁН В C++17. ИСПОЛЬЗУЙТЕ std::shuffle 


#include <ctime>
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	setlocale(LC_ALL, "Russian");
	
	int arr[] = { 1,2,3,4,5 };

	srand(time(NULL));

	random_shuffle(begin(arr), end(arr)); 		//Рандомное перемешивание элементов в коллекции.

	for (auto el : arr)
	{
		cout << el << " ";
	}

	return 0;
}


Рандомный порядок вызова переопределённого метода классов:

class IAction {						//Виртуальный класс
public:
	virtual void Action() = 0;
};

class CatAction : public IAction {			//Переопределение виртуального метода класса
	virtual void Action() override {
		cout << "Гладим кота" << endl;
	}
};

class TeaAction : public IAction {
	virtual void Action() override {
		cout << "Пьём чай" << endl;
	}
};

class DogAction : public IAction {
	virtual void Action() override {
		cout << "Гуляем с собакой" << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	srand(time(NULL));

	IAction *arr[] = 
	{ 
		&CatAction(),
		&TeaAction(),
		&DogAction()
	};

	random_shuffle(begin(arr), end(arr)); 		//Рандомное перемешивание элементов в коллекции.

	for (auto &el : arr) {
		el->Action();
	}

	return 0;
}


##########################
Почему std::shuffle лучше

1. Контроль над генератором

// Можно использовать разные генераторы
std::mt19937 gen1(rd());        // Mersenne Twister
std::minstd_rand gen2(rd());    // Линейный конгруэнтный
std::ranlux24 gen3(rd());       // RANLUX

std::shuffle(vec.begin(), vec.end(), gen1);


2. Воспроизводимость

// Для тестов - одинаковый результат каждый раз
std::mt19937 gen(12345);  // фиксированный seed
std::shuffle(test_data.begin(), test_data.end(), gen);


3. Лучшее качество случайности

std::mt19937 имеет:
- Большой период (2^19937 - 1)
- Равномерное распределение
- Высокую производительность




______________________________________________________________________________________
STL Алгоритмы сортировки | Бинарный предикат | Лямбда функции

std::sort(Итератор указывающий на место начала сортировки, Итератор указывающий на место конца сортировки, бинарный предикат (если нужен));

Пример сортировки по умолчанию:

std::vector<int> v = { 9,4,94,6,1,3,7 };
std::sort(v.begin(), v.end());		          //1,3,4,6,7,9,94


Пример сортировки с предикатом: В данном случае предикат сортирует элементы вектора в порядке уменьшения.

bool MyPred(int a, int b){
	return a > b;
}

int main()
{

	std::vector<int> v = { 9,4,94,6,1,3,7 };
	std::sort(v.begin(), v.end(), MyPred);		//94,9,7,6,4,3,1	
	
	return 0;
}


Функция MyPred может больше нигде не использоваться в коде, поэтому логично использовать для неё лямбда функцию.

int main()
{
	std::vector<int> v = { 9,4,94,6,1,3,7 };
	std::sort(v.begin(), v.end(), [](int a, int b) 
		{
			return a > b;
		});
	
	return 0;
}


Сортировка обычного массива (не контейнера STL): Имя массива это указатель на его первый элемент. С помощью арифметики указателей можем указать и на последний элемент.

int main()
{
	const int size = 7;
	int arr[size] = { 9,4,94,6,1,3,7 };

	std::sort(arr, arr + size);			//Указатель на первый элемент массива + его размер = указатель на последний элемент массива.
	
	return 0;
}


Реальная задача: У нас есть коллекция людей с баллами по егэ. Нужно их отсортировать.

class Person { 
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 							//Функтор предикат
		return p.score > 180;
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	vector<Person> people{									//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150)
	};

	std::sort(people.begin(), people.end(), [](const Person &p1, const Person &p2) {		//Сортировка в которой лямбда функция на месте предиката
			return p1.name < p2.name; 						//Сортировка по имени
			//return p1.score > p2.score; 						//Сортировка по баллам
	});

	for (auto el : people){									//Вывод в консоль
		cout << "Имя:\t" << el.name << "\tбаллы\t" << el.score << endl;
	}
	return 0;
}






______________________________________________________________________________________
### 2. Константные (не изменяющие) алгоритмы

Не меняют элементы, только читают:


| Алгоритм                             | Что делает                                         |
|--------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------
| std::find, find_if, find_if_not      | Линейный поиск                                     | auto pos = std::find(v.begin(), v.end(), 42); 
|                                      |                                                    | auto pos2 = std::find_if(v.begin(), v.end(), [](int x){return x > 100;});
|--------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------
| std::count, count_if                 | Подсчёт количества элементов                       | int cnt = std::count(v.begin(), v.end(), 5); 
|                                      |                                                    | int even_cnt = std::count_if(v.begin(), v.end(), is_even);  
|--------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------
| std::all_of, std::any_of,            | Проверка условия для всех/хотя бы одного/ни одного | bool result = std::all_of(v.begin(), v.end(), [](int x) {return x % 2 == 0;});
| std::none_of                 (C++11) |                                                    |
|--------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------
| std::equal                           | Сравнение двух диапазонов                          | bool result1 = std::equal(v1.begin(), v1.end(), v2.begin()); // Можно сравнивать разные контейнеры, например std::vector<int> и std::list<int>
|--------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------
| std::mismatch                        | Находит первое различие                            | auto result = std::mismatch(v1.begin(), v1.end(), v2.begin()); // Находим первую позицию, где элементы отличаются
|--------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------
| std::search                          | Поиск подпоследовательности                        | vector<int> pattern = {3, 4, 5}; 
|                                      |                                                    | auto found = std::search(v.begin(), v.end(), pattern.begin(), pattern.end()); 
|--------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------
| std::find_first_of                   | Поиск любого из нескольких значений                | std::string text = "Hello, World!"; 
|                                      |                                                    | std::string vowels = "aeiouAEIOU"; 
|                                      |                                                    | auto it = std::find_first_of(text.begin(), text.end(), vowels.begin(), vowels.end()); // Ищем первую гласную букву в строке
|--------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------
| std::adjacent_find                   | Поиск двух подряд идущих одинаковых элементов      | auto adj = std::adjacent_find(v.begin(), v.end()); // первый подряд идущий дубликат  
|--------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------
| std::binary_search                   | Бинарный поиск (только на отсортированных!)        | std::sort(v.begin(), v.end()); 
|                                      |                                                    | bool has7 = std::binary_search(v.begin(), v.end(), 7);  
|--------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------
| std::lower_bound                     | Находит первый элемент, который не меньше          | std::sort(v.begin(), v.end()); 
|                                      | заданного значения                                 | auto lb = std::lower_bound(v.begin(), v.end(), 5); // первый >= 5 
|--------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------
| std::upper_bound                     | Находит первый элемент, который строго больше      | std::sort(v.begin(), v.end()); 
|                                      | заданного значения                                 | auto ub = std::upper_bound(v.begin(), v.end(), 5); // первый > 5 
|--------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------
| std::equal_range                     | Возвращает пару итераторов, представляющих         | auto [l, u] = std::equal_range(v.begin(), v.end(), 5);  // пара lb + ub 
|                                      | диапазон [lower_bound, upper_bound)                |
|--------------------------------------|----------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------


#########################
Подробнее про некоторые из них



______________________________________________________________________________________
STL алгоритмы поиска | std::find | std::find_if | std::find_if_not

std::find позволяет узнать присутствует ли в какой то коллекции какой то конкретный элемент.

Синтаксис:
std::find(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска, значение которое нужно найти). Возвращает итератор на место найденного элемента, или итератор на конец коллекции если элемент не найден.

Пример:
std::vector<int> v = { 6,4,4,12,1,2,7 };

auto res = std::find(v.begin(), v.end(), 12); 	//res это итератор, который хранит указатель, который указывает на наш элемент.

if (res == v.end()) {				
	cout << "Число не найдено" << endl;
}
else {
	cout << "Число найдено" << endl;
}


Метод std::find не гибкий, он может проверять элементы в коллекции только на равенство с тем элементом, который мы передаём в качестве 3его параметра. Если мы хотим найти элемент по 
другому принципу, нам нужно использовать методы std::find_if и std::find_if_not.

Синтаксис:
std::find_if(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска, предикат)

Пример:
Есть ли в коллекции вообще чётные числа?:

std::vector<int> v = { 6,4,4,12,1,2,7 };

auto res = std::find_if(v.begin(), v.end(), [](int a) { //Предикат с помощью лямбда выражения
	return a % 2 == 0;
});

if (res == v.end()) {
	cout << "Число не найдено" << endl;
}
else {
	cout << "Число найдено" << endl;
}
return 0;


std::find_if_not тоже самое что и std::find_if, только инвертированное (он возвращает true если предикат возвращает false).



Пример работы с более сложным типом данных:

class Person { //Класс студентов
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 						//Функтор предикат
		return p.score > 180;
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	std::vector<Person> people{								//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150)
	};

	auto res = std::find_if(people.begin(), people.end(), [](const Person &p) {
		return p.name == "Маша";						//Ищем человека с именем Маша
		//return p.name == "Маша" && p.score == 179; 				//Пример двойного условия	
	});

	if (res == people.end()) {
		cout << "Не найдено" << endl;
	}
	else {
		cout << "Найдено" << endl;
	}
	return 0;
}

Преимущество в том что мы можем гибко настраивать параметры поиска. Недостаток в том что мы можем вернуть только один элемент. Если в коллекции два элемента подходящие по 
условию, то вернётся только первый попавшийся.




______________________________________________________________________________________
STL Подсчёт чего либо в коллекции | std::count

Синтаксис:
std::count(Итератор указывающий на место начала подсчёта, Итератор указывающий на место конца подсчёта, константное значение любого типа)

std::vector<int> vec = {-1, 1, -2, 2, -3, 3, 1};			// Вектор
std::cout << std::count(vec.begin(), vec.end(), 1) << std::endl;	// Ищем в векторе кол-во единиц. Результат: 2


Синтаксис:
std::count_if(Итератор указывающий на место начала подсчёта, Итератор указывающий на место конца подсчёта, предикат подсчёта). 



Пример:

bool GreaterThenZero(int a) { 		//Предикат отвечающий на вопрос больше ли наше число чем ноль. 
	return a > 0;			//Если предикат возвращает true то счётчик count_if увеличивается.
}

int main()
{
	setlocale(LC_ALL, "Russian");
	
	std::vector<int> v = { 1,-2,-55,9,-3,8 };

	int res = std::count_if(v.begin(), v.end(), GreaterThenZero); //Алгоритм STL, который может подсчитать что либо в коллекции

	std::cout << res << std::endl; //Выведет число 3. Т.е. std::count_if подсчитал, что в нашей коллекции v есть три числа, отвечающие требованиям предиката GreaterThenZero.
	
	return 0;
}




______________________________________________________________________________________
std::equal и std::mismatch | Сравнение массивов

Алгоритмы STL могут работать с различными контейнерами, также и с двумя различными контейнерами в одном алгоритме одновременно, например сравнивать элементы массива и вектора или вектора и листа и т.д. Сравнение идёт по элементно. 
Т.е. если даже сумма двух коллекций равна, но значения элементов отличаются, то коллекции считаются разными.

#include <algorithm> //Для работы с алгоритмами STL

std::equal - сравнение двух контейнеров через оператор равенства. Если в собственном типе данных не перегружен оператор равенства, то не получится вычислить корректный ответ. Но в этом случае вы можете использовать предикат, 
и указывать конкретно по какому полю нужно сравнить эти две последовательности.

Синтаксис:
std::equal(итератор на начало первой коллекции, итератор на конец первой коллекции, итератор на начало второй коллекции, итератор на конец второй коллекции, предикат).

int arr[] = { 10,3,4,5,7,11 }; 
std::vector<int> arr2 = { 10,3,4,5,7,11 };  

bool res = std::equal(std::begin(arr), std::end(arr), std::begin(arr2), std::end(arr2)); //Сравнение двух коллекций.

std::cout << res << std::endl;


std::mismatch - тоже проверяет на равенство две последовательности, тоже может работать с разными типами последовательностями, но работает несколько иначе: По мимо проверки последовательностей на равенство, если он нашёл элементы, 
которые не равны, он ещё и возвращает пару итераторов, которые указывают на эти элементы, т.е. мы ещё можем посмотреть какие конкретно элементы не равны. Если коллекции равны, то в ответе вернётся пара итераторов, указывающих на 
концы своих коллекций (end).

Синтаксис:
std::mismatch(итератор на начало первой коллекции, итератор на конец первой коллекции, итератор на начало второй коллекции, итератор на конец второй коллекции).

int arr[] = { 10,3,4,5,7,11 }; 
std::vector<int> arr2 = { 10,3,4,5,7,11 }; 

auto res = std::mismatch(std::begin(arr), std::end(arr), std::begin(arr2), std::end(arr2));

if (res.first == std::end(arr) && res.second == std::end(arr2))						// Если коллекции равны
	std::cout << "+" << std::endl;
else {												        // если коллекции не равны
	std::cout << "-" << std::endl;
	std::cout << "result.first:\t" << *res.first << "\t result.second:\t" << *res.second << std::endl;
}



############################
std::equal predicate

Мы можем использовать вместе с алгоритмом std::equal бинарный предикат. Если в классе не переопределён опереатор сравнения, мы всё ровно можем сравнить объекты классов, используя лямбда функцию и опиывая в ней логику сравнения.

class Point {													//Класс
public:
	Point(int x, int y) {
		this->x = x;
		this->y = y;
	}
	int x, y;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	std::vector<Point> arr{											                        //Первая коллекции
		Point(1,3), Point(4,5), Point(5,7)
	};
	std::vector<Point> arr2{
		Point(1,3), Point(4,5), Point(5,7)								                        //Вторая коллекция
	};

	bool res = std::equal(std::begin(arr), std::end(arr), std::begin(arr2), std::end(arr2), [](const Point &p1, const Point &p2) { 	//Сравнение двух коллекций
		return p1.x == p2.x && p1.y == p2.y;
	});
		
	std::cout << res << std::endl;											                //Вывод результата

	return 0;
}




______________________________________________________________________________________
### 3. Алгоритмы работы с кучей (heap)

Куча — это специальная древовидная структура данных, которая удовлетворяет свойству кучи: родитель >= потомков (корень — максимальный элемент) или min-heap: родитель <= потомков (корень — минимальный элемент). 
В STL по умолчанию создается max-heap. 

Для элемента с индексом i: Левый потомок равняется: 2*i + 1, правый потомок 2*i + 2, а родитель: (i-1)/2

Если нужна готовая реализация кучи, то просто можно использовать std::priority_queue.

Преимущества куч:
- Эффективные операции — O(log n) для вставки/удаления
- Быстрый доступ к экстремуму — O(1) для доступа к min/max
- Гибкость — можно реализовать как min-heap, так и max-heap

Кучи широко используются в алгоритмах (heapsort, Dijkstra, Huffman coding) и системах, где нужен эффективный доступ к экстремальным элементам.


| Алгоритм                     | Описание                                               |
|------------------------------|--------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------
| std::make_heap               | Преобразует диапазон в кучу за время O(n)              | std::make_heap(v.begin(), v.end()); 
|------------------------------|--------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------
| std::push_heap               | Добавление элемента в кучу                             | v.push_back(99); 
|                              |                                                        | push_heap(v.begin(), v.end()); // Добавляем новый элемент в конец а затем восстанавливаем свойства кучи
|------------------------------|--------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------
| std::pop_heap		       | Перемещает максимальный (или минимальный, для min-кучи)| std::pop_heap(v.begin(), v.end()); // Это позволяет безопасно удалить элемент, не разрушая «кучу».
|                              | элемент из «кучи» в конец диапазона                    | v.pop_back();                         
|------------------------------|--------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------
| std::sort_heap               | Сортирует кучу (после этого она перестаёт быть кучей)  | std::sort_heap(v.begin(), v.end());      // это алгоритм завершает работу с кучей, преобразуя её в отсортированную диапазон. Использует 
|                              |                                                        |                                          // алгоритм сортировки heapsort
|                              |                                                        |                                          // Важно: контейнер должен уже быть кучей  
|------------------------------|--------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------               
| std::is_heap                 | Проверяет, является ли диапазон валидной кучей         | bool is_valid = std::is_heap(valid_heap.begin(), valid_heap.end()); // Проверяет, является ли диапазон валидной кучей.
|------------------------------|--------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------
| std::is_heap_until           | Находит первый элемент, который нарушает свойство кучи | auto it = std::is_heap_until(data.begin(), data.end());
|------------------------------|--------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------






______________________________________________________________________________________
### 4. Мин/макс и сравнения

| Алгоритм                     | Описание                                               |
|------------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::min, std::max           | Минимум/максимум (есть версии для initializer_list)    | int a = 10, b = 5; int min_val = std::min(a, b);       
|                              |                                                        | int min_val = std::min({10, 5, 8, 3, 12, 7});    // Находим минимальное из нескольких значений. Возвращает ссылку на минимальный элемент(std::max 
|                              |                                                        |                                                  // тоже возвращает ссылку)
|------------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::minmax		       | Возвращает пару минимальное и максимальное значение    | int a = 10, b = 5; auto result = std::minmax(a, b);  
|------------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::min_element,            | Поиск в диапазоне                                      | auto min_it = std::min_element(numbers.begin(), numbers.end());                // Находим минимальный элемент;   
| std::max_element,            |                                                        | auto [min_it, max_it] = std::minmax_element(numbers.begin(), numbers.end());   // Находим минимальный и максимальный элементы за один проход
| std::minmax_element          |                                                        |
|------------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------


#########################
Подробнее про некоторые из них


______________________________________________________________________________________
Поиск максимального элемента | std::max_element

// Синтаксис
std::max_element(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска)

Возвращает итератор на наибольший элемент в коллекции.

std::vector<int> v = {10,1,-55,11,13,58};			// Наша коллекция

auto res = std::max_element(v.begin(), v.end()); 		// Получаем итератор на наибольшее число коллекции
	
std::cout << *res << std::endl;					//Чтобы получить число а не сам итератор, итератор нужно разыменовать.



Если мы работаем не с контейнерами STL.

const int size = 6;					// Размер статического массива
int arr[size] = {10,1,-55,11,13,58};			// Его определение

auto res = std::max_element(arr, arr + size); 		// Имя массива это указатель на его первый элемент. С помощью арифметики указателей, мы можем указать и на последний элемент массива (arr + size).
							

std::cout << *res << std::endl;	//Чтобы получить число а не сам итератор, итератор нужно разыменовать.



______________________________________________________________________________________
Поиск минимального элемента | std::min_element

// Синтаксис
std::min_element(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска)

Возвращает итератор на наименьший элемент в коллекции.


##################
Одновременный поиск и максимального и минимального элементов.

// Синтаксис
std::minmax_element(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска)

Возвращает пару значений итераторов, указывающих на минимальный и максимальный элементы.

const int size = 6;
int arr[size] = {10,1,-55,11,13,58};

auto res = std::minmax_element(arr, arr + size); 

std::cout << "min = "<< *res.first << " max = "<< *res.second << std::endl;	//Чтобы получить число а не сам итератор, итератор нужно разыменовать.





______________________________________________________________________________________
### 5. Перестановки (permutations) Важный!



| Алгоритм                        | Описание                                               |
|---------------------------------|--------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------
| std::next_permutation           | Следующая лексикографическая перестановка              | std::string str("ABC"); 
|                                 |                                                        | std::sort(str.begin(), str.end()); 
|                                 |                                                        | bool b = std::next_permutation(str.begin(), str.end());    // генерирует следующую лексикографическую перестановку и возвращает true - если 
|                                 |                                                        |                                                            // следующая перестановка существует и false - если перестановки закончились 
|                                 |                                                        |                                                            // (последняя перестановка). // Важно: сначала отсортировать для получения всех 
|                                 |                                                        |                                                            // перестановок. В данном случае следующая перестановка будет ACB, потом BAC, 
|                                 |                                                        |                                                            // потом BCA, CAB, CBA. Всего: 6 перестановок.
|---------------------------------|--------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------
| std::prev_permutation           | Предыдущая                                             | std::string str("ABC"); 
|                                 |                                                        | std::sort(str.begin(), str.end()); 
|                                 |                                                        | bool b = std::prev_permutation(str.begin(), str.end());
|---------------------------------|--------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------
| std::is_sorted, is_sorted_until | Проверка отсортированности                             | std::is_sorted(v.begin(), v.end()); // проверка отсортированности; 
|                                 |                                                        | std::is_sorted_until(v.begin(), v.end()); // находит первый элемент, нарушающий порядок
|---------------------------------|--------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------




______________________________________________________________________________________
### 6. Алгоритмы из <numeric>


| Алгоритм                   | Описание                                               |
|----------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::accumulate            | Сумма (или любая другая бинарная операция)             | int sum = std::accumulate(v.begin(), v.end(), 0); // Простое суммирование; 
|                            |                                                        | int product = std::accumulate(v.begin(), v.end(), 1, std::multiplies<int>()); // Произведение элементов 
|                            |                                                        | int sum_of_squares = std::accumulate(numbers.begin(), numbers.end(), 0, [](int acc, int x) { return acc + x * x; }); // Сумма квадратов
|----------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::reduce (C++17)        | Параллельная версия accumulate                         | int sum = std::reduce(v.begin(), v.end(), 0); 
|----------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::inner_product         | Скалярное произведение и обобщения                     | int result = std::inner_product(v1.begin(), v1.end(), v2.begin(), 0); // Стандартное скалярное произведение
|----------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::partial_sum           | Частичные суммы                                        | std::partial_sum(input.begin(), input.end(), result.begin()); // Вычисление частичных сумм
|----------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::adjacent_difference   | Разности соседних элементов                            | std::adjacent_difference(input.begin(), input.end(), result.begin()); // Вычисление разностей между соседними элементами
|----------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::iota                  | Заполняет последовательными значениями (как 1,2,3…)    | std::iota(numbers.begin(), numbers.end(), 10); // Заполняем последовательными значениями, начиная с 10
|----------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------


#########################
Подробнее про некоторые из них




______________________________________________________________________________________
std::accumulate | сумма и произведение элементов массива

Алгоритм std::accumulate очень гибкий инструмент, с помощью него можно многое вычислить. По умолчанию вычисляет сумму всех чисел в коллекции.

#include <numeric> // Подключение алгоритма accumulate

Синтаксис:
std::accumulate(Итератор указывающий на место начала коллекции, Итератор указывающий на место конца коллекции, к какому изначальному значению будут прибавляться все остальные 
	значения в коллекции (точка отсчёта), четвёртый параметр ниже).

Возвращает какой то конкретный результат (не итератор).

Важный момент это точка отсчёта. Она определяет тип возвращаемого значения (Если 0 то вернёт int, если 0.1 то вернёт double).

Пример:
std::vector<int> v = { 2,3,4 }; 

auto res = std::accumulate(v.begin(), v.end(), 0); // 0 + 2 + 3 + 4 = 9.

std::cout << res << std::endl; // res = 9.


Для коллекций не являющимися контейнерами STL (например статический массив), в место первого параметра нужно тоже передать указатель на начало и конец коллекции. Для массива это будет так: 
std::accumulate(имя массива, имя массива + его размер, 0). Однако мы не всегда знаем размер массива. Для этого есть альтернатива: В пространстве имён std доступны по отдельности функции std::begin() и std::end(). 
Их задача аналогична методам контейнеров в STL, однако они не привязаны к каким то конкретным коллекциям.

int arr[] = { 2,3,4 }; 				//Обычный статический массив

auto res = std::accumulate(std::begin(arr), std::end(arr), 0);


#########
Для изменения поведения алгоритама std::accumulate мы должны добавить четвёртый параметр - функцию, которая принимает два параметра и возвращает какое то значение.

Первый параметр хранит в себе текущее состояние при расчётах на момент выполнения алгоритма accumulate. Второй параметр - это тот элемент, который мы сейчас будем прибавлять.

Пример:
int arr[] = { 2,3,4 }; 

auto res = std::accumulate(std::begin(arr), std::end(arr), 1, [](int a, int b) { 		// Кастомный алгоритм.
	return a * b; 										// Получим перемножение всех элементов массива arr.
});

std::cout << res << std::endl;								        // res = 24 = 1 * 2 * 3 * 4.


Ещё один пример: Сумма всех чётных элементов.

int arr[] = { 2,3,4 }; 

auto res = std::accumulate(std::begin(arr), std::end(arr), 0, [](int a, int b) { 	// Кастомный алгоритм
	if (b % 2 == 0) 						                // Сумма всех чётных чисел
		return a + b;
	else
		return a;
});

std::cout << res << std::endl;


Пример работы с другим типом данных. У нас есть массив чисел, нам нужно сделать из них строку, разделив эти элементы между собой знаком +. Поскольку вернуть нам нужно строку то изменяем тип точки отсчёта на строку: 
std::to_string(arr[0]) // преобразует числовое значение в строку. Поскольку хранить теперь мы будем данные с типом строки, нам нужно изменить входящие в лямбда функцию параметры. Для того чтобы не включать в строку ответа первый 
элемент два раза, нам нужно использовать метод std::next(), который сдвигает итератор на шаг вперёд, чтобы функция std::accumulate  начинала работу со второго элемента.

int arr[] = { 2,3,4,5,6,7 }; 

auto res = std::accumulate(std::next(begin(arr)), end(arr), std::to_string(arr[0]), [](string a, int b) { 	// Кастомный алгоритм
	return a + "+" + std::to_string(b);
});

std::cout << res << std::endl;										        // res = "2+3+4+5+6+7"



______________________________________________________________________________________
std::reduce (C++17)

std::reduce — это алгоритм из стандартной библиотеки C++ (появился в C++17), который выполняет свертку (редукцию) элементов диапазона с помощью заданной бинарной операции.

std::reduce похож на std::accumulate, но с важными отличиями:
- Может выполняться параллельно
- Порядок применения операции не гарантируется
- Требует ассоциативности и коммутативности операции

Пример: 
std::vector<int> v = {1, 2, 3, 4, 5};

// Простая сумма (по умолчанию операция - std::plus<>)
int sum = std::reduce(v.begin(), v.end());
std::cout << "Sum: " << sum << "\n";          // 15

// С начальным значением
int sum_with_init = std::reduce(v.begin(), v.end(), 10);
std::cout << "Sum with init: " << sum_with_init << "\n"; // 25
    
// С пользовательской операцией
int product = std::reduce(v.begin(), v.end(), 1, std::multiplies<>());
std::cout << "Product: " << product << "\n"; // 120


##############
Главное преимущество std::reduce — поддержка параллелизма:

#include <numeric>
#include <vector>
#include <execution> // для политик выполнения
#include <iostream>

std::vector<int> large_data(1'000'000, 1); // 1 млн единиц

// Последовательное выполнение
auto seq_start = std::chrono::high_resolution_clock::now();
int seq_sum = std::reduce(std::execution::seq, 
                          large_data.begin(), large_data.end());

auto seq_end = std::chrono::high_resolution_clock::now();


// Параллельное выполнение
auto par_start = std::chrono::high_resolution_clock::now();
int par_sum = std::reduce(std::execution::par,
                         large_data.begin(), large_data.end());

auto par_end = std::chrono::high_resolution_clock::now();
    
std::cout << "Sequential time: " 
          << std::chrono::duration_cast<std::chrono::microseconds>(
             seq_end - seq_start).count() << " microseconds\n";

std::cout << "Parallel time: " 
          << std::chrono::duration_cast<std::chrono::microseconds>(
             par_end - par_start).count() << " microseconds\n";


##############
Политики выполнения

#include <execution>

std::vector<int> data = {1, 2, 3, 4, 5};

// Последовательное выполнение (по умолчанию)
int result1 = std::reduce(std::execution::seq, data.begin(), data.end());

// Параллельное выполнение
int result2 = std::reduce(std::execution::par, data.begin(), data.end());

// Векторизованное + параллельное (C++20)
int result3 = std::reduce(std::execution::par_unseq, data.begin(), data.end());


##############
Требования к операции

Для корректной работы с параллельными политиками операция должна быть:
Ассоциативной: (a o b) o c = a o (b o c)
Коммутативной: a o b = b o a

Примеры подходящих операций:

// Ассоциативные и коммутативные операции
std::plus<>()       // сложение: a + b
std::multiplies<>() // умножение: a * b
std::bit_and<>()    // побитовое AND: a & b
std::bit_or<>()     // побитовое OR: a | b
std::bit_xor<>()    // побитовое XOR: a ^ b

Примеры НЕподходящих операций:

// Вычитание - не ассоциативно и не коммутативно
std::minus<>()      // (a - b) - c != a - (b - c)

// Деление - не ассоциативно и не коммутативно
std::divides<>()

Для неассоциативных операций используйте std::accumulate


##############
Сравнение с std::accumulate


|    Характеристика     | std::accumulate              | std::reduce
|-----------------------|------------------------------|-----------------------------
|    Порядок            | Гарантирован (слева направо) | Не гарантирован
|-----------------------|------------------------------|-----------------------------
|    Параллелизм	| Нет	                       | Да (с политиками)
|-----------------------|------------------------------|-----------------------------
| Требования к операции	| Любая бинарная операция      | Ассоциативная и коммутативная
|-----------------------|------------------------------|-----------------------------
|   Производительность	| Медленнее	               | Быстрее (может быть параллельной)
|-----------------------|------------------------------|-----------------------------


Используйте std::reduce когда нужна производительность на больших данных и операция удовлетворяет требованиям, и std::accumulate когда важен порядок операций или операция неассоциативна.



______________________________________________________________________________________
std::inner_product

std::inner_product — это алгоритм из стандартной библиотеки C++, который вычисляет скалярное произведение двух последовательностей. Он также может использоваться для обобщенных операций свертки двух диапазонов.

std::inner_product вычисляет сумму произведений соответствующих элементов двух последовательностей:
result = init + (a1 * b1) + (a2 * b2) + ... + (an * bn)

Пример:
std::vector<int> a = {1, 2, 3, 4};
std::vector<int> b = {2, 3, 4, 5};
    
// Стандартное скалярное произведение
int result = std::inner_product(a.begin(), a.end(), b.begin(), 0);
    
std::cout << "Inner product: " << result << "\n"; 
// 1*2 + 2*3 + 3*4 + 4*5 = 2 + 6 + 12 + 20 = 40



##############
Особенности и ограничения

1) Требования к последовательностям
- Последовательности должны быть одинаковой длины
- Если вторая последовательность короче — неопределенное поведение
- Если вторая последовательность длиннее — используются только первые n элементов

2) Производительность
- Один проход по данным
- Эффективная работа с итераторами
- Нет поддержки параллелизма (в отличие от std::reduce)

Когда использовать:
- Для математических операций над двумя последовательностями
- Когда нужна гибкость в определении операций
- Для читаемого выражения математических концепций

Когда не использовать:
- Когда нужна параллельная обработка (используйте std::transform_reduce)
- Для простых операций с одним диапазоном (используйте std::accumulate)




______________________________________________________________________________________
std::partial_sum | Вычисление частичных сумм

std::partial_sum — это алгоритм из стандартной библиотеки C++, который вычисляет частичные суммы (prefix sums) элементов последовательности. Каждый элемент результата представляет собой сумму всех предыдущих элементов исходной 
последовательности.

Для последовательности [a, b, c, d] std::partial_sum вычисляет:
result[0] = a
result[1] = a + b  
result[2] = a + b + c
result[3] = a + b + c + d

std::vector<int> input = {1, 2, 3, 4, 5};
std::vector<int> result(5);

// Вычисление частичных сумм
std::partial_sum(input.begin(), input.end(), result.begin());
    
for (int x : result) {
	std::cout << x << " "; // 1 3 6 10 15
}


std::partial_sum — это полезный алгоритм для:
- Вычисления частичных сумм и накопленных значений
- Статистических расчетов (кумулятивные распределения)
- Финансовых вычислений (накопленная доходность)
- Оптимизации запросов (префиксные суммы для быстрых range-запросов)
- Обработки сигналов и данных

Когда использовать:
- Для последовательных накоплений
- Когда нужны кумулятивные статистики
- Для подготовки данных к дальнейшей обработке

Когда не использовать:
- Для параллельной обработки больших данных (используйте std::inclusive_scan)
- Когда нужны только конечные суммы (используйте std::accumulate)





______________________________________________________________________________________
std::adjacent_difference | разности между соседними элементами

std::adjacent_difference — это алгоритм из стандартной библиотеки C++, который вычисляет разности между соседними элементами последовательности. Каждый элемент результата (кроме первого) представляет собой разность между текущим и 
предыдущим элементом исходной последовательности.

Для последовательности [a, b, c, d, e] std::adjacent_difference вычисляет:
result[0] = a
result[1] = b - a  
result[2] = c - b
result[3] = d - c
result[4] = e - d


Пример:
std::vector<int> input = {2, 4, 6, 8, 10};
std::vector<int> result(5);
    
// Вычисление разностей между соседними элементами
std::adjacent_difference(input.begin(), input.end(), result.begin());
    
for (int x : result) {
	std::cout << x << " "; // 2 2 2 2 2
}


std::adjacent_difference — это мощный алгоритм для:
- Обработки сигналов (производные, градиенты)
- Анализа временных рядов (изменения, волатильность)
- Сжатия данных (разностное кодирование)
- Геометрических вычислений (расстояния, длины путей)
- Статистического анализа (последовательные разности)

Когда использовать:
- Для анализа изменений между соседними элементами
- Для сжатия данных с маленькими разностями
- Для вычисления дискретных производных
- В комбинации с std::partial_sum для преобразований данных

Когда не использовать:
- Когда нужны только конечные результаты (используйте специализированные алгоритмы)
- Для простых операций, которые можно выразить циклом for
- Когда производительность критична (может быть медленнее специализированных реализаций)



______________________________________________________________________________________
std::iota | Заполнение диапазона 

std::iota — это алгоритм из стандартной библиотеки C++, который заполняет диапазон последовательными возрастающими значениями, начиная с заданного начального значения. Название "iota" происходит от греческой буквы йота, которая 
в языке APL использовалась для подобной операции.

Заполняет диапазон [first, last) значениями:
value, value + 1, value + 2, ..., value + (last - first - 1)

std::vector<int> numbers(5); // вектор из 5 элементов
    
// Заполняем последовательными значениями, начиная с 10
std::iota(numbers.begin(), numbers.end(), 10);
    
for (int n : numbers) {
	std::cout << n << " "; // 10 11 12 13 14
}




##############
Особенности и ограничения

Тип значения должен поддерживать:
- Копирование/присваивание
- Оператор префиксного инкремента ++
- Совместимость с типом элементов контейнера


Производительность
- In-place заполнение
- Линейная сложность: O(n)
- Один проход по диапазону
- Эффективнее ручных циклов (может быть оптимизирован компилятором)

Итог
std::iota — это простой, но мощный алгоритм для:
- Инициализации последовательностей чисел
- Создания индексов для сортировки и поиска
- Генерации тестовых данных
- Назначения уникальных ID
- Заполнения матриц и многомерных структур

Когда использовать:
- Для инициализации диапазонов последовательными значениями
- Когда нужны индексы для косвенной сортировки
- Для создания уникальных идентификаторов
- В тестах и демонстрационных примерах

Когда не использовать:
- Когда нужны сложные последовательности (с шагом, нелинейные)
- Когда значения генерируются случайным образом
- Когда нужна ленивая генерация (используйте ranges или генераторы)





______________________________________________________________________________________
### 7. Новые алгоритмы C++20 / C++23


| Алгоритм                   | Описание                                               |
|----------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::shift_left,           | сдвиги без копирования                                 | auto result = std::shift_left(v.begin(), v.end(), 2); // Сдвигаем на 2 позиции влево
| std::shift_right   (C++20) |                                                        |
|----------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::ranges::              | версии почти всех алгоритмов (работают с ranges, views,|
|                            | поддерживают проекции и т.д.)                          | 
|----------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::lerp                  | линейная интерполяция                                  | double result = std::lerp(a, b, t);
|----------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::midpoint              | безопасное среднее для указателей и чисел              | int result = std::midpoint(a, b);
|----------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------
| std::clamp                 | ограничивает значение диапазоном                       | 
|----------------------------|--------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------


#########################
Подробнее про некоторые из них



______________________________________________________________________________________
std::shift_left и std::shift_right

std::shift_left и std::shift_right — это алгоритмы из стандартной библиотеки C++ (появились в C++20), которые выполняют сдвиг элементов в диапазоне влево или вправо. Эти алгоритмы перемещают элементы внутри диапазона, аналогично 
битовым сдвигам, но для последовательностей элементов.

std::shift_left сдвигает элементы влево, заполняя начало диапазона более поздними элементами.

Поведение:
- Элементы в диапазоне [first + n, last) перемещаются в [first, last - n)
- Элементы в [last - n, last) становятся неопределенными (valid but unspecified)

std::vector<int> v = {1, 2, 3, 4, 5};
    
// Сдвигаем на 2 позиции влево
auto result = std::shift_left(v.begin(), v.end(), 2);
    
std::cout << "After shift_left by 2: ";
for (int x : v) {
	std::cout << x << " "; // 3 4 5 4 5 (первые 3 элемента перемещены)
}
std::cout << "\nNew end: " << std::distance(v.begin(), result) << "\n";



std::shift_right сдвигает элементы вправо, заполняя конец диапазона более ранними элементами.

Поведение:
- Элементы в диапазоне [first, last - n) перемещаются в [first + n, last)
- Элементы в [first, first + n) становятся неопределенными (valid but unspecified)

std::vector<int> v = {1, 2, 3, 4, 5};
    
// Сдвигаем на 2 позиции вправо
auto result = std::shift_right(v.begin(), v.end(), 2);
    
std::cout << "After shift_right by 2: ";
for (int x : v) {
	std::cout << x << " "; // 1 2 1 2 3 (последние 3 элемента перемещены)
}
std::cout << "\nNew start of preserved: " << std::distance(v.begin(), result) << "\n";


##############
Особенности и ограничения

Требования к итераторам:
- std::shift_left: ForwardIterator
- std::shift_right: ForwardIterator (или BidirectionalIterator для C++20)

Сложность:
- Линейная: O(std::distance(first, last))
- Может быть более эффективной, чем ручная реализация

Состояние элементов:
- Перемещенные элементы имеют valid but unspecified state
- Для типов с нетривиальными деструкторами нужно быть осторожным

Возвращаемое значение:
- shift_left: итератор на новый конец диапазона
- shift_right: итератор на начало сохраненной последовательности


std::shift_left и std::shift_right — это полезные алгоритмы для:
- Управления буферами данных
- Реализации очередей с фиксированным размером
- Обработки скользящих окон
- Эффективного удаления элементов из начала/конца

Когда использовать:
- Для работы с циклическими буферами
- Когда нужно сохранить порядок элементов при сдвиге
- Для эффективной обработки потоков данных

Когда не использовать:
- Когда нужно сохранить все элементы (используйте std::rotate)
- Для простого удаления элементов (используйте std::remove)
- Когда важна стабильность перемещенных объектов




______________________________________________________________________________________
std::ranges::  (C++20)

std::ranges:: — это пространство имен, появившееся в C++20, которое содержит ranges-версии стандартных алгоритмов и новые компоненты для работы с диапазонами (ranges).

Основная концепция Ranges:
Ranges — это современная замена итераторным парам [begin, end), которая предоставляет:

1) Более безопасные и выразительные интерфейсы
// Старый стиль (до C++20)
std::vector<int> v = {1, 2, 3, 4, 5};
std::sort(v.begin(), v.end());

// Новый стиль (C++20)
std::ranges::sort(v);  // Проще и безопаснее!


2) Отсутствие ошибок с непарными итераторами
// ОПАСНО: легко ошибиться
std::sort(v.begin(), v.end()); // Правильно
std::sort(v.end(), v.begin()); // Неправильно - Неопределенное поведение!

// БЕЗОПАСНО: компилятор проверит
std::ranges::sort(v); 



Основные компоненты std::ranges::
1) Алгоритмы (Algorithms) Все стандартные алгоритмы имеют ranges-версии:

std::vector<int> v = {5, 3, 1, 4, 2};

std::ranges::sort(v); 			// Сортировка
auto it = std::ranges::find(v, 3);      // Поиск
int count = std::ranges::count(v, 4);   // Подсчет

std::vector<int> squares;
std::ranges::transform(v, std::back_inserter(squares), // Преобразование
                       [](int x) { return x * x; });


2) Вьюхи (Views) Ленивые операции над диапазонами:

std::vector<int> numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

auto evens = numbers | std::views::filter([](int n) { return n % 2 == 0; });     // Фильтрация: только четные числа

auto squares = evens | std::views::transform([](int n) { return n * n; });       // Преобразование: в квадраты

auto first_three = squares | std::views::take(3);                                // Взять первые 3

std::cout << "Result: ";
for (int x : first_three) {
	std::cout << x << " "; // 4 16 36
}



3) Адаптеры диапазонов (Range Adaptors)

std::vector<int> v = {1, 2, 3, 4, 5};

for (int x : v | std::views::reverse) {             // Реверс
	std::cout << x << " "; // 5 4 3 2 1
}

for (int x : v | std::views::drop(2)) {		    // Пропуск первых N элементов
        std::cout << x << " "; // 3 4 5
}

for (int x : v | std::views::take(3)) {             // Взятие первых N элементов  
        std::cout << x << " "; // 1 2 3
}



##############
Ключевые преимущества

1) Безопасность типов и компиляция

std::vector<int> vec = {1, 2, 3};
std::list<int> lst = {1, 2, 3};

// std::ranges::sort(lst);          // Не компилируется! Ошибка компиляции: list doesn't have random access iterator

std::ranges::sort(vec); // Компилируется


2) Проекции (Projections)

struct Person {
    std::string name;
    int age;
};


// Сортировка по возрасту с проекцией
std::ranges::sort(people, {}, &Person::age);

// Эквивалентно:
// std::ranges::sort(people, [](const Person& a, const Person& b) {
//     return a.age < b.age;
// });


// Сортировка по имени в обратном порядке
std::ranges::sort(people, std::ranges::greater{}, &Person::name);


3) Возвращаемые значения

std::vector<int> v = {5, 3, 1, 4, 2};

// Старый алгоритм возвращает только итератор
auto old_it = std::find(v.begin(), v.end(), 3);

// Ranges алгоритм возвращает структуру с информацией
auto result = std::ranges::find(v, 3);
if (result != v.end()) {
        // result - итератор на найденный элемент
        std::cout << "Found: " << *result << "\n";
}




##############
Новые алгоритмы в ranges

1) starts_with, ends_with

std::vector<int> v1 = {1, 2, 3, 4, 5};
std::vector<int> v2 = {1, 2, 3};
std::vector<int> v3 = {3, 4, 5};

bool starts = std::ranges::starts_with(v1, v2); // true

bool ends = std::ranges::ends_with(v1, v3);     // true


2) contains

std::vector<int> v = {1, 2, 3, 4, 5};

bool has_three = std::ranges::contains(v, 3); // true

bool has_six = std::ranges::contains(v, 6);   // false




##############
Особенности реализации

1) Концепты (Concepts)

template<std::ranges::random_access_range R>
void fast_sort(R&& range) {
    std::ranges::sort(range);
}

template<std::ranges::range R>  
void print_range(R&& range) {
    for (const auto& elem : range) {
        std::cout << elem << " ";
    }
}

int main() {
	std::vector<int> vec = {3, 1, 2}; // random_access_range
    	std::list<int> lst = {3, 1, 2};   // bidirectional_range

	fast_sort(vec);    // Компилируется
	// fast_sort(lst); // Не компилируется

	print_range(vec); // Компилируется
    	print_range(lst); // Компилируется
}



2) Ленивые вычисления

std::vector<int> data = {1, 2, 3, 4, 5};

// Ленивое преобразование - вычисляется только при итерации
auto transformed = data | std::views::transform([](int x) {
	std::cout << "Transforming " << x << "\n";
        return x * x;
});

std::cout << "Before iteration:\n";

// Вычисления происходят здесь:
for (int x : transformed | std::views::take(2)) {
        std::cout << "Result: " << x << "\n";
}

// Вывод:
// Before iteration:
// Transforming 1
// Result: 1
// Transforming 2  
// Result: 4



##############
Итог:
std::ranges:: — это современный, безопасный и выразительный способ работы с алгоритмами и диапазонами в C++20. 

Преимущества:
- Безопасность — проверки на этапе компиляции
- Выразительность — функциональный стиль, пайплайны
- Удобство — проекции, улучшенные возвращаемые значения
- Производительность — ленивые вычисления, оптимизации

Когда использовать:
- В новом коде на C++20+
- Для сложных цепочек обработки данных
- Когда важна безопасность типов
- Для функционального стиля программирования

Рекомендация: Постепенно мигрировать на std::ranges:: версии алгоритмов в новом коде, сохраняя старые версии для совместимости при необходимости.



______________________________________________________________________________________
std::lerp | линейная интерполяция

std::lerp — это математическая функция из стандартной библиотеки C++ (появилась в C++20), которая выполняет линейную интерполяцию (Linear Interpolation) между двумя значениями. Вычисляет значение между a и b на основе параметра t:
result = a + t * (b - a)

где a — начальное значение, b — конечное значение, t — параметр интерполяции (обычно от 0.0 до 1.0)

double a = 10.0;
double b = 20.0;
double t = 0.5;
    
double result = std::lerp(a, b, t);
std::cout << "lerp(" << a << ", " << b << ", " << t << ") = " << result << "\n";
// 10 + 0.5 * (20 - 10) = 15


// Для целых чисел (C++23):
constexpr Integral lerp(Integral a, Integral b, Integral t) noexcept;


std::lerp гарантирует высокую точность, особенно когда a и b имеют большой разброс и t близко к 0 или 1.


Преимущества:
- Высокая точность для крайних значений
- Обработка особых случаев (inf, nan)
- constexpr поддержка
- Оптимизации компилятора

Производительность:
- constexpr: может вычисляться на этапе компиляции
- Быстрее ручных реализаций в некоторых случаях
- Векторизуется современными компиляторами



______________________________________________________________________________________
std::midpoint | середину между двумя значениями

std::midpoint — это математическая функция из стандартной библиотеки C++ (появилась в C++20), которая вычисляет середину между двумя значениями безопасным и точным способом без риска переполнения:
result = a + (b - a) / 2

int a = 10;
int b = 20;

int result = std::midpoint(a, b);
std::cout << "midpoint(" << a << ", " << b << ") = " << result << "\n";
// 10 + (20 - 10) / 2 = 15


Сравнение с альтернативами
// Опасность переполнения
int naive1(int a, int b) { return (a + b) / 2; }

// Неправильное округление для отрицательных чисел
int naive2(int a, int b) { return a + (b - a) / 2; }

// std::midpoint решает обе проблемы
int safe(int a, int b) { return std::midpoint(a, b); }



Производительность
- constexpr: вычисления во время компиляции
- Эффективность: часто одна инструкция процессора
- Оптимизация: компиляторы хорошо оптимизируют

Рекомендация: Всегда используйте std::midpoint вместо ручных вычислений (a + b) / 2 в C++20 и новее, особенно в шаблонном коде и алгоритмах.



______________________________________________________________________________________
std::clamp | ограничивает значение заданными границами

std::clamp — это алгоритм из стандартной библиотеки C++ (появился в C++17), который ограничивает значение заданными границами. Он возвращает значение, "зажатое" между нижней и верхней границей.


Основная концепция
std::clamp ограничивает значение v между lo (нижняя граница) и hi (верхняя граница):
if (v < lo) return lo;
if (hi < v) return hi; 
return v;


int value = 15;
int low = 10;
int high = 20;
    
int result = std::clamp(value, low, high);
std::cout << "clamp(" << value << ", " << low << ", " << high << ") = " << result << "\n";
// 15 (остается тем же, так как в диапазоне)



Особенности и тонкости

1) Требование: lo <= hi
int value = 5;
int low = 10;
int high = 0; // Некорректно: low > high
    
// Неопределенное поведение!
// int result = std::clamp(value, low, high); // ОПАСНО!
    
// Всегда проверяйте, что lo <= hi
if (low <= high) {
        int result = std::clamp(value, low, high);
        std::cout << "Result: " << result << "\n";
} else {
        std::cout << "Invalid range: [" << low << ", " << high << "]\n";
}





2) Возвращаемая ссылка
int a = 10, b = 20, c = 15;
    
// clamp возвращает ссылку на один из аргументов
const int& result = std::clamp(c, a, b);
    
std::cout << "Result: " << result << "\n"; // 15
std::cout << "Address matches c: " << (&result == &c) << "\n"; // true
    
// Если значение за пределами диапазона, возвращается ссылка на границу
const int& clamped_low = std::clamp(5, a, b);
std::cout << "Address matches a: " << (&clamped_low == &a) << "\n"; // true

Рекомендация: Используйте std::clamp вместо ручных проверок везде, где нужно ограничить значение диапазоном. Это делает код более читаемым и менее подверженным ошибкам.












______________________________________________________________________________________
Алгоритм for_each

Предназначение алгоритм for_each абслоютно точно такое же, как и у цикла for each. Разница в особенностях использования.

for_each(итератор на начало коллекции, итератор на конец коллекции, функция которая определяет что будет делать алгоритм for_each будет делать).

#include <algorithm> //Подключаем for_each

void Foo(int a) {				//Функция выводит в консоль параметр
	cout << a << endl;
}

int main()
{
    setlocale(LC_ALL, "Russian");
	
	int arr[] = { 1,2,10,55 };
	for_each(begin(arr), end(arr), Foo); 	//for_each преберает все элементы arr и вызывает функцию Foo на каждой итерации, передавая в параметр текущий элемент.
    	
	for (auto a : arr) {			//Тоже самое только через цикл, а не алгоритм.
		Foo(a);
	}
	
	for_each(begin(arr), end(arr), [](int a) { //Тоже самое только через лямбда функцию.
		cout << a << endl;
	});

	return 0;
}








______________________________________________________________________________________
Теория: Различия между set и unordered_set

std::set` и `std::unordered_set` являются контейнерами, предоставляемыми стандартной библиотекой и используемыми для хранения уникальных элементов. Основное различие между этими 
двумя типами контейнеров заключается в их внутреннем устройстве, что влияет на производительность операций вставки, поиска и удаления, а также на порядок хранения элементов.

`std::set`
Реализован на основе сбалансированного двоичного дерева поиска (обычно красно-черное дерево). Это обеспечивает следующие характеристики:

Упорядоченное хранение: Элементы в `std::set` автоматически сортируются по возрастанию (или с использованием предоставленного компаратора), что позволяет легко получить 
отсортированный список элементов.
Время доступа: Операции поиска, вставки и удаления элементов имеют логарифмическую сложность времени `O(log n)`, где `n` — количество элементов в контейнере.
```cpp
#include <iostream>
#include <set>

int main() {
    std::set<int> s;
    s.insert(3);
    s.insert(1);
    s.insert(4);

    // Элементы будут автоматически упорядочены
    for (int x : s) {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
`std::unordered_set`
Реализован на основе хеш-таблицы. Это влечет за собой другие характеристики:

Неупорядоченное хранение: Элементы хранятся в произвольном порядке, что делает невозможным их простую сортировку или последовательный доступ в отсортированном порядке.
Время доступа: В среднем случае операции поиска, вставки и удаления элементов имеют константное время `O(1)`. Однако в худшем случае, например, когда происходит множество коллизий 
хеш-функции, эти операции могут деградировать до `O(n)`.
```cpp
#include <iostream>
#include <unordered_set>

int main() {
    std::unordered_set<int> us;
    us.insert(3);
    us.insert(1);
    us.insert(4);

    // Порядок элементов не гарантирован
    for (int x : us) {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
Выбор между `std::set` и `std::unordered_set` зависит от требований к вашему приложению:

Используйте `std::set`, если вам нужен упорядоченный доступ к элементам или если вы часто выполняете операции, которые зависят от порядка элементов.
Выбирайте `std::unordered_set` для более быстрых операций вставки и поиска, если порядок элементов не имеет значения.


______________________________________________________________________________________
Теория: самый худший случай поиска unordered_set

В `unordered_set`, который основан на хеш-таблице, самый худший случай поиска возникает, когда структура данных деградирует до такой степени, что время поиска становится линейным, 
то есть \(O(n)\), где \(n\) — количество элементов в контейнере. Это происходит по нескольким причинам:

1. Плохая хеш-функция

Играет ключевую роль в распределении элементов по "ведрам" (buckets) в `unordered_set`. Если хеш-функция плохо разрабатывается и генерирует одинаковые или близкие хеш-коды для 
большого количества ключей, элементы начинают накапливаться в очень небольшом числе ведер. Это приводит к тому, что большинство операций поиска, вставки и удаления начинают 
зависеть от числа элементов в самом длинном связном списке, а не от общего количества ведер, что сильно ухудшает производительность.

2. Высокая степень загрузки

Загрузка хеш-таблицы (`load factor`) — это отношение количества элементов в хеш-таблице к количеству ведер. Когда `load factor` становится слишком высоким, вероятность коллизий 
увеличивается, что также приводит к увеличению длины цепочек в каждом ведре. Хотя `unordered_set` автоматически увеличивает количество ведер при увеличении количества элементов, 
в случаях с экстремально высоким `load factor` поиск может деградировать до линейного.

3. Неблагоприятная последовательность вставок

Вставляются данные, которые неудачно распределяются хеш-функцией, даже если сама функция в целом хороша, это может привести к временной деградации производительности. Например, 
последовательная вставка элементов с одинаковым хешем приведет к удлинению одной цепочки.

Представьте `unordered_set`, в котором из-за плохой хеш-функции все элементы попадают в одно ведро. В таком случае, любая операция поиска будет выполняться с временем \(O(n)\), 
так как каждый раз придется просматривать все элементы, хранящиеся в этом ведре.

Для минимизации риска худшего случая в `unordered_set` важно:

Использовать хорошо подобранную хеш-функцию, которая равномерно распределяет значения по ведрам.
Контролировать `load factor` и при необходимости увеличивать количество ведер.
Возможно, рассмотреть альтернативные структуры данных или алгоритмы, если хеш-таблицы не подходят из-за природы данных или операций.




______________________________________________________________________________________
Теория: Всегда ли сложность в деревьях равно log(n)?

Сложность поиска в бинарных деревьях зависит от их структуры и баланса. Логарифмическая сложность поиска, то есть \(O(\log n)\), где \(n\) — количество узлов в дереве, достигается 
в идеально сбалансированных бинарных деревьях. Однако это не всегда так, и различные типы бинарных деревьев могут иметь разные характеристики поиска.

Идеально сбалансированные бинарные деревья
Каждый уровень дерева, кроме возможно последнего, полностью заполнен. Это означает, что количество узлов удваивается с каждым новым уровнем. В таком дереве максимальная глубина 
(или высота) \(h\) равна \(\log_2(n+1)\). Поиск, вставка или удаление элемента в таком дереве имеет временную сложность \(O(\log n)\).

Несбалансированные бинарные деревья
Сложность поиска может деградировать до \(O(n)\) в худшем случае. Это может произойти, например, если элементы добавляются в дерево в уже отсортированном порядке, при котором 
каждый новый узел становится правым ребёнком предыдущего. Такое дерево принимает форму "вытянутого списка", и поиск в нём становится по сути линейным поиском.

Сбалансированные бинарные деревья
Для обеспечения логарифмической сложности поиска независимо от порядка вставки элементов разработаны специальные структуры данных, такие как AVL-деревья и красно-чёрные деревья. 
Эти структуры являются самобалансирующимися, то есть они автоматически поддерживают свою структуру таким образом, чтобы глубина дерева оставалась логарифмической относительно 
количества элементов, что обеспечивает поддержание сложности операций на уровне \(O(\log n)\).

Логарифмическая сложность поиска в бинарных деревьях достигается только в сбалансированных деревьях. В несбалансированных деревьях сложность поиска может увеличиться до линейной. 
Поэтому важно выбирать правильный тип дерева или использовать самобалансирующиеся деревья для задач, где предполагается частое добавление и удаление элементов.



______________________________________________________________________________________
Теория: Каким свойством должен обладать объект, чтобы его можно было добавить в ассоциативные контейнеры в качестве ключа?

Т.к. значения ассоциативных контейнеров хранятся отсортированными, то объект должен реализовывать оператор сравнения < (меньше), а остальные операторы сравнения м.б. выражены через него.

Как из меньше реализовать все остальные операторы?

template <typename T>
bool less(const T& a, const T& b); // Меньше уже реализованно

template <typename T>
bool greater(const T& a, const T& b) { // Реализовываем больше
	return less(b, a);
}

template <typename T>
bool equal(const T& a, const T& b) { // Реализовываем операцию равенства ==
	return !less && !greater;
}


Чтобы объект мог быть в ассоциативном контейнере, он должен быть создаваемым, копируемым или перемещаемым.



______________________________________________________________________________________
std::tuple

(Реализацию смотри в файле "Шаблоны, auto, decltype")

std::tuple — это контейнер из стандартной библиотеки C++, предназначенный для хранения набора элементов разного типа. В отличие от std::pair, который ограничен двумя элементами, 
std::tuple поддерживает произвольное количество элементов. std::tuple удобен, если нужно работать с наборами значений разного типа, но если данных много и они связаны по смыслу, 
лучше использовать struct или class. std::tuple объявлен в заголовке <tuple>.

Доступ к элементам std::tuple осуществляется через std::get<N>(t), где N — индекс элемента (нумерация с 0):

int main() {
    std::tuple<int, double, std::string> t(42, 3.14, "Hello");

    std::cout << std::get<0>(t) << '\n'; 	// 42
    std::cout << std::get<1>(t) << '\n'; 	// 3.14
    std::cout << std::get<2>(t) << '\n'; 	// Hello

    return 0;
}


Создание через std::make_tuple. std::make_tuple автоматически определяет типы элементов:
auto t = std::make_tuple(42, 3.14, std::string("Hello"));


Изменение элементов:
std::get<1>(t) = 2.71;  // Меняем второй элемент


Количество элементов в tuple:
std::cout << std::tuple_size<decltype(t)>::value; 	// 3


Тип конкретного элемента tuple:
using T = std::tuple_element<1, decltype(t)>::type; // T == double


Сравнение std::tuple:
std::tuple<int, char> t1(1, 'a');
std::tuple<int, char> t2(2, 'b');

std::cout << (t1 < t2); // true, сравнение происходит лексикографически



Распаковка std::tuple.
Распаковка (unpacking) std::tuple — это процесс извлечения значений из кортежа (std::tuple) и их присвоения отдельным переменным.

1) Распаковка с помощью std::tie (C++11). Используется, если переменные уже объявлены заранее.

int main() {
    std::tuple<int, double, char> t(42, 3.14, 'A');

    int x;
    double y;
    char z;

    std::tie(x, y, z) = t; 					// Распаковка

    std::cout << x << " " << y << " " << z << "\n"; 		// 42 3.14 A
    return 0;
}


Можно игнорировать ненужные элементы с помощью std::ignore:
std::tie(x, std::ignore, z) = t; // Второй элемент пропускается


2) Распаковка через std::get<N> (C++11). Можно извлекать отдельные элементы напрямую:

int a = std::get<0>(t);
double b = std::get<1>(t);
char c = std::get<2>(t);

Этот метод менее удобен для извлечения всех значений сразу.


3) Распаковка с помощью auto [ ... ] (C++17, structured bindings). 
Начиная с C++17, можно использовать structured bindings, которые делают код проще:

int main() {
    std::tuple<int, double, char> t(42, 3.14, 'A');

    auto [x, y, z] = t; 					// Распаковка в новые переменные. Здесь мы сделали копии всех элементов tuple в новые переменные x, y и z.

    std::cout << x << " " << y << " " << z << "\n"; 		// 42 3.14 A

    return 0;
}

Этот способ распаковки не требует std::tie или std::get<N>, а также нам не нужно самостоятельно объявлять переменные заранее.


Применение std::tuple:
1) Возвращение нескольких значений из функции:

std::tuple<int, double, std::string> getData() {
    return {42, 3.14, "Hello"};
}

auto [x, y, z] = getData(); 			// C++17 structured bindings

2) Хранение гетерогенных данных в контейнере (данные разных типов).
3) Использование в std::map или std::unordered_map в качестве ключа.




______________________________________________________________________________________
std::optional (C++17)

Примерную реализацию см. в "Шаблонны, мета-программирование" раздел "Deducing this (since C++23)".

std::optional - это тип из стандартной библиотеки (введён в C++17), который представляет значение, которое может быть, а может и не быть (т.е. опциональное значение). Т.е. это контейнер, который либо содержит значение типа T, либо 
пустой (не содержит ничего). Это безопасная и явная альтернатива старым способам обозначения "нет значения", таким как:
- Возврат nullptr. Это опасно, может привести к dereference-ошибкам.
- Возврат "магического" значения, например -1 для возраста.
- Использование пары {value, bool success}.

Зачем это нужно в реальной работе?
- Функции, которые могут не вернуть результат(поиск в map, парсинг строки в число и т.д.)
- Избежание исключений (exceptions) в случаях, когда "не нашёл" - это нормальная ситуация, а не ошибка, поэтому можно избежать exceptions.
- Читаемый и безопасный код: компилятор заставляет тебя проверять, есть ли значение.

Основные операции:
#include <optional>
#include <iostream>
#include <string>

std::optional<int> find_even_number(const std::vector<int>& vec) {
	for (int x : vec) {
		if (x % 2 ==0) {
			return x;	// Возвращаем optional, содержащий x
		}
	}
	return std::nullopt;		// Если ничего не нашли, явно говорим "ничего не нашли"
}

int main() {
	std::vector<int> numbers = {1, 3, 7, 8, 11};
	
	auto result = find_even_number(numbers);

	// Вариант 1: проверка через if
	if (result) {
		std::cout << "Нашли чётное: " << *result << "\n";	// разыменование как у указателя
	} else {
		std::cout << "Чётных нет\n";
	}

	// Вариант 2: value_or() - вернуть значение или дефолт
	int value = result.value_or(0);					// Если нет - вернёт 0
	std::cout << "Значение или 0: " << value << "\n";

	// Вариант 3: value() - бросит исключение, если пустой
	// int bad = std::optional<int>{}.value();			// бросит std::bad_optional_access
}


###
Ключевые методы и особенности
- Создание
std::optional<int> a = 42;			// Содержит 42
std::optional<int> b = std::nullopt;		// Пустой
std::optional<int> c{};				// Пустой (по умолчанию)
std::optional<std::string> d = "hello";		// Содержит строку

- Проверка наличия значения
if (opt) { ... }				// true, если есть значение
if (opt.has_value()) { ... }			// то же самое

- Доступ к значению
*opt				// Как указатель (требует, чтобы было значение)
opt.value()			// Верёнт значение или бросит bad_optional_access
opt.value_or(default_value)	// безопасно: вернёт значение или default_value

- Модификация
opt = 100;			// Теперь содержит 100
opt = std::nullopt;		// Очищаем
opt.emplace(200);		// Создаём значение "на месте" (in-place)


###
Пример из жизни: поиск в контейнере

#include <optional>
#include <unordered_map>
#include <string>

std::unordered_map<std::string, int> ages = {
	{"Alice", 25},
	{"Bob", 30}
};

std::optional<int> get_age(const std::string& name) {
	auto it = ages.find(name);
	if (it != ages.end()) {
		return it->second;
	}
	return std::nullopt;
}

// Использование
auto age = get_age("Alice");
if (age) {
	std::cout << "Возраст: " << *age << '\n';
} else {
	std::cout << "Не найден\n";
}


###
Почему это лучше старых способов?

Старый способ	        |   	Проблемы		|	std::optional
------------------------|-------------------------------|-----------------------------
 возврат nullptr 	|  Легко забыть проверу, 	| Компилятор заставляет
			|  что приведёт к крашу  	| проверять
------------------------|-------------------------------|-----------------------------
Магическое              | Неочевидно, легко ошибиться   | Явно: либо есть значение,
значение (-1 или "")	|                        	| либо нет
------------------------|-------------------------------|-----------------------------
Пара {value, bool}    	| Много boilerplate            	| Удобный синтаксис
	 		|		        	| и методы
------------------------|-------------------------------|-----------------------------
Исключения		| Дорого, если "не             	| Нет overhead, просто
	                | нашёл" - норма              	| optional



______________________________________________________________________________________
std::variant

Подробное объяснение и приближённую реализацию смотри в "Unions and type aliasing"

std::variant - это тип из STL (введён в C++17), который представляет значение одного из заранее заданного списка типов. Простыми словами: это безопасный и типизированный аналог union, который может хранить только 
один тип из списка в любой момент времени.


Зачем это нужно?
Старый union опасен: нет проверки типов, легко прочитать неправильный член, что приведёт к UB. std::variant решает это:
- Знает, какой тип сейчас хранится.
- Не позволяет прочитать неправильный тип (либо проверка, либо исключение).
- Поддерживает удобный паттерн "visitor" для обработки разных типов.

Типичные сценарии использования:
- Парсинг данных (результат м.б. int, string, bool и т.д.)
- AST (абстрактное синтаксическое дерево) в компиляторах/интерпретаторах.
- Возврат разных типов из функции без dynamic_cast и наследования.
- Хранение heterogeneous данных в контейнерах (вектор вариантов)


###
Основные операции

#include <variant>
#include <iostream>
#include <string>

using MyVariant = std::variant<int, double, std::string>;

void print(const MyVariant& v) {
	std::visit([](const auto& value) {
		std::cout << value << '\n';
	}, v);
}

int main() {
	MyVariant v1 = 42;			// Хранит int
	MyVariant v2 =3.14;			// Хранит double
	MyVariant v3 = std::string("hello");	// Хранит std::string

	print(v1);	// 42
	print(v2);	// 3.14
	print(v3);	// hello

	// изменить содержимое
	v1 = "now string";		// Теперь хранит std::string
	v1 = 100.5;			// Теперь хранит double
}


###
Ключевые методы и особенности
- Создание:
std::variant<int, std::string> v = 42;		// Первый тип стоит по умолчанию (т.е. в нашем случае это int)
std::variant<int, std::string> v2{"text"};	// Выбирает подходящий тип
std::variant<int, std::string> v3;		// Содержит первый тип (int) со значением по умолчанию (в данном случае 0)

- Проверка текущего типа:
1) 
if (std::holds_alternative<int>(v)) { ... }			// true, если сейчас int

2) Индекс активного типа
using MyVariant = std::variant<int, double, std::string>;
MyVariant v1;
int index = v.index();						// Интекс типа в variant: 0 для int, 1 для double, 2 std::string (и т.д. если в варианте есть ещё типы)


- Доступ к значению:
1)
int i = std::get<int>(v);			// Бросит bad_variant_access, если не int
int i2 = std::get<0>(v);			// По индексу( 0 - певый тип)

Если тип не совпадает - будет исключение
v = 10;
std::get<double>(v);				// std::bad_variant_access

2)
// Безопасно
if (auto p = std::get_if<std::string>(&v)) {
	std::cout << *p << '\n';		// p - указатель на значение или nullptr
}


###
- Самый удобный способ - std::visit:
std::visit использует "visitor" (lambda или структурированный объект), который перегружается для каждого типа.

std::variant в любой момент может хранить только один тип. Чтобы обработать значение, нужно узнать, какой тип сейчас внутри, и сделать что-то соответствующее.

Например если std::variant<int, double, std::string>, то можно писать так (длинно и некрасиво):


if (std::holds_alternative<int>(v)) {
	std::cout << std::get<int>(v) * 2 << '\n';
} else if (std::holds_alternative<double>(v)) {
	std::cout << std::get<double>(v) + 1.5 << '\n';
} else if (std::holds_alternative<std::string>(v)) {
	std::cout << std::get<std::string>(v) + "!!" << '\n';
}

Но std::visit позволяет написать то же самое в одной лаконичной конструкции, без кучи if-ов.
1) Самый простой вариант: одна generic lambda

std::visit([](const auto& value) {
	std::cout << value << '\n';
}, v);

Здесь auto - это generic lambda (из C++14). Компилятор создаёт отдельную перегрузку для каждого возможного типа в std::variant. Это работает, если ты хочешь сделать одно и то же со всеми типами (например просто вывести).


2) Когда нужна разная обработка для каждого типа - перегруженные лямбды
Тут начинается "некрасивый" синтаксис.

Вариант 1: ручные перегрузки (классика)
Здесь мы создаём структуру с перегруженным operator(). std::visit вызывает нужную перегрузку в зависимости от текущего типа в std::variant.

struct Visitor {
	void operator()(int i) const {
		std::cout << "Это int: " << i * 2 << '\n';
	}
	void operator()(double d) const {
		std::cout << "Это double: " << d + 1.5 << '\n';
	}
	void operator()(const std::string& s) const {
		std::cout << "Это string: " << s + "!!" << '\n';
	}
};

std::visit(Visitor{}, v);


Вариант 2: Перегрузка лямбд через наследование (самый частый "страшный" код)
Это generic lambda с шаблоном (C++20). Не так страшно - просто одна лямбда, внутри if constexpr.

std::visit([]<typename T>(const T& value) {
	if constexpr (std::is_same_v<T, int>)
		std::cout << "Это int: " << i * 2 << '\n';
	else if constexpr (std::is_same_v<T, double>)
		std::cout << "Это double: " << d + 1.5 << '\n';
	else if constexpr (std::is_same_v<T, std::string>)
		std::cout << "Это string: " << s + "!!" << '\n';
}, v);


Вариант 3: Самый красивый - шаблон overloaded (C++17) (удобная множественная диспетчеризация)
Чаще всего в реальном коде используют вспомогательный шаблон overloaded - это стандартный идиоматический паттерн. overloaded - это способ объединить несколько лямбд в один объект с перегруженным operator(), чтобы удобно обрабатывать 
разные типы std::variant через std::visit.

struct overloaded {
	template<class... Ts> struct helper : Ts... { using Ts::operator()...; };
	template<class... Ts> overloaded(Ts...) -> helper<Ts...>; 	// deduction guide (начиная с C++20 они не нужны)
};

// Использование
std::variant<int, double, std::string> v = "hello";

std::visit(overloaded{
	[](int i)			{ std::cout << "Это int: " << i * 2 << '\n' },
	[](double d)			{ std::cout << "Это double: " << d + 1.5 << '\n'; },
	[](const std::string& s)	{ std::cout << "Это string: " << s + "!!" << '\n'; }
}, v);

// Меняем значение
v =42;

std::visit(overloaded{
	[](int i)			{ std::cout << "Это int: " << i * 2 << '\n' },
	[](double d)		{ std::cout << "Это double: " << d + 1.5 << '\n'; },
	[](const std::string& s)	{ std::cout << "Это string: " << s + "!!" << '\n'; }
}, v);

Что здесь происходит:
- Мы создаём структуру, которая наследуется от всех лямбд.
- Благодаря using Ts::operator()...; импортируем все operator() из базовых лямбд.
- Получаем одну структуру с несколькими перегруженными operator() - именно то, что нужно std::visit.

Почему это круто а не ужас:
- После того как один раз напишешь overloaded, дальше всё просто и красиво.
- Нет кучи if-ов.
- Типобезопасно: если добавишь новый тип в std::variant, компилятор ругнётся, что visitor не обрабатывает его (если не использовать generic fallback).
- Очень эффективно - всё на этапе компиляции.


###
Особенности std::variant
- Превый тип в списке - дефолтный (если std::variant создан без аргументов).
std::variant<int, std::string) v;	// Содержит int = 0

- Если один из типов пустой (например std::monostate), можно представить "пустое" состояние.
std::variant<std::monostate, int, std::string> v;

- Размер std::variant примерно равен размеру самого большого типа + небольшой overhead для индекса.

- Есть редкий случай, когда объект временно "без значения" (из-за исключения при перемещении)
if (v.valueless_by_exception()) {
	// Восстановить или заново присвоить
}


###
Частые ошибки
- Класть много больших типов. Из-за этого std::variant раздувается по памяти
- Пытаться использовать как замену std::any
- Игнорировать std::visit и плодить if




______________________________________________________________________________________
std::any

Подробно про std::any смотри в файле "С++ Указатели и ссылки" в разделе "Идеома Type erasure (Стирание типа)"

std::any — это тип из стандартной библиотеки (введён в C++17), который может хранить значение любого типа (копируемого, потому что в std::any объекты только копируются), и при этом знает, какой тип сейчас внутри. 
Простыми словами: это безопасный и удобный "контейнер для любого значения", аналог void*, но с типобезопасностью на этапе выполнения (runtime).

#include <any>
#include <iostream>
#include <string>
#include <vector>

int main() {
    std::any a = 42;                    	// хранит int
    a = 3.14;                           	// теперь double
    a = std::string("hello");           	// теперь string
    a = std::vector<int>{1, 2, 3};       	// теперь vector<int>

    // Проверка, что внутри
    if (a.type() == typeid(int)) {
        std::cout << "Это int\n";
    }

    // Извлечение значения
    try {
        int i = std::any_cast<int>(a);          // бросит bad_any_cast, если не int
        std::cout << i << '\n';
    } catch (const std::bad_any_cast& e) {
        std::cout << "Не удалось привести к int: " << e.what() << '\n';
    }

    // Безопасное извлечение (возвращает указатель)
    if (auto ptr = std::any_cast<std::string>(&a)) {
        std::cout << "Строка: " << *ptr << '\n';
    } else {
        std::cout << "Не строка\n";
    }
}


###
Ключевые методы и особенности
- Создание и присваивание:

std::any a;                         // пустой (empty)
std::any b = 100;                   // хранит int
std::any c = std::string("text");   // хранит string
b = 3.14;                           // меняем тип и значение

- Проверка состояния:
if (a.has_value()) { ... }          // true, если что-то хранит
a.type() == typeid(T)               // проверка текущего типа

- Доступ к значению:
T value = std::any_cast<T>(a);              // бросит bad_any_cast при ошибке
T value = std::any_cast<T>(std::move(a));   // move-версия (если T move-constructible)

// Безопасно
const T* ptr = std::any_cast<T>(&a);        // nullptr, если не тот тип
T* ptr = std::any_cast<T>(&a);              // для модификации

- Очистка:
a.reset();                          // становится пустым
a.emplace<T>(args...);              // создаёт значение типа T "на месте"


###
Пример из реальной жизни: простая конфигурация

#include <any>
#include <unordered_map>
#include <string>
#include <iostream>

using Config = std::unordered_map<std::string, std::any>;

Config config = {
    {"window_width",  1280},
    {"window_title", std::string("My Game")},
    {"fullscreen",   false},
    {"volumes",      std::vector<int>{80, 60, 100}}
};

template<typename T>
T get_config(const Config& cfg, const std::string& key, T default_value) {
    auto it = cfg.find(key);
    if (it != cfg.end() && it->second.type() == typeid(T)) {
        return std::any_cast<T>(it->second);
    }
    return default_value;
}

int main() {
    int width = get_config(config, "window_width", 800);
    std::string title = get_config(config, "window_title", std::string("Default"));
    bool fullscreen = get_config(config, "fullscreen", false);

    std::cout << title << " " << width << " fullscreen: " << fullscreen << '\n';
}


###
Важные ограничения
- Только копируемые типы: нельзя хранить std::unique_ptr, move-only типы (для этого есть библиотеки вроде Boost.Any).
- Выделение памяти: внутри обычно small object optimization (SOO), но большие объекты — на куче.
- Runtime overhead: проверка типа и каст — в runtime.




______________________________________________________________________________________








