Библиотека стандартных шаблонов  STL.
Это набор стандартных типичных решений для часто используемых задач.

______________________________________________________________________________________
string

const string& s = "aaaaaaaaaaaaaaaaaaaa";

на стеке создаётся строка которая должна хранить на стеке "aaaaaaaaaaaaaaaaaaaa". Но для оптимизации она на стеке хранит два числа и указатель: число обозначающее размер, 
число обозначающее capacity, и указатель, который указывает на динамическую память, в которой и будут храниться символы "aaaaaaaaaaaaaaaaaaaa". При создании строки она 
вызывает оператор new, для хранения строки с символами в динамической памяти. Т.е. в реальности на стеке лежать всего 24 байта с двумя числами и указателем, а всё остальное 
лежит в динамической памяти.


______________________________________________________________________________________
vector

Вектор это шаблонный динамический массив(коллекция), но только очень прокаченный. При работе с вектором мы должны явно указать с каким типом данных он работает. Подключаем 
с помощью дерективы #include <vector>. 

vector<int> myVector; 			//Инициализация вектора
vector<int> myVector = { 0, 1, 2 }; 	//Вариант инициализации.
vector<int> myVector(20); 		//Инициализация вектора с 20 элементами и все = 0.
vector<int> myVector(20, 1); 		//Инициализация вектора с 20 элементами и все = 1.

myVector.push_back(0); 	//Добавить элемент в конец вектора. Сложность: Амортизированная константа

myVector.size(); 	//Кол-во элементов в векторе

myVector[0] = 1; 	//Обращение к элементу 0. Используя [] мы можем получить доступ за пределы вектора (не проверяем границы вектора).

myVector.at(0) = 0; 	//Обращение к элементу 0. Используя .at проверяет выход за границы вектора. Он никогда не даст нам возможности получить не свои данные.
//Метод at медленнее чем [].

myVector.clear(); 	//Очищаем вектор от всех элементов.

myVector.pop_back(); 	//Удаление последнего элемента вектора. Сложность: константа
	

myVector.capacity(); //Возвращает вместимость (ёмкость) вектора, т.е. сколько элементов в нём может поместиться.
	Если мы хотим добавить новый элемент в массив, массиву каждый раз приходится выделять память для нового массива, переписывать туда старые элементы и добавлять новые 
	элементы (как и в случае с обычным массивом). Это очень накладная операция, и если бы вектор каждый раз делал так, он был бы медленным. Поэтому в векторе при 
	добавлении элемента выделяется память с запасом (т.е. на несколько элементов больше, чем нужно). Количество памяти запаса зависит от определённого коэффициента и от 
	кол-ва уже имеющихся элементов в векторе. Далее перемещаются старые элементы на свои места, добавляется новый элемент. Метод size показывает нам только кол-во имеющихся 
	элементов вектора, а метод capacity кол-во всех выделенных в памяти ячеек (и пустых запасных и заполненных). Т.е. пока у нас есть запас операции выделения новой памяти 
	и копирования старых данных производиться не будут, мы просто будем добавлять новые элементы в зарезервированные ячейки. Это хорошо сказывается на его 
	производительности.

Мы можем самостоятельно управлять этим процессом, указав сколько элементов в запасе (capacity) должно находиться в векторе:

myVector.reserve(10); 		//Указываем ёмкость вектора.
myVector.shrink_to_fit(); 	//Освобождение зарезервированной памяти (например если её слишком много). Создаётся новый массив с меньшим кол-во ячеек и переписали все элементы.

myVector.empty(); 		//Проверка пустой ли вектор. Возвращает true если вектор пустой и false если нет.

myVector.resize(20); 		//Установить кол-во элементов в векторе.

myVector.begin(); 		//Интератор указывающий на начало вектора.
myVector.end(); 		//Итератор указывающий на элемент после последнего элемента (несуществующий).
myVector.cbegin(); 		//Возврат константного итератора
myVector.cend();		//Возврат константного итератора
myVector.rbegin(); 		//Реверс итератор
myVector.rend();		//Реверс итератор



Вставка элемента в конкретное место в векторе:

myVector.insert(it, 999); //1-ый параметр: итератор, который указывает на место вставки нового элемента, 2-ой параметр: значение нового элемента. Сложность: Разная для разных случаев. https://en.cppreference.com/w/cpp/container/vector/insert

Удаления элемента из конкретного места в векторе: 

myVector.erase(it); // Удаление элемента, на который указывает итератор. Сложность: Линейная

Удалить диапазон элементов:

myVector.erase(it, it + 3); //1-ый параметр итератор указывающий на начальный элемент удаления, 2-ой параметр: итератор указывающий на конечный элемент удаления.



______________________________________________________________________________________
Теория: Сложность удаления элемента из начала вектора

Удаление элемента из начала вектора (`std::vector`) считается операцией с высокой вычислительной сложностью из-за особенностей его внутренней реализации. Давайте рассмотрим, почему 
это так.

Внутренняя структура std::vector

`std::vector` хранит свои элементы в непрерывном блоке памяти. Это означает, что элементы расположены друг за другом без промежутков. Такая организация позволяет `std::vector` 
обеспечивать очень быстрый доступ к элементам по индексу, но в то же время накладывает ограничения на операции вставки и удаления.

Удаление элемента из начала

Когда удаляете элемент из начала вектора, все оставшиеся элементы должны быть сдвинуты на одну позицию влево, чтобы закрыть образовавшийся пробел. Это сдвигание является операцией, 
которая требует времени, пропорционального количеству перемещаемых элементов. Таким образом, сложность удаления из начала вектора — `O(n)`, где `n` — количество элементов в векторе 
после удаляемого. Это делает операцию неэффективной, особенно для больших векторов.Пример:

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Удаление первого элемента
    vec.erase(vec.begin());

    // Вывод оставшихся элементов
    for (int x : vec) {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
В этом примере при вызове `vec.erase(vec.begin())`, `std::vector` должен переместить все элементы на одну позицию влево, что требует времени, пропорционального размеру вектора.

Удаление элемента из начала вектора является дорогостоящей операцией, потому что требует перемещения всех остальных элементов, чтобы поддерживать непрерывность блока памяти. В 
отличие от таких структур, как `std::list` или `std::deque`, где удаление из начала занимает константное время, `std::vector` менее подходит для задач, где часто требуется удаление 
элементов из начала или середины коллекции.


______________________________________________________________________________________
Теория: Сложность удаления элемента из конца вектора

Удаление элемента из конца вектора (`std::vector`) обычно является очень эффективной операцией с точки зрения производительности. Это связано с тем, что `std::vector` хранит свои 
элементы в непрерывном блоке памяти, и удаление последнего элемента не требует перемещения других элементов.

Сложность операции

Операция удаления элемента из конца вектора (`std::vector::pop_back()`) имеет константную сложность времени `O(1)`. Это означает, что время, необходимое для выполнения операции, не 
зависит от размера вектора. Вот почему:

1. Нет необходимости перемещать элементы: Поскольку удаляемый элемент находится в конце вектора, не требуется перемещать другие элементы для заполнения пробела.

2. Вызов деструктора: При удалении последнего элемента `std::vector` вызывает деструктор для этого объекта, чтобы корректно освободить любые ресурсы, которыми он может управлять. 
Деструктор вызывается только для одного элемента, поэтому это действие выполняется за константное время.

Пример:


#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {10, 20, 30, 40, 50};

    // Удаление элемента с конца
    vec.pop_back();

    // Вывод оставшихся элементов вектора
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}

В этом примере после вызова `vec.pop_back()`, последний элемент вектора (50) удаляется, и размер вектора уменьшается на один. Эта операция происходит за константное время, и 
последующий вывод показывает состояние вектора после удаления элемента.

Важно отметить, что удаление элемента из конца вектора не приводит к немедленному освобождению памяти, которая была выделена под массив элементов вектора. Вектор управляет своей 
памятью с помощью механизма емкости (`capacity`), которая может оставаться неизменной даже после удаления элементов. Память будет освобождена или уменьшена только тогда, когда 
будет вызван метод `shrink_to_fit` или вектор будет уничтожен.

Хотя сложность `pop_back()` константная, следует помнить, что вызов деструктора для сложных объектов может быть затратным в плане времени выполнения.
Удаление элемента из конца вектора — эффективная операция, занимающая константное время, что делает `std::vector` идеальным выбором для использования в сценариях, когда часто 
требуется добавление или удаление элементов с конца.


______________________________________________________________________________________
Внутреннее устройство класса std::vector (Implementation std::vector)

Реализуем простейшее представление класса vector с методом push_pack().

template <typename T>
class vector {
	T* arr_;
	size_t sz_;						// size
	size_t cap_;						// capacity

	void reserve(size_t newcap) {
		T* newarr_ = new T[newcap];			// Здесь позникает проблема
	}	

	void push_pack(const T& value) {			
		if(sz == cap_) {
			reserve(cap_ > 0 ? cap_ * 2 : 1); 	// Примерно так работает увеличение capacity
		}
	}
};



int main() {
		
}

При реализации метода reserve мы столкнулись с интересной проблемой. Допустим что у нас есть тип:

struct S {
	int x;
	S(int x): x(x){}
};

У данной структуры нет конструктора по умолчанию, однако мы можем создать std::vector из таких структур, но вот в нашей реализации пока это не получиться сделать, потому что у
T может и не быть конструктора по умолчанию. Да и даже если он был, мы не хотим создавать new cap_ объектов. Это одна из важнейших проблем при реализации вектора.
Нам нужно научиться сделать реалокацию, но не создавая при этом столько объектов сколько мы хотим. Когда мы говорим reserve, мы не требуем создать в 2 раза больше объектов,
мы требуем выделить память под столько объектов, и объекты мы будем класть туда по мере надобности. Какже нам выделить память под newcap объектов не создавая их? 

T* newarr_ = reinterpret_cast<T*>(new char[newcap * sizeof(T)]);			// Решаем проблему, однако это не лучший способ.

Но мы не можем себе позволить вызвать new от T, потому что он будет пытаться создать n штук от T, но мы не должны, мы должны выделить чистую память байтов нужного кол-ва, а
дальше её чем то заполнять.

Цифрами будем помечать грабли(ошибки), которые сведетельствуют о неумении реализовывать push_pack().
(28 лекция 34.10)

В (2) у нас UB. Очень важно понять почему это так, почему в строчке (2) UB. Представим вектор из string. Что сейчас такое newarr[index]? Это сырые байты, там нет никокого 
объекта. Мы пытаемся сделать присваивание какой то штуке, которая скастится к ссылке на T, но там нет T ещё, объект ещё не создан, мы не можем присваивать туда ничего. У нас там
чары просто лежат, байты сырые. Мы вызываем оператор присваивания от T к другому T, но в newarr T ещё нет.

template <typename T>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;

	void reserve(size_t newcap) {
		T* newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)]); 	// Решаем проблему, однако это не лучший способ.	(1)Грабля 
		for(size_t index = 0; index < sz_; ++index) {				
			newarr[index] = arr_[index];					// (2) Грабля. В newarr ещё нет никаких объектов, там просто выделена память, а мы уже хотим чтото присвоить.
		}
	}	

	void push_pack(const T& value) {			
		if(sz == cap_) {
			reserve(cap_ > 0 ? cap_ * 2 : 1); 	
		}
	}
};

Можно попробовать копировать память с помощью memcpy, но это не будет работать для ситуации если одно из полей объекта является указателем или ссылкой на другое его поле. Эти
объекты кажутся странными: Вот пример типа, который не переживёт такую реалокацию с помощью memcpy:

struct Strange {
	int x;
	int& r;		// r будет ссылаться на x.
	Strange(int y): x(y), r(x) {}
};

Также например std::string является таким типом. Если у нас какие то элементы вектора ссылаются на другие элементы ввектора это не переживёт релокацию, и не должно, при 
реалокации вектора дропаются указатели и ссылки на все его предыдущие элементы. Но если поле является ссылкой на другое своё же поле, того же объекта, то это должно пережить 
реалокацию. 

Короче нельзя делать memcpy. По сути нам нужно по данному адресу вызвать конструктор данного типа на сырой памяти. Как вызвать конструктор данного типа по данному адресу, зная 
что там пока не лежит никогого объекта? В данном случае нам потребуется языковая конструкция placement new. У оператора new есть, на ряду со стандартной формой new[T], есть ещё
new с параметром (поинтером): new(newarr + index) T(arr[index]); // placement new. Вызвать конструктор данного типа по данному адресу.

Далее нам нужно освободить старый массив. Для этого нам сначало нужно вызвать все деструкторы, причём вызвать их явно. Мы не можем просто вызвать оператор delete: 
delete arr_, поскольку он будет вызывать деструкторы, но в каком кол-ве и по каким адресам? Мы не можем удалить arr_ как будто это массив T, потому что изначально arr_ мы 
выделяли как массим чаров, а не T. Когда мы создавали arr_, мы его также создавали как сырые байты, мы не можем вызвать оператор delete[] на нём, потому что он будет думать,
что это был массив T, но там небыло T. Он будет смотреть на то что он записал слева как на размер этого массива, и пытаться вызвать деструкторы в таком кол-ве, но на самом деле,
там небыло столько объектов. Поэтому нам нужно delete обратно реинтропредкастнуть к char*, а деструкторы нужно вызвать вручную. Также ещё деструкторы нужно вызвать вручную, 
поскольку, reserve мы можем вызывать не только когда у нас sz_ переполнено, мы можем сделать reserve на большее, если у нас массив даже не целеком был заполнен объектами ещё.
И в этом случае мы должны вызвать ровно столько деструкторов, сколько было объектов, а остальная память была ещё незаполнена.

Теперь нам нужно будет поменять размер cap_ и arr_.

template <typename T>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;

	void reserve(size_t newcap) {
		if (newcap <= cap_)							// Если мы делаем reserve на чтото меньшее просто прерываем функцию.
			return;
		
		T* newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)]); 	
		for(size_t index = 0; index < sz_; ++index) {			
			//newarr[index] = arr_[index];	
			new(newarr + index) T(arr[index]); 				// placement new. Вызвать конструктор данного типа по данному адресу.
		}
		
		//delete arr_;								// Так нельзя
		
					
		for (size_t index = 0; index < sz; ++index) {				// Освобождаем старый массив
			(arr_ + index)->~T();						// Вызов деструкторов вручную
		}
		delete[] reinterpret_cast<char*>(arr_);		

		arr_ = newarr;								
		cap_ = newcap;								// Меняем размер
	}	

	void push_pack(const T& value) {			
		if(sz == cap_) {
			reserve(cap_ > 0 ? cap_ * 2 : 1); 	
		}
	}
};


Теперь нехватает exception safety. Напишем безопасный относительно исключений reserve. new здесь может кинуть исключение в нескольких местах:

1) T* newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)]); 
Если new кинет исключение здесь, то ничего страшного не будет, поскольку к этому моменту мы ещё ничего не испортили, потому что память не удалось выделить, мы так наверх и
вылетем с этим исключением bad_alloc.

2) new(newarr + index) T(arr[index]);
placement new сам по себе не кидает исключение, потому что он памяти новой не запрашивает ни у кого, он только вызывает конструктор. Но здесь T может кинуть исключение в 
конструкторе, и вот это самое неприятное. Нам нужно удалить всё то, что мы до этого успели скопировать. Поэтому мы всё это оборачиваем в try. Однако мы не узнаем что такое 
newarr вне try, поэтому newarr мы должны объявить до try, также index объявляем вне try. В блоке catch вызываем деструкторы в кол-ве равному сколько мы успели создать объектов.
Незабываем reinterpret_cast только теперь не к arr_ а к newarr. throw нужен чтобы бросить дальше то, что мы поймали.

Всегда считаем что деструкторы вызывать безопасно, потому что они не кидают исключения, delete так же не кидает исключений.

template <typename T>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;

	void reserve(size_t newcap) {
		if (newcap <= cap_)							
			return;

		size_t index = 0;
		T* newarr = newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)]);	
						
		try {
			T* newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)]); 	
			for(; index < sz_; ++index) {				
				new(newarr + index) T(arr[index]); 				
			}		
		} catch(...) {
			for(size_t oldindex = 0; oldindex < index; ++oldindex) {
				(newarr + oldindex)->~T();
			}
			delete[] reinterpret_cast<char*>(newarr);	
			throw;
		}		
	
		for (size_t index = 0; index < sz; ++index) {				
			(arr_ + index)->~T();						
		}
		delete[] reinterpret_cast<char*>(arr_);		

		arr_ = newarr;								
		cap_ = newcap;								
	}	

	void push_pack(const T& value) {			
		if(sz == cap_) {
			reserve(cap_ > 0 ? cap_ * 2 : 1); 	
		}
	}
};

Мы сделали reserve и вернёлись к push_back. И теперь мы пытаемся положить на новое место новый элемент. А вдруг он кинет исключение? Тогда нам нужно будет всё вернуть как было.
На самом деле push_back выражать через reserv не очень хорошо, потому что push_back должен отличаться от reserve тем, что после цикла с placement new ещё пытаемся не выходя из
этого try, сделать new по newarr + sz_ T(value); И только потом в catch обратно всё кладём.

Такой push_back() сойдёт на троечку, по крайней мере не UB.



######################
Есть ещё особый вид вектора - вектор bool. Самое интересное в векторе bool это оператор []. Как реализовать его? Мне нужно чтобы я мог присваивать квадратными скобочками, и 
это меняло один битик в векторе.

Вектор bool от обычного вектора отличается ?


Лайфхак: чтобы узнать какой тип у T (т.е. у v[5]) можно сделать так:

template <typename T>
class Debug {
	Debug(T) = delete;
};

int main() {
	std::vector<bool> v(10);
	v[5] = true;			// Хотим узнать какой тип у v[5]
	Debug d(v[5]);			// CE, но компилятор подсказывает что это за тип - std::_Bit_reference
}

std::_Bit_reference это внутренний тип, который интересно устроен. Квадратные скобочки в векторе от bool должны возвращать этот тип по значению. Не ссылку а копию. Потому что
нам нужен новый объект создать. _Bit_reference будет так устроен, что он будет хранить указатель на ячейку и номер бита в этой ячейке. Так же этот _Bit_reference будет уметь
то, что присваивание ему будет менять эту ячейку. Присваивание bool _Bit_reference меняет под указателем битик по нужному индексу. 

Что делают [] в векторе bool? Они должны вернуть новый объект _Bit_reference. Мы просто создаём _Bit_reference от соответствующей ячейки.

Также у BitReference должен быть оператор неявного каста в bool.

template <>
class vector<bool> {
	char* arr;
	size_t sz_;
	size_t cap_;

	
	struct BitReference {
		char* cell;
		unit8_t index;
		
		BitReference(char* cell, uint8_ index) :
			cell(cell), index(index) {}

		void operator=(bool b) {
			if(b) {
				*cell |= (1 << index);
			} else {
				*cell &= ~(1 << index);
			}
		}

		operator bool() const {					// оператор неявного каста в bool
			return *cell & (1 << index);
		}
	};
public:
	BitReference operator[](size_t index){
		return BitReference(arr_ + index / 8, index % 8);
	};

};

int main() {
	std::vector<bool> v(10);
	v[5] = true;
	Debug d(v[5]);
}

Когда я говорю v[5] = true; что на самом деле происходит: на самом деле v[5] это rvalue. BitReference это новый временный объект, это не ссылка, и ему можно присваивать, и это
присваивание работает как изменение объекта вектора. Это пример ситуации когда rvalue можно и нужно чтото присваивать.

В остальном вектор bool ничем не примечателеню.


____________________
Инвалидация указателей в векторе

Представим такой пример: Что будет?

vector<int> v(10);
int* p = &v[5];
v.push_back(1);		// pointer invalidation
cout << *p;

Правильный ответ будет UB, потому что нельзя ничего вставлять в вектор(в том числе push_back) и после чего разыменовывать указатели на элементы вектора, которые были созданы до
этого. Это явление называется инвалидация указателей. Потому что вектор мог реалоцироваться, и скорее всего так и произошло, потому что когда мы создаём вектор от конкретного 
числа элементов, он ровно столько памяти и выделяет. Когда мы сделали push_back(), capacity вектора стало 20, произошла реалокация, и теперь этот указатель указывает на память,
которая нам больше не пренадлежит.

А что если бы я сделал не указатель а ссылку? Мы завели ссылку на элемент вектора, теперь ref это другое название для v[5].

vector<int> v(10);
int& ref = v[5];
v.push_back(1);		
cout << ref;

Это UB. Произойдёт всё тоже самое, что и с указателем. В данном случае произойдёт reference invalidation (битая ссылка).

Вектор инвалидирует указатели и ссылки на свои элементы после того как вектор был изменён. pop_back() не инвалидирует, кроме того элемента, который удалили. shrink_to_fit 
инвалидирует, потому что релацирует.



______________________________________________________________________________________
Итераторы STL и категории итераторов

В контейнерах list, map уже не получится делать индексацию привычным нам способом поэлементно. Дело в том что индексом в них может быть не обязательно число. Но нам важно иметь
обобщённую итерацию. 

Итератор это такой тип, который позволяет нам делать обход последовательности в различных контейнерах STL. Поведение итераторов очень похоже на поведение указателей и на поведение 
умных указателей. Но сами по себе итераторы не являются указателями, это некая объектная оболочка над указателями, которая позволяет нам себя разыменовывать и инкрементировать, ещё 
сравнивать на равенство друг с другом. Это главные свойства, которыми должен обладать итератор. Обычный указатель это тоже итератор, умный указатель уже не итератор поскольку его 
нельзя инкрементировать. Для разных групп контейнеров в STL итераторы организованы по разному. В любом контейнере должно быть можно обходить итератором.

В каждом стандартном контейнере внутри определён тип Iterator, который позволяет ходить по этому контейнеру, и в зависимости от контейнера он разный по виду.


Итераторы в стандарте подразделяются на категории:
Сейчас мы обсуждаем не конкретные типы в c++, а мета типы (например как отличается структура двусвязный список и его реализация в c++ под названием list)

1) Самый минималистичный итератор называется InputIterator, это итератор умеет только эти базовые свойства. 

2) Частным случаем InputIterator является ForwardIterator. Тип считается ForwardIterator если он считается InputIterator, и вдобавок ещё гарантирует (в отличии от InputIterator), 
что если мы будем ходить по одной и той же последовательности несколько раз, не меняя её, то мы будем видеть одно и тоже.

Пример: Итератор в односвязном списке, он не является BidirectionIterator. 
Контейнеры, которые имеют такие итераторы: forward_list, unordered_set, unordered_map

3) BidirectionIterator вдобавок к ForwardIterator ещё умеет декрементировать (--)
Контейнеры, которые имеют такие итераторы: list, set, map

4) RandomAccessIterator ещё умеет делать += число, -= число, просто умеет складываться с числом, разность двух итераторов, сравнивать на <, >, <=, >=.
Контейнеры, которые имеют такие итераторы: deque

5) (C++17) ContiguousIterator частный случай RandomAccessIterator. Он гарантирует что он эквивалентен указателю, в том смысле что если мы разыменуем итератор, потом обратно
возьмём адрес, прибавим N и снова разыменуем, то это было бы всё ровно, что мы просто к оператору прибавили N и разыменовали. *(& * it + n) == *(it + N)
Т.е. сложение итераторов, это прсто хождение по  памяти на N шагов. В деке это не так, потому что там элементы в памяти лежат неподряд.

Контейнеры, которые имеют такие итераторы: vector, array, любой указатель


Все std алгоритмы принимают итераторы.


##########################
Пример на обычном массиве:

int arr[] = { 2,6,9 };		
cout << arr[1] << endl;		// Доступ ко 2-ому элементу массива (значение 6).
cout << *(arr + 1) << endl; 	// Это тоже доступ ко 2-ому элементу массива (значение 6). Используем разыменование указателя на имя массива + 1. Имя массива это есть указатель 
				// на его первый (индекс 0) элемент. Получается указатель на первый элемент + 1 равен указатель на второй элемент массива.

Работа с итераторами в STL похожа на это.

myVector.begin(); 		//Интератор указывающий на начало вектора.
myVector.end(); 		//Итератор указывающий на элемент после последнего элемента (несуществующий).

vector<int> myVector = {1,9,44,422,676,78}; 	//Инициализация вектора
	
vector<int>::iterator it; 	//Создание итератора vector с типом данных int
it = myVector.begin(); 		//Теперь итератор указывает на первый элемент нашего вектора (связываем итератор с нашим вектором).
cout << *it << endl; 		//Получаем данные через итератор (сейчас в итераторе данные из первого элемента вектора).
*it = 5; 			//Присваиваем новое значение через итератор.
it++; 				//Инкремент итератора означает что мы переходим на следующий элемент вектора.
it += 2; 			//Сдвиг на 2 элемента вправо.
it--; 				//Сдвиг на 1 элемент влево.

for (vector<int>::iterator i = myVector.begin(); i != myVector.end(); i++)
{
	cout << *i << endl;
}
return 0;


Константный итератор. Разрешено только чтение, запись запрещена.

for (vector<int>::const_iterator i = myVector.begin(); i != myVector.end(); i++)
{
	//*i = 5;		//Ошибка, перезапись константы запрещена.
	cout << *i << endl;
}
return 0;

Константый итератор в переменную обычного итератора мы присвоить не можем.


Мы можем итерировать с конца коллекции в начало:

for (vector<int>::reverse_iterator i = myVector.rbegin(); i != myVector.rend(); i++)
{
	cout << *i << endl;
}


Не все итераторы можно перемещать используя арифметику указателей, поэтому существует функция перемещения итератора:

advance(it, 3);  //1-ый параметр: итератор, который нужно переместить, 2-ой параметр: на сколько шагов.



Вставка элемента в конкретное место в векторе:

myVector.insert(it, 999); 	//1-ый параметр: итератор, который указывает на место вставки нового элемента, 2-ой параметр: значение нового элемента.

Удаления элемента из конкретного места в векторе: 

myVector.erase(it); 		// Удаление элемента, на который указывает итератор.

Удалить диапазон элементов:

myVector.erase(it, it + 3); 	//1-ый параметр итератор указывающий на начальный элемент удаления, 2-ой параметр: итератор указывающий на конечный элемент удаления.


#########################
i++ или ++i в for

Разница в использовании префиксного и постфиксного инкремента/декремента для итераторов в том, что в случае префиксного итератора, в теории, просто изменяется состояние объекта, 
и потом он возвращается, а при использовании постфиксного инкремента, состояние также изменяется, но возвращается объект с предыдущим состоянием, т.е. для этого компилятору 
необходимо создать ещё 1 объект. Это влияет на скорость работы. Но, вроде как современные компиляторы уже могут сами оптимизировать подобные случаи, и скорость работы не 
отличается. Но для себя я всё же сделал вывод, что если использование префиксного и постфиксного инкремента не влияет на правильность ответа, то предпочтительно использовать 
префиксный инкремент.

int a = 5;

cout << a++ << endl; //В консоль выведется 5, после того как все операции закончились (в нашем случае вывод в консоль), a присвоется значение 6. (Переменная сначала вывелась, 
		     //затем увеличилась).

cout << ++a << endl; //В консоль выведется 6 сразу (Переменная сначала увеличилась, затем вывелась).


##########################
range-based for

Начиная с C++11 мы для любого элемента в контейнере можем написать так:
set<int> s;
for(int x : s) {

}

Вопрос: Что это формально значит? Что значит : в for? На самом деле это синтаксический сахар. Раньше до C++11 приходилось писать так:

for(std::set<int>::iterator it = s.begin(); it != s.end(); ++it) {
	// И работать в теле цикла с разыменованном it: *it
}

Чтобы в нашем контейнере работал цикл ренч бэйсит фор нужно определить методы begin() и end() и итератор.

При старте цикла, range-based for запоминает(кэширует) изначальные begin и end которые были, и идёт в их границах, независимо от того, что происходит с точки зрения реалокаций.
Запоминает он их для того, что постоянный вызов метода end() может быть дорогостоющим. 


С вектором и деком так делать нельзя:

std::vector<int> v = {1, 2, 3, 4, 5};
for(int& x : v) {
	v.push_back(x);			// UB. Для дека это тоже UB.
}
for(int& x : v){
	std::cout << x;
}



Оффтоп про range-based for:

Перебор всех элементов массива arr

int arr[] = { 5,11,94,99,44 };

for (int var : arr) 			//Перебор всех элементов массива arr
{
	cout << var << endl;
};

этот цикл называется range-based цикл. В каждой итерации этого цикла в переменную var будет скопирован следующий элемент массива (начинаю с 0). Это означает что при изменении
переменной var, элемент коллекции не изменяется. Если нужно изменять элементы коллекции, то нужно передавать элементы по ссылке:

for (int &var : arr) 			//Перебор всех элементов массива arr
{
	var++;
	cout << var << endl;
};

Если нужно передавать элемент по ссылке, но не нужно его его изменять, то нужно указать ключевое слово const:

for (const int &var : arr)
{
	//var++; 			//Не получится
	cout << var << endl;
};


С помощью этого цикла мы можем перебрать контейнер без итератора:

list<int> myList = { 1,99,4,94,799,44,6 };

for (const auto &var : myList)
{
	cout << var << endl;
};


##########################
Как узнать тип который лежит под итератором?

Представим что я пишу итератор.

Имея шаблонный тип InputIterator как мне узнать тип. Вдруг это поледовательность из double или int или string или чтото другое.

Можно написать используя auto, 

template <typename InputIterator>
void findMostOftenNumber(InputIterator begin, InputIterator end){
	auto x = *begin;	
}

однако это может дать неверный результат в некотором случае: Если мы возьмём в векторе bool begin и разыменуем, что мы получим? 

template <typename T>
void f() = delete;

int main() {
	std::vector<bool> vb(10);
	f(*vb.begin());
}

Я же должен уметь по begin присваивать. И должен от этого поменяться вектор от bool. Значит разыменование begin должно давать мне ту самую BitReference, присваивание которой
должно поменять исходный bool (битик). Т.е. для вектора bool это будет некорректным типом, нельзя написать auto, потому что тип разыменованного begin это не всегда то, что 
нужно. Это не всегда тот тип, из которого реально состоит последовательность, это может быть какая нибудь обёртка над ним.

Существует стандартная метафункция для узнавания какой тип лежит под инетратором, а точнее существует целый набор метафункций для узнавания много чего про итератор и называется
это iterator_traits: Нужно писать typename, потому что value_type зависимое имя.

template <typename InputIterator>
void findMostOftenNumber(InputIterator begin, InputIterator end){
	typename std::iterator_traits<InputIterator>::value_type x = *begin;
}

iterator_category позволяет узнать категорию итератора.

std::distance - считает разность итераторов. Считает кол-во шагов которое нужно чтобы дойти от first до last. Если итератор RandomAccessIterator то за O(1), если нет то за O(n).
Реализация функции distance, Нам нужно как то написать: если итератор поддерживает операцию вычетания, то просто вычесть разность и вернуть её, а если нет, то завести цикл и 
посчитать кол-во шагов, которое нам потребовалось чтобы дойти от first к last. Для этого нужно написать условие if constexpr. Если мы напишем без if constexpr, то будет CE
когда мы подставим не RandomAccessIterator, потому что эта строчка будет пытаться компилироваться.

template <ypename Iterator>
typename std::iterator_traits<Iterator>::difference_type
distance(Iterator first, Iterator last) {
	if constexpr (std::is_base_of_v<							// O(1)
			std::random_access_iterator_tag,
			typename std::iterator_traits<Iterator>::iterator_category	
			>) {
		return last - first;
	} 
	int i = 0;
	for(int i = 0; first != last; ++i, ++first);						// O(n)
	return i;
}


std::advance - аналогично действует.

std::prev - функция которая даёт итератор на предыдущий элемент
std::next - функция которая даёт итератор на следующий элемент


Примеры из жизни про итераторы:
Виды итераторов довольно глубокая и достаточно абстрактная идея, применимая не только к C++. Если задуматься, виды итераторов это про то, насколько качественно у нас запомнена
информация. Однако, наличие итераторов это на самом деле большое требование и достаточно большое усложнение. Без итераторов контейнеры можно было бы реализовать гораздо проще. 
Наличие итераторов в каждом контейнере - это требование, которое сильно усложняет реализацию, потому что помнить с итераторами это существенно более сложнее чем просто помнить. 

Например помнить материал семестра по c++ то одно (InputIterator), другое дело это когда мы не просто помним, а ещё можем перечислить в правильном порядке как был рассказан этот
материал, т.е. у нас появляется итератор (ForwardIterator). Ещё сложнее это помнить материал семестра в обратную сторону (BidirectionIterator), и ещё сложнее когда мы помним как
RandomAccessIterator.

Пример 2: 
InputIterator: У нас у каждого есть список чатов в телеге. И про каждого произвольного человека мы можем сказать есть ли у меня с ним чат, переписываемся ли мы с ним. Однако 
мы врядли можем перечислить все свои чаты хоть в каком то порядке, гарантированно не забыв ни про кого. Просто помнить какое то множество вещей это гараздо меньше, чем помнить 
с итератором.

ForwardIterator: С другой стороны, например мы помним стихотворение "У лукоморья дуб зелёный", но если вас спросят как строчка идёт перед строчкой "И 33 витязей прекрасных",
нам придётся линейное время потратить чтобы вспомнить (перебор всех строк до нужной), потому что когда мы учим стихи мы помним их только в одну сторону. Мы не просто помним все
строки по отдельности, мы помним их умея переходить к следующей, но мы не умеем переходить к предыдущей. Уметь переходить к предыдущей это нечто большее.

BidirectionIterator: Мы можем помнить остановки метро. Что после Тульской? Нагатенская. А в обратную сторону Серпуховская. Но мы врядли скажем за O(1) как называется остановка,
находящаяся через 10 остановок от нас, даже если мы помним всю ветку и ездием по ней регулярно.

RandomAccessIterator: Наконец если мы помним информацию прям от O(1).



______________________________________________________________________________________
Реализация итераторов. Const и reverse итераторы.

Как реализовать итератор для своего контейнера? В контейнере должен быть внутренний тип, называющийся Iterator. На примере вектора он будет хранить указатель на T. Так же у него
должны быть методы: конструктор, копи конструктор, присваивание, уничтожаться, свопаться. Также чтобы получить итератор на вектор нужна функции begin() и end().

Как переопределять оператор стрелочка? У неё странный синтаксис: она ничего не принемает. В стандарте есть костыль: если мы переопределяем стрелочку, когда мы пишем:
СвойТип->что_то то берётся наша стрелочка и к тому что она вернула автоматически дописывается ещё стрелочка. Т.е. мы должны вернуть поинтер в чистом виде и компилятор сам 
допишет в него ещё стрелочку. Т.е. переопределение стрелочки тривиально, мы просто возвращаем поинтер и всё.  

template <typename T>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;

public:
	class iterator {
	private:
		T* ptr;
		iterator(T* ptr): ptr(ptr){}			// Конструктор от T* 
	public:
		iterator(const iterator&) = default;		// Копи
		iterator& operator=(const iterator&) = default; // Присваивание

		T& operator*() const {				// Разыменовывание
			return *ptr;	
		}
		T* operator->() const {				// Переопределение стрелочки
			return ptr;
		}

		iterator& operation++() { 			// Инкремент префексный
			++ptr;	
			return this;
		}
		iterator operator ++(int) {			// Инкремент постфиксный
			iterator copy = *this;
			++ptr;
			return copy;
		}		
	};	

	iterator begin() {
		return iterator{arr_};
	}

	iterator end() {
		return iterator{arr_ + sz_};
	}
};


Это всё база. Поговорим о том, как сделать итератор константным, не в смысле что сам итератор константный, а в смысле всё что под ним не должно меняться. Мы хотим сделать так, 
чтобы у нас был аналог указателей на константу в мире итераторов. Т.е. такой вид итератороа, что если мы его берём, то разыменование его даёт нам const T&, а не просто T&. И 
такой итератор тоже должен быть в каждом контейнере и называется он const_iterator. И вот нужно не путать когда сам итератор константный и когда он const_iterator в смысле
как итератор на константу. Когда мы видем const_iterator это означает то что мы получим при  разыменовании будет const, а не сам тератор const. Он выглядит почти также как и 
реализация обычного итератора, только нам нужно сделать указатель на константу и возвращать const_iterator.

template <typename T>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;

public:
	class const_iterator {						
	private:
		const T* ptr;						
		const_iterator (T* ptr): ptr(ptr){}			
	public:
		const_iterator (const const_iterator &) = default;		
		const_iterator & operator=(const const_iterator &) = default; 

		const T& operator*() const {				
			return *ptr;	
		}
		const T* operator->() const {				
			return ptr;
		}

		const_iterator & operation++() { 			
			++ptr;	
			return this;
		}
		const_iterator  operator ++(int) {			
			const_iterator  copy = *this;
			++ptr;
			return copy;
		}		
	};	

	class iterator {
	private:
		T* ptr;
		iterator(T* ptr): ptr(ptr){}			// Конструктор от T* 
	public:
		iterator(const iterator&) = default;		// Копи
		iterator& operator=(const iterator&) = default; // Присваивание

		T& operator*() const {				// Разыменовывание
			return *ptr;	
		}
		T* operator->() const {				// Переопределение стрелочки
			return ptr;
		}

		iterator& operation++() { 			// Инкремент префексный
			++ptr;	
			return this;
		}
		iterator operator ++(int) {			// Инкремент постфиксный
			iterator copy = *this;
			++ptr;
			return copy;
		}		
	};	
};


Глядя на это возникает естественное желание убрать копипасту. Это можно сделать с помощью шаблонов. Как единожды написав тело класса iterator получить и interator и 
const_iterator одним махом? Нам нужно, чтобы в зависимости от параметра IsConst тип был то T* то const T*. Нам поможет std::conditional_t. Для облегчения кода нужно использовать
using для определение типа указателя, типа ссылки и типа по значению. Теперь base_iterator должен быть приватным. И теперь iterator в классе vector это у нас using. 

Теперь нужно поговорить про методы begin() и end(). Эти методы константные или нет? Правильно эти методы нужно определить по разному для константного и неконстантного вектора.
У константного вектора тоже можно вызвать методы begin() и end(), и если например мы вызовем метод begin() то он просто вернёт const_iterator.

Помимо begin() и end(), есть ещё cbegin() и cend(), которые возвращают const_iterator даже для неконстантного контейнера.

Так же теперь нам нехватает одного важного метода, с помощью которого любой итератор неявно преобразовывался в константный итератор, чтобы каст от обычного итератора к конст 
итератору работал неявно, а в обратную сторону нет. Есть два способа: можно сделать через дополнительный конструктор, а можно сделать через оператор приведения типа.
Сделаем с помощью 2-ого способа.

Также сделаем класс vector дружественным классом для класса base_iterator, поскольку конструктор base_iterator приватный.


template <typename T>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;

private:	
	template <bool IsConst>
	class base_iterator {
	public:
		using pointer_type = std::conditional_t<IsConst, const T*, T*>;		// Тип указателя
		using reference_type = std::conditional_t<IsConst, const T&, T&>;	// Тип ссылки
		using value_type = T;							// value_type говорит нам о том, какой тип лежит в контейнере.
	
	private:	
		pointer_type ptr;
		base_iterator(T* ptr): ptr(ptr){}	
		friend class vector<T>;		
	public:
		base_iterator(const base_iterator&) = default;		
		base_iterator& operator=(const base_iterator&) = default; 

		reference_type operator*() const {				
			return *ptr;	
		}
		pointer_type operator->() const {				
			return ptr;
		}

		base_iterator& operation++() { 			
			++ptr;	
			return this;
		}
		base_iterator operator ++(int) {			
			base_iterator copy = *this;
			++ptr;
			return copy;
		}

		operator base_iterator<true>() const {	// Неявное преобразование без конст в конст итератор
			return {ptr};
		}		
	};
public:
	using iterator = base_iterator<false>;		// Итератор
	using const_iterator = base_iterator<true>;	// Константный итератор
	
	iterator begin() {			// begin с обычным итератором
		return {arr_};
	}
	
	iterator end() {			// end с обычным итератором
		return {arr_ + sz_};
	}

	const_iterator begin() const {		// begin с const_iterator
		return {arr_};
	}

	const_iterator end() const {		// end с const_iterator
		return {arr_ + sz_};
	}

	const_iterator cbegin() const {		// cbegin() возвращает const_iterator для любого контейнера (имеется ввиду неконстантного и константного)
		return {arr_};
	}

	const_iterator cend() const {		// cend() возвращает const_iterator для любого контейнера
		return {arr_ + sz_};
	}
};


##################################
Ещё у контейнеров есть такой тип reverse_iterator и const_reverse_iterator. Мы хотим уметь ходить по последовательности и назад, если исходный итератор будет хотя бы 
BidirectionIterator. Чтобы обойти например map или set в обратном порядке нужен reverse_iterator. Просто std::iterator это устаревший тип с C++17(Его больше нет, он безполезен). 
В стантартной библиотеке это отдельный класс std::reverse_iterator, и на самом деле это адаптер над итератором. reverse_iterator шаблонизирован параметром iterator, и это
по сути обёртка над обычным другим итератором, которая берёт все наши действия и разворачивает в обратную сторону. reverse_iterator можно создать от произвольного итератора, и 
он в себе будет хранить этот итератор. Когда мы просим reverse_iterator сделать ++ он просто делает декремент(--) у итератора который лежит в нём, и наоборот. Когда мы делаем
звёздочку или стрелочку, он нам просто возвращает, но возвращает не тот итератор, который лежит, а его минус 1. Зачем минус 1? Чтобы мы когда от end делаем ревёрс, то получаем 
rbegin (rbegin это итератор на end (конец)), когда мы от begin делаем ревёрс мы получаем rend (rend это итератор на место, которое находится перед begin (началом)). 

Т.е.  begin даёт итератор на начальный элемент, end даёт итератор на место, после последнего элемента.
      rbegin даёт итератор на последний элемент, rend даёт итератор на место, которое находится перед начальным элементом.


reverse_iterator в векторе. Самостоятельно реализовывать реверс итераторы не нужно. Достаточно использовать std::reverse_iterator:

using iterator = base_iterator<false>;					// Итератор
using const_iterator = base_iterator<true>;				// Константный итератор
using reverse_iterator = std::reverse_iterator<iterator>;		// Реверс итератор
using const_reverse_iterator = std::reverse_iterator<const_iterator>;	// Константный реверс итератор

Теперь мы умеем ходить взади-вперёд по вектору с помощью итераторов. Так же есть crbegin() и crend(), они ведут себя аналогично как и rbegin() и rend().


______________________________________________________________________________________
Инвалидация итераторов в векторе (Важный пример)
Вернёмся к примеру с инвалидация указателей:

В векторе из-за реалокации у нас может произойти инвалидация ссылки и указателя:
vector<int> v(10);
int& ref = &v[5];
v.push_back(1);		// UB
std::cout << ref;

Если так сделать с деком, то всё будет нормально. А что если в векторе мы так сделаем не с указателем или ссылкой, а с итератором? Можно ли так делать с итераторами? Происходит
ли инвалидация итераторов?

vector<int> v(10);
std::vector<int>::iterator x = v.begin() + 5;	
v.push_back(1);					// UB или нет?
std::cout << *x;				

Ответ: Нет, в векторе так НЕЛЬЗЯ делать, это UB, так же как и в случае ссылок и указателей.


Но ведь мы могли бы в итераторе вектора хранить просто индекс и указатель на сам вектор, чтобы при реалокации не происходило инвалидации. Однако, это плохо, потому что это 
неэффективно. Если бы мы в итераторе хранили указатель на сам контейнер, то разыменование итератора занимало бы 2 разыменования, вместо одного, т.е. сначала разыменовываем 
указатель и получить контейнер, потом разыменовать ещё указатель и получить элемент. Мы хотим, чтобы разыменовать итератор было так же дёшево, как разыменовать указатель. 
Ни в каких итераторах мы не храним указатели на контейнер. Но и на самом деле мы и формально не сможем так сделать, потому что мы не сможем соблюсти одно из требований к 
итератору: Мы должны уметь свопать контейнеры, а итераторы при этом должны оставаться корректными. Поэтому итератры в веторе инвалидируются. 


В деке итераторы тоже инвалидируются! Это довольно глубокое понимание, что в деке указатели и ссылки неинвалидируются, а вот итераторы инвалидируются. Т.е. завести указатель и 
ссылку на элемент дека, а потом положить что-то в дек, указатель и ссылка остануться валидными. А вот завести итератор на элемент дека, и чтото положить в дек, после этого
разыменовывать итератор это UB. Потому что в деке итератор будет состоять из двух указателей на элемент внешнего и элемент винутреннего массива. Нам нужно хранить указатель на 
элемент внешнего(вертикального) массива, но внешний массив может реалоцироваться при push_back() в деке. 

В std::list, std::forward_list, std::map, std::set ничего не инвалидируется никогда, потому что ничего не реалоцируется. В std::set ноды не реалоцируются от того что мы чтото 
добавляем. В них только переставляются поинтеры, они переподвешиваются, но они не реалоцируются сами по себе. 



______________________________________________________________________________________
output iterators and stream iterators.

Допустим мы хотим скопировать элементы одного диапозона в другой с помощью std::copy поэлементно из вектора в массив. Массив размером 10 и вектор размером 5, при чём масси 
заполнен только на первые 5 элементов, остальные 5 элементов пустые. С помощью std::copy мы можем скопировать элементы из вектора в массив. Но можем ли мы скопировать элементы
из массива в вектор?  

#include <algorithm>
#include <vector>

int main() {
	int a[10] = {1, 2, 3, 4, 5};
	std::vector<int> v(5);
	
	std::copy(v.begin(), v.end(), a);	// Так мы можем
	
	std::copy(a, a + 10, v.begin());	// UB	
}

std::copy это просто алгоритм который разыменовывает, присваивает, инкрементирует (и так повторяется по все элементам). Он не делает push_back(). Этот алгоритм ничего не знает
про то, что лежит под итератором, он воспринимает итератор просто как указатель. Если мы передадим ему вектор, он просто начнёт писать за границу этого вектора. Хуже если мы 
передадим ему std::list: в векторе хотябы элементы лежат по порядку в памяти. Но если там list, map или set, то в какой то момент, когда дойдёт до конца.он сделает инкремент 
итератора, и просто по тупому будет дальше разыменовывать и присваивать, но инкремент это же прыжок по указателю, но если конец списка то указатель никуда не ведёт и от nullptr
он упадёт, или же он может быть зацикленный и вести сам на себя, тогда он будет писать в себя же несколько раз. Короче эти итераторы не подходят для того, чтобы по ним писать.
И поэтому они не являются output итераторами.


output итератор, это такой итератор, который гарантирует, что можно его разыменовыват, инкрементировать и присваивать и так делать сколько угодно раз и ничего не сломается.
Он гарантирует корректность, если мы будем писать в него с помощью алгоритмов. Итераторы в контейнерах такими не являются, поэтому нам нужен отдельный вид итераторов.

Пример 1) insert_iterator. Как можно сделать так, чтобы можно было использовать стандартные алгоритмы над контейнерами, чтобы в контейнере писать. Вот мы хотим написать 
std::copy_if который копирует все чётные числа:

bool even(int x) {		// Предикат
	return x % 2 == 0;
}

std::copy_if(a, a + 10, v.begin(), &even);

Но я не могу так напрямую вызывать этото алгоритм, потому что он вызовет UB, потому что будет писать мимо вектора, начиная с какого то момента. Какую обёртку написать над 
вектором, чтобы это корректно работало? Нужно сделать обёртку над итератором вектора, которая предоставляла бы мне интерфейст output итератора. 

Такая обёртка называется back_insert_iterator. Это output итератор, который докладывает в конец элементы в контейнер для которого был сконструирован. 

bool even(int x) {		// Предикат
	return x % 2 == 0;
}

std::copy_if(a, a + 10, std::back_insert_iterator<std::vector<int>>(v), &even);


Реализация класса back_insert_iterator:
Это такая обёртка над итератором, которая хранит ссылку на контейнер, и умеет конструироваться от контейнера. Мы хотим back_insert_iterator реализовать так, чтобы алгоритм, 
который разыменовывает, присваивает, инкрементирует, приводил к тому, что в контейнере делается push_back(). 
Для этого можно сделать такой трюк(сродни трюку с вектором bool): 
Мы определим своему итератору операратор присваивания от value_type контейнера. value_type говорит нам о том, какой тип лежит в контейнере. При инкременте и разыменовании
ничего не делаем. Звёздочка и инкремент возвращают back_insert_iterator (его же).


template <typename Container>
class back_insert_iterator {
	Container& container;
public:
	back_insert_iterator(Container& container): container(container) {}
 
	back_insert_iterator& operator=(const_typename Container::value_type& value) {	// Операратор присваивания от value_type контейнера
		container.push_back(value);
		return *this;
	}

	back_insert_iterator& operator++() {						// Ничего не делаем при префиксномикременте
		return *this;
	}
	back_insert_iterator operator++(int) {						// Ничего не делаем при постфиксном икременте
		return *this;
	}

	back_insert_iterator& operator() {						// Ничего не делаем при разыменовании
		return *this;
	}
};

Чтоже происходит когда мы делаем например так: *it1++ = *it2++; 
1) Делается инкремент, вовращается копия back_insert_iterator, инкремент ничего не делает с back_insert_iterator при этом.
2) Потом делается разыменование, опять ничего не делается с back_insert_iterator. И ему присваивается x value. Мы оператор присваивания определили не от другого итератора, а от
value контейнера. Т.е. итератору мы присваиваем значения элементов в контейнере. И это приводит к тому, что делается push_back(). Т.о. эта обёртка над итератором позволяет нам
вызывать стандартные алгоритмы над контейнерами и класть в них как будто мы пишем и просто идём по массиву, а в реальности мы делаем push_back() в контейнер.


Но писать back_insert_iterator от std::vector неудобно, поэтому есть функция std::back_inserter. Она нужна просто для того, чтобы поменьше писать код:
Реализация:

template <typename Container>
back_insert_iterator<Container> back_inserter(Container& container) {
	return {container};	// Создаёт back_insert_iterator от container
}


Теперь вместо длинной записи мы можем написать так:

bool even(int x) {		// Предикат
	return x % 2 == 0;
}

std::copy_if(a, a + 10, std::back_inserter(v), &even);


Помимо back_inserter есть ещё front_inserter, который делает всё тоже самое только push_front().

И inserter, который принимает не только контейнер, а контейнер и итератор в этом контейнере. Он применим к любому контейнеру, потому что он пишет в середину, т.е. мы можем
inserter отдать связаный список и итератор на элемент в этом связном списке и inserter будет писать по этому итератору туда, т.е. он будет не push_back() делать, а вызывать
метод insert() у данного контейнера по данному итератору.



______________________________________________________________________________________
LIST (Список).

LIST представляет собой реализацию двусвязного списка. Лист это контейнер с данными, в котором эффективно реализована возможность добавления и удаления элемента в коллекцию,
абсолютно в любом месте контейнера (Очень быстро работает с удалением и добавлением элементов). В списке не реализована перегрузка оператора [], предётся использовать 
итераторы. Так же не реализован итератор произвольного доступа (мы не можем сразу получить доступ по какому то конкретному индексу). Лист тоже шаблонный контейнер, как и вектор.

#include <list> 				//Подключаем список

list<int> myList; 				//Создание списка
//list<int> myList = {15,64,77};

myList.push_back(1); 				//Добавление элемента в конец списка. Сложность: константа
myList.push_front(0); 				//Добавление элемента в начало списка Сложность: константа

list<int>::iterator it = myList.begin(); 	//Создаём итератор для перемещения по списку
cout << *it << endl; 				//Вывод первого элемента списка

for (auto i = lst.cbegin(); i != lst.cend(); ++i) //Перебор всех элементов списка
{
	cout << *i << endl;
}

myList.sort(); //Сортировка списка по возрастанию. Сложность: N * log(N)

myList.pop_back(); //Удалить последний элемент списка. Сложность: константа
myList.pop_front(); //Удалить первый элемент списка. Сложность: константа

myList.unique(); //Удаление дубликатов (только последовательных) из списка  Сложность: N - 1

myList.reverse(); //Реверс всего списка. Сложность: Линейная

myList.clear(); //Очистка всего списка от всех элементов. Сложность: Линейная

Вставка элемента в список:
myList.insert(it, 11); //1-ый параметр: итератор, который указывает на место вставки нового элемента, 2-ой параметр: значение нового элемента. Сложность: Константа или линейная, зависит от случая.

Сдвиг итератора:
advance(it, 3); //1-ый параметр: итератор, который нужно переместить, 2-ой параметр: на сколько шагов.

Удаление элемента списка:
myList.erase(it); // Удаление элемента, на который указывает итератор. Сложность: Константа или линейная, зависит от случая.

myList.remove(99); //Удалить элемент со значением 99 Сложность: Линейная

myList.assign(3, 1); //Заполнить список элементами. Перед тем как заполнить лист новыми элементами, старые удаляются. 1-ый параметр: кол-во новых чисел, 2-ой параметр: их значение.

Копирование элементов с заменой на новые
myList.assign(myList2.begin(), myList2.end()); //Копирование из myList2 в myList



______________________________________________________________________________________
forward list

forward list представляет собой реализацию односвязного списка.

#include <forward_list>  	//Подключаем односвязный список

В forward_list есть многие методы, которые есть в list и Vector, их предназначение одинаковое для всех.

Особенности forward_list: в отличие от обычного list, в forward_list добавлять и удалять элементы мы можем только в начале списка. Есть метод insert_after, который позволяет
вставить элемент в любое место.


for (auto var : fl) 				//Перебор всех элементов списка
	cout << var << endl;

forward_list<int>::iterator it = fl.begin(); 	//Итератор для списка

it++; 						//Переход на следующий элемент
//it--; 					//Не работает, эта операция не перегружена, потому что это односвязный список.

cout << *it << endl;


В forward list есть методы с приставкой after: insert_after, erase_after. А так же методы с приставкой before: before_begin, cbefore_begin. Наличие этих методов объясняется
логикой односвязного списка: В двусвязном списке при работе метода insert(3, 0) этот четвёртый элемент (итерация с 0) становится пятым, а на его место ставится новый элемент.
При односвязном списке такая операция не возможна, потому что старый четвёртый элемент не хранит адрес предыдущего элемента. Именно по этому был добавлен метод insert_after,
в котором новый элемент вставиться не перед указанным в параметре элементом, а после него. erase работает так же.

forward_list<int> fl = {131, 94, 494};

forward_list<int>::iterator it = fl.begin(); 	//Итератор для списка

fl.insert_after(it, 9999);

for (auto var : fl) 				//Перебор всех элементов списка
	cout << var << endl;
 

Метод before_begin ставит итератор на область памяти перед первым элементом (по сути в никуда). Он нужен чтобы получить доступ для методов insert_after и erase_after к первому
элементу списка.


______________________________________________________________________________________
array STL

#include <array> //Подключаем массив

array является обёрткой для статического массива (А vector для динамического).

array<int, 4> arr; //Инициализация
Поскольку массив статический, мы не можем не добавить элемент ни удалить.

arr.at(1);
arr.size();
arr.fill(-1); //Заполняет полностью массив числом -1
arr.front(); //Доступ к первому элементу массива
arr.back(); //Доступ к последнему элементу массива



______________________________________________________________________________________
Контейнеры STL и операторы сравнения

У всех контейнеров STL присутствует перегрузка операторов сравнения.

array <int, 4> arr = { 1, 94, 77, 9 };
array <int, 4> arr2 = { 1, 94, 77, 9 };

bool res = (arr == arr2); //res = true.

#####
array <int, 4> arr = { 1, 94, 77, 10 };
array <int, 4> arr2 = { 1, 94, 77, 9 };

bool res = (arr > arr2); //res = true. В arr последний элемент 10 а в arr2 последний элемент 9, поэтому arr > arr2 (Сумма всех элементов arr > чем в arr2).

Главное условие сравнивания контейнеров, это то, чтобы внутри такого контейнера минимальный элемент сам по себе должен иметь перегруженный оператор сравнения.



______________________________________________________________________________________
deque (Дек)

Дек - это двусторонняя очередь. Это некий гибрид вектора и двусвязного списка. По сути дек это двусвязный список векторов, т.е. несколько векторов связаны в один список. 
Дек позволяет сгладить недостатки списка при попытке доступа к конкретному элементу. В списке все элементы разбросанны по всей памяти и переход от одного элемента к другому 
медленный. В векторе все элементы объеденены в непрерывной области памяти, поэтому переход от одного элемента к другому очень быстрый. Получаем скорость итерации выглядит так:
список (медленный) < дек (средний) < вектор (быстрый).

Так же важна скорость доступа, добавления и удаления элемента в начало и в конец коллекции. В двусвязном списке это делается очень быстро по причине самой структуры контейнера.
В векторе приходится перевыделять память заново и копировать все элементы, затем уже добавлять новые, это очень долго. Получаем скорость добавления и удаления элемента выглядит
так: список (быстрый) > дек (средний) > вектор (медленный).

#include <deque> //Двусторонняя очередь

В дек в отличии от vector есть метод push_front. Остальные методы идентичны предыдущим контейнерам. Сложность: константа


______________________________________________________________________________________
внутренности std::deque (internals std::deque)

У дека два отличия от вектора.

1) Дек не инвалидирует указатели и ссылки при добавлении чего-то в дек. Это главное почему именно дек используется под капотом по умолчанию в таких контейнерах как стек, кью,
приорити кью. 
2) Дек умеет делать пуш и поп форнт.

Нам нужно реализовать контейнер, который умеет всё тоже что и вектор, но ещё и пушфронт попфронт, и не инвалидирует указатели и ссылки.


Как реализован стандартный дек:

Заводят массив, который состоит из указателей, изначально они nullptr, но когда в деке чтото появляется, то появляется указатель на настоящий массив. Размер этих массивов 
некоторая константа, ну например N = 32. Горизонтальный(внутренний) массив это массив T, вертикальный(внешний) массив это массив указателей на T. Т.е. на самом деле мы храним массив 
T** arr. Изначально вертикальный(внешний) массив можно сделать из одного элемента, который будет указывать на горизонтальный(внутренний) массив с сырой памятью. В горизонтальном 
(внутреннем) массиве сырая память, поскольку здесь нет изначально объектов типа T. Когда мы создаём дек без аргумента не должна выделятся память вообще, дек должен быть пустым, 
0 аллокаций. Как только мы кладём в него какой нибудь элемент, дек выделяет вертикальный(внешний) массив какой то длинны, и выделяет горизонтальный(внутренний) массив 
(бакет (bucket)). Потом он кладёт в первую ячейку элемент T. В остальных ячейках всё ещё сырая неинициализированная память. Когда мы делаем push_back() горизонтальный массив 
заполняется, в момент когда он будет переполнен, дек создаст второй бакет, и начнёт класть элементы туда. 

					  N = 32
	|---------|             /------------------------\
	| nullptr |
	|---------|		|----|----|----|----|----|
	|   ptr   | --------->  | T0 | T1 |... | T30| T31|
	|---------|		|----|----|----|----|----|
	| nullptr |
	|---------|
	| nullptr |
	|---------|
	| nullptr |
	|---------|


Если мы делаем push_front(), то выделяется новый бакет, и в нём в самую последнюю ячейку кладётся элемент.
Демонстрация метода push_front():

					 
	|---------|             |----|----|----|----|----|
	|   ptr   | --------->	|    |    |    |    | T0 |
	|---------|		|----|----|----|----|----|
	|   ptr   | --------->  | T1 | T2 |... | T31| T32|
	|---------|		|----|----|----|----|----|
	| nullptr |
	|---------|
	| nullptr |
	|---------|
	| nullptr |
	|---------|

Реализовать поведение горизонтальных массивов не получится с помощью вектором из-за недостатка некоторых операций, поэтому их нужно реализовывать с помощью сишных массивов. 
Так же нужно помнить какой номер бакета и какой индекс у нас является началом текущего дека и какой номер бакета и какой индекс является концом текущего дека.

Почему указатели и ссылки не инвалидируются при реалокации? Что вообще такое реалокация дека? Например если у нас закончился последний массив и элементы нам уже некуда класть, 
но мы всё ровно делаем push_back(), то бакеты остаются на своих местах. Мы реалоцируем вертикальный массив с указателями и добавляем в него больше места для новых указателей. 
Указатели на старые массивы остаются. Мы добавляем новый бакет и указатель на него.


	#
	# ----> ____...___#	(Здесь мы делали push_front())
	# ----> ####...####
	# ----> ####...####
	# ----> ####...####	(Здесь мы делаем push_back() но места нет)

	Реалоцируем внешний массив указателей


	#
	#
	# ----> ____...___#
	# ----> ####...####
	# ----> ####...####
	# ----> ####...####
	# ----> #___...____	(Появился новый чистый массив)
	#
	
Чтобы класть элементы на сырую память нужно использовать placement new. Для того чтобы удалить элемент, например pop_front(), нам нужно по этому адресу вызвать деструктор T и 
сдвинуть индекс.

Как работает оператор [] за O(1)? Мы знаем начало и у нас константый размер бакетов. Т.е. когда нам говорят [индекс], мы просто зная размер N и зная индекс начала, пересчитываем
этот индекс в терминах наших координат, и за O(1) понимаем в какой массив по какому индексу нужно обратиться чтобы это был нужный нам элемент. 

Индексация в деке идёт с 0 а не с отрицательного числа. Т.е. если мы положили 10 элементов в дек а потом сделали push_front(), то индекс нового элемента станет 0, а индексы всех 
старых элементов поменяются. Отрицательная индексация в деке запрещена. 

У дека есть почти все методы вектора и даже есть дополнительные, такие как push_front и pop_front. Однако у вектора есть три метода, которые отсутствуют у дека: shrink_to_fit, 
reserve и capacity, т.е. методы связанные с реалокацией у дека отсутствуют.


______________________________________________________________________________________
SET | MULTISET | Ассоциативные контейнеры

SET и MULTISET это два упорядоченных ассоциативных контейнера. Эти контейнеры реализованы на основе бинарного дерева.

#include <set> //Подключение бинарного дерева

Здесь нет методов push_back или push_front поскольку структура бинарного дерева очень сильно отличается от списка. Так же нет перегрузки операторов [] и метода at.
Здесь есть метод insert: 

set<int> mySet;

mySet.insert(5); 		//Корень дерева (поскольку добавился первым). Сложность: разная, зависит от случая. В основном логарифмическая по размеру контейнера.
mySet.insert(1);
mySet.insert(12);
mySet.insert(4);
mySet.insert(-1);

for (int var : mySet)
	cout << var << endl; 	//Бинарное дерево упорядоченная структура данных, поэтому в консоль будут выводиться данные в порядке возрастания.

Важная особенность сета, по мимо упорядочивания элементов, это то, что сет не может хранить несколько одинаковых элементов (хранит всегда только уникальные значения). В этом
моменте как раз и есть отличие SET от MULTISET. MULTISET тоже хранит элементы в упорядоченном состоянии, однако позволяет добавлять несколько одинаковых элементов. 
Так же контейнер сет не может изменить элемент, который в нём находится. Это можно обойти тем, что просто удалить старый элемент, и добавить его новое значение заново.


Поиск элемента в сете:

set<int> mySet = {5,45,35,11,86};
	
auto it = mySet.find(10); 	//Если метод find нашёл элемент, он возратит итератор на определённый элемент в сете. Если нет, то итератор вернёт значение, которое будет 
				//указывать на mySet.end() (элемент, который находится после коллекции т.е. в никуда). Сложность: логарифмическая по размеру контейнера.

auto it = mySet.find(11);

В методе find поиск элемента происходит с помощью бинарного поиска.


Удаление элемента в сете:

mySet.erase(5); // Удаления числа 5 из дерева. Сложность: В разных случаях по разному, константа или логарифмическая.

Если элемента нет, а мы попытаемся его удалить, то ничего не произойдёт.

Методы insert и erase возвращают результат своей работы. Метод erase возвращает 1 если получилось удалить и 0 если не получилось. Метод insert возвращает пару значений:
в 1-ом итератор на добавленный элемент после его добавления и 2-ой булева переменная true или false. Если получилось добавить элемент то будет true если нет то false.
Итератор на элемент будет в любом случае.


Для пользования MULTISET нам нужно подключить тот же заголовок #include <set>.

multiset<int> myMultiset = {1,1,45,35,11,86};

В связи с тем что мультисет может хранить несколько одинаковых элементов в контейнере, в этом контейнере имеет смысл использовать методы lower_bound и upper_bound. 
Это нектороые аналог метода find, которые позволяют искать элемент. Эти методы возвращают итераторы на нужное нам число.

multiset<int> myMultiset = {1,1,45,35,11,86};

auto it1 = myMultiset.lower_bound(1); 	//Найдёт первую единицу, которую найдёт (потому что единица в параметре). Сложность: логарифмическая по размеру контейнера.

auto it2 = myMultiset.upper_bound(1); 	//Найдёт следующий после единицы элемент (который больше его). Поскольку в мультисете все элементы хранятся в упорядоченном состоянии, 
					//то в нашем случае следующий элемент будет 11, а не 1 или 45. Сложность: логарифмическая по размеру контейнера.


auto a = myMultiset.equal_range(1); 	//Возвращает диапазон чисел от lower_bound до upper_bound. В нашем случает вернёт (1,11); Сложность: логарифмическая по размеру контейнера.


Коментарии к видео:
А насчёт этого... Корнем этих классов становится число, которое было добавлено самым первым, так ведь? Т.е, у нас может первым числом добавиться значение -999999999999, а потом
 будут добавляться лишь значения больше, тогда у нас вся левая ветка древа будет пуста? Логично, что да. Есть ли у этих классов функции для сортировки дерева? Ну, или, мб в 
дальнейшем будут какие-то пояснения по этой теме?

Явно, что если корнем дерева будет число, максимально близкое к среднему арифметическому этого дерева, то поиск будет быстрее, чем, если к примеру, корнем будет число 1, и 
числа 2,3,4...100 будут рассортированы в правой ветке. Так, чтобы найти число 51, придётся сделать 50 шагов. А если имеются те же числа, но корнем дерева будет число 50, то для
 нахождения числа 51 придётся сделать всего лишь 1 шаг...

Как-бы всё правильно, но есть одно но: когда мы делаем выбор в пользу того или иного контейнера, то мы хоть как-то представляем себе каким образом туда будуть попадать данные и
если мы предполагаем, что элементы будут записываться всегда или почти всегда по возрастанию, то бинарное дерево может быть и не лучшим выбором. Тут всё зависит от задач. 
Бинарный поиск один из самых быстрых, а в описаной вами ситуации поиск по-умолчанию будет одинаково доглим для любого контейнера

В контейнере stl set используется не обычное бинарное дерево, а сбалансированное. Например, красно-чёрное. После добавления эллемента такое дерево ещё будет балансироваться. 
Таким образом корень может измениться. Пример, который вы привели в комментариях полностью отображает потребность такой балансировки для эффективности.


______________________________________________________________________________________
Теория: set сложность вставки, удаления, поиска

В set сложность вставки, удаления, поиска - логарифмическая
В стандартной библиотеке C++ контейнер `std::set` обычно реализован как бинарное дерево поиска, чаще всего как красно-чёрное дерево. Этот тип дерева является самобалансирующимся, 
что гарантирует, что дерево остаётся относительно сбалансированным после каждой операции вставки или удаления. Благодаря этому, высота дерева поддерживается на уровне \(O(\log n)\),
 где \(n\) — количество элементов в контейнере. Это гарантирует, что основные операции, такие как поиск, вставка и удаление элементов, выполняются за логарифмическое время.

Вставка

Включает в себя несколько шагов:
1. Поиск места для вставки: сначала необходимо определить, где в дереве должен находиться новый элемент, чтобы сохранить свойства упорядоченного дерева.
2. Вставка элемента: после того как место найдено, элемент вставляется в дерево.
3. Балансировка дерева: поскольку `std::set` обычно использует красно-чёрное дерево, после вставки может потребоваться несколько операций для восстановления сбалансированности 
дерева.

Удаление

Требует поддержания свойств бинарного дерева:
1. Поиск элемента для удаления: сначала находится элемент, который должен быть удалён.
2. Удаление элемента: элемент удаляется из дерева, что может включать замену удаляемого узла его потомком, если у узла есть дети.
3. Балансировка дерева: как и при вставке, после удаления может потребоваться несколько операций для восстановления сбалансированности дерева.

Поиск

Выполняется путём сравнения искомого значения с элементами в узлах, начиная от корня и перемещаясь вниз по дереву к листьям. Это поиск делает относительно простым благодаря 
свойствам красно-чёрного дерева, что обеспечивает логарифмическую сложность операции.

`std::set` обеспечивает эффективное управление упорядоченным набором элементов с логарифмической сложностью для операций вставки, удаления и поиска, что делает его подходящим 
выбором для многих задач, где важна скорость выполнения операций с данными в упорядоченном виде.


______________________________________________________________________________________
Теория: Худший случай поиска в бинарном дереве

Худший случай поиска в бинарном дереве возникает, когда дерево вырождается в свою одностороннюю форму, то есть принимает форму линейного списка (цепочки). Это происходит, когда 
элементы вставляются в дерево в уже отсортированном порядке, или когда каждый следующий элемент меньше (или больше) предыдущего.

Допустим, у нас есть последовательность чисел, которые мы хотим вставить в бинарное дерево поиска: 1, 2, 3, 4, 5. Если вставлять их в указанном порядке, то каждый новый элемент 
будет правым потомком предыдущего, что приведет к следующей структуре дерева:

```
1
 \
  2
   \
    3
     \
      4
       \
        5
```
В этом случае дерево вырождается в своего рода "правую ветку", и для поиска любого значения мы потенциально должны пройти по всем узлам. Например, чтобы найти число 5, нам 
необходимо сделать 5 сравнений.

Почему это плохо

Поиск в сбалансированном бинарном дереве работает за время \(O(\log n)\), где \(n\) — количество узлов в дереве. Это потому что с каждым шагом вглубь дерева количество узлов, 
которые еще предстоит рассмотреть, уменьшается вдвое. Однако, в вырожденном случае, как показано выше, поиск работает за \(O(n)\), так как каждый узел в дереве требует отдельного 
шага проверки.

Как избежать

Для предотвращения вырождения бинарных деревьев используют так называемые сбалансированные деревья поиска, такие как красно-черные деревья или AVL-деревья. Эти структуры данных 
автоматически перебалансируются при каждой операции вставки или удаления, что обеспечивает поддержание высоты дерева порядка \(O(\log n)\) и гарантирует, что операции поиска, 
вставки и удаления будут выполняться за логарифмическое время.

Худший случай поиска в бинарном дереве наступает, когда дерево становится похожим на линейный список, требуя \(O(n)\) времени для поиска элемента. Это случается при неудачном 
порядке вставки элементов. Использование сбалансированных деревьев помогает избежать такой проблемы.



______________________________________________________________________________________
Теория: разница между set и unordered_set

https://www.geeksforgeeks.org/set-vs-unordered_set-c-stl/?ref=lbp

Разница:
	      |         set		  | unordered_set
--------------|---------------------------|---------------------
Сортировка    |Сортировка по возрастающему| Нет сортировки
	      |порядку (по умолчанию) 	  |
--------------|---------------------------|----------------------
Реализация    |Самобалансирующееся дерево | Хеш-таблица
	      |двоичного поиска например, |
	      |"Красно-черное дерево".	  |	
--------------|---------------------------|----------------------
время поиска  |	  	log(n)  	  | O(1) -> среднее
	      |				  | O(n) -> Худший случай	
--------------|---------------------------|----------------------			
Время вставки | log(n) + Перебалансировка | O(1) -> среднее
	      |				  | O(n) -> Худший случай
--------------|---------------------------|----------------------
Время удаления| log(n) + Перебалансировка | O(1) -> среднее
	      | 			  | O(n) -> Худший случай


Используйте set, когда:
- 
Нам нужны упорядоченные данные.
- 
Нам нужно распечатать/получить доступ к данным (в отсортированном порядке).

- Нам нужны предшественники/преемники элементов.
- 
Поскольку множество упорядочено, мы можем использовать такие функции, как binary_search(), lower_bound() и upper_bound() для элементов множества. Эти функции нельзя использовать для неупорядоченного_множества().
- 
Дополнительные примеры см. в разделе Преимущества BST над Hash Table. https://www.geeksforgeeks.org/advantages-of-bst-over-hash-table/


Используйте unordered_set, когда:
- 

Нам нужно хранить набор отдельных элементов, и упорядочивание не требуется.
- 
Нам нужен доступ к одному элементу, т. е. без обхода.




______________________________________________________________________________________
MAP | MULTIMAP | Ассоциативные контейнеры

MAP и MULTIMAP схожи с SET и MULTISET, они тоже упорядочены, тоже имеют структуру бинарного дерева, но в отличии от SET и MULTISET которые просто хранят какое то одно значение, 
и строются в виде бинарного дерева логически, контейнеры MAP и MULTIMAP хранят не просто одно значение, а пары состоящие из ключа и значения. Так же как SET и MULTISET, 
MAP и MULTIMAP отличаются по тому же признаку: MAP может хранить только уникальные значения, MULTIMAP может хранить и дубирующие значения. Упорядочивание осуществляется на
основе ключа, а значение к нему просто подвязывается. Как итог мы получаем некий словарь.

#include <map> //Подключение карты

Простая пара:

pair<int, string> p(1, "телефон"); 	//Пара в чистом виде
p.first; 				//Первый элемент пары (1). Это ключ
p.second; 				//Второй элемент пары (телефон). Это данные


Добавление элемента в карту: Параметр insert принимает только уже готовую пару.

myMap.insert(make_pair(1, "телефон")); 		//Метод make_pair создаёт пару Сложность: В разных случаях по разному, амортизированная константа или логарифмическая.

myMap.insert(pair<int, string>(2, "ноутбук")); 	//Ручное создание пары в параметре

myMap.emplace(3, "монитор"); 			//автоматическое добавление нового элемента Сложность: Логарифмическая по размеру контейнера.

Метод insert либо копирует готовый объект, либо перемещает его. Метод emplace просто создаёт объект во время выполнения (он должен работать немного быстрее). В случае добавления
нового элемента с ключём, который уже есть map, новый элемент добавлен не будет. Так же как и в SET, метод insert возвращает пару значений: 1-ый параметр пара по заданному ключу,
2-ой параметр результат добавления (true или false).

auto res = myMap.emplace(4, "ывопатвы"); 	// В нашем случае res равен ((4, "ывопатвы"), true).



Поиск осуществляется методом find по ключу. Этот метод возвращает результатом своей работы итератор, который указывает на пару ключ-значение в map в случае если он смог найти 
элемент с текущим ключём. Если мы пытаемся найти элемент по ключу, которого у нас нет в map, то метод вернёт значение end() (по сути в никуда). 

auto it = myMap.find(3); 			//Поиск элемента по ключу (в нашем случае по ключу 3). Сложность: Логарифмическая по размеру контейнера.

cout << it->first << it->second << endl;	//Вывод значений пары ключ-значение, на который указывает итератор.


if (it != myMap.end()) 				//Чтобы не получить ошибку по выводу несуществующего элемента.
{
	cout << it->first << it->second << endl;
}



Для контейнера map перегружен оператор [].

cout << myMap[3] << endl; 			//Вывод в консоль: монитор




Типы данных для ключа тоже могут быть разными: Например у строк тоже есть перегруженный оператор больше и меньше, поэтому построение бинарного дерева на основании строк тоже
возможно.

map<string, int> myMap;				//Ключ типа string
	
myMap.emplace("Петя", 18);
myMap.emplace("Маша", 22);
myMap.emplace("Саша", 20);

Теперь когда мы хотим обратиться к интексу в нашем map (например в методе find или []), мы должны указывать соответствующий тип данных ключа. 

cout << myMap["Петя"] << endl; 	//Выведется значение 18

Так же с оператором [] мы можем не только получать значение, но и помещать значения в пару.

myMap["Маша"] = 25; 		//Присвоили Маше значение 25

Если мы помещаем значение с ключём, которого ещё нет в map, то данная пара появится в map.

А вот если использовать метод at с ключём которого нет в карте, то новая пара не будет добавлена, а метод at вызовет исключение. 



Удалить элемент из контейнера можно методом erase, положив в параметр ключ элемента, который нужно удалить.

myMap.erase("Саша"); // Сложность: В разных случаях по разному, амортизированная константа или логарифмическая.



multimap работает так же как и map, только multimap может хранить дублирующиеся ключи. Так же в multimap не перегуржен оператор [] и отсутствует метод at.
 
myMultimap.emplace("Петя", 12);
myMultimap.emplace("Петя", 24);



______________________________________________________________________________________
Теория: разница между map и unordered_map

https://www.geeksforgeeks.org/map-vs-unordered_map-c/


Разница:
	      |         map		  | unordered_map
--------------|---------------------------|---------------------
Сортировка    |Сортировка по возрастающему| Нет сортировки
	      |порядку ключей 		  |
	      |(по умолчанию) 		  |
--------------|---------------------------|----------------------
Реализация    |Самобалансирующееся дерево | Хеш-таблица
	      |двоичного поиска например, |
	      |"Красно-черное дерево".	  |	
--------------|---------------------------|----------------------
время поиска  |	  	log(n)  	  | O(1) -> среднее
	      |				  | O(n) -> Худший случай	
--------------|---------------------------|----------------------			
Время вставки | log(n) + Перебалансировка | O(1) -> среднее
	      |				  | O(n) -> Худший случай
--------------|---------------------------|----------------------
Время удаления| log(n) + Перебалансировка | O(1) -> среднее
	      | 			  | O(n) -> Худший случай


Используйте std::map, когда:
- 

Вам нужны упорядоченные данные.
- 
Вам придется печатать/получать доступ к данным (в отсортированном порядке).
- 
Вам нужны предшественники/преемники элементов.
- 
Другие примеры смотрите в разделе Преимущества BST над Hash Table. https://www.geeksforgeeks.org/advantages-of-bst-over-hash-table/


Используйте std::unordered_map, когда:
- 

Вам нужно вести подсчет некоторых данных (пример - строки), и упорядочивание не требуется.
- 
Вам нужен доступ к одному элементу, т.е. без обхода.




______________________________________________________________________________________
Stack | Адаптеры контейнеров

В STL существует 3 адаптера: Stack, queue (очередь), priority qoeue(очередь с приоритетом). Их особенность в том, что они не являются самостоятельными контейнерами в STL, они
являются адаптерами для контейнеров.

Принцип Стека: В Стеке тот элемент, который был добавлен в стек самым последним, будет извлечён самым первым (положить в  ящик). Для реализации этого принципа мы можем выбрать 
как базой абсолютно любую динамическую структуру данных (и вектор и лист и дек). И в веторе и в листе и в деке мы можем итерироваться по элементам, добавлять и удалять 
элементы в любом место контейнера. Но если мы поверх всего этого функционала для любого их этих контейнеров, наложим правила стека, ограничим функционал, таким образом мы 
любой из этих контейнеров адаптируем под стек. И разница будет в том, что стек будет по разному себя вести в плане быстродействия, если в его основу был положен тот или иной 
контейнер. В с++ stack, queue, priority qoeue реализованы т.о., что они как бы ограничивают функционал, того контейнера, который был положен в их основу, только лишь теми 
методами, которые доступны в стеке или очереди (в зависимости что выберешь). Получается адаптеры над контейнерами умеют переадресовывать свои методы в методы соответствующего 
контейнера.


#include <stack> //Подключаем стек

stack<int> st;

st.push(1); //Создаёт копию объекта, затем эту копию переносит в коллекцию. Сложность: Равно сложности метода push_back контейнера основы.
st.push(2);

st.emplace(3); //Создаёт объект, который мы помещаем в стек, непосредственно в коллекции (без копировани, значит быстрее). Сложность: Равно сложности метода emplace контейнера основы.

st.size(); // Сложность: константа.

st.empty(); // Сложность: константа.

st.pop(); //Извлекает (удаляет) последний (самый верхний) элемент стека (не возвращает ничего). Сложность: Равно сложности метода pop_back контейнера основы.

st.top(); //Просмотор последнего элемента в стеке (возвращает ссылку на последний элемент, не удаляя его). Сложность: константа.


Прербор всех элементов циколм в стеке не возможен, итараторы тоже не работают, сама идея стека в том, чтобы смотреть только последний элемент.
Но вот вариант перебора всех элементов стека:
while (!st.empty()) {
    cout << st.top() << endl;
    st.pop();		//Удалять нужно полюбому, потому что цикл не успокоится, пока в стеке не останется элементов.
}


Под стек мы можем использовать вектор, лист и дек.

auto a = st._Get_container(); //Возвращает тот сырой контейнер, который был положен в основу стека.
cout << a[1] << endl; 	//Вывод второго элемента из извлечённого контейнера. С помощью этого метода при необходимости мы можем избавиться от всех ограничений стека. Извлечь 
			//оригинальный контейнер, который лежи в основе нашего стека и начань манипулировать с ним без ограничений.


Можно явно указать с каким контейнером будет работать стек:
stack<int, list<int>> st;


std::stack это шаблон, у которого первый параметр T, а второй это шаблонный параметр по умолчанию, который равен std::deque<T> :
template<typename T, typename std::deque<T>>

Второй параметр мы можем изменить на свой Это именно typename а не template. Это не шаблонный шаблонный параметр, а фиксированный тип. Мы бы могли написать стек на шаблонном 
контейнере и вторым параметром шаблона могли бы передавать шаблон а не typename, но тут передаётся именно typename с фиксированным T, потому что у контейнера может быть больше 
одного шаблонного параметра и мы заранее не знаем со сколькими шаблонными параметрами мы будем иметь дело. Можно было бы здесь конечно написать ... передав сюда шаблон с 
переменным кол-вом аргументов, однако вдруг там были бы аргументы разными(типами или числами).



______________________________________________________________________________________
queue | priority queue (очередь, очередь с приоритетом)

Так же как и стек, queue и priority queue являются адаптерами для контейнеров, а не самостоятельными контейнерами (оболочка). Под очередь могут быть адаптированы вектор, лист и
дек. Для очередей нет своей реализации, очереди просто основываются на одном из контейнеров, ограничивая функционал.

#include <queue> //Подключение библиотеки для queue и priority queue

Вектор не может быть основой для обычной очереди (только лист и дек). 

queue<int> q;
queue<int, list<int>> q; //При необходимости в начале указываем ещё и тип контейнера для адаптера. 

q.emplace(1); //Добавить элемент в очередь. Схож с методом push, однако не копирует элемент, а сразу создаёт. Сложность: Равно сложности метода emplace контейнера основы.

q.back(); //Доступ к последнему добавленному элементу в очереди. Получаем ссылку на элемент, можем посмотреть или изменить, но удалить нельзя. Сложность: константа.
q.front(); //Доступ к первому элементу в очереди. Получаем ссылку на элемент. Сложность: константа.

q.empty(); //Проверка на пустоту. Сложность: константа.

q.pop(); //Извлечь элемент (самый первый элемент будет извлечён). Сложность: Равно сложности метода pop_back контейнера основы.

q.size(); //размер очереди. Сложность: константа.

q.swap(); //Обмен содержимого одного адаптера с другим. Сложность: То же, что и базовый контейнер (обычно константа).

q._Get_container(); //Возвращает базовый контейнер, на котором основан адаптер


Очередь с приоритетом не может использовать лист (только вектор и дек). Тут нет метода q._Get_container();

q.top(); //Доступ к самому первому элементу очереди с приоритетом. Сложность: константа.

В STL реализован такой способ работы очереди с приоритетом, что при добавлении элементов, они сразу выстраиваются в очереди, и добавляются в очередь, согласно приоритету.
По умолчанию элементы выстраиваются от большего к меньшему: [0] 99, [1] 56, [2] 7, [3] 4.





______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________


Алгоритмы:

Алгоритмы STL это набор функций, которые призваны решать какие либо типичные задачи. 

Для их применения нужно подключить библиотеку algorithm.

Полный список всех алгоритмов:
https://en.cppreference.com/w/cpp/algorithm

______________________________________________________________________________________
STL Подсчёт чего либо в коллекции:

count(Итератор указывающий на место начала подсчёта, Итератор указывающий на место конца подсчёта, константное значение любого типа)

std::vector<int> vec = {-1, 1, -2, 2, -3, 3, 1};			// Вектор
std::cout << std::count(vec.begin(), vec.end(), 1) << std::endl;	// Ищем в векторе кол-во единиц. Результат: 2


count_if(Итератор указывающий на место начала подсчёта, Итератор указывающий на место конца подсчёта, предикат подсчёта). 


Пример:


bool GreaterThenZero(int a) { 		//Предикат отвечающий на вопрос больше ли наше число чем ноль. 
	return a > 0;			//Если предикат возвращает true то счётчик count_if увеличивается.
}

int main()
{
	setlocale(LC_ALL, "Russian");
	
	vector<int> v = { 1,-2,-55,9,-3,8 };

	int res = count_if(v.begin(), v.end(), GreaterThenZero); //Алгоритм STL, который может подсчитать что либо в коллекции

	cout << res << endl; //Выведет число 3. Т.е. count_if подсчитал, что в нашей коллекции v есть три числа, отвечающие требованиям предиката GreaterThenZero.
	
	return 0;
}



______________________________________________________________________________________
STL Алгоритмы сортировки | Бинарный предикат | Лямбда функции

sort(Итератор указывающий на место начала сортировки, Итератор указывающий на место конца сортировки, бинарный предикат (если нужен));

Пример сортировки по умолчанию:

vector<int> v = { 9,4,94,6,1,3,7 };
sort(v.begin(), v.end());		//1,3,4,6,7,9,94


Пример сортировки с предикатом: В данном случае предикат сортирует элементы вектора в порядке уменьшения.

bool MyPred(int a, int b){
	return a > b;
}

int main()
{

	vector<int> v = { 9,4,94,6,1,3,7 };
	sort(v.begin(), v.end(), MyPred);		//94,9,7,6,4,3,1	
	
	return 0;
}


Функция MyPred может больше нигде не использоваться в коде, поэтому логично использовать для неё лямбда функцию.

int main()
{
	vector<int> v = { 9,4,94,6,1,3,7 };
	sort(v.begin(), v.end(), [](int a, int b) 
		{
			return a > b;
		});
	
	return 0;
}


Сортировка обычного массива (не контейнера STL): Имя массива это указатель на его первый элемент. С помощью арифметики указателей можем указать и на последний элемент.

int main()
{
	const int size = 7;
	int arr[size] = { 9,4,94,6,1,3,7 };

	sort(arr, arr + size);			//Указатель на первый элемент массива + его размер = указатель на последний элемент массива.
	
	return 0;
}


Реальная задача: У нас есть коллекция людей с баллами по егэ. Нужно их отсортировать.

class Person { 
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 							//Функтор предикат
		return p.score > 180;
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	vector<Person> people{									//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150)
	};

	sort(people.begin(), people.end(), [](const Person &p1, const Person &p2) {		//Сортировка в которой лямбда функция на месте предиката
			return p1.name < p2.name; 						//Сортировка по имени
			//return p1.score > p2.score; 						//Сортировка по баллам
	});

	for (auto el : people){									//Вывод в консоль
		cout << "Имя:\t" << el.name << "\tбаллы\t" << el.score << endl;
	}
	return 0;
}



______________________________________________________________________________________
STL алгоритмы поиска | find | find_if | find_if_not

find позволяет узнать присутствует ли в какой то коллекции какой то конкретный элемент.

find(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска, значение которое нужно найти). Возвращает итератор на место найденного элемента, 
или итератор на конец коллекции если элемент не найден.

vector<int> v = { 6,4,4,12,1,2,7 };

auto res = find(v.begin(), v.end(), 12); 	//res это итератор, который хранит указатель, который указывает на наш элемент.

if (res == v.end()) {				
	cout << "Число не найдено" << endl;
}
else {
	cout << "Число найдено" << endl;
}


Метод find не гибкий, он может проверять элементы в коллекции только на равенство с тем элементом, который мы передаём в качестве 3его параметра. Если мы хотим найти элемент по
другому принципу, нам нужно использовать методы find_if и find_if_not.

find_if(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска, предикат)

Есть ли в коллекции вообще чётные числа?:

vector<int> v = { 6,4,4,12,1,2,7 };

auto res = find_if(v.begin(), v.end(), [](int a) { //Предикат с помощью лямбда выражения
	return a % 2 == 0;
});

if (res == v.end()) {
	cout << "Число не найдено" << endl;
}
else {
	cout << "Число найдено" << endl;
}
return 0;


find_if_not тоже самое что и find_if, только инвертированное (он возвращает true если предикат возвращает false).



Пример работы с более сложным типом данных:

class Person { //Класс студентов
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 						//Функтор предикат
		return p.score > 180;
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	vector<Person> people{								//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150)
	};

	auto res = find_if(people.begin(), people.end(), [](const Person &p) {
		return p.name == "Маша";						//Ищем человека с именем Маша
		//return p.name == "Маша" && p.score == 179; 				//Пример двойного условия	
	});

	if (res == people.end()) {
		cout << "Не найдено" << endl;
	}
	else {
		cout << "Найдено" << endl;
	}
	return 0;
}

Преимущество в том что мы можем гибко настраивать параметры поиска. Недостаток в том что мы можем вернуть только один элемент. Если в коллекции два элемента подходящие по 
условию, то вернётся только первый попавшийся (Рассмотренно в следующей теме).



______________________________________________________________________________________
stl copy | stl copy_if | Выборка данных по условию

Задача алгоритмов copy_if и copy скопировать все элементы из одной коллекции в другую, чтобы эти коллекции содержали в себе одинаковые элементы и были идентичны.

copy(Итератор указывающий на место начала копирования, Итератор указывающий на место конца копирования, коллекция в которую нужно копировать).



Ответ на вопрос из предыдущей темы: Каким образом можно выбрать определённое кол-во объектов в новую коллекцию, которые удовлетворяют каким то нашим условиям?

copy_if(Итератор указывающий на место начала копирования, Итератор указывающий на место конца копирования, коллекция в которую нужно копировать, предикат).

class Person { //Класс студентов
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 						//Функтор предикат
		return p.score > 180;
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	vector<Person> people{								//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150),
		Person("Иван", 199)
	};

	vector<Person> res;								//Вектор для вывода результата
	
	copy_if(people.begin(), people.end(), back_inserter(res), [](const Person &p) { //Копируем элементы коллекции people, которые подходят по нашему предикату(условию), 
		return p.name == "Иван";						//заданному лямбда функцией, в вектор res.
	});
	cout << "Всего элементов:\t" << res.size() << endl;

	for (auto el : res) {
		cout << "Имя:\t" << el.name << "\tбаллы\t" << el.score << endl;
	}
	return 0;
}



______________________________________________________________________________________
stl remove | remove_if  удаление элемента по условию

алгоритмы remove и remove_if удаляют все элементы подходящие под условия (даже если есть дублирующие элементы). На самом деле алгоритм remove ничего не удаляет. Все подходящие
по условию элементы он оставляет в конце вектора (после всех неудалённых элементов), и возвращает итератор на позицию за последним не исключённым элементом. По сути мы нужные
элементы собираем в одну сторону, а не нужные в другую.

remove(Итератор указывающий на место начала поиска для удаления, Итератор указывающий на место конца поиска для удаления, элемент который хотим удалить).

vector<int> v = { 5,9,1,46,4,9,4 };		//Вектор, в котором нужно удалить число 9

auto res = remove(v.begin(), v.end(), 9);	//Получаем итератор на первый элемент, который нужно удалить. Сейчас в векторе такой порядок: 5,1,46,4,4,9,9 (итератор на 1ой 9).

v.erase(res, v.end()); 				//Удаляем ненужные элементы. Вектор: 5,1,46,4,4



remove_if(Итератор указывающий на место начала поиска для удаления, Итератор указывающий на место конца поиска для удаления, предикат)

Удалим все абитуриенов, баллы которых меньше 150.

class Person { //Класс студентов
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 					
		return p.score > 180;
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	vector<Person> people{								//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150),
		Person("Иван", 199)
	};

	auto res = remove_if(people.begin(), people.end(), [](const Person &p) { 	//Получаем итератор на границу между нужными и ненужными объектами.
		return p.score < 150;
	});

	people.erase(res, people.end());

	/* Второй вариант без промежуточной переменной res:
	people.erase(remove_if(people.begin(), people.end(), [](const Person &p) {
		return p.score < 150;
	});, people.end());
	*/

	cout << "Всего элементов:\t" << people.size() << endl;

	for (auto el : people) {
		cout << "Имя:\t" << el.name << "\tбаллы\t" << el.score << endl;
	}
	return 0;
}



______________________________________________________________________________________
Поиск максимального элемента | max_element

max_element(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска)

Возвращает итератор на наибольший элемент в коллекции.

vector<int> v = {10,1,-55,11,13,58};			//Наша коллекция

auto res = max_element(v.begin(), v.end()); 		//Получаем итератор на наибольшее число коллекции
	
cout << *res << endl;					//Чтобы получить число а не сам итератор, итератор нужно разыменовать.



Если мы работаем не с контейнерами STL.

const int size = 6;					//Размер статического массива
int arr[size] = {10,1,-55,11,13,58};			//Его определение

auto res = max_element(arr, arr + size); 		//Имя массива это указатель на его первый элемент. С помощью арифметики указателей, мы можем указать и на последний
							//элемент массива (arr + size).

cout << *res << endl;	//Чтобы получить число а не сам итератор, итератор нужно разыменовать.



______________________________________________________________________________________
Поиск минимального элемента | min_element

min_element(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска)

Возвращает итератор на наименьший элемент в коллекции.

##################
Одновременный поиск и максимального и минимального элементов.

minmax_element(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска)

Возвращает пару значений итераторов, указывающих на минимальный и максимальный элементы.

const int size = 6;
int arr[size] = {10,1,-55,11,13,58};

auto res = minmax_element(arr, arr + size); 

cout << "min = "<< *res.first << " max = "<< *res.second << endl;	//Чтобы получить число а не сам итератор, итератор нужно разыменовать.



______________________________________________________________________________________
accumulate | сумма и произведение элементов массива

Алгоритм accumulate очень гибкий инструмент, с помощью него можно многое вычислить. По умолчанию вычисляет сумму всех чисел в коллекции.

#include <numeric> // Подключение алгоритма accumulate

accumulate(Итератор указывающий на место начала коллекции, Итератор указывающий на место конца коллекции, к какому изначальному значению будут прибавляться все остальные 
	значения в коллекции (точка отсчёта), четвёртый параметр ниже).

Возвращает какой то конкретный результат (не итератор).

Важный момент это точка отсчёта. Она определяет тип возвращаемого значения (Если 0 то вернёт int, если 0.1 то вернёт double).

vector<int> v = { 2,3,4 }; 

auto res = accumulate(v.begin(), v.end(), 0); // 0 + 2 + 3 + 4 = 9.

cout << res << endl; // res = 9.


Для коллекций не являющимися контейнерами STL (например статический массив), в место первого параметра нужно тоже передать указатель на начало и конец коллекции. Для массива
это будет так: accumulate(имя массива, имя массива + его размер, 0). Однако мы не всегда знаем размер массива. Для этого есть альтернатива: В пространстве имён std доступны
по отдельности функции begin() и end(). Их задача аналогична методам контейнеров в STL, однако они не привязаны к каким то конкретным коллекциям.

int arr[] = { 2,3,4 }; 				//Обычный статический массив

auto res = accumulate(begin(arr), end(arr), 0);

#########
Для изменения поведения алгоритама accumulate мы должны добавить четвёртый параметр - функцию, которая принимает два параметра и возвращает какое то значение.

Первый параметр хранит в себе текущее состояние при расчётах на момент выполнения алгоритма accumulate. Второй параметр - это тот элемент, который мы сейчас будем прибавлять.

int arr[] = { 2,3,4 }; 

auto res = accumulate(begin(arr), end(arr), 1, [](int a, int b) { 		//Кастомный алгоритм.
	return a * b; 								// Получим перемножение всех элементов массива arr.
});

cout << res << endl;								//res = 24 = 1 * 2 * 3 * 4.


Ещё один пример: Сумма всех чётных элементов.

int arr[] = { 2,3,4 }; 

auto res = accumulate(begin(arr), end(arr), 0, [](int a, int b) { 	//Кастомный алгоритм
	if (b % 2 == 0) 						//Сумма всех чётных чисел
		return a + b;
	else
		return a;
});

cout << res << endl;


Пример работы с другим типом данных. У нас есть массив чисел, нам нужно сделать из них строку, разделив эти элементы между собой знаком +. Поскольку вернуть нам нужно строку
то изменяем тип точки отсчёта на строку: to_string(arr[0]). Поскольку хранить теперь мы будем данные с типом строки, нам нужно изменить входящие в лямбда функцию параметры.
Для того чтобы не включать в строку ответа первый элемент два раза, нам нужно использовать метод next(), который сдвигает итератор на шаг вперёд, чтобы функция accumulate 
начинала работу со второго элемента.

int arr[] = { 2,3,4,5,6,7 }; 

auto res = accumulate(next(begin(arr)), end(arr), to_string(arr[0]), [](string a, int b) { 	//Кастомный алгоритм
	return a + "+" + to_string(b);
});

cout << res << endl;										//res = "2+3+4+5+6+7"



______________________________________________________________________________________
STL equal и mismatch | Сравнение массивов

Алгоритмы STL могут работать с различными контейнерами, также и с двумя различными контейнерами в одном алгоритме одновременно, например сравнивать элементы массива и вектора 
или вектора и листа и т.д. Сравнение идёт по элементно. Т.е. если даже сумма двух коллекций равна, но значения элементов отличаются, то коллекции считаются разными.

#include <algorithm> //Для работы с алгоритмами STL

equal - сравнение двух контейнеров через оператор равенства. Если в собственном типе данных не перегружен оператор равенства, то не получится вычислить корректный ответ. Но в 
этом случае вы можете использовать предикат, и указывать конкретно по какому полю нужно сравнить эти две последовательности.

equal(итератор на начало первой коллекции, итератор на конец первой коллекции, итератор на начало второй коллекции, итератор на конец второй коллекции, предикат).

int arr[] = { 10,3,4,5,7,11 }; 
vector<int> arr2 = { 10,3,4,5,7,11 };  

bool res = equal(begin(arr), end(arr), begin(arr2), end(arr2)); //Сравнение двух коллекций.

cout << res << endl;


mismatch - тоже проверяет на равенство две последовательности, тоже может работать с разными типами последовательностями, но работает несколько иначе: По мимо проверки 
последовательностей на равенство, если он нашёл элементы, которые не равны, он ещё и возвращает пару итераторов, которые указывают на эти элементы, т.е. мы ещё можем посмотреть
какие конкретно элементы не равны. Если коллекции равны, то в ответе вернётся пара итераторов, указывающих на концы своих коллекций (end).

mismatch(итератор на начало первой коллекции, итератор на конец первой коллекции, итератор на начало второй коллекции, итератор на конец второй коллекции).

int arr[] = { 10,3,4,5,7,11 }; 
vector<int> arr2 = { 10,3,4,5,7,11 }; 

auto res = mismatch(begin(arr), end(arr), begin(arr2), end(arr2));

if (res.first == end(arr) && res.second == end(arr2))						//Если коллекции равны
	cout << "+" << endl;
else {												//если коллекции не равны
	cout << "-" << endl;
	cout << "result.first:\t" << *res.first << "\t result.second:\t" << *res.second << endl;
}



______________________________________________________________________________________
std equal predicate

Мы можем использовать вместе с алгоритмом equal бинарный предикат. Если в классе не переопределён опереатор сравнения, мы всё ровно можем сравнить объекты классов, используя
лямбда функцию и опиывая в ней логику сравнения.

class Point {													//Класс
public:
	Point(int x, int y) {
		this->x = x;
		this->y = y;
	}
	int x, y;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	vector<Point> arr{											//Первая коллекции
		Point(1,3), Point(4,5), Point(5,7)
	};
	vector<Point> arr2{
		Point(1,3), Point(4,5), Point(5,7)								//Вторая коллекция
	};

	bool res = equal(begin(arr), end(arr), begin(arr2), end(arr2), [](const Point &p1, const Point &p2) { 	//Сравнение двух коллекций
		return p1.x == p2.x && p1.y == p2.y;
	});
		
	cout << res << endl;											//Вывод результата

	return 0;
}



______________________________________________________________________________________
Алгоритм for_each

Предназначение алгоритм for_each абслоютно точно такое же, как и у цикла for each. Разница в особенностях использования.

for_each(итератор на начало коллекции, итератор на конец коллекции, функция которая определяет что будет делать алгоритм for_each будет делать).

#include <algorithm> //Подключаем for_each

void Foo(int a) {				//Функция выводит в консоль параметр
	cout << a << endl;
}

int main()
{
    setlocale(LC_ALL, "Russian");
	
	int arr[] = { 1,2,10,55 };
	for_each(begin(arr), end(arr), Foo); 	//for_each преберает все элементы arr и вызывает функцию Foo на каждой итерации, передавая в параметр текущий элемент.
    	
	for (auto a : arr) {			//Тоже самое только через цикл, а не алгоритм.
		Foo(a);
	}
	
	for_each(begin(arr), end(arr), [](int a) { //Тоже самое только через лямбда функцию.
		cout << a << endl;
	});

	return 0;
}


______________________________________________________________________________________
unique

Каким образом мы можем решить задачу удаления ПОСЛЕДОВАТЕЛЬНО повторяющихся элементов, в какой либо коллекции. 

#include <algorithm> 

unique(итератор на начало коллекции, итератор на конец коллекции).

У нас есть массив. Наша задача избавиться от дубликатов, чтобы осталось по одному элементу с уникальным значением.

int arr[] = { 1,2,2,2,5,4,4 };

auto res = unique(begin(arr), end(arr));

for_each(begin(arr), res, [](int a) { 		//Вывод всех уникальных чисел
	cout << a << endl;
});

Размер статического массива мы не можем изменить, поэтому при выполнении этой функции у нас изменятся только их порядок. Т.е. в начале массива у нас будут уникальные числа, а в
конце ненужные не уникальные. Возвращает итератор на начало ненужных чисел. Изменить кол-во элементов таким способом мы можем только с контейнерами STL:

vector<int> v = { 1,2,2,2,5,4,4 };

auto res = unique(begin(v), end(v));
	
v.erase(res, end(v)); 


Алгоритм unique_copy схож с unique, но во отличие от него он позволяет скопировать элементы в новый контейнер:

unique_copy(итератор на начало коллекции, итератор на конец коллекции, коллекция куда копировать значения).

vector<int> v = { 1,2,2,2,5,4,4 };
vector<int> v2;
	
unique_copy(begin(v), end(v), back_inserter(v2)); //Копируем в v2 все уникальные числа.


Коментарии под видео:

Если я не прав исправьте меня.
На самом деле при выполнении алгоритма unique "нужные"(уникальные) элементы копируются вместо "ненужных"(дубли) по очереди в том порядке как они расположены в контейнере. То 
есть "ненужные" элементы не перемещаются в конец контейнера, а просто заменяются на "нужные". То есть "ненужный" хвост контейнера ПОСЛЕ применения unique равен хвосту 
контейнера ДО применения unique. Например, vector<int> v = { 1,2,2,2,4,    4,4,4,8,8,8,5,4,4 } после unique будет выглядеть {1,2,4,8,5, "ненужный" хвост -> 4,4,4,8,8,8,5,4,4}. 
Примерно так же ведет себя алгоритм remove.

но он не подходит усли вам нужно сохранить порядок и не работает если числа идут не последоватьльно, тоесть {2,3,5,2,7,6} - 2йки не пропадут) не работает! нужно что б они 
последоватьльно шли)



______________________________________________________________________________________
Отсортировать массив в случайном порядке | random_shuffle

random_shuffle(итератор на начало коллекции, итератор на конец коллекции).

#include <ctime>
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	setlocale(LC_ALL, "Russian");
	
	int arr[] = { 1,2,3,4,5 };

	srand(time(NULL));

	random_shuffle(begin(arr), end(arr)); 		//Рандомное перемешивание элементов в коллекции.

	for (auto el : arr)
	{
		cout << el << " ";
	}

	return 0;
}


Рандомный порядок вызова переопределённого метода классов:

class IAction {						//Виртуальный класс
public:
	virtual void Action() = 0;
};

class CatAction : public IAction {			//Переопределение виртуального метода класса
	virtual void Action() override {
		cout << "Гладим кота" << endl;
	}
};

class TeaAction : public IAction {
	virtual void Action() override {
		cout << "Пьём чай" << endl;
	}
};

class DogAction : public IAction {
	virtual void Action() override {
		cout << "Гуляем с собакой" << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	srand(time(NULL));

	IAction *arr[] = 
	{ 
		&CatAction(),
		&TeaAction(),
		&DogAction()
	};

	random_shuffle(begin(arr), end(arr)); 		//Рандомное перемешивание элементов в коллекции.

	for (auto &el : arr) {
		el->Action();
	}

	return 0;
}


______________________________________________________________________________________
Теория: Различия между set и unordered_set

std::set` и `std::unordered_set` являются контейнерами, предоставляемыми стандартной библиотекой и используемыми для хранения уникальных элементов. Основное различие между этими 
двумя типами контейнеров заключается в их внутреннем устройстве, что влияет на производительность операций вставки, поиска и удаления, а также на порядок хранения элементов.

`std::set`
Реализован на основе сбалансированного двоичного дерева поиска (обычно красно-черное дерево). Это обеспечивает следующие характеристики:

Упорядоченное хранение: Элементы в `std::set` автоматически сортируются по возрастанию (или с использованием предоставленного компаратора), что позволяет легко получить 
отсортированный список элементов.
Время доступа: Операции поиска, вставки и удаления элементов имеют логарифмическую сложность времени `O(log n)`, где `n` — количество элементов в контейнере.
```cpp
#include <iostream>
#include <set>

int main() {
    std::set<int> s;
    s.insert(3);
    s.insert(1);
    s.insert(4);

    // Элементы будут автоматически упорядочены
    for (int x : s) {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
`std::unordered_set`
Реализован на основе хеш-таблицы. Это влечет за собой другие характеристики:

Неупорядоченное хранение: Элементы хранятся в произвольном порядке, что делает невозможным их простую сортировку или последовательный доступ в отсортированном порядке.
Время доступа: В среднем случае операции поиска, вставки и удаления элементов имеют константное время `O(1)`. Однако в худшем случае, например, когда происходит множество коллизий 
хеш-функции, эти операции могут деградировать до `O(n)`.
```cpp
#include <iostream>
#include <unordered_set>

int main() {
    std::unordered_set<int> us;
    us.insert(3);
    us.insert(1);
    us.insert(4);

    // Порядок элементов не гарантирован
    for (int x : us) {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
Выбор между `std::set` и `std::unordered_set` зависит от требований к вашему приложению:

Используйте `std::set`, если вам нужен упорядоченный доступ к элементам или если вы часто выполняете операции, которые зависят от порядка элементов.
Выбирайте `std::unordered_set` для более быстрых операций вставки и поиска, если порядок элементов не имеет значения.


______________________________________________________________________________________
Теория: самый худший случай поиска unordered_set

В `unordered_set`, который основан на хеш-таблице, самый худший случай поиска возникает, когда структура данных деградирует до такой степени, что время поиска становится линейным, 
то есть \(O(n)\), где \(n\) — количество элементов в контейнере. Это происходит по нескольким причинам:

1. Плохая хеш-функция

Играет ключевую роль в распределении элементов по "ведрам" (buckets) в `unordered_set`. Если хеш-функция плохо разрабатывается и генерирует одинаковые или близкие хеш-коды для 
большого количества ключей, элементы начинают накапливаться в очень небольшом числе ведер. Это приводит к тому, что большинство операций поиска, вставки и удаления начинают 
зависеть от числа элементов в самом длинном связном списке, а не от общего количества ведер, что сильно ухудшает производительность.

2. Высокая степень загрузки

Загрузка хеш-таблицы (`load factor`) — это отношение количества элементов в хеш-таблице к количеству ведер. Когда `load factor` становится слишком высоким, вероятность коллизий 
увеличивается, что также приводит к увеличению длины цепочек в каждом ведре. Хотя `unordered_set` автоматически увеличивает количество ведер при увеличении количества элементов, 
в случаях с экстремально высоким `load factor` поиск может деградировать до линейного.

3. Неблагоприятная последовательность вставок

Вставляются данные, которые неудачно распределяются хеш-функцией, даже если сама функция в целом хороша, это может привести к временной деградации производительности. Например, 
последовательная вставка элементов с одинаковым хешем приведет к удлинению одной цепочки.

Представьте `unordered_set`, в котором из-за плохой хеш-функции все элементы попадают в одно ведро. В таком случае, любая операция поиска будет выполняться с временем \(O(n)\), 
так как каждый раз придется просматривать все элементы, хранящиеся в этом ведре.

Для минимизации риска худшего случая в `unordered_set` важно:

Использовать хорошо подобранную хеш-функцию, которая равномерно распределяет значения по ведрам.
Контролировать `load factor` и при необходимости увеличивать количество ведер.
Возможно, рассмотреть альтернативные структуры данных или алгоритмы, если хеш-таблицы не подходят из-за природы данных или операций.




______________________________________________________________________________________
Теория: Всегда ли сложность в деревьях равно log(n)?

Сложность поиска в бинарных деревьях зависит от их структуры и баланса. Логарифмическая сложность поиска, то есть \(O(\log n)\), где \(n\) — количество узлов в дереве, достигается 
в идеально сбалансированных бинарных деревьях. Однако это не всегда так, и различные типы бинарных деревьев могут иметь разные характеристики поиска.

Идеально сбалансированные бинарные деревья
Каждый уровень дерева, кроме возможно последнего, полностью заполнен. Это означает, что количество узлов удваивается с каждым новым уровнем. В таком дереве максимальная глубина 
(или высота) \(h\) равна \(\log_2(n+1)\). Поиск, вставка или удаление элемента в таком дереве имеет временную сложность \(O(\log n)\).

Несбалансированные бинарные деревья
Сложность поиска может деградировать до \(O(n)\) в худшем случае. Это может произойти, например, если элементы добавляются в дерево в уже отсортированном порядке, при котором 
каждый новый узел становится правым ребёнком предыдущего. Такое дерево принимает форму "вытянутого списка", и поиск в нём становится по сути линейным поиском.

Сбалансированные бинарные деревья
Для обеспечения логарифмической сложности поиска независимо от порядка вставки элементов разработаны специальные структуры данных, такие как AVL-деревья и красно-чёрные деревья. 
Эти структуры являются самобалансирующимися, то есть они автоматически поддерживают свою структуру таким образом, чтобы глубина дерева оставалась логарифмической относительно 
количества элементов, что обеспечивает поддержание сложности операций на уровне \(O(\log n)\).

Логарифмическая сложность поиска в бинарных деревьях достигается только в сбалансированных деревьях. В несбалансированных деревьях сложность поиска может увеличиться до линейной. 
Поэтому важно выбирать правильный тип дерева или использовать самобалансирующиеся деревья для задач, где предполагается частое добавление и удаление элементов.



______________________________________________________________________________________
Теория: Каким свойством должен обладать объект, чтобы его можно было добавить в ассоциативные контейнеры в качестве ключа?

Т.к. значения ассоциативных контейнеров хранятся отсортированными, то объект должен реализовывать оператор сравнения < (меньше), а остальные операторы сравнения м.б. выражены через него.

Как из меньше реализовать все остальные операторы?

template <typename T>
bool less(const T& a, const T& b); // Меньше уже реализованно

template <typename T>
bool greater(const T& a, const T& b) { // Реализовываем больше
	return less(b, a);
}

template <typename T>
bool equal(const T& a, const T& b) { // Реализовываем операцию равенства ==
	return !less && !greater;
}


Чтобы объект мог быть в ассоциативном контейнере, он должен быть создаваемым, копируемым или перемещаемым.



______________________________________________________________________________________






