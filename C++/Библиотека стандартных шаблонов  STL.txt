Библиотека стандартных шаблонов  STL.
Это набор стандартных типичных решений для часто используемых задач.

______________________________________________________________________________________
vector

Вектор это шаблонный динамический массив(коллекция), но только очень прокаченный. При работе с вектором мы должны явно указать с каким типом данных он работает. Подключаем 
с помощью дерективы #include <vector>. 

vector<int> myVector; 			//Инициализация вектора
vector<int> myVector = { 0, 1, 2 }; 	//Вариант инициализации.
vector<int> myVector(20); 		//Инициализация вектора с 20 элементами и все = 0.
vector<int> myVector(20, 1); 		//Инициализация вектора с 20 элементами и все = 1.

myVector.push_back(0); 	//Добавить элемент в конец вектора

myVector.size(); 	//Кол-во элементов в векторе

myVector[0] = 1; 	//Обращение к элементу 0. Используя [] мы можем получить доступ за пределы вектора (не проверяем границы вектора).

myVector.at(0) = 0; 	//Обращение к элементу 0. Используя .at проверяет выход за границы вектора. Он никогда не даст нам возможности получить не свои данные.
//Метод at медленнее чем [].

myVector.clear(); 	//Очищаем вектор от всех элементов.

myVector.pop_back(); 	//Удаление последнего элемента вектора.
	

myVector.capacity(); //Возвращает вместимость (ёмкость) вектора, т.е. сколько элементов в нём может поместиться.
	Если мы хотим добавить новый элемент в массив, массиву каждый раз приходится выделять память для нового массива, переписывать туда старые элементы и добавлять новые 
	элементы (как и в случае с обычным массивом). Это очень накладная операция, и если бы вектор каждый раз делал так, он был бы медленным. Поэтому в векторе при 
	добавлении элемента выделяется память с запасом (т.е. на несколько элементов больше, чем нужно). Количество памяти запаса зависит от определённого коэффициента и от 
	кол-ва уже имеющихся элементов в векторе. Далее перемещаются старые элементы на свои места, добавляется новый элемент. Метод size показывает нам только кол-во имеющихся 
	элементов вектора, а метод capacity кол-во всех выделенных в памяти ячеек (и пустых запасных и заполненных). Т.е. пока у нас есть запас операции выделения новой памяти 
	и копирования старых данных производиться не будут, мы просто будем добавлять новые элементы в зарезервированные ячейки. Это хорошо сказывается на его 
	производительности.

Мы можем самостоятельно управлять этим процессом, указав сколько элементов в запасе (capacity) должно находиться в векторе:

myVector.reserve(10); 		//Указываем ёмкость вектора.
myVector.shrink_to_fit(); 	//Освобождение зарезервированной памяти (например если её слишком много). Создаётся новый массив с меньшим кол-во ячеек и переписали все элементы.

myVector.empty(); 		//Проверка пустой ли вектор. Возвращает true если вектор пустой и false если нет.

myVector.resize(20); 		//Установить кол-во элементов в векторе.

myVector.begin(); 		//Интератор указывающий на начало вектора.
myVector.end(); 		//Итератор указывающий на элемент после последнего элемента (несуществующий).
myVector.cbegin(); 		//Возврат константного итератора
myVector.cend();		//Возврат константного итератора
myVector.rbegin(); 		//Реверс итератор
myVector.rend();		//Реверс итератор



Вставка элемента в конкретное место в векторе:

myVector.insert(it, 999); //1-ый параметр: итератор, который указывает на место вставки нового элемента, 2-ой параметр: значение нового элемента.

Удаления элемента из конкретного места в векторе: 

myVector.erase(it); // Удаление элемента, на который указывает итератор.

Удалить диапазон элементов:

myVector.erase(it, it + 3); //1-ый параметр итератор указывающий на начальный элемент удаления, 2-ой параметр: итератор указывающий на конечный элемент удаления.



______________________________________________________________________________________
Теория: Сложность удаления элемента из начала вектора

Удаление элемента из начала вектора (`std::vector`) считается операцией с высокой вычислительной сложностью из-за особенностей его внутренней реализации. Давайте рассмотрим, почему 
это так.

Внутренняя структура std::vector

`std::vector` хранит свои элементы в непрерывном блоке памяти. Это означает, что элементы расположены друг за другом без промежутков. Такая организация позволяет `std::vector` 
обеспечивать очень быстрый доступ к элементам по индексу, но в то же время накладывает ограничения на операции вставки и удаления.

Удаление элемента из начала

Когда удаляете элемент из начала вектора, все оставшиеся элементы должны быть сдвинуты на одну позицию влево, чтобы закрыть образовавшийся пробел. Это сдвигание является операцией, 
которая требует времени, пропорционального количеству перемещаемых элементов. Таким образом, сложность удаления из начала вектора — `O(n)`, где `n` — количество элементов в векторе 
после удаляемого. Это делает операцию неэффективной, особенно для больших векторов.Пример:

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Удаление первого элемента
    vec.erase(vec.begin());

    // Вывод оставшихся элементов
    for (int x : vec) {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
В этом примере при вызове `vec.erase(vec.begin())`, `std::vector` должен переместить все элементы на одну позицию влево, что требует времени, пропорционального размеру вектора.

Удаление элемента из начала вектора является дорогостоящей операцией, потому что требует перемещения всех остальных элементов, чтобы поддерживать непрерывность блока памяти. В 
отличие от таких структур, как `std::list` или `std::deque`, где удаление из начала занимает константное время, `std::vector` менее подходит для задач, где часто требуется удаление 
элементов из начала или середины коллекции.


______________________________________________________________________________________
Теория: Сложность удаления элемента из конца вектора

Удаление элемента из конца вектора (`std::vector`) обычно является очень эффективной операцией с точки зрения производительности. Это связано с тем, что `std::vector` хранит свои 
элементы в непрерывном блоке памяти, и удаление последнего элемента не требует перемещения других элементов.

Сложность операции

Операция удаления элемента из конца вектора (`std::vector::pop_back()`) имеет константную сложность времени `O(1)`. Это означает, что время, необходимое для выполнения операции, не 
зависит от размера вектора. Вот почему:

1. Нет необходимости перемещать элементы: Поскольку удаляемый элемент находится в конце вектора, не требуется перемещать другие элементы для заполнения пробела.

2. Вызов деструктора: При удалении последнего элемента `std::vector` вызывает деструктор для этого объекта, чтобы корректно освободить любые ресурсы, которыми он может управлять. 
Деструктор вызывается только для одного элемента, поэтому это действие выполняется за константное время.

Пример:


#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {10, 20, 30, 40, 50};

    // Удаление элемента с конца
    vec.pop_back();

    // Вывод оставшихся элементов вектора
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}

В этом примере после вызова `vec.pop_back()`, последний элемент вектора (50) удаляется, и размер вектора уменьшается на один. Эта операция происходит за константное время, и 
последующий вывод показывает состояние вектора после удаления элемента.

Важно отметить, что удаление элемента из конца вектора не приводит к немедленному освобождению памяти, которая была выделена под массив элементов вектора. Вектор управляет своей 
памятью с помощью механизма емкости (`capacity`), которая может оставаться неизменной даже после удаления элементов. Память будет освобождена или уменьшена только тогда, когда 
будет вызван метод `shrink_to_fit` или вектор будет уничтожен.

Хотя сложность `pop_back()` константная, следует помнить, что вызов деструктора для сложных объектов может быть затратным в плане времени выполнения.
Удаление элемента из конца вектора — эффективная операция, занимающая константное время, что делает `std::vector` идеальным выбором для использования в сценариях, когда часто 
требуется добавление или удаление элементов с конца.

______________________________________________________________________________________
Итераторы STL

Итераторы это сущности которые нужны для взаимодействия с элементами, которые представлены в различных контейнерах STL. Поведение итераторов очень похоже на поведение 
указателей и на поведение умных указателей. Но сами по себе итераторы не являются указателями, это некая объектная оболочка над указателями, которая определяет некторую логику
поведения, каким образом эти указатели будут работать. Для разных групп контейнеров в STL итераторы организованы по разному.

Пример на обычном массиве:

int arr[] = { 2,6,9 };		
cout << arr[1] << endl;		//Доступ ко 2-ому элементу массива (значение 6).
cout << *(arr + 1) << endl; 	//Это тоже доступ ко 2-ому элементу массива (значение 6). Используем разыменование указателя на имя массива + 1. Имя массива это есть указатель 
на его первый (индекс 0) элемент. Получается указатель на первый элемент + 1 равен указатель на второй элемент массива.

Работа с итераторами в STL похожа на это.

myVector.begin(); //Интератор указывающий на начало вектора.
myVector.end(); //Итератор указывающий на элемент после последнего элемента (несуществующий).

vector<int> myVector = {1,9,44,422,676,78}; //Инициализация вектора
	
vector<int>::iterator it; //Создание итератора vector с типом данных int
it = myVector.begin(); //Теперь итератор указывает на первый элемент нашего вектора (связываем итератор с нашим вектором).
cout << *it << endl; //Получаем данные через итератор (сейчас в итераторе данные из первого элемента вектора).
*it = 5; //Присваиваем новое значение через итератор.
it++; //Инкремент итератора означает что мы переходим на следующий элемент вектора.
it += 2; //Сдвиг на 2 элемента вправо.
it--; //Сдвиг на 1 элемент влево.

for (vector<int>::iterator i = myVector.begin(); i != myVector.end(); i++)
{
	cout << *i << endl;
}
return 0;


Константный итератор. Разрешено только чтение, запись запрещена.

for (vector<int>::const_iterator i = myVector.begin(); i != myVector.end(); i++)
{
	//*i = 5;//Ошибка, перезапись константы запрещена.
	cout << *i << endl;
}
return 0;

Константый итератор в переменную обычного итератора мы присвоить не можем.


Мы можем итерировать с конца коллекции в начало:

for (vector<int>::reverse_iterator i = myVector.rbegin(); i != myVector.rend(); i++)
{
	cout << *i << endl;
}


Не все итераторы можно перемещать используя арифметику указателей, поэтому существует функция перемещения итератора:

advance(it, 3); //1-ый параметр: итератор, который нужно переместить, 2-ой параметр: на сколько шагов.



Вставка элемента в конкретное место в векторе:

myVector.insert(it, 999); //1-ый параметр: итератор, который указывает на место вставки нового элемента, 2-ой параметр: значение нового элемента.

Удаления элемента из конкретного места в векторе: 

myVector.erase(it); // Удаление элемента, на который указывает итератор.

Удалить диапазон элементов:

myVector.erase(it, it + 3); //1-ый параметр итератор указывающий на начальный элемент удаления, 2-ой параметр: итератор указывающий на конечный элемент удаления.



______________________________________________________________________________________
LIST (Список).

LIST представляет собой реализацию двусвязного списка. Лист это контейнер с данными, в котором эффективно реализована возможность добавления и удаления элемента в коллекцию,
абсолютно в любом месте контейнера (Очень быстро работает с удалением и добавлением элементов). В списке не реализована перегрузка оператора [], предётся использовать 
итераторы. Так же не реализован итератор произвольного доступа (мы не можем сразу получить доступ по какому то конкретному индексу). Лист тоже шаблонный контейнер, как и вектор.

#include <list> 				//Подключаем список

list<int> myList; 				//Создание списка
//list<int> myList = {15,64,77};

myList.push_back(1); 				//Добавление элемента в конец списка
myList.push_front(0); 				//Добавление элемента в начало списка

list<int>::iterator it = myList.begin(); 	//Создаём итератор для перемещения по списку
cout << *it << endl; 				//Вывод первого элемента списка

for (auto i = lst.cbegin(); i != lst.cend(); ++i) //Перебор всех элементов списка
{
	cout << *i << endl;
}

myList.sort(); //Сортировка списка по возрастанию

myList.pop_back(); //Удалить последний элемент списка
myList.pop_front(); //Удалить первый элемент списка.

myList.unique(); //Удаление дубликатов (только последовательных) из списка

myList.reverse(); //Реверс всего списка

myList.clear(); //Очистка всего списка от всех элементов

Вставка элемента в список:
myList.insert(it, 11); //1-ый параметр: итератор, который указывает на место вставки нового элемента, 2-ой параметр: значение нового элемента.

Сдвиг итератора:
advance(it, 3); //1-ый параметр: итератор, который нужно переместить, 2-ой параметр: на сколько шагов.

Удаление элемента списка:
myList.erase(it); // Удаление элемента, на который указывает итератор.

myList.remove(99); //Удалить элемент со значением 99

myList.assign(3, 1); //Заполнить список элементами. Перед тем как заполнить лист новыми элементами, старые удаляются. 1-ый параметр: кол-во новых чисел, 2-ой параметр: их значение.

Копирование элементов с заменой на новые
myList.assign(myList2.begin(), myList2.end()); //Копирование из myList2 в myList



______________________________________________________________________________________
Итераторы stl 


i++ или ++i в for
#########################
Разница в использовании префиксного и постфиксного инкремента/декремента для итераторов в том, что в случае префиксного итератора, в теории, просто изменяется состояние объекта, 
и потом он возвращается, а при использовании постфиксного инкремента, состояние также изменяется, но возвращается объект с предыдущим состоянием, т.е. для этого компилятору 
необходимо создать ещё 1 объект. Это влияет на скорость работы. Но, вроде как современные компиляторы уже могут сами оптимизировать подобные случаи, и скорость работы не 
отличается. Но для себя я всё же сделал вывод, что если использование префиксного и постфиксного инкремента не влияет на правильность ответа, то предпочтительно использовать 
префиксный инкремент.

int a = 5;

cout << a++ << endl; //В консоль выведется 5, после того как все операции закончились (в нашем случае вывод в консоль), a присвоется значение 6. (Переменная сначала вывелась, 
		     //затем увеличилась).

cout << ++a << endl; //В консоль выведется 6 сразу (Переменная сначала увеличилась, затем вывелась).


#########################
Как попасть в код реализации операции: Ставим курсор на интересующею операцию и нажимаем F12.



______________________________________________________________________________________
Цикл foreach. range-based циклы.

Цикл foreach отличается от других циклов своим специфическим предназначением, он в первую очередь предназначен для того, чтобы итерироваться по каким либо контейнерами, и 
получать доступ к элементам этого контейнера (перебор коллекции элементов).

Базовое построение цикла foreach:

for each (object var in collection_to_loop)
{

}

Мы ищем в какой то коллекции объектов (collection_to_loop) какой то конкретный объект (object var).

Сейчас почему то foreach так уже не работает. Теперь он работает вот так:

int arr[] = { 5,11,94,99,44 };

for (int var : arr) 			//Перебор всех элементов массива arr
{
	cout << var << endl;
};

этот цикл называется range-based цикл. В каждой итерации этого цикла в переменную var будет скопирован следующий элемент массива (начинаю с 0). Это означает что при изменении
переменной var, элемент коллекции не изменяется. Если нужно изменять элементы коллекции, то нужно передавать элементы по ссылке:

for (int &var : arr) 			//Перебор всех элементов массива arr
{
	var++;
	cout << var << endl;
};

Если нужно передавать элемент по ссылке, но не нужно его его изменять, то нужно указать ключевое слово const:

for (const int &var : arr)
{
	//var++; 			//Не получится
	cout << var << endl;
};


С помощью этого цикла мы можем перебрать контейнер без итератора:

list<int> myList = { 1,99,4,94,799,44,6 };

for (const auto &var : myList)
{
	cout << var << endl;
};



______________________________________________________________________________________
forward list

forward list представляет собой реализацию односвязного списка.

#include <forward_list>  	//Подключаем односвязный список

В forward_list есть многие методы, которые есть в list и Vector, их предназначение одинаковое для всех.

Особенности forward_list: в отличие от обычного list, в forward_list добавлять и удалять элементы мы можем только в начале списка. Есть метод insert_after, который позволяет
вставить элемент в любое место.


for (auto var : fl) 				//Перебор всех элементов списка
	cout << var << endl;

forward_list<int>::iterator it = fl.begin(); 	//Итератор для списка

it++; 						//Переход на следующий элемент
//it--; 					//Не работает, эта операция не перегружена, потому что это односвязный список.

cout << *it << endl;


В forward list есть методы с приставкой after: insert_after, erase_after. А так же методы с приставкой before: before_begin, cbefore_begin. Наличие этих методов объясняется
логикой односвязного списка: В двусвязном списке при работе метода insert(3, 0) этот четвёртый элемент (итерация с 0) становится пятым, а на его место ставится новый элемент.
При односвязном списке такая операция не возможна, потому что старый четвёртый элемент не хранит адрес предыдущего элемента. Именно по этому был добавлен метод insert_after,
в котором новый элемент вставиться не перед указанным в параметре элементом, а после него. erase работает так же.

forward_list<int> fl = {131, 94, 494};

forward_list<int>::iterator it = fl.begin(); 	//Итератор для списка

fl.insert_after(it, 9999);

for (auto var : fl) 				//Перебор всех элементов списка
	cout << var << endl;
 

Метод before_begin ставит итератор на область памяти перед первым элементом (по сути в никуда). Он нужен чтобы получить доступ для методов insert_after и erase_after к первому
элементу списка.


______________________________________________________________________________________
array STL

#include <array> //Подключаем массив

array является обёрткой для статического массива (А vector для динамического).

array<int, 4> arr; //Инициализация
Поскольку массив статический, мы не можем не добавить элемент ни удалить.

arr.at(1);
arr.size();
arr.fill(-1); //Заполняет полностью массив числом -1
arr.front(); //Доступ к первому элементу массива
arr.back(); //Доступ к последнему элементу массива



______________________________________________________________________________________
Контейнеры STL и операторы сравнения

У всех контейнеров STL присутствует перегрузка операторов сравнения.

array <int, 4> arr = { 1, 94, 77, 9 };
array <int, 4> arr2 = { 1, 94, 77, 9 };

bool res = (arr == arr2); //res = true.

#####
array <int, 4> arr = { 1, 94, 77, 10 };
array <int, 4> arr2 = { 1, 94, 77, 9 };

bool res = (arr > arr2); //res = true. В arr последний элемент 10 а в arr2 последний элемент 9, поэтому arr > arr2 (Сумма всех элементов arr > чем в arr2).

Главное условие сравнивания контейнеров, это то, чтобы внутри такого контейнера минимальный элемент сам по себе должен иметь перегруженный оператор сравнения.



______________________________________________________________________________________
deque (Дек)

Дек - это двусторонняя очередь. Это некий гибрид вектора и двусвязного списка. По сути дек это двусвязный список векторов, т.е. несколько векторов связаны в один список. 
Дек позволяет сгладить недостатки списка при попытке доступа к конкретному элементу. В списке все элементы разбросанны по всей памяти и переход от одного элемента к другому 
медленный. В векторе все элементы объеденены в непрерывной области памяти, поэтому переход от одного элемента к другому очень быстрый. Получаем скорость итерации выглядит так:
список (медленный) < дек (средний) < вектор (быстрый).

Так же важна скорость доступа, добавления и удаления элемента в начало и в конец коллекции. В двусвязном списке это делается очень быстро по причине самой структуры контейнера.
В векторе приходится перевыделять память заново и копировать все элементы, затем уже добавлять новые, это очень долго. Получаем скорость добавления и удаления элемента выглядит
так: список (быстрый) > дек (средний) > вектор (медленный).

#include <deque> //Двусторонняя очередь

В дек в отличии от vector есть метод push_front. Остальные методы идентичны предыдущим контейнерам.



______________________________________________________________________________________
SET | MULTISET | Ассоциативные контейнеры

SET и MULTISET это два упорядоченных ассоциативных контейнера. Эти контейнеры реализованы на основе бинарного дерева.

#include <set> //Подключение бинарного дерева

Здесь нет методов push_back или push_front поскольку структура бинарного дерева очень сильно отличается от списка. Так же нет перегрузки операторов [] и метода at.
Здесь есть метод insert: 

set<int> mySet;

mySet.insert(5); 		//Корень дерева (поскольку добавился первым).
mySet.insert(1);
mySet.insert(12);
mySet.insert(4);
mySet.insert(-1);

for (int var : mySet)
	cout << var << endl; 	//Бинарное дерево упорядоченная структура данных, поэтому в консоль будут выводиться данные в порядке возрастания.

Важная особенность сета, по мимо упорядочивания элементов, это то, что сет не может хранить несколько одинаковых элементов (хранит всегда только уникальные значения). В этом
моменте как раз и есть отличие SET от MULTISET. MULTISET тоже хранит элементы в упорядоченном состоянии, однако позволяет добавлять несколько одинаковых элементов. 
Так же контейнер сет не может изменить элемент, который в нём находится. Это можно обойти тем, что просто удалить старый элемент, и добавить его новое значение заново.


Поиск элемента в сете:

set<int> mySet = {5,45,35,11,86};
	
auto it = mySet.find(10); 	//Если метод find нашёл элемент, он возратит итератор на определённый элемент в сете. Если нет, то итератор вернёт значение, которое будет 
				//указывать на mySet.end() (элемент, который находится после коллекции т.е. в никуда).

auto it = mySet.find(11);

В методе find поиск элемента происходит с помощью бинарного поиска.


Удаление элемента в сете:

mySet.erase(5); // Удаления числа 5 из дерева.

Если элемента нет, а мы попытаемся его удалить, то ничего не произойдёт.

Методы insert и erase возвращают результат своей работы. Метод erase возвращает 1 если получилось удалить и 0 если не получилось. Метод insert возвращает пару значений:
в 1-ом итератор на добавленный элемент после его добавления и 2-ой булева переменная true или false. Если получилось добавить элемент то будет true если нет то false.
Итератор на элемент будет в любом случае.


Для пользования MULTISET нам нужно подключить тот же заголовок #include <set>.

multiset<int> myMultiset = {1,1,45,35,11,86};

В связи с тем что мультисет может хранить несколько одинаковых элементов в контейнере, в этом контейнере имеет смысл использовать методы lower_bound и upper_bound. 
Это нектороые аналог метода find, которые позволяют искать элемент. Эти методы возвращают итераторы на нужное нам число.

multiset<int> myMultiset = {1,1,45,35,11,86};

auto it1 = myMultiset.lower_bound(1); 	//Найдёт первую единицу, которую найдёт (потому что единица в параметре).

auto it2 = myMultiset.upper_bound(1); 	//Найдёт следующий после единицы элемент (который больше его). Поскольку в мультисете все элементы хранятся в упорядоченном состоянии, 
					//то в нашем случае следующий элемент будет 11, а не 1 или 45.


auto a = myMultiset.equal_range(1); 	//Возвращает диапазон чисел от lower_bound до upper_bound. В нашем случает вернёт (1,11);


Коментарии к видео:
А насчёт этого... Корнем этих классов становится число, которое было добавлено самым первым, так ведь? Т.е, у нас может первым числом добавиться значение -999999999999, а потом
 будут добавляться лишь значения больше, тогда у нас вся левая ветка древа будет пуста? Логично, что да. Есть ли у этих классов функции для сортировки дерева? Ну, или, мб в 
дальнейшем будут какие-то пояснения по этой теме?

Явно, что если корнем дерева будет число, максимально близкое к среднему арифметическому этого дерева, то поиск будет быстрее, чем, если к примеру, корнем будет число 1, и 
числа 2,3,4...100 будут рассортированы в правой ветке. Так, чтобы найти число 51, придётся сделать 50 шагов. А если имеются те же числа, но корнем дерева будет число 50, то для
 нахождения числа 51 придётся сделать всего лишь 1 шаг...

Как-бы всё правильно, но есть одно но: когда мы делаем выбор в пользу того или иного контейнера, то мы хоть как-то представляем себе каким образом туда будуть попадать данные и
если мы предполагаем, что элементы будут записываться всегда или почти всегда по возрастанию, то бинарное дерево может быть и не лучшим выбором. Тут всё зависит от задач. 
Бинарный поиск один из самых быстрых, а в описаной вами ситуации поиск по-умолчанию будет одинаково доглим для любого контейнера

В контейнере stl set используется не обычное бинарное дерево, а сбалансированное. Например, красно-чёрное. После добавления эллемента такое дерево ещё будет балансироваться. 
Таким образом корень может измениться. Пример, который вы привели в комментариях полностью отображает потребность такой балансировки для эффективности.


______________________________________________________________________________________
Теория: set сложность вставки, удаления, поиска

В set сложность вставки, удаления, поиска - логарифмическая
В стандартной библиотеке C++ контейнер `std::set` обычно реализован как бинарное дерево поиска, чаще всего как красно-чёрное дерево. Этот тип дерева является самобалансирующимся, 
что гарантирует, что дерево остаётся относительно сбалансированным после каждой операции вставки или удаления. Благодаря этому, высота дерева поддерживается на уровне \(O(\log n)\),
 где \(n\) — количество элементов в контейнере. Это гарантирует, что основные операции, такие как поиск, вставка и удаление элементов, выполняются за логарифмическое время.

Вставка

Включает в себя несколько шагов:
1. Поиск места для вставки: сначала необходимо определить, где в дереве должен находиться новый элемент, чтобы сохранить свойства упорядоченного дерева.
2. Вставка элемента: после того как место найдено, элемент вставляется в дерево.
3. Балансировка дерева: поскольку `std::set` обычно использует красно-чёрное дерево, после вставки может потребоваться несколько операций для восстановления сбалансированности 
дерева.

Удаление

Требует поддержания свойств бинарного дерева:
1. Поиск элемента для удаления: сначала находится элемент, который должен быть удалён.
2. Удаление элемента: элемент удаляется из дерева, что может включать замену удаляемого узла его потомком, если у узла есть дети.
3. Балансировка дерева: как и при вставке, после удаления может потребоваться несколько операций для восстановления сбалансированности дерева.

Поиск

Выполняется путём сравнения искомого значения с элементами в узлах, начиная от корня и перемещаясь вниз по дереву к листьям. Это поиск делает относительно простым благодаря 
свойствам красно-чёрного дерева, что обеспечивает логарифмическую сложность операции.

`std::set` обеспечивает эффективное управление упорядоченным набором элементов с логарифмической сложностью для операций вставки, удаления и поиска, что делает его подходящим 
выбором для многих задач, где важна скорость выполнения операций с данными в упорядоченном виде.


______________________________________________________________________________________
Теория: Худший случай поиска в бинарном дереве

Худший случай поиска в бинарном дереве возникает, когда дерево вырождается в свою одностороннюю форму, то есть принимает форму линейного списка (цепочки). Это происходит, когда 
элементы вставляются в дерево в уже отсортированном порядке, или когда каждый следующий элемент меньше (или больше) предыдущего.

Допустим, у нас есть последовательность чисел, которые мы хотим вставить в бинарное дерево поиска: 1, 2, 3, 4, 5. Если вставлять их в указанном порядке, то каждый новый элемент 
будет правым потомком предыдущего, что приведет к следующей структуре дерева:

```
1
 \
  2
   \
    3
     \
      4
       \
        5
```
В этом случае дерево вырождается в своего рода "правую ветку", и для поиска любого значения мы потенциально должны пройти по всем узлам. Например, чтобы найти число 5, нам 
необходимо сделать 5 сравнений.

Почему это плохо

Поиск в сбалансированном бинарном дереве работает за время \(O(\log n)\), где \(n\) — количество узлов в дереве. Это потому что с каждым шагом вглубь дерева количество узлов, 
которые еще предстоит рассмотреть, уменьшается вдвое. Однако, в вырожденном случае, как показано выше, поиск работает за \(O(n)\), так как каждый узел в дереве требует отдельного 
шага проверки.

Как избежать

Для предотвращения вырождения бинарных деревьев используют так называемые сбалансированные деревья поиска, такие как красно-черные деревья или AVL-деревья. Эти структуры данных 
автоматически перебалансируются при каждой операции вставки или удаления, что обеспечивает поддержание высоты дерева порядка \(O(\log n)\) и гарантирует, что операции поиска, 
вставки и удаления будут выполняться за логарифмическое время.

Худший случай поиска в бинарном дереве наступает, когда дерево становится похожим на линейный список, требуя \(O(n)\) времени для поиска элемента. Это случается при неудачном 
порядке вставки элементов. Использование сбалансированных деревьев помогает избежать такой проблемы.


______________________________________________________________________________________
MAP | MULTIMAP | Ассоциативные контейнеры

MAP и MULTIMAP схожи с SET и MULTISET, они тоже упорядочены, тоже имеют структуру бинарного дерева, но в отличии от SET и MULTISET которые просто хранят какое то одно значение, 
и строются в виде бинарного дерева логически, контейнеры MAP и MULTIMAP хранят не просто одно значение, а пары состоящие из ключа и значения. Так же как SET и MULTISET, 
MAP и MULTIMAP отличаются по тому же признаку: MAP может хранить только уникальные значения, MULTIMAP может хранить и дубирующие значения. Упорядочивание осуществляется на
основе ключа, а значение к нему просто подвязывается. Как итог мы получаем некий словарь.

#include <map> //Подключение карты

Простая пара:

pair<int, string> p(1, "телефон"); 	//Пара в чистом виде
p.first; 				//Первый элемент пары (1). Это ключ
p.second; 				//Второй элемент пары (телефон). Это данные


Добавление элемента в карту: Параметр insert принимает только уже готовую пару.

myMap.insert(make_pair(1, "телефон")); 		//Метод make_pair создаёт пару

myMap.insert(pair<int, string>(2, "ноутбук")); 	//Ручное создание пары в параметре

myMap.emplace(3, "монитор"); 			//автоматическое добавление нового элемента

Метод insert либо копирует готовый объект, либо перемещает его. Метод emplace просто создаёт объект во время выполнения (он должен работать немного быстрее). В случае добавления
нового элемента с ключём, который уже есть map, новый элемент добавлен не будет. Так же как и в SET, метод insert возвращает пару значений: 1-ый параметр пара по заданному ключу,
2-ой параметр результат добавления (true или false).

auto res = myMap.emplace(4, "ывопатвы"); 	// В нашем случае res равен ((4, "ывопатвы"), true).



Поиск осуществляется методом find по ключу. Этот метод возвращает результатом своей работы итератор, который указывает на пару ключ-значение в map в случае если он смог найти 
элемент с текущим ключём. Если мы пытаемся найти элемент по ключу, которого у нас нет в map, то метод вернёт значение end() (по сути в никуда). 

auto it = myMap.find(3); 			//Поиск элемента по ключу (в нашем случае по ключу 3).

cout << it->first << it->second << endl;	//Вывод значений пары ключ-значение, на который указывает итератор.


if (it != myMap.end()) 				//Чтобы не получить ошибку по выводу несуществующего элемента.
{
	cout << it->first << it->second << endl;
}



Для контейнера map перегружен оператор [].

cout << myMap[3] << endl; 			//Вывод в консоль: монитор




Типы данных для ключа тоже могут быть разными: Например у строк тоже есть перегруженный оператор больше и меньше, поэтому построение бинарного дерева на основании строк тоже
возможно.

map<string, int> myMap;				//Ключ типа string
	
myMap.emplace("Петя", 18);
myMap.emplace("Маша", 22);
myMap.emplace("Саша", 20);

Теперь когда мы хотим обратиться к интексу в нашем map (например в методе find или []), мы должны указывать соответствующий тип данных ключа. 

cout << myMap["Петя"] << endl; 	//Выведется значение 18

Так же с оператором [] мы можем не только получать значение, но и помещать значения в пару.

myMap["Маша"] = 25; 		//Присвоили Маше значение 25

Если мы помещаем значение с ключём, которого ещё нет в map, то данная пара появится в map.

А вот если использовать метод at с ключём которого нет в карте, то новая пара не будет добавлена, а метод at вызовет исключение. 



Удалить элемент из контейнера можно методом erase, положив в параметр ключ элемента, который нужно удалить.

myMap.erase("Саша");



multimap работает так же как и map, только multimap может хранить дублирующиеся ключи. Так же в multimap не перегуржен оператор [] и отсутствует метод at.
 
myMultimap.emplace("Петя", 12);
myMultimap.emplace("Петя", 24);


______________________________________________________________________________________
Stack | Адаптеры контейнеров

В STL существует 3 адаптера: Stack, queue (очередь), priority qoeue(очередь с приоритетом). Их особенность в том, что они не являются самостоятельными контейнерами в STL, они
являются адаптерами для контейнеров.

Принцип Стека: В Стеке тот элемент, который был добавлен в стек самым последним, будет извлечён самым первым (положить в  ящик). Для реализации этого принципа мы можем выбрать 
как базой абсолютно любую динамическую структуру данных (и вектор и лист и дек). И в веторе и в листе и в деке мы можем итерироваться по элементам, добавлять и удалять 
элементы в любом место контейнера. Но если мы поверх всего этого функционала для любого их этих контейнеров, наложим правила стека, ограничим функционал, таким образом мы 
любой из этих контейнеров адаптируем под стек. И разница будет в том, что стек будет по разному себя вести в плане быстродействия, если в его основу был положен тот или иной 
контейнер. В с++ stack, queue, priority qoeue реализованы т.о., что они как бы ограничивают функционал, того контейнера, который был положен в их основу, только лишь теми 
методами, которые доступны в стеке или очереди (в зависимости что выберешь).

#include <stack> //Подключаем стек

stack<int> st;

st.push(1); //Создаёт копию объекта, затем эту копию переносит в коллекцию
st.push(2);

st.emplace(3); //Создаёт объект, который мы помещаем в стек, непосредственно в коллекции (без копировани, значит быстрее).

st.size();

st.empty();

st.pop(); //Извлекает (удаляет) последний (самый верхний) элемент стека (не возвращает ничего).

st.top(); //Просмотор последнего элемента в стеке (возвращает ссылку на последний элемент, не удаляя его).


Прербор всех элементов циколм в стеке не возможен, итараторы тоже не работают, сама идея стека в том, чтобы смотреть только последний элемент.
Но вот вариант перебора всех элементов стека:
while (!st.empty()) {
    cout << st.top() << endl;
    st.pop();		//Удалять нужно полюбому, потому что цикл не успокоится, пока в стеке не останется элементов.
}


Под стек мы можем использовать вектор, лист и дек.

auto a = st._Get_container(); //Возвращает тот сырой контейнер, который был положен в основу стека.
cout << a[1] << endl; 	//Вывод второго элемента из извлечённого контейнера. С помощью этого метода при необходимости мы можем избавиться от всех ограничений стека. Извлечь 
			//оригинальный контейнер, который лежи в основе нашего стека и начань манипулировать с ним без ограничений.


Можно явно указать с каким контейнером будет работать стек:
stack<int, list<int>> st;



______________________________________________________________________________________
queue | priority queue (очередь, очередь с приоритетом)

Так же как и стек, queue и priority queue являются адаптерами для контейнеров, а не самостоятельными контейнерами (оболочка). Под очередь могут быть адаптированы вектор, лист и
дек. Для очередей нет своей реализации, очереди просто основываются на одном из контейнеров, ограничивая функционал.

#include <queue> //Подключение библиотеки для queue и priority queue

Вектор не может быть основой для обычной очереди (только лист и дек). 

queue<int> q;
queue<int, list<int>> q; //При необходимости в начале указываем ещё и тип контейнера для адаптера

q.emplace(1); //Добавить элемент в очередь. Схож с методом push, однако не копирует элемент, а сразу создаёт

q.back(); //Доступ к последнему добавленному элементу в очереди. Получаем ссылку на элемент, можем посмотреть или изменить, но удалить нельзя
q.front(); //Доступ к первому элементу в очереди. Получаем ссылку на элемент

q.empty(); //Проверка на пустоту

q.pop(); //Извлечь элемент (самый первый элемент будет извлечён)

q.size(); //размер очереди

q.swap(); //Обмен содержимого одного адаптера с другим

q._Get_container(); //Возвращает базовый контейнер, на котором основан адаптер


Очередь с приоритетом не может использовать лист (только вектор и дек). Тут нет метода q._Get_container();

q.top(); //Доступ к самому первому элементу очереди с приоритетом

В STL реализован такой способ работы очереди с приоритетом, что при добавлении элементов, они сразу выстраиваются в очереди, и добавляются в очередь, согласно приоритету.
По умолчанию элементы выстраиваются от большего к меньшему: [0] 99, [1] 56, [2] 7, [3] 4.





______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________


Алгоритмы:

Алгоритмы STL это набор функций, которые призваны решать какие либо типичные задачи. 

Для их применения нужно подключить библиотеку algorithm.

______________________________________________________________________________________
STL Подсчёт чего либо в коллекции:

count_if(Итератор указывающий на место начала подсчёта, Итератор указывающий на место конца подсчёта, предикат подсчёта). 


Пример:


bool GreaterThenZero(int a) { 		//Предикат отвечающий на вопрос больше ли наше число чем ноль. 
	return a > 0;			//Если предикат возвращает true то счётчик count_if увеличивается.
}

int main()
{
	setlocale(LC_ALL, "Russian");
	
	vector<int> v = { 1,-2,-55,9,-3,8 };

	int res = count_if(v.begin(), v.end(), GreaterThenZero); //Алгоритм STL, который может подсчитать что либо в коллекции

	cout << res << endl; //Выведет число 3. Т.е. count_if подсчитал, что в нашей коллекции v есть три числа, отвечающие требованиям предиката GreaterThenZero.
	
	return 0;
}



______________________________________________________________________________________
STL Алгоритмы сортировки | Бинарный предикат | Лямбда функции

sort(Итератор указывающий на место начала сортировки, Итератор указывающий на место конца сортировки, бинарный предикат (если нужен));

Пример сортировки по умолчанию:

vector<int> v = { 9,4,94,6,1,3,7 };
sort(v.begin(), v.end());		//1,3,4,6,7,9,94


Пример сортировки с предикатом: В данном случае предикат сортирует элементы вектора в порядке уменьшения.

bool MyPred(int a, int b){
	return a > b;
}

int main()
{

	vector<int> v = { 9,4,94,6,1,3,7 };
	sort(v.begin(), v.end(), MyPred);		//94,9,7,6,4,3,1	
	
	return 0;
}


Функция MyPred может больше нигде не использоваться в коде, поэтому логично использовать для неё лямбда функцию.

int main()
{
	vector<int> v = { 9,4,94,6,1,3,7 };
	sort(v.begin(), v.end(), [](int a, int b) 
		{
			return a > b;
		});
	
	return 0;
}


Сортировка обычного массива (не контейнера STL): Имя массива это указатель на его первый элемент. С помощью арифметики указателей можем указать и на последний элемент.

int main()
{
	const int size = 7;
	int arr[size] = { 9,4,94,6,1,3,7 };

	sort(arr, arr + size);			//Указатель на первый элемент массива + его размер = указатель на последний элемент массива.
	
	return 0;
}


Реальная задача: У нас есть коллекция людей с баллами по егэ. Нужно их отсортировать.

class Person { 
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 							//Функтор предикат
		return p.score > 180;
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	vector<Person> people{									//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150)
	};

	sort(people.begin(), people.end(), [](const Person &p1, const Person &p2) {		//Сортировка в которой лямбда функция на месте предиката
			return p1.name < p2.name; 						//Сортировка по имени
			//return p1.score > p2.score; 						//Сортировка по баллам
	});

	for (auto el : people){									//Вывод в консоль
		cout << "Имя:\t" << el.name << "\tбаллы\t" << el.score << endl;
	}
	return 0;
}



______________________________________________________________________________________
STL алгоритмы поиска | find | find_if | find_if_not

find позволяет узнать присутствует ли в какой то коллекции какой то конкретный элемент.

find(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска, значение которое нужно найти). Возвращает итератор на место найденного элемента, 
или итератор на конец коллекции если элемент не найден.

vector<int> v = { 6,4,4,12,1,2,7 };

auto res = find(v.begin(), v.end(), 12); 	//res это итератор, который хранит указатель, который указывает на наш элемент.

if (res == v.end()) {				
	cout << "Число не найдено" << endl;
}
else {
	cout << "Число найдено" << endl;
}


Метод find не гибкий, он может проверять элементы в коллекции только на равенство с тем элементом, который мы передаём в качестве 3его параметра. Если мы хотим найти элемент по
другому принципу, нам нужно использовать методы find_if и find_if_not.

find_if(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска, предикат)

Есть ли в коллекции вообще чётные числа?:

vector<int> v = { 6,4,4,12,1,2,7 };

auto res = find_if(v.begin(), v.end(), [](int a) { //Предикат с помощью лямбда выражения
	return a % 2 == 0;
});

if (res == v.end()) {
	cout << "Число не найдено" << endl;
}
else {
	cout << "Число найдено" << endl;
}
return 0;


find_if_not тоже самое что и find_if, только инвертированное (он возвращает true если предикат возвращает false).



Пример работы с более сложным типом данных:

class Person { //Класс студентов
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 						//Функтор предикат
		return p.score > 180;
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	vector<Person> people{								//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150)
	};

	auto res = find_if(people.begin(), people.end(), [](const Person &p) {
		return p.name == "Маша";						//Ищем человека с именем Маша
		//return p.name == "Маша" && p.score == 179; 				//Пример двойного условия	
	});

	if (res == people.end()) {
		cout << "Не найдено" << endl;
	}
	else {
		cout << "Найдено" << endl;
	}
	return 0;
}

Преимущество в том что мы можем гибко настраивать параметры поиска. Недостаток в том что мы можем вернуть только один элемент. Если в коллекции два элемента подходящие по 
условию, то вернётся только первый попавшийся (Рассмотренно в следующей теме).



______________________________________________________________________________________
stl copy | stl copy_if | Выборка данных по условию

Задача алгоритмов copy_if и copy скопировать все элементы из одной коллекции в другую, чтобы эти коллекции содержали в себе одинаковые элементы и были идентичны.

copy(Итератор указывающий на место начала копирования, Итератор указывающий на место конца копирования, коллекция в которую нужно копировать).



Ответ на вопрос из предыдущей темы: Каким образом можно выбрать определённое кол-во объектов в новую коллекцию, которые удовлетворяют каким то нашим условиям?

copy_if(Итератор указывающий на место начала копирования, Итератор указывающий на место конца копирования, коллекция в которую нужно копировать, предикат).

class Person { //Класс студентов
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 						//Функтор предикат
		return p.score > 180;
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	vector<Person> people{								//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150),
		Person("Иван", 199)
	};

	vector<Person> res;								//Вектор для вывода результата
	
	copy_if(people.begin(), people.end(), back_inserter(res), [](const Person &p) { //Копируем элементы коллекции people, которые подходят по нашему предикату(условию), 
		return p.name == "Иван";						//заданному лямбда функцией, в вектор res.
	});
	cout << "Всего элементов:\t" << res.size() << endl;

	for (auto el : res) {
		cout << "Имя:\t" << el.name << "\tбаллы\t" << el.score << endl;
	}
	return 0;
}



______________________________________________________________________________________
stl remove | remove_if  удаление элемента по условию

алгоритмы remove и remove_if удаляют все элементы подходящие под условия (даже если есть дублирующие элементы). На самом деле алгоритм remove ничего не удаляет. Все подходящие
по условию элементы он оставляет в конце вектора (после всех неудалённых элементов), и возвращает итератор на позицию за последним не исключённым элементом. По сути мы нужные
элементы собираем в одну сторону, а не нужные в другую.

remove(Итератор указывающий на место начала поиска для удаления, Итератор указывающий на место конца поиска для удаления, элемент который хотим удалить).

vector<int> v = { 5,9,1,46,4,9,4 };		//Вектор, в котором нужно удалить число 9

auto res = remove(v.begin(), v.end(), 9);	//Получаем итератор на первый элемент, который нужно удалить. Сейчас в векторе такой порядок: 5,1,46,4,4,9,9 (итератор на 1ой 9).

v.erase(res, v.end()); 				//Удаляем ненужные элементы. Вектор: 5,1,46,4,4



remove_if(Итератор указывающий на место начала поиска для удаления, Итератор указывающий на место конца поиска для удаления, предикат)

Удалим все абитуриенов, баллы которых меньше 150.

class Person { //Класс студентов
public:
	Person(string name, double score) {
		this->name = name;
		this->score = score;
	}
	bool operator()(const Person &p) { 					
		return p.score > 180;
	}
	string name;
	int score;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	vector<Person> people{								//Коллекция студентов
		Person("Вася", 181),
		Person("Петя", 30),
		Person("Маша", 179),
		Person("Даша", 200),
		Person("Катя", 198),
		Person("Андрей", 181),
		Person("Сергей", 50),
		Person("Иван", 150),
		Person("Иван", 199)
	};

	auto res = remove_if(people.begin(), people.end(), [](const Person &p) { 	//Получаем итератор на границу между нужными и ненужными объектами.
		return p.score < 150;
	});

	people.erase(res, people.end());

	/* Второй вариант без промежуточной переменной res:
	people.erase(remove_if(people.begin(), people.end(), [](const Person &p) {
		return p.score < 150;
	});, people.end());
	*/

	cout << "Всего элементов:\t" << people.size() << endl;

	for (auto el : people) {
		cout << "Имя:\t" << el.name << "\tбаллы\t" << el.score << endl;
	}
	return 0;
}



______________________________________________________________________________________
Поиск максимального элемента | max_element

max_element(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска)

Возвращает итератор на наибольший элемент в коллекции.

vector<int> v = {10,1,-55,11,13,58};			//Наша коллекция

auto res = max_element(v.begin(), v.end()); 		//Получаем итератор на наибольшее число коллекции
	
cout << *res << endl;					//Чтобы получить число а не сам итератор, итератор нужно разыменовать.



Если мы работаем не с контейнерами STL.

const int size = 6;					//Размер статического массива
int arr[size] = {10,1,-55,11,13,58};			//Его определение

auto res = max_element(arr, arr + size); 		//Имя массива это указатель на его первый элемент. С помощью арифметики указателей, мы можем указать и на последний
							//элемент массива (arr + size).

cout << *res << endl;	//Чтобы получить число а не сам итератор, итератор нужно разыменовать.



______________________________________________________________________________________
Поиск минимального элемента | min_element

min_element(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска)

Возвращает итератор на наименьший элемент в коллекции.


Одновременный поиск и максимального и минимального элементов.

minmax_element(Итератор указывающий на место начала поиска, Итератор указывающий на место конца поиска)

Возвращает пару значений итераторов, указывающих на минимальный и максимальный элементы.

const int size = 6;
int arr[size] = {10,1,-55,11,13,58};

auto res = minmax_element(arr, arr + size); 

cout << "min = "<< *res.first << " max = "<< *res.second << endl;	//Чтобы получить число а не сам итератор, итератор нужно разыменовать.



______________________________________________________________________________________
accumulate | сумма и произведение элементов массива

Алгоритм accumulate очень гибкий инструмент, с помощью него можно многое вычислить. По умолчанию вычисляет сумму всех чисел в коллекции.

#include <numeric> // Подключение алгоритма accumulate

accumulate(Итератор указывающий на место начала коллекции, Итератор указывающий на место конца коллекции, к какому изначальному значению будут прибавляться все остальные 
	значения в коллекции (точка отсчёта), четвёртый параметр ниже).

Возвращает какой то конкретный результат (не итератор).

Важный момент это точка отсчёта. Она определяет тип возвращаемого значения (Если 0 то вернёт int, если 0.1 то вернёт double).

vector<int> v = { 2,3,4 }; 

auto res = accumulate(v.begin(), v.end(), 0); // 0 + 2 + 3 + 4 = 9.

cout << res << endl; // res = 9.


Для коллекций не являющимися контейнерами STL (например статический массив), в место первого параметра нужно тоже передать указатель на начало и конец коллекции. Для массива
это будет так: accumulate(имя массива, имя массива + его размер, 0). Однако мы не всегда знаем размер массива. Для этого есть альтернатива: В пространстве имён std доступны
по отдельности функции begin() и end(). Их задача аналогична методам контейнеров в STL, однако они не привязаны к каким то конкретным коллекциям.

int arr[] = { 2,3,4 }; 				//Обычный статический массив

auto res = accumulate(begin(arr), end(arr), 0);

#########
Для изменения поведения алгоритама accumulate мы должны добавить четвёртый параметр - функцию, которая принимает два параметра и возвращает какое то значение.

Первый параметр хранит в себе текущее состояние при расчётах на момент выполнения алгоритма accumulate. Второй параметр - это тот элемент, который мы сейчас будем прибавлять.

int arr[] = { 2,3,4 }; 

auto res = accumulate(begin(arr), end(arr), 1, [](int a, int b) { 		//Кастомный алгоритм.
	return a * b; 								// Получим перемножение всех элементов массива arr.
});

cout << res << endl;								//res = 24 = 1 * 2 * 3 * 4.


Ещё один пример: Сумма всех чётных элементов.

int arr[] = { 2,3,4 }; 

auto res = accumulate(begin(arr), end(arr), 0, [](int a, int b) { 	//Кастомный алгоритм
	if (b % 2 == 0) 						//Сумма всех чётных чисел
		return a + b;
	else
		return a;
});

cout << res << endl;


Пример работы с другим типом данных. У нас есть массив чисел, нам нужно сделать из них строку, разделив эти элементы между собой знаком +. Поскольку вернуть нам нужно строку
то изменяем тип точки отсчёта на строку: to_string(arr[0]). Поскольку хранить теперь мы будем данные с типом строки, нам нужно изменить входящие в лямбда функцию параметры.
Для того чтобы не включать в строку ответа первый элемент два раза, нам нужно использовать метод next(), который сдвигает итератор на шаг вперёд, чтобы функция accumulate 
начинала работу со второго элемента.

int arr[] = { 2,3,4,5,6,7 }; 

auto res = accumulate(next(begin(arr)), end(arr), to_string(arr[0]), [](string a, int b) { 	//Кастомный алгоритм
	return a + "+" + to_string(b);
});

cout << res << endl;										//res = "2+3+4+5+6+7"



______________________________________________________________________________________
STL equal и mismatch | Сравнение массивов

Алгоритмы STL могут работать с различными контейнерами, также и с двумя различными контейнерами в одном алгоритме одновременно, например сравнивать элементы массива и вектора 
или вектора и листа и т.д. Сравнение идёт по элементно. Т.е. если даже сумма двух коллекций равна, но значения элементов отличаются, то коллекции считаются разными.

#include <algorithm> //Для работы с алгоритмами STL

equal - сравнение двух контейнеров через оператор равенства. Если в собственном типе данных не перегружен оператор равенства, то не получится вычислить корректный ответ. Но в 
этом случае вы можете использовать предикат, и указывать конкретно по какому полю нужно сравнить эти две последовательности.

equal(итератор на начало первой коллекции, итератор на конец первой коллекции, итератор на начало второй коллекции, итератор на конец второй коллекции, предикат).

int arr[] = { 10,3,4,5,7,11 }; 
vector<int> arr2 = { 10,3,4,5,7,11 };  

bool res = equal(begin(arr), end(arr), begin(arr2), end(arr2)); //Сравнение двух коллекций.

cout << res << endl;


mismatch - тоже проверяет на равенство две последовательности, тоже может работать с разными типами последовательностями, но работает несколько иначе: По мимо проверки 
последовательностей на равенство, если он нашёл элементы, которые не равны, он ещё и возвращает пару итераторов, которые указывают на эти элементы, т.е. мы ещё можем посмотреть
какие конкретно элементы не равны. Если коллекции равны, то в ответе вернётся пара итераторов, указывающих на концы своих коллекций (end).

mismatch(итератор на начало первой коллекции, итератор на конец первой коллекции, итератор на начало второй коллекции, итератор на конец второй коллекции).

int arr[] = { 10,3,4,5,7,11 }; 
vector<int> arr2 = { 10,3,4,5,7,11 }; 

auto res = mismatch(begin(arr), end(arr), begin(arr2), end(arr2));

if (res.first == end(arr) && res.second == end(arr2))						//Если коллекции равны
	cout << "+" << endl;
else {												//если коллекции не равны
	cout << "-" << endl;
	cout << "result.first:\t" << *res.first << "\t result.second:\t" << *res.second << endl;
}



______________________________________________________________________________________
std equal predicate

Мы можем использовать вместе с алгоритмом equal бинарный предикат. Если в классе не переопределён опереатор сравнения, мы всё ровно можем сравнить объекты классов, используя
лямбда функцию и опиывая в ней логику сравнения.

class Point {													//Класс
public:
	Point(int x, int y) {
		this->x = x;
		this->y = y;
	}
	int x, y;
};

int main()
{
	setlocale(LC_ALL, "Russian");

	vector<Point> arr{											//Первая коллекции
		Point(1,3), Point(4,5), Point(5,7)
	};
	vector<Point> arr2{
		Point(1,3), Point(4,5), Point(5,7)								//Вторая коллекция
	};

	bool res = equal(begin(arr), end(arr), begin(arr2), end(arr2), [](const Point &p1, const Point &p2) { 	//Сравнение двух коллекций
		return p1.x == p2.x && p1.y == p2.y;
	});
		
	cout << res << endl;											//Вывод результата

	return 0;
}



______________________________________________________________________________________
Алгоритм for_each

Предназначение алгоритм for_each абслоютно точно такое же, как и у цикла for each. Разница в особенностях использования.

for_each(итератор на начало коллекции, итератор на конец коллекции, функция которая определяет что будет делать алгоритм for_each будет делать).

#include <algorithm> //Подключаем for_each

void Foo(int a) {				//Функция выводит в консоль параметр
	cout << a << endl;
}

int main()
{
    setlocale(LC_ALL, "Russian");
	
	int arr[] = { 1,2,10,55 };
	for_each(begin(arr), end(arr), Foo); 	//for_each преберает все элементы arr и вызывает функцию Foo на каждой итерации, передавая в параметр текущий элемент.
    	
	for (auto a : arr) {			//Тоже самое только через цикл, а не алгоритм.
		Foo(a);
	}
	
	for_each(begin(arr), end(arr), [](int a) { //Тоже самое только через лямбда функцию.
		cout << a << endl;
	});

	return 0;
}


______________________________________________________________________________________
unique

Каким образом мы можем решить задачу удаления ПОСЛЕДОВАТЕЛЬНО повторяющихся элементов, в какой либо коллекции. 

#include <algorithm> 

unique(итератор на начало коллекции, итератор на конец коллекции).

У нас есть массив. Наша задача избавиться от дубликатов, чтобы осталось по одному элементу с уникальным значением.

int arr[] = { 1,2,2,2,5,4,4 };

auto res = unique(begin(arr), end(arr));

for_each(begin(arr), res, [](int a) { 		//Вывод всех уникальных чисел
	cout << a << endl;
});

Размер статического массива мы не можем изменить, поэтому при выполнении этой функции у нас изменятся только их порядок. Т.е. в начале массива у нас будут уникальные числа, а в
конце ненужные не уникальные. Возвращает итератор на начало ненужных чисел. Изменить кол-во элементов таким способом мы можем только с контейнерами STL:

vector<int> v = { 1,2,2,2,5,4,4 };

auto res = unique(begin(v), end(v));
	
v.erase(res, end(v)); 


Алгоритм unique_copy схож с unique, но во отличие от него он позволяет скопировать элементы в новый контейнер:

unique_copy(итератор на начало коллекции, итератор на конец коллекции, коллекция куда копировать значения).

vector<int> v = { 1,2,2,2,5,4,4 };
vector<int> v2;
	
unique_copy(begin(v), end(v), back_inserter(v2)); //Копируем в v2 все уникальные числа.


Коментарии под видео:

Если я не прав исправьте меня.
На самом деле при выполнении алгоритма unique "нужные"(уникальные) элементы копируются вместо "ненужных"(дубли) по очереди в том порядке как они расположены в контейнере. То 
есть "ненужные" элементы не перемещаются в конец контейнера, а просто заменяются на "нужные". То есть "ненужный" хвост контейнера ПОСЛЕ применения unique равен хвосту 
контейнера ДО применения unique. Например, vector<int> v = { 1,2,2,2,4,    4,4,4,8,8,8,5,4,4 } после unique будет выглядеть {1,2,4,8,5, "ненужный" хвост -> 4,4,4,8,8,8,5,4,4}. 
Примерно так же ведет себя алгоритм remove.

но он не подходит усли вам нужно сохранить порядок и не работает если числа идут не последоватьльно, тоесть {2,3,5,2,7,6} - 2йки не пропадут) не работает! нужно что б они 
последоватьльно шли)



______________________________________________________________________________________
Отсортировать массив в случайном порядке | random_shuffle

random_shuffle(итератор на начало коллекции, итератор на конец коллекции).

#include <ctime>
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	setlocale(LC_ALL, "Russian");
	
	int arr[] = { 1,2,3,4,5 };

	srand(time(NULL));

	random_shuffle(begin(arr), end(arr)); 		//Рандомное перемешивание элементов в коллекции.

	for (auto el : arr)
	{
		cout << el << " ";
	}

	return 0;
}


Рандомный порядок вызова переопределённого метода классов:

class IAction {						//Виртуальный класс
public:
	virtual void Action() = 0;
};

class CatAction : public IAction {			//Переопределение виртуального метода класса
	virtual void Action() override {
		cout << "Гладим кота" << endl;
	}
};

class TeaAction : public IAction {
	virtual void Action() override {
		cout << "Пьём чай" << endl;
	}
};

class DogAction : public IAction {
	virtual void Action() override {
		cout << "Гуляем с собакой" << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	srand(time(NULL));

	IAction *arr[] = 
	{ 
		&CatAction(),
		&TeaAction(),
		&DogAction()
	};

	random_shuffle(begin(arr), end(arr)); 		//Рандомное перемешивание элементов в коллекции.

	for (auto &el : arr) {
		el->Action();
	}

	return 0;
}


______________________________________________________________________________________
Теория: Различия между set и unordered_set

std::set` и `std::unordered_set` являются контейнерами, предоставляемыми стандартной библиотекой и используемыми для хранения уникальных элементов. Основное различие между этими 
двумя типами контейнеров заключается в их внутреннем устройстве, что влияет на производительность операций вставки, поиска и удаления, а также на порядок хранения элементов.

`std::set`
Реализован на основе сбалансированного двоичного дерева поиска (обычно красно-черное дерево). Это обеспечивает следующие характеристики:

Упорядоченное хранение: Элементы в `std::set` автоматически сортируются по возрастанию (или с использованием предоставленного компаратора), что позволяет легко получить 
отсортированный список элементов.
Время доступа: Операции поиска, вставки и удаления элементов имеют логарифмическую сложность времени `O(log n)`, где `n` — количество элементов в контейнере.
```cpp
#include <iostream>
#include <set>

int main() {
    std::set<int> s;
    s.insert(3);
    s.insert(1);
    s.insert(4);

    // Элементы будут автоматически упорядочены
    for (int x : s) {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
`std::unordered_set`
Реализован на основе хеш-таблицы. Это влечет за собой другие характеристики:

Неупорядоченное хранение: Элементы хранятся в произвольном порядке, что делает невозможным их простую сортировку или последовательный доступ в отсортированном порядке.
Время доступа: В среднем случае операции поиска, вставки и удаления элементов имеют константное время `O(1)`. Однако в худшем случае, например, когда происходит множество коллизий 
хеш-функции, эти операции могут деградировать до `O(n)`.
```cpp
#include <iostream>
#include <unordered_set>

int main() {
    std::unordered_set<int> us;
    us.insert(3);
    us.insert(1);
    us.insert(4);

    // Порядок элементов не гарантирован
    for (int x : us) {
        std::cout << x << " ";
    }
    std::cout << std::endl;

    return 0;
}
```
Выбор между `std::set` и `std::unordered_set` зависит от требований к вашему приложению:

Используйте `std::set`, если вам нужен упорядоченный доступ к элементам или если вы часто выполняете операции, которые зависят от порядка элементов.
Выбирайте `std::unordered_set` для более быстрых операций вставки и поиска, если порядок элементов не имеет значения.


______________________________________________________________________________________
Теория: самый худший случай поиска unordered_set

В `unordered_set`, который основан на хеш-таблице, самый худший случай поиска возникает, когда структура данных деградирует до такой степени, что время поиска становится линейным, 
то есть \(O(n)\), где \(n\) — количество элементов в контейнере. Это происходит по нескольким причинам:

1. Плохая хеш-функция

Играет ключевую роль в распределении элементов по "ведрам" (buckets) в `unordered_set`. Если хеш-функция плохо разрабатывается и генерирует одинаковые или близкие хеш-коды для 
большого количества ключей, элементы начинают накапливаться в очень небольшом числе ведер. Это приводит к тому, что большинство операций поиска, вставки и удаления начинают 
зависеть от числа элементов в самом длинном связном списке, а не от общего количества ведер, что сильно ухудшает производительность.

2. Высокая степень загрузки

Загрузка хеш-таблицы (`load factor`) — это отношение количества элементов в хеш-таблице к количеству ведер. Когда `load factor` становится слишком высоким, вероятность коллизий 
увеличивается, что также приводит к увеличению длины цепочек в каждом ведре. Хотя `unordered_set` автоматически увеличивает количество ведер при увеличении количества элементов, 
в случаях с экстремально высоким `load factor` поиск может деградировать до линейного.

3. Неблагоприятная последовательность вставок

Вставляются данные, которые неудачно распределяются хеш-функцией, даже если сама функция в целом хороша, это может привести к временной деградации производительности. Например, 
последовательная вставка элементов с одинаковым хешем приведет к удлинению одной цепочки.

Представьте `unordered_set`, в котором из-за плохой хеш-функции все элементы попадают в одно ведро. В таком случае, любая операция поиска будет выполняться с временем \(O(n)\), 
так как каждый раз придется просматривать все элементы, хранящиеся в этом ведре.

Для минимизации риска худшего случая в `unordered_set` важно:

Использовать хорошо подобранную хеш-функцию, которая равномерно распределяет значения по ведрам.
Контролировать `load factor` и при необходимости увеличивать количество ведер.
Возможно, рассмотреть альтернативные структуры данных или алгоритмы, если хеш-таблицы не подходят из-за природы данных или операций.




______________________________________________________________________________________
Теория: Всегда ли сложность в деревьях равно log(n)?

Сложность поиска в бинарных деревьях зависит от их структуры и баланса. Логарифмическая сложность поиска, то есть \(O(\log n)\), где \(n\) — количество узлов в дереве, достигается 
в идеально сбалансированных бинарных деревьях. Однако это не всегда так, и различные типы бинарных деревьев могут иметь разные характеристики поиска.

Идеально сбалансированные бинарные деревья
Каждый уровень дерева, кроме возможно последнего, полностью заполнен. Это означает, что количество узлов удваивается с каждым новым уровнем. В таком дереве максимальная глубина 
(или высота) \(h\) равна \(\log_2(n+1)\). Поиск, вставка или удаление элемента в таком дереве имеет временную сложность \(O(\log n)\).

Несбалансированные бинарные деревья
Сложность поиска может деградировать до \(O(n)\) в худшем случае. Это может произойти, например, если элементы добавляются в дерево в уже отсортированном порядке, при котором 
каждый новый узел становится правым ребёнком предыдущего. Такое дерево принимает форму "вытянутого списка", и поиск в нём становится по сути линейным поиском.

Сбалансированные бинарные деревья
Для обеспечения логарифмической сложности поиска независимо от порядка вставки элементов разработаны специальные структуры данных, такие как AVL-деревья и красно-чёрные деревья. 
Эти структуры являются самобалансирующимися, то есть они автоматически поддерживают свою структуру таким образом, чтобы глубина дерева оставалась логарифмической относительно 
количества элементов, что обеспечивает поддержание сложности операций на уровне \(O(\log n)\).

Логарифмическая сложность поиска в бинарных деревьях достигается только в сбалансированных деревьях. В несбалансированных деревьях сложность поиска может увеличиться до линейной. 
Поэтому важно выбирать правильный тип дерева или использовать самобалансирующиеся деревья для задач, где предполагается частое добавление и удаление элементов.



______________________________________________________________________________________
Теория: Каким свойством должен обладать объект, чтобы его можно было добавить в ассоциативные контейнеры в качестве ключа?

Т.к. значения ассоциативных контейнеров хранятся отсортированными, то объект должен реализовывать оператор сравнения < (меньше), а остальные операторы сравнения м.б. выражены через него.

Как из меньше реализовать все остальные операторы?

template <typename T>
bool less(const T& a, const T& b); // Меньше уже реализованно

template <typename T>
bool greater(const T& a, const T& b) { // Реализовываем больше
	return less(b, a);
}

template <typename T>
bool equal(const T& a, const T& b) { // Реализовываем операцию равенства ==
	return !less && !greater;
}


Чтобы объект мог быть в ассоциативном контейнере, он должен быть создаваемым, копируемым или перемещаемым.



______________________________________________________________________________________






