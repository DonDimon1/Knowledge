Шаблоны в C++ — это мощная функция, позволяющая писать общий код, то есть вы можете написать одну функцию или класс, которые могут работать с разными типами данных. Это означает, что 
вам не нужно писать отдельные функции или классы для каждого типа данных, с которым вы хотите работать.

______________________________________________________________________________________
Функции шаблона

Чтобы создать функцию шаблона, вы используете templateключевое слово, за которым следуют параметры типа или заполнители, заключенные в угловые скобки ( < >). Затем вы определяете свою
функцию, как обычно, используя параметры типа для указания универсальных типов. Вот пример простой шаблонной функции, которая принимает два аргумента и возвращает больший из двух:

template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

Чтобы использовать эту функцию, вы можете явно указать параметр типа:

int result = max<int>(10, 20);

Или вы можете позволить компилятору определить тип за вас:

int result = max(10, 20);


______________________________________________________________________________________
Классы шаблонов

Аналогичным образом вы можете создавать классы шаблонов, используя templateключевое слово. Вот пример простого класса шаблона, который представляет пару значений:

template <typename T1, typename T2>
class Pair {
public:
    T1 first;
    T2 second;

    Pair(T1 first, T2 second) : first(first), second(second) {}
};

Чтобы использовать этот класс, вам необходимо указать параметры типа при создании объекта:

Pair<int, std::string> pair(1, "Hello");


______________________________________________________________________________________
Специализация шаблона

Иногда вам может потребоваться особое поведение для определенного типа данных. В этом случае вы можете использовать специализацию шаблона. Например, вы можете специализировать 
Pair класс для определенного типа, например char:

template <>
class Pair<char, char> {
public:
    char first;
    char second;

    Pair(char first, char second) : first(first), second(second) {
        // Special behavior for characters (e.g., convert to uppercase)
        this->first = std::toupper(this->first);
        this->second = std::toupper(this->second);
    }
};

Теперь, когда вы создаете Pair объект с char аргументами шаблона, будет использоваться специализированное поведение:

Pair<char, char> charPair('a', 'b');


Это может быть полезно, если вы хотите оптимизировать поведение или предоставить конкретную реализацию для определенного типа, не влияя на общее поведение шаблона для других типов.

Существует два основных способа специализации шаблона:

Полная специализация. Это происходит, когда вы предоставляете конкретную реализацию для определенного типа или набора типов.

Частичная специализация. Это происходит, когда вы предоставляете более общую реализацию для подмножества типов, соответствующих определенному шаблону или условию.


#####################################
Полная специализация по шаблонам

Полная специализация шаблона позволяет предоставить конкретную реализацию или поведение шаблона при использовании с определенным набором параметров типа.

Чтобы создать полную специализацию шаблона, вам необходимо определить конкретный тип, для которого должна произойти специализация. Синтаксис выглядит следующим образом:

template <> //Indicates that this is a specialization
className<specificType>

Пример:

// Generic template
template <typename T>
class MyContainer {
public:
    void print() {
        std::cout << "Generic container." << std::endl;
    }
};

// Full template specialization for int
template <>
class MyContainer<int> {
public:
    void print() {
        std::cout << "Container for integers." << std::endl;
    }
};

int main() {
    MyContainer<double> d;
    MyContainer<int> i;

    d.print(); // Output: Generic container.
    i.print(); // Output: Container for integers.

    return 0;
}

В этом примере мы определили общий MyContainer класс шаблона вместе с полной специализацией для int типа. Когда мы используем контейнер с типом, вызывается метод int 
специализированной реализации. print Для других типов будет использоваться реализация общего шаблона.


#####################################
Частичная специализация шаблонов

Частичная специализация шаблона — это концепция шаблонов C++, которая позволяет специализировать шаблон для подмножества его возможных аргументов типа. Это особенно полезно, когда вы 
хотите предоставить индивидуальную реализацию для определенной группы типов без необходимости определять отдельные специализации для всех типов в этой группе.

Частичная специализация шаблона достигается путем предоставления специализации шаблона с новым набором параметров шаблона. Этот новый шаблон будет выбран, когда компилятор определит 
типы, соответствующие частичной специализации.

Вот пример кода, демонстрирующий частичную специализацию шаблона:

// Primary template
template <typename T>
struct MyTemplate {
    static const char* name() {
        return "General case";
    }
};

// Partial specialization for pointers
template <typename T>
struct MyTemplate<T*> {
    static const char* name() {
        return "Partial specialization for pointers";
    }
};

// Full specialization for int
template <>
struct MyTemplate<int> {
    static const char* name() {
        return "Full specialization for int";
    }
};

int main() {
    MyTemplate<double> t1; // General case
    MyTemplate<double*> t2; // Partial specialization for pointers
    MyTemplate<int> t3; // Full specialization for int

    std::cout << t1.name() << std::endl;
    std::cout << t2.name() << std::endl;
    std::cout << t3.name() << std::endl;

    return 0;
}

В приведенном выше примере мы определили основной шаблон MyTemplateс одним параметром типа T. Затем мы предоставляем частичную специализацию шаблона для типов указателей, указав 
MyTemplate<T*>. Это означает, что частичная специализация будет выбрана, когда аргумент типа является типом указателя. Наконец, мы обеспечиваем полную специализацию типа, int указав 
MyTemplate<int>. Это будет выбрано, если аргумент типа равен int.

______________________________________________________________________________________
Вариативные шаблоны

Шаблоны с переменным числом аргументов — это функция C++11, позволяющая определять шаблон с переменным количеством аргументов. Это особенно полезно, когда вам нужно написать функцию 
или класс, которые могут принимать разные числа и типы аргументов.

Синтаксис вариативных шаблонов очень прост. Чтобы определить вариативный шаблон, используйте ...обозначение (многоточие):

template <typename... Args>

Это обозначение представляет пакет параметров, который может содержать ноль или более аргументов. Этот пакет параметров можно использовать как список переменных параметров шаблона 
в определении шаблона.

Примеры
Суммирование нескольких аргументов с использованием шаблонов с переменным числом аргументов:

#include <iostream>

// Base case for recursion
template <typename T>
T sum(T t) {
  return t;
}

// Variadic template
template <typename T, typename... Args>
T sum(T t, Args... args) {
  return t + sum(args...);
}

int main() {
  int result = sum(1, 2, 3, 4, 5);  // expands to 1 + 2 + 3 + 4 + 5
  std::cout << "The sum is: " << result << std::endl;

  return 0;
}

Класс кортежа с использованием шаблонов Variadic

template <typename... Types>
class Tuple;

// Base case: empty tuple
template <>
class Tuple<> {};

// Recursive case: Tuple with one or more elements
template <typename Head, typename... Tail>
class Tuple<Head, Tail...> : public Tuple<Tail...> {
 public:
  Tuple(Head head, Tail... tail) : Tuple<Tail...>(tail...), head_(head) {}

  Head head() const { return head_; }

 private:
  Head head_;
};

int main() {
  Tuple<int, float, double> tuple(1, 2.0f, 3.0);
  std::cout << "First element: " << tuple.head() << std::endl;
  return 0;
}

Обратите внимание, что показанные примеры предназначены для образовательных целей и могут быть не самыми эффективными и готовыми к использованию реализациями. В C++17 и более поздних 
версиях появились еще более лаконичные способы обработки шаблонов с переменным числом вариантов, например использование выражений свертки.


______________________________________________________________________________________
Признаки типа

Признаки типа — это набор классов шаблонов в C++, которые помогают получить информацию о свойствах, поведении или характеристиках типа. Их можно найти в <type_traits> заголовочном 
файле. Используя признаки типа, вы можете адаптировать свой код в зависимости от свойств данного типа или даже применять определенные свойства для параметров вашего типа в коде 
шаблона.

Некоторые общие черты типа:

std::is_pointer: Проверяет, является ли данный тип типом указателя.
std::is_arithmetic: Проверяет, является ли данный тип арифметическим типом.
std::is_function: Проверяет, является ли данный тип типом функции.
std::decay: применяет правила decltype к входному типу (удаляет ссылки, cv-квалификаторы и т. д.).

Применение

#include <iostream>
#include <type_traits>

int main() {
    int a;
    int* a_ptr = &a;

    std::cout << "Is 'a' a pointer? " << std::boolalpha << std::is_pointer<decltype(a)>::value << std::endl;
    std::cout << "Is 'a_ptr' a pointer? " << std::boolalpha << std::is_pointer<decltype(a_ptr)>::value << std::endl;

    return 0;
}

Составление типовых черт
Некоторые черты типа помогают вам составить другие черты или изменить их, например:

std::conditional: Если данное логическое значение истинно, используйте тип A; в противном случае используйте тип B.
std::enable_if: Если данное логическое значение истинно, используйте тип A; в противном случае вложенный тип отсутствует.

Пример:

#include <iostream>
#include <type_traits>

template <typename T>
typename std::enable_if<std::is_arithmetic<T>::value, T>::type find_max(T a, T b) {
    return a > b ? a : b;
}

int main() {
    int max = find_max(10, 20);
    std::cout << "Max: " << max << std::endl;

    return 0;
}

В этом примере find_maxфункция шаблона определяется только в том случае, если T имеет арифметический тип (например, int, float, double). Это предотвращает непреднамеренное 
использование функции find_maxс неарифметическими типами. В целом, признаки типов — это мощный инструмент для создания более универсального, расширяемого и эффективного кода C++, 
предоставляющий возможность запрашивать и адаптировать ваш код на основе характеристик типа.


______________________________________________________________________________________
SFINAE (Отказ от замены не является ошибкой)

SFINAE — это принцип метапрограммирования шаблонов C++, который позволяет компилятору выбирать соответствующую функцию или класс, когда конкретная специализация шаблона терпит неудачу
во время замены. Термин «ошибка замены» относится к процессу, в котором компилятор пытается заменить аргументы шаблона в шаблон функции или шаблон класса. Если замена вызывает ошибку,
компилятор не будет рассматривать эту конкретную специализацию как кандидата и продолжит поиск допустимой.

Ключевая идея SFINAE заключается в том, что если возникает ошибка замены, она молча игнорируется, и компилятор продолжает исследовать другие специализации или перегрузки шаблона. Это 
позволяет вам писать более гибкий и универсальный код, поскольку позволяет иметь несколько специализаций для разных сценариев.

Пример кода
Вот пример, демонстрирующий SFINAE в действии:

#include <iostream>
#include <type_traits>

template <typename T, typename = void>
struct foo_impl {
    void operator()(T t) {
        std::cout << "Called when T is not arithmetic" << std::endl;
    }
};

template <typename T>
struct foo_impl<T, std::enable_if_t<std::is_arithmetic<T>::value>> {
    void operator()(T t) {
        std::cout << "Called when T is arithmetic" << std::endl;
    }
};

template <typename T>
void foo(T t) {
    foo_impl<T>()(t);
}

int main() {
    int a = 5;
    foo(a); // output: Called when T is arithmetic

    std::string s = "example";
    foo(s); // output: Called when T is not arithmetic
}


В этом примере мы определяем две foo_impl специализированные функции на основе логического значения std::is_arithmetic<T>. Первый активируется, если T это арифметический тип, а второй
активен, если T не является арифметическим типом. Затем функция foo вызывает соответствующую foo_implспециализацию на основе результата признака типа.

При вызове foo(a) целого числа выбирается первая специализация, а при вызове foo(s) строки — вторая специализация. Если действующей специализации нет, код не сможет скомпилироваться.






















