Шаблоны в C++ — это мощная функция, позволяющая писать общий код, то есть вы можете написать одну функцию или класс, которые могут работать с разными типами данных. Это означает, что 
вам не нужно писать отдельные функции или классы для каждого типа данных, с которым вы хотите работать.

______________________________________________________________________________________
Идея шаблонов и базовые примеры

template <typename T> и template <class T> это одно и тоже кроме возможно одного заковырестого случая. По кодстайлу шаблонные параметры называть с большой буквы.

1) Шаблон функции:

Чтобы создать функцию шаблона, вы используете ключевое слово template, за которым следуют параметры типа или заполнители, заключенные в угловые скобки <>. Затем вы определяете свою
функцию, как обычно, используя параметры типа для указания универсальных типов.

template <typename T>
void swap(T& x, T& y){
	T t = x;
	x = y;
	y = t;
}


Вот пример простой шаблонной функции, которая принимает два аргумента и возвращает больший из двух:

template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

Чтобы использовать эту функцию, вы можете явно указать параметр типа:

int result = max<int>(10, 20);

Или вы можете позволить компилятору определить тип за вас:

int result = max(10, 20);



2) Шаблонный класс:

template <typename T>
class vector {
   	T* arr;
	size_t sz;
	size_t cap;
};

Аналогичным образом вы можете создавать классы шаблонов, используя ключевое слово template. Вот пример простого класса шаблона, который представляет пару значений:

template <typename T1, typename T2>
class Pair {
public:
    T1 first;
    T2 second;

    Pair(T1 first, T2 second) : first(first), second(second) {}
};

Чтобы использовать этот класс, вам необходимо указать параметры типа при создании объекта:

Pair<int, std::string> pair(1, "Hello");



3) Шаблонный using (C++11)
Например у нас есть очень длинный тип, и мы хотим для любого T определить алиас этоготипа (другое название).

template <typename T>
using mymap = std::map<T, T, std::greater<T>>; 	// std::greater - компоратор, который сравнивает на больше
mymap<T> m;


4) Шаблонные переменные (C++14)
Для произвольного типа T можно определить переменную или константу, которая для разных T будет значить разное.


##################################
При указании разных типов будет CE
template <typename T>
void swap(T& x, T& y){
	T t = x;
	x = y;
	y = t;
}

int main() {
	int a = 0;	
	long b = 1;
	swap(a, b); // CE, компилятор не понимает что в качестве T int, или long?
}


Тут не применяется правило что типо конверсия long в int хуже чем конверсия int в long. Сначала компилятору нужно решить для каких T ему сгенирировать версию swap, для разных
типов код асемблера будет разный. 

Шаблоны это кодогенерация, нужно воспринимать шаблоны не как готовый код, а как такой паттерн, по которому компилятор должен сгенирировать код. Т.е. функция swap это не 
реальный код, а паттерн по которому компилятор в дальнейшем будет генирировать код для разных типов T. То для каких T компилятору сгенирировать swap, это вопрос первой 
стадии компиляции, которая выполняется до всех, которые мы обсуждали ранее, до перегрузки, до выбора имён (т.е. это не препроцессинг). 

Можно подсказать компилятору какую версию генирировать, указав шаблонный аргумент T явно:

template <typename T>
void swap(T x, T y){
	T t = x;
	x = y;
	y = t;
}

int a = 0;
long long b = 1;
swap<long long>(a, b);


Когда мы имеем дело с классами, нам обычно нужно явно указывать шаблонный аргумент, например: vector<int> v, в качестве T мы ставим int. Для всякого T генирируется свой
класс. Если мы сделаем 5 векторов например от int, double, char, float, string, это всё 5 разных классов, компилятор просто накопипастит код вектора 5 раз. 


______________________________________________________
Перегрузка шаблонных функций

template <typename T>	// У нас есть шаблонная функция
void f(T x){}

void f(int x) {}	// А также её перегрузка с типом int

int main() {
	int x = 0;
	f(x);		// Что выберется? 
}

Ответ: выберется вторая версия с типом int. Почему мы хотим, чтобы это работало именно так? Здесь работает правило частоное лучше общего. Если у нас есть инструкция как 
действовать в общем случае, а ещё есть частная инструкция, которая говорит что если случай конкретный действуй иначе, то предпочитается частная инструкция.


На самом деле, генерация шаблонных версий делается не полностью до выбора версии. Если у нас есть выбор между шаблонной версией и нешаблонной, то это решение компилятору 
нужно принять раньше, до того как он начнёт генирировать шаблонную версию. Компилятор понимает что под этот вызов f подходит как шаблонная версия, и он может сгенирировать
T = int, и подходит нешаблонная и он может ничего не генирировать, и просто выбрать версию от int, тогда он предпочтёт второй вариант. Но если частная версия не так хорошо
подходит как общая, то он предпочтёт общую версию T = int.

Есть два правила как действует компилятор:
1) частоное лучше общего
2) но несмотря на это точное соответствие лучше, чем какой нибудь каст.

Т.е. если компилятор способен сгенирировать шаблонную версию так, что там будет идеальное соответсвтие типа, то это лучше чем выбрать частную версию но сделать хоть какое
привидение типа.

template <typename T>	
void f(T x){
	std::cout << 1;
}

void f(long long x) {
	std::cout << 2;
}	

int main() {
	int x = 0;
	f(x);		// Сейчас выберется 1.
}



##########################################
Мы можем указать шаблонный параметр явно:

template <typename T>	
void f(T x){
	std::cout << 1;
}

void f(int x) {
	std::cout << 2;
}	

int main() {
	int x = 0;
	f<int>(x);		// Сейчас выберется 1.
}

Если я явно указываю шаблонный параметр, тем самым я обязываю компилятор выбрать какую то шаблонную версию, даже если есть частная перегрузка с нужным типом.



#################################################
Можем указывать шаблонный аргумент по умолчанию:

template <typename T = int>	
void f(T x){
	std::cout << 1;
}

У нас может быть шаблонный аргумент, который если явно не указан, то компилятор должен подставить конкретный (в нашем случае int).

По переданным аргументам в функцию компилятор иногда может сам понять, что за тип ему передали без явного указания. Когда я указываю шаблонные аргументы при вызове функции, 
я могу указывать не все, он применяет только те, которые я указал первые по списку, а остальные пытается вывести сам.
Например:

template <typename U, typename T>	
U f(T x){
	std::cout << 1;
	return x;
}

void f(int x) {
	std::cout << 2;
}

int main() {
	int x = 0;
	int g = f<int>(x);	// Говорим что <int> это тип U, а x с типом int это тип T x в функции f.
}

Мы указываем что в функции f typename U это тип int, т.е. в функции f возвращаемый тип это int. Какой тип T он должен угадать сам, и он сможет догадаться, поскольку T это 
переданный аргумент, с уже заданным типом. Но вот если мы поменяем U и T местами, тогда это уже CE, поскольку он не может догадаться какой теперь возвращаемый тип:

template <typename T, typename U>	
U f(T x){				// U непонятно какой тип
	std::cout << 1;
	return x;
}

void f(int x) {
	std::cout << 2;
}

int main() {
	int x = 0;
	int g = f<int>(x);		// CE
}



########################
 1) Какая функция вызовется?

template <typename T>
void f(T& x) {		// Аргумент по ссылке
	std::cout << 1;
}


template <typename T>
void f(T x) {		// Аргумент по значению
	std::cout << 2;
}

int main() {
	int x = 0;
	f(x);		// Вызываем функцию от int x = 0;
}


Ответ: Будет CE, call of overloaded f(int&) is ambiguous.

 2) А вот если мы вызовем функцию с rvalue, то тогда выберется второй вариант.

int main() {
	int x = 0;
	f(1);		// Вывод в консоль 2.
}


 3) А если мы вызовем функцию с константой, тогда будет CE, обе версии одинаково подходят:

template <typename T>
void f(const T& x) {		// Константный аргумент по ссылке
	std::cout << 1;
}

template <typename T>
void f(T x) {			// Аргумент по значению
	std::cout << 2;
}

int main() {
	int x = 0;
	f(1);			// CE
}


 4) Можно принять 1 как в качестве константной ссылки, так и в качестве просто значения, и одно не лучше другого. Анологично CE и в следующем примере:

template <typename T>
void f(const T& x) {		// Константный аргумент по ссылке
	std::cout << 1;
}


template <typename T>
void f(T& x) {			// Аргумент по значению
	std::cout << 2;
}

int main() {
	f(1);			// CE
}


______________________________________________________________________________________
Специализация шаблонов классов Template specializations.

Иногда вам может потребоваться особое поведение для определенного типа данных. В этом случае вы можете использовать специализацию шаблона. Это может быть полезно, если вы хотите 
оптимизировать поведение или предоставить конкретную реализацию для определенного типа, не влияя на общее поведение шаблона для других типов.

Представим что мы реализуем шаблонный класс (например вектор). Всё хорошо, но мы хотим чтобы для какого то конкретного T этот класс был не таким, как для всех остальных,
например чтобы вектор bool был не таким как всё остальное, а именно чтобы вектор bool хранил не массив bool, а массив char, но при этом в нём когда мы записываем элемент,
он менял соответствующий бит в массиве, а не целый байт. Мы можем это добиться путём специализации шаблона.


Существует два основных способа специализации шаблона:

1) Полная специализация. Это происходит, когда вы предоставляете конкретную реализацию для определенного типа или набора типов.

2) Частичная специализация. Это происходит, когда вы предоставляете более общую реализацию для подмножества типов, соответствующих определенному шаблону или условию.


#####################################
Полная специализация класса (Full specializations):

Полная специализация шаблона позволяет предоставить конкретную реализацию или поведение шаблона при использовании с определенным набором параметров типа.

Чтобы создать полную специализацию шаблона, вам необходимо определить конкретный тип, для которого должна произойти специализация. Синтаксис выглядит следующим образом:

template <> 			//Indicates that this is a specialization
className<specificType>

Пример 1):

template <typename T>						// Общий шаблонный класс
class MyContainer {
public:
    void print() {
        std::cout << "Generic container." << std::endl;
    }
};

template <>							// Полная специализация класса для типа int
class MyContainer<int> {
public:
    void print() {
        std::cout << "Container for integers." << std::endl;
    }
};

int main() {
    MyContainer<double> d;
    MyContainer<int> i;

    d.print(); // Output: Generic container.
    i.print(); // Output: Container for integers.

    return 0;
}

В этом примере мы определили общий MyContainer класс шаблона вместе с полной специализацией для int типа. Когда мы используем контейнер с типом, вызывается метод int 
специализированной реализации. print Для других типов будет использоваться реализация общего шаблона.

Пример 2):

template <typename T>	// Общий шаблонный класс
class vector {
	T* arr;
	size sz;
	size_t cap;
};

template <>		// Полная специализация класса 
class vector<bool> {
	char* arr;
	size_t sz;
	size_t cap;
}

Т.е. для каких то типов, в нашем случае bool, делаем класс иным, нежели для всех остальных типов.
В угловых скобочках я перечисляю фиксированные аргументы. Они могут быть не конкретными. Т.е. у нас могут быть шаблон от двух аргументов, и мы можем отдельно определить
шаблон от одного аргумента, если эти аргументы одинаковые.



#####################################
Частичная специализация (Partial specialization):

Частичная специализация шаблона — это концепция шаблонов C++, которая позволяет специализировать шаблон для подмножества его возможных аргументов типа. Это особенно полезно, когда вы 
хотите предоставить индивидуальную реализацию для определенной группы типов без необходимости определять отдельные специализации для всех типов в этой группе.

Частичная специализация шаблона достигается путем предоставления специализации шаблона с новым набором параметров шаблона. Этот новый шаблон будет выбран, когда компилятор определит 
типы, соответствующие частичной специализации.

Пример 1) Вот пример кода, демонстрирующий частичную специализацию шаблона:

template <typename T>					// Primary template
struct MyTemplate {
    static const char* name() {
        return "General case";
    }
};


template <typename T>					// Partial specialization for pointers
struct MyTemplate<T*> {
    static const char* name() {
        return "Partial specialization for pointers";
    }
};

template <>						// Full specialization for int
struct MyTemplate<int> {
    static const char* name() {
        return "Full specialization for int";
    }
};

int main() {
    MyTemplate<double> t1; 				// General case
    MyTemplate<double*> t2; 				// Partial specialization for pointers
    MyTemplate<int> t3; 				// Full specialization for int

    std::cout << t1.name() << std::endl;
    std::cout << t2.name() << std::endl;
    std::cout << t3.name() << std::endl;

    return 0;
}

В приведенном выше примере мы определили основной шаблон MyTemplate с одним параметром типа T. Затем мы предоставляем частичную специализацию шаблона для типов указателей, указав 
MyTemplate<T*>. Это означает, что частичная специализация будет выбрана, когда аргумент типа является типом указателя. Наконец, мы обеспечиваем полную специализацию типа, int указав 
MyTemplate<int>. Это будет выбрано, если аргумент типа равен int.


Пример 2):

template <typename T, typename U>	// Общий вариант
struct S {};

// Частичная специализация 
template <typename T>			// В этом префиксе шаблонов я перечисляю те аргументы, которые мне здесь пригодятся для объяснения того, какую специализацию я хочу объявить.
struct S<T, T> {};			// Здесь в <> я описываю метасигнатуру, которая является частным случаем класса выше.

В данном случае мы видим пример частичной специализации. Для любых T и U, S определена общим вариантом, но для любого T, если первый аргумент равен второму, S определена иначе.
Можно написать по разному, например:

template <typename T>	
struct S<int, T> {};	// Для любого T структура с первым аргументом int, определена иначе



Мы можем сделать несколько частичных специализаций:

template <typename T, typename U>	
struct S {};

template <typename T>
struct S <int, T>{};

template <typename T>
struct S <T, int>{};

int main() {
	S<int, int> s;	// CE, ambigous template instantiation (неоднозначаное инстанцированние шаблона)
}

Инстанцированние - это начальная генерации шаблона. 

Компилятору непонятно int подставить в качестве первого аргумента подставить, или в качестве второго. Однако если бы мы имели полную специализацию, без каких либо параметров 
просто от двух int, то компилятор бы предпочёл её:

template <>
struct S <int, int>{};


Так же частичную специализацию можно написать вот так:

template <typename T>	// Обычная версия
struct S {};

template <typename T>	// Для всех типов, являющиеся ссылками сделаем свою версию.
struct S<T&> {};

template <typename T>	// От константного T это третья версия
struct S<const T> {};



#############
Итог:

Полная специализация, это когда template <> мы пишем с пустыми угловыми скобочками, тем самым мы говорим что мы хотим определить частный случай этого шаблона для некоторых
конкретных наборов аргументов, без использования всяких метапеременных T и прочее. Проще говоря реализация шаблона для конкретного типа данных.

Частичная специализация, это когда мы пишем (template), и дальше в угловых скобочках чтото пишем (<typename T>), но потом объявляем класс который уже был выше (struct S),
и просто в угловые скобочки ставим чтото более частное (<int, T>). Частичная специализация повзоляет уточнить поведение шаблона для подмножества типов, но при этом сохранить общую 
реализацию для других случаев. Это полезно, когда нужно специализированное поведение для определённых шаблонных параметров, но не для конкретного типа, как в полной специализации.



______________________________________________________
Специализация шаблонов функций Template specializations.

Представим две шаблонные функции, с одним и двумя разными аргументами. Какая версия выберется?

template <typename T, typename U>	// Версия 1
void f(T, U){
	std::cout << 1:
}

template <typename T>			// Версия 2
void f(T, T){
	std::cout << 2:
}

int main() {
	f(0, 0);			// Вызываемся от двух int
}

Вторая версия более частная чем первая, всё что подходит во вторую версию подходит и в первую, а обратно так не работает. Поэтому в данном случае выбирается вторая версия.


Добавим полную специализацию которая принимает 2 int:

template <typename T, typename U>	// Версия 1
void f(T, U){
	std::cout << 1:
}

template <>				// Версия 3
void f(int, int){
	std::cout << 3:
}

template <typename T>			// Версия 2
void f(T, T){
	std::cout << 2:
}

int main() {
	f(0, 0);			// Вызываемся от двух int
}

В консоль всё ровно выведется 2. Но если мы переставим определение от (int, int) ниже, то:

template <typename T, typename U>	// Версия 1
void f(T, U){
	std::cout << 1:
}

template <typename T>			// Версия 2
void f(T, T){
	std::cout << 2:
}

template <>				// Версия 3
void f(int, int){
	std::cout << 3:
}

int main() {
	f(0, 0);			// Вызываемся от двух int
}

Теперь выведется 3. (Я так полагаю из-за перегрузки функций)



У нас бывает перегрузка функций, а бывает специализация шаблонных функций, и это разные вещи. Для функций, в отличие от классов, существует перегрузка, нельзя переопределить
структуру, с другим количеством шаблонных параметров, а функцию можно. 

void f(T, U){
	std::cout << 1:			// Функция с 2 шаблонными параметрами 			(номер 1)
}

template <typename T>			// Функция с 1 шаблонным параметром			(номер 2)
void f(T, T){
	std::cout << 2:
}

template <>				// Частный случай функции с 1 шаблонным параметром	(номер 3)
void f(int, int){
	std::cout << 3:
}

void f(int, int ){			// Нешаблонная функция					(номер 4)
	std::cout << 4;			
}

int main() {
	f(0, 0);			// Вызываемся от двух int
}

Здесь у нас есть 3 разных версии перегрузки функции f, у одной из которых есть ещё специализация. В данном случае выведется 4, потому что есть шаблонная версия номер 1, есть 
шаблонная версия номер 2, есть обычная версия номер 4 (нешаблонная), а у шаблонной версии номер 2 есть частный случай номер 3. Когда компилятор решает какую версию функции 
ему выбрать, он сначала смотрит на версии перегрузки, а перегрузки здесь 3 (1, 2 и 4). Но у некоторых из них могут быть специализации, в нашем случае у 2 есть специализация, под
номером 3. Тем немение, компилятор, сначало выбирает между версиями перегрузки, какая более предпочтительна, а потом, уже после того как он выбрал версию перегрузки, он 
решает нет ли у неё подходящей специализации.

Сначала у нас делается перегрузка между шаблонами, потом в выбранный шаблон подставляются аргументы, и генирируются нужные версии, потом делается перегрузка между тем, что 
получилось.

Для функцию несуществует понятия частичная специализация, есть только полная специализация, поскольку частичная специализация лишена смысла, так как у функции есть перегрузки.



Под какой функцией мы пишем специализацию, к той функции и будет привязана специализация:

Пример 1:

void f(T, U){
	std::cout << 1:			// Функция с 2 шаблонными параметрами 			(номер 1)
}

template <>				// Специализация функции, написанной над нами (специализация функции номер 1)
void f(int, int){
	std::cout << 3:
}

template <typename T>			// Функция с 1 шаблонным параметром			(номер 2)
void f(T, T){
	std::cout << 2:
}


Пример 2:

void f(T, U){
	std::cout << 1:			// Функция с 2 шаблонными параметрами 			(номер 1)
}

template <typename T>			// Функция с 1 шаблонным параметром			(номер 2)
void f(T, T){
	std::cout << 2:
}

template <>				// Специализация функции, написанной над нами (специализация функции номер 2)
void f(int, int){
	std::cout << 3:
}



______________________________________________________
NTTP 	(Non-type template parameters)

Не только типы могут быть параметрами шаблона, а ещё и числа. Мы можем сделать параметром шаблона число.

#include <array> 			// Массив фиксированного размера

int main() {
	std::array<int, 100> a;		// Здесь 100 это параметр шаблона, но он является числом а не типом (Non-type парметр)
}

Как такое объявлять?

template <typename T, size_t N>
class array {
	T arr[N];
};

int main() {
	std::array<int, 100> a;
}



#######################
Матрица 

template <size_t M, size_t N, typename Field = Rational> 	// Матрица над полем из M строк, N столбцов
class Matrix {};						// Rational это класс рациональных произвольной точности

template <size_t N, typename Field = Rational> 			// Тип квадратная матрица
using SquareMatrix = Matrix<N, N, Field>			// матрица с параметром N на N

int main() {
	std::array<int, 100> a;
	Matrix<5, 5> m;
	SquareMatrix<5> sm;
}

Здесь очень удобно что, эти числа являются параметрами типа, т.е. матрица 4 на 3 и матрица 3 на 4 это разные типы, и они друг с другом с точки зрения кодогенерации никак не 
связаны.

Определим умножение разных матриц. Нам нужно сделать так, что только лишь матрицы соответствующих размеров можно перемножать над одним и тем же полем, а если мы попытаемся 
умножить матрицы несоответствующих размеров то будет CE, потому что компилятор не сможет вывести шаблонные параметры.

template <size_t M, size_t K, size_t N, typename Field>
Matrix<M, N, Field> operator*(const Matrix<M, K, Field>& a, const Matrix<K, N, Field>& b);

Таким образом у классов могут быть числовые параметры, однако эти параметры должны быть известны на этапе компиляции. Например, вот так нельзя делать:

int main(){
	int x = 5;
	Matrix<x, x> m;	// CE
}

Здесь переменная x не является константой, которой можно подставить в шаблон (с const сработает).



#####################
constexpr (C++11)

constexpr означает не просто константу, а константу, известную на этапе компиляции. В шаблоны мы должны передавать именно такие константы.

constexpr int x = 5; 


______________________________________________________
template template parameters

Параметры шаблонов бывают типами (typename), бывают целочисленными (size_t, int и все его вариации, bool, char), а так же бывает третий вид шаблонных параметров: параметры шаблонов
которые сами являются шаблонами.

Например я хочу реализовать стек. Стек будет состоять из какого то типа, и я стек реализую как обёртку над каким то контейнером. Например std stack по сути в себе хранит дек или 
вектор. Так вот мы тоже можем параметром стека сделать вид шаблонного контейнера, который мы хотим принять в качетсве параметра. Т.е. мы можем сделать стек на векторе или стек на 
деке или стек на листе. Для этого можно написать:

template <typename T, template<typename> class Container>
class Stack {
	Container<T> container;
};

Здесь мы написали что вторым параметром шаблона является контейнер, но контейнер это не конкретный тип, это другой шаблон, у которого есть свои шаблонные параметры:
, template - означает что вторым параметром мы передали другой шаблон, дальше открывается угловая скобочка <typename> и перечесляются виды шаблонных параметров(метатипы).

Вот здесь есть одна тонкость, в которой слова template и class имеют разный смысл в упоминании шаблонных параметров: Когда я объявляю параметр шаблонна, который сам является
шаблоном вот здесь может быть важно написать class или typename. До C++17 здесь нужно было писать именно class, начиная с C++17 здесь тоже не важно что писать class или typename.

Здесь Container это не тип, а шаблон, и сам по себе Container это непонятно что, но в Container можно передавать шаблонные параметры. Т.е. Container это некоторый шаблон, с 
шаблонным параметром один тип, и вот его уже можно параметризовать типом уже внутри тела класса.

Мы можем установить его по умолчанию. Однако на самом деле у вектора 2 шаблонных аргумента, второй аргумент по умолчанию это алокатор, и он всегда по умолчанию равен std::allocator 
от T. Он есть у каждого контейнера. Поэтому если мы хотим сделать std::vector пенредать в качестве шаблона, то нам нужно указать 2 шаблонных параметра

template <typename T, template<typename, typename> class Container = std::vector>
class Stack {
	Container<T, std::allocator<T>> container;
};

int main(){
	Stack<int, std::vector> s;
};


______________________________________________________
Вычисление в компалтайме (Basic compile time computations)

Допустим я хочу узнать чему равно 20-ое число Фибоначи:
Мы просим компилятор рекурсивно инстанцировать шаблон шаг за шагом, но у компилятора есть встроенный лимит на глубину шаблонной рекурсии. Т.е. когда он инстанцирует шаблон, ему 
потребовалось инстанцировать другой шаблон, и так шаг за шагом. По умолчинию стоит лимит глубины и если он привышает то получается fatal error. Например: 

template <int N>
struct Fibonacci {
	static constexpr int value = Fibonacci<N-1>::value + Fibonacci<N-2>::value;		// CE
};

int main() {
	std::cout << Fibonacci<20>::value;
}

Для того чтобы это пофиксить нужно написать специализацию:

template <int N>
struct Fibonacci {
	static constexpr int value = Fibonacci<N-1>::value + Fibonacci<N-2>::value;
};

template <>
struct Fibonacci<1> {
	static constexpr int value = 1;
};

template <>
struct Fibonacci<0> {
	static constexpr int value = 0;
};

int main() {
	std::cout << Fibonacci<20>::value;
}

За какую асимптотику это отрабатывает? За линейную. Потому что единожды сгенирировав реализацию для какого то N он потом не генирирует её вторично. В реальности оказалось
сгенирировано 21 класс, поскольку Фибоначи от 0 и от 1 это всё разные типы. Компилятор их всех сгенирировал, и они все единожды были сгенирированы.


#################
2-ое упражнение. Как проверить в компайлтайме является ли число простым за линейное время?

template<int N, int D>
struct IsPrimeHelper {
	static constexpr bool value = N % D == 0 ? false : IsPrimeHelper<N, D-1>::value;
};


template<int N>
struct IsPrimeHelper<N, 1> {
	static constexpr bool value = true;
};

template <int N>
struct IsPrime {
	static constexpr bool value = IsPrimeHelper<aN, N-1>::value;
};

template <>
struct IsPrime<1> {
	static constexpr bool value = false;
};

int main() {
	std::cout << IsPrime<257>::value;
}



Дополнения:
1) Мы можем объявлять шаблонные переменные:

...

template <int N>					// Объявляем шаблонную переменную
const bool is_prime = IsPrime<N>::value;

int main() {
	std::cout << is_prime;				// Обращение к структуре с помощью is_prime без ::value
}

Можно сказать что это метафункция: она принимает int в угловых скобочках а не круглых, и это возвращает мне true или false, смотря какой int я передал и всё это делается в 
компайл тайме.


2) Существует такое ключевое слово static_assert. Есть просто assert, это функция которая падает в рантайме (она вызывает std::abort если условие ложно). static_assert это
функция, которая кидает CE если ей передали false, но ей тоже нужно передать константу времени компиляции.

int main() {
	static_assert(is_prime<257>);			// Вызываем CE если это false.
}

Смысл в том, что например, если матрица неквадратная, нельзя будет вызвать её определитель.



______________________________________________________
Зависимые имена (Dependent name)

Рассмотрим такой пример:

template <typename T>
struct S {
	using A = int;		// Публичный using
};

template <typename T>
void f(){
	S<T>::A* x;		// Из струткуры S достаём тип A
}

int main(){
	f<int>();
}

Здесь будет CE. Объяснение: допишем в код специализацию:

template <typename T>
struct S {
	using A = int;		// A обозначает тип int 
};

template <>			// Добавим специализацию
struct S<double> {
	static const int A = 5; // A обозначает переменную типа int 
}

int x = 0;

template <typename T>
void f(){
	S<T>::A* x;		// Неопределённость declaration or expression???
}

Здесь есть проблема, мой шаблонный класс может иметь специализацию и в одной из версии шаблона имя может обозначать тип, а в другой версии шаблона имя может обозначать 
переменную. И вот компилятор пытается скомпилировтаь шаблонную функцию f, которая обращается к шаблонной структуре S, и в ней к сущности под названием A и видит строчку:
S<T>::A* x; С одной стороны это может быть int* x и это дикларейшен, с другой стороны это может быть 5 * x и это экспрешен, в зависимости от T. В данном случае A это зависимое
имя, то чем является A зависит от T, но T это шаблонный параметр, компилятор до подстановки T не может понять что это за конструкция. Поэтому компилятор хочет на стадии 
семантического парсинга, до подстановки всяких T, понять что это за конструкция. Поэтому в стандарте введено следующее правило: во всех таких ситуациях компилятор считает по
умолчанию что это экспрешен. Т.е. все зависимые имена по умолчанию парсятся как выражения, а не как названия типов.

Если закоментировать строчку int x = 0; то такой код даст CE по причине x was not declared in this scope.

Что нужно сделать чтобы компилятор это воспринял как тип а не как имя: Нужно написать typename перед зависимым именем:

template <typename T>
void f(){
	typename S<T>::A* x;		// Неопределённость declaration or expression???
}

Нельзя чтобы в зависимости от T это было то declaration то expression, язык это запрещает.

Но если мы теперь вызовем f<double> то это будет CE  

int main(){
	f<int>();
	f<double>(); // CE no type named A in struct S<double>
}



####################

Что тут теперь написано?

#include <array>

template <typename T>
struct S {
	template <int N>
	using A = std::array<int, N>;	
};

template <>			
struct S<double> {
	static const int A = 5;
}

template <typename T>
void f() {
	typename S<T>::A<10> x;		
}

int main() {
	f<int>();
}

Данный случай можно распарсить как экспрешен A < 10 > x (A меньше 10 больше x). Правда если стоит typename это нельзя так распарсить, однако если бы написали вот так:
typename S<T>::A() <10> x; то это можно было бы распарсить даже если там стоит typename.

Особая боль ситуации заключается в том что слово typename недостаточно здесь, потому что когда мы пишем typename он считает что это название типа, но он всё ещё не считает что
это название шаблона. Слово typename заставляет компилятор думать что это название типа но не шаблона. И чтобы он считал это названием шаблона нужно дописать template.

typename S<T>::template A<10> x;


2 пример:

template <typename T>
struct S {
	template <int N>
	void foo(int) {}	
};

template <typename T>
void bar(int x, int y) {
	S<T> s;
	s.foo<S>(x + y);	// парситься неоднозначно экспрешен или шаблонная функция???
}

int main() {
	bar<int>(2, 3);
}

Строка s.foo < S >(x + y); означает что я взял переменную foo сравнил её с 5, а потом полученный результат сравнил с суммой x + y 
ИЛИ
строка s.foo<S>(x + y); означчает что я вызвал шаблонную функцию с шаблонным параметром 5 от x + y ???

s.foo это может быть переменная а не функция. Это будет эксперешен но у этого будет разный смысл. В данном случае здесь уже никак не обойтись без template:

s.template foo<S>(x + y);	// Это будет компилироваться



##############
Что здесь не так? В чём проблема этого кода?

template <typename T>
struct Base {
	int x = 0;
};

template <>
struct Base<double> {
};

template <typename T>
struct Derived: Base<T> {
	void f() {
		++x;
	}
};

int main(){}

Непонятно что такое x. В зависимости от T, x может то присутствовать то отсутствовать, а может это вообще быть тип, или функция. Когда мы говорим ++x компилятор не понимает что
мы ему говорим, поскольку компилятор не залезает в шаблонного родителя, чтобы посмотреть, что это такое. Это можно починить следующим образом:

++this->x; 

Если мы хотим обратиться к полю шаблонного родителя из наследника, то нам нужно явно указывать this. Так же можно явно указать родителя: ++Base<T>::x;


Компиляция это сложный многостадийный процесс. Есть так называемая Two face translation. Это такой термин, применимый к шаблоном, когда компилятор компилирует шаблоный код, он
это делает в два прохода. Первый проход до того как мы подставили T, второй проход, после того как мы подставили T. До того как мы подставиил T, мы смотрим на синтаксис, на
базовые симантические проверки, на имена независимые от T, но мы не можем полностью проверить всю корректность кода, с точки зрения компиляции, до тех пор, пока T не подставили.
Тем не менее при первом проходе нужно до какой то степени проверить корректнось, чтобы часть ошибок отловить на первой стадии. Но вот вторая стадия, когда мы подставили 
конкретное T, возникают новые ошибки. Именно поэтому когда мы написали например какой нибудь шаблонный контейнер, но пока не использовали его в main(), часть ошибок компиляции
может не найтись, но как только мы инстанцировали в мейне может выпасть ещё куча ошибок компиляции.



______________________________________________________
Metafunctions and type traits.

Шаблоны дают нам возможность писать метафункции. Метафункции это как бы функции от типов. Например можно представить функцию, которая принимает не объекты, а типы и возвращает
их. Простейшая метафункция это проверка равны ли два типа в компайлтайме:

template <typename T, typename U>			// Шаблонная структура
struct is_same {
	static constexpr bool value = false;
};

template <typename T>					// Специализация структуры если T и U одинаковые
struct is_same<T, T> {
	static constexpr bool value = true;
};

// Если типы T и U одинаковые, то выполняется специализация и value становиться true. Если типы T и U разные то выполняется обычный шаблон, и поле value = false;


// Вызов проверки
template <typename T, typename U>			// Просто шаблонная функция
void f(T x, U y) {
	//... 						// Какая то куча действий
	
	// Как нам написать что, Если типы T и U одинаковы то сделай одно, а иначе другое

	// Вариант 1:
	
	/*
	if(typeid(x) == typeid(y)) {} 			// Это работает но это плохо, потому что это рантайм проверка, а нам нужно проверить в компайлтайме. Это безсмысленно,
	*/						// если типы в компайл тайме известны. typeid осмысленны когда у нас x и y полиформны.

	// Вариант 2:
	
	// Мы говорим компилятору что для разных пар T и U, нагенирировал разный код. Когда мы вызываем f от T и U, мы для каждой пары T и U компилятором генерируем свою версию 
	// f. Мы можем сделать так, что в одинх версиях f будет нагенерирован этот код который мы сейчас написали, а в других не будет:
 	
	/*
	if(is_same<T, U>::value) {
		
	}
	*/

	// Однако есть проблема с if. Хоть и условие if(is_same<T, U>::value) известно в компайлтайме, сам этот if всё ровно вычисляться будет в рантайме. Вот чтобы ещё и сам
	// if вычислялся в компайлтайме нужно constexpr прописать после слова if:

	if constexpr (is_same<T, U>::value) {
		x = y;
	}
}

int main() {
	f<int, std::string>(5, "abc");
}

Без constexpr было бы CE. Когда я написал if и поставил какое то условие. В данный момент условие ложно, но код всё ровно компилировать надо, компилятор смотрит и дальше 
компилирует инструкции, это же не важно что это условие можно в компайлтайме проверить, код всё ровно компилировать надо. Так вот constexpr говорит компилятору, что нужно просто
выкинуть этот if из кода и не смотреть на то что внутри него, если это условие ложно, но условие должно быть проверено в компайлтайме. Т.е. если я хочу написать какую то вещь,
которая компилируема только при условии, что выполнено какое то свойство над типами, я могу её обернуть в if constexpr и что находиться под этим if будет компилятором расмотрено
и синтактически распаршено, но семантика того что здесь делается не будет проверена, корректность типов не будет определяться, при условии что if constexpr ложно.


######################
Существует стандарнтая структура сравнения типов C++11:

#include <type_traits>

int main() {
	std::if_same<int, float>;	// Простая мета функция которая по двум типам возвращает bool
}


####################
Бывают метафункции которые по типу возвращают другой тип:

template <typename T>
struct remove_reference {
	using type = T;
};

template <typename T>
struct remove_reference<T&> {
	using type = T;
};

template <typename T>
void f() {
	typename remove_reference<T>::type x;
}


####################
Можно сделать remove_pointer, или remove_const - снимает константность с типа:

template <typename T>
struct remove_const {
	using type = T;
};

template <typename T>
struct remove_const<const T> {
	using type = T;
};

В чём разница между remove_const и const_cast? Это вприницпе разные вещи, мало что общего они имеют между собой.

Аналогично есть функции is_const, is_pointer, is_reference, is_array. Они лежат в заголовочном файле #include <type_traits> C++11

Вот один из type_traits под названием std::conditional

template <bool B, typename T, typename F>
struct conditional {
	using type = F;
};

template <typename T, typename F>
struct conditional <true, T, F>{
	using type = T;
};

Это тернарный оператор только для типов. 


Вывод: не использовать эти структуры в чистом виде, а использовать шаблонные алиасы.


______________________________________________________________________________________
Признаки типа <type_traits>

Признаки типа — это набор классов шаблонов в C++, которые помогают получить информацию о свойствах, поведении или характеристиках типа. Их можно найти в <type_traits> заголовочном 
файле. Используя признаки типа, вы можете адаптировать свой код в зависимости от свойств данного типа или даже применять определенные свойства для параметров вашего типа в коде 
шаблона.

Некоторые общие черты типа:

std::is_pointer: Проверяет, является ли данный тип типом указателя.
std::is_arithmetic: Проверяет, является ли данный тип арифметическим типом.
std::is_function: Проверяет, является ли данный тип типом функции.
std::decay: применяет правила decltype к входному типу (удаляет ссылки, cv-квалификаторы и т. д.).

Применение

#include <iostream>
#include <type_traits>

int main() {
    int a;
    int* a_ptr = &a;

    std::cout << "Is 'a' a pointer? " << std::boolalpha << std::is_pointer<decltype(a)>::value << std::endl;
    std::cout << "Is 'a_ptr' a pointer? " << std::boolalpha << std::is_pointer<decltype(a_ptr)>::value << std::endl;

    return 0;
}

Составление типовых черт
Некоторые черты типа помогают вам составить другие черты или изменить их, например:

std::conditional: Если данное логическое значение истинно, используйте тип A; в противном случае используйте тип B.
std::enable_if: Если данное логическое значение истинно, используйте тип A; в противном случае вложенный тип отсутствует.

Пример:

#include <iostream>
#include <type_traits>

template <typename T>
typename std::enable_if<std::is_arithmetic<T>::value, T>::type find_max(T a, T b) {
    return a > b ? a : b;
}

int main() {
    int max = find_max(10, 20);
    std::cout << "Max: " << max << std::endl;

    return 0;
}

В этом примере find_max функция шаблона определяется только в том случае, если T имеет арифметический тип (например, int, float, double). Это предотвращает непреднамеренное 
использование функции find_maxс неарифметическими типами. В целом, признаки типов — это мощный инструмент для создания более универсального, расширяемого и эффективного кода C++, 
предоставляющий возможность запрашивать и адаптировать ваш код на основе характеристик типа.


______________________________________________________________________________________
Вариативные шаблоны. Шаблоны с переменным количеством аргументов (variadic templates C++11)

Шаблоны с переменным числом аргументов — это функция C++11, позволяющая определять шаблон с переменным количеством аргументов. Это особенно полезно, когда вам нужно написать функцию 
или класс, которые могут принимать разные числа и типы аргументов.

Синтаксис вариативных шаблонов очень прост. Чтобы определить вариативный шаблон, используйте ...обозначение (многоточие):

template <typename... Types>		// Передаём пакет типов. Здесь ... означает что мы объявили пачку типов.
void f(Types.. tx) {			// Распаковка пакета. А здесь ... означает что мы распаковали пачку типов, и это означает что tx теперь пачка переменных.
	
}

Здесь Types это пакет типов, особый вид шаблонного архумента, который представляет из себя пачку типов. Эту пачку можно распаковывать. Пакет может быть пустым. Этот пакет параметров 
можно использовать как список переменных параметров шаблона в определении шаблона.


Примеры:
1) Суммирование нескольких аргументов с использованием шаблонов с переменным числом аргументов:

#include <iostream>

// Base case for recursion
template <typename T>
T sum(T t) {
  return t;
}

// Variadic template
template <typename T, typename... Args>
T sum(T t, Args... args) {
  return t + sum(args...);
}

int main() {
  int result = sum(1, 2, 3, 4, 5);  // expands to 1 + 2 + 3 + 4 + 5
  std::cout << "The sum is: " << result << std::endl;

  return 0;
}

2) Класс кортежа с использованием шаблонов Variadic

template <typename... Types>
class Tuple;

// Base case: empty tuple
template <>
class Tuple<> {};

// Recursive case: Tuple with one or more elements
template <typename Head, typename... Tail>
class Tuple<Head, Tail...> : public Tuple<Tail...> {
 public:
  Tuple(Head head, Tail... tail) : Tuple<Tail...>(tail...), head_(head) {}

  Head head() const { return head_; }

 private:
  Head head_;
};

int main() {
  Tuple<int, float, double> tuple(1, 2.0f, 3.0);
  std::cout << "First element: " << tuple.head() << std::endl;
  return 0;
}

Обратите внимание, что показанные примеры предназначены для образовательных целей и могут быть не самыми эффективными и готовыми к использованию реализациями. В C++17 и более поздних 
версиях появились еще более лаконичные способы обработки шаблонов с переменным числом вариантов, например использование выражений свертки.


3) Пример: Представим что мы хотим написать функцию print, которая берёт переменное кол-во параметров, и выводит их по одному в консоль. Здесь нам пригодится шаблонная рекурсия. 
Нужно понимать, что когда я вызываю print от 10 шаблонных параметров, а потом вызываю print от 9, это всё разные принты будут, будет 10 разных версий принт сгенерировано 
компилятором. И мы хотим чтобы принт от 10 шаблонных параметров нам выводил первый из них, и вызывал рекурсивно принт от 9 шаблонных параметров.

Для того чтобы это реализовать, нам нужно откусить голову. Когда люди пишут код с переменным кол-во шаблонных аргрументов, они обычно делают так: они говорят что есть первый 
аргумен Head, и он имеет тип, а есть ещё хвост, который является пакетом оставшихся типов. 

void print() {}						// Без этого CE. Эта функция на случай, если аргументов не осталось.

template <typename Head, <typename... Tail>		// Эта функция подходит для случаем, когда хоть 1 аргумент есть. Пакет может быть пустым, но первый аргумент должен быть всё ровно.	
void print(const Head& head, const Tail&... tail) {	// Константные ссылки нужны для передачи далее без копирования.		
	std::cout << head << ' ';
	print(tail...);
}

int main() {
	print(1, 2.0, "abc");
}

Пустая функция print без аргуметов нужна для рекурсии.


#####################
Упражнение: Давайте напишем метафункцию, которая проверяет, что все типы в пакете одинаковые.

template <typename First, typename Second, typename... Types>
struct is_homogeneous { 
	static constexpr bool value = std::is_same_v<First, Second>
		&& is_homogeneous<Second, Types...>::value;
};

template <typename First, typename Second>
struct is_homogeneous <First, Second> {
	static constexpr bool value = std::is_same<First, Second> 
};


#####################
Оператор sizeof...

Есть встроенный оператор sizeof... и его можно вызывать от пакетов:

std::cout << sizeof...(tail);

Он возвращает в компайлтайме число, равное размеру пакета (Как от пакета переменных, так и от пакета типов.)



______________________________________________________
Выражения свёртки (fold expressions) C++17

В C++17 добавили более крутую функцию. Допустим мы хотим проверить что все типы в пакете это указатели. Мы имеем метафункцию std::is_pointer_v, которая для данного типа 
проверяет указатель ли это или нет.

template <typename ... Types>
struct all_pointers {
	static const bool value = (std::is_pointer_v<Types> && ...);
};

Если у нас есть пакет, то мы можем засунуть его в fold expressions. fold expressions это когда мы берём какой нибудь expressions, в котором фигурирует пакет, и бинарным 
оператором его соединяем просто с многоточием (...). Это всё разворачивается в компайлтайме. Т.е. это означает для всех типов из пакета повтори вот эту штуку через коньюнкицю и.


Реализуем  is_homogeneous с помощью fold expressions:

template <typename Head, typename... Tail>
struct is_homogeneous {
	static const bool value = (std::is_same_v<Head, Tail> && ...);
};


Реализуем print:

template <typename... Types>
void print(const Types&... types){
	(std::cout << ... << types);
}


У fold expressions есть 4 разновидности:

1) ( pack op ... )
2) ( ... op pack )
3) ( pack op ... op init )
4) ( init op ... op pack )

где, pack - пакет, op - оператор, init - инициализатор.

В чём разница между 1) и 2)? Разница в ассоциативносию. Разные операторы имеют разную ассоциативность, кто-то лево ассоциативен, кто-то право ассоциативен. 1) вид выражения
превращается в правоассоциативную штуку. Т.е. написать вариант 1) это тоже самое что написать (E_1 op (... op (E_N - 1 op E_N))), т.е. скобки справа налево расставлены.
2) вариант эквивалентно написанию (((E_1 op E_2) op ...) op E_N).

3) и 4) тоже самое, только с инициализацией.


______________________________________________________
Неочевидное использование шаблоннов

1) Паттерн CRTP 

template <class T>
struct Base {
	
	/* Просто пояснения, это не входит в пример	
	// T x;    Не будет работать
	T* ptr;	// Будет работать
	T& rtf;
	*/
	
	void interface() {
		// ...
		static_cast<T*>(this)->implementation();
		// ...
	}
	
	static void static_func() {
		// ...
		T::static_sub_finc();
		// ...
	}
};

struct Derived : Base<Derived> {
	void implementation();
	static void static_sub_finc();
};

Класс Derived наследуется от Base с шаблонным параметром Derived. Т.о. Base в некотором смысле знает что T это его потомок. С помощью этого паттерна мы можем в каком то смысле 
иметировать поведение виртуальных функций. У нас есть функция interface, определённая у базового класса, которая для разных T она себя ведёт по разному, и мы, обращаясь к 
базовому классу, можем вызвать эту функцию. Но по факту будет делаться static_cast к наследнику и вызываться его реализация. 

Шаблоны это просто генерация кода, т.е. когда я говорю Derived : Base<Derived>, я просто говорю компилятору подставь T = Derived в Base и просто возьми этот кусок кода и 
скопипасть его, но только чтобы вместо T везде напиши Derived.



2) Expression templates

Очень долгое объяснение. Лекция 26 21.40


______________________________________________________________________________________
SFINAE (Отказ от замены не является ошибкой)

SFINAE — это принцип метапрограммирования шаблонов C++, который позволяет компилятору выбирать соответствующую функцию или класс, когда конкретная специализация шаблона терпит неудачу
во время замены. Термин «ошибка замены» относится к процессу, в котором компилятор пытается заменить аргументы шаблона в шаблон функции или шаблон класса. Если замена вызывает ошибку,
компилятор не будет рассматривать эту конкретную специализацию как кандидата и продолжит поиск допустимой.

Ключевая идея SFINAE заключается в том, что если возникает ошибка замены, она молча игнорируется, и компилятор продолжает исследовать другие специализации или перегрузки шаблона. Это 
позволяет вам писать более гибкий и универсальный код, поскольку позволяет иметь несколько специализаций для разных сценариев.

Пример кода
Вот пример, демонстрирующий SFINAE в действии:

#include <iostream>
#include <type_traits>

template <typename T, typename = void>
struct foo_impl {
    void operator()(T t) {
        std::cout << "Called when T is not arithmetic" << std::endl;
    }
};

template <typename T>
struct foo_impl<T, std::enable_if_t<std::is_arithmetic<T>::value>> {
    void operator()(T t) {
        std::cout << "Called when T is arithmetic" << std::endl;
    }
};

template <typename T>
void foo(T t) {
    foo_impl<T>()(t);
}

int main() {
    int a = 5;
    foo(a); // output: Called when T is arithmetic

    std::string s = "example";
    foo(s); // output: Called when T is not arithmetic
}


В этом примере мы определяем две foo_impl специализированные функции на основе логического значения std::is_arithmetic<T>. Первый активируется, если T это арифметический тип, а второй
активен, если T не является арифметическим типом. Затем функция foo вызывает соответствующую foo_implспециализацию на основе результата признака типа.

При вызове foo(a) целого числа выбирается первая специализация, а при вызове foo(s) строки — вторая специализация. Если действующей специализации нет, код не сможет скомпилироваться.






















