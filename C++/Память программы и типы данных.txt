Память программы

В C++ можно использовать различные типы объектов, которые различаются по использованию памяти. Так, глобальные объекты создаются при запуске программы и освобождаются при ее завершении. Локальные 
автоматические объекты создаются в блоке кода и удаляются, когда этот блок кода завершает работу. Локальные статические объекты создаются перед их первым использованием и освобождаются при завершении 
программы.

Глобальные, а также статические локальные объекты помещаются в статической памяти, а локальные автоматические объекты размещаются в стеке. Объекты в статической памяти и стеке создаются и удаляются 
компилятором. Статическая память очищается при завершении программы, а объекты из стека существуют, пока выполняется блок, в котором они определены. Когда блок завершает выполнение, то память в стеке, 
отведенная для переменных блока, освобождается. Стоит отметить, что память, выделяемая для стека, имеет ограниченный фиксированный размер.

В дополнение к этим типам в C++ можно создавать динамические объекты. Продолжительность их жизни не зависит от того, где они созданы. Динамические объекты существуют, пока не будут удалены явным образом.
Динамические объекты размещаются в динамической памяти (free store). Это область памяти, не занятая операционной системой или другими загруженными в данный момент программами. Использование динамических 
объектов имеет ряд преимуществ. Во-первых, более эффективное использование памяти - выделяется имеенно столько места, сколько необходимо, а после использования сразу освобождается. Во-вторых, мы можем 
использовать гораздо больший объем памяти, который в ином случае был бы не доступен. Но это и накладывает ограничения: мы должны следить, чтобы все динамические объекты были удалены.

Оператор new выделяет место в динамической памяти для объекта и возвращает указатель на этот объект.
Оператор delete получает указатель на динамический объект и удаляет его из памяти.


______________________________________________________________________________________
Статическая типизация

В C++ статическая типизация означает, что тип данных переменной определяется во время компиляции перед выполнением программы. Это означает, что переменную можно использовать только с 
данными определенного типа, и компилятор гарантирует, что операции, выполняемые с переменной, совместимы с ее типом. Если есть несоответствие, компилятор скорректирует тип данных 
переменной, чтобы он соответствовал другому, если это возможно. Этот процесс известен как Type Conversion. Если компилятору не удастся выполнить преобразование типов, 
Invalid Type Conversionво время компиляции кода возникнет ошибка.

C++ — это статически типизированный язык, а это означает, что он использует статическую типизацию для определения типов данных и выполнения проверки типов во время компиляции. Это помогает обеспечить 
безопасность типов и предотвратить возникновение определенных типов ошибок во время выполнения программы.

Вот простой пример кода, демонстрирующий статическую типизацию на C++:

#include <iostream>

int main() {
    int num = 65;        // 'num' is statically typed as an integer
    double pi = 3.14159; // 'pi' is statically typed as a double
    char c = 'c';        // 'c' is statically typed as a char

    c = num;    // This asssigment would convert num's value to ASCII equivalent character
    num = pi; // This assignment would convert pi's value from double type to int type
    
    std::cout << "The value of num is: " << num << std::endl;
    std::cout << "The value of pi is: " << pi << std::endl;
    std::cout << "The value of c is: "<< c << std::endl;
    return 0;
}

В приведенном выше коде переменная num статически типизирована как int, pi статически типизирована как a double и c статически типизирована как char. Если вы попытаетесь pi присвоить 
значение num, значение 3.14159 будет преобразовано в целое число 3 и присвоено num. Аналогично, когда значение num присваивается c, компилятор преобразует это значение 65 в 
соответствующий код ASCII, то есть A.


______________________________________________________________________________________
Динамическая типизация в C++

C++ известен как статически типизированный язык, что означает, что типы данных его переменных определяются во время компиляции. Однако C++ также предоставляет концепции определенного 
уровня динамической типизации , что означает определение типов данных переменных во время выполнения.

Вот краткий обзор двух способов достижения динамической типизации в C++:

1) void* Указатели

Указатель void* — это универсальный указатель, который может указывать на объекты любого типа данных. Их можно использовать для хранения ссылки на объект любого типа без знания 
конкретного типа объекта.
Пример:

#include <iostream>

int main() {
    int x = 42;
    float y = 3.14f;
    std::string z = "Hello, world!";

    void* void_ptr;

    void_ptr = &x;
    std::cout << "int value: " << *(static_cast<int*>(void_ptr)) << std::endl;

    void_ptr = &y;
    std::cout << "float value: " << *(static_cast<float*>(void_ptr)) << std::endl;

    void_ptr = &z;
    std::cout << "string value: " << *(static_cast<std::string*>(void_ptr)) << std::endl;

    return 0;
}

2) std::any(С++17)
В C++17 появился std::any - класс, который представляет собой обобщенный типобезопасный контейнер для отдельных значений любого типа.

Пример:

#include <iostream>
#include <any>

int main() {
    std::any any_value;

    any_value = 42;
    std::cout << "int value: " << std::any_cast<int>(any_value) << std::endl;

    any_value = 3.14;
    std::cout << "double value: " << std::any_cast<double>(any_value) << std::endl;

    any_value = std::string("Hello, world!");
    std::cout << "string value: " << std::any_cast<std::string>(any_value) << std::endl;

    return 0;
}
Имейте в виду, что оба void* указателя и std::any влияют на производительность из-за дополнительной проверки типов и приведения типов, которые происходят во время выполнения. Их 
следует использовать осторожно и только в случае крайней необходимости.


______________________________________________________________________________________
Идентификация типа во время выполнения (RTTI)

Идентификация типа во время выполнения (RTTI) — это функция C++, которая позволяет получать информацию о типе объекта во время выполнения программы. Это может быть полезно при 
использовании динамической типизации, когда тип объекта может меняться во время выполнения.

В C++ существует два основных механизма RTTI:

1) typeid оператор

typeid— оператор, возвращающий ссылку на объект типа std::type_info, содержащую информацию о типе объекта. Для использования заголовочный файл <typeinfo> должен быть включен typeid.

Вот пример:

#include <iostream>
#include <typeinfo>

class Base { virtual void dummy() {} };
class Derived : public Base { /* ... */ };

int main() {
    Base* base_ptr = new Derived;

    // Using typeid to get the type of the object
    std::cout << "Type: " << typeid(*base_ptr).name() << '\n';

    delete base_ptr;
    return 0;
}


2) оператор динамического_приведения

dynamic_cast— это оператор приведения типов, который выполняет проверку типа во время выполнения и безопасно понижает базовый указатель или ссылку до производного указателя или ссылки.
Он возвращает значение null или выдает исключение bad_cast (если приведение ссылается) в случае сбоя приведения.

Вот пример:

#include <iostream>

class Base { virtual void dummy() {} };
class Derived1 : public Base { /* ... */ };
class Derived2 : public Base { /* ... */ };

int main() {
    Base* base_ptr = new Derived1;

    // Using dynamic_cast to safely downcast the pointer
    Derived1* derived1_ptr = dynamic_cast<Derived1*>(base_ptr);
    if (derived1_ptr) {
        std::cout << "Downcast to Derived1 successful\n";
    }
    else {
        std::cout << "Downcast to Derived1 failed\n";
    }

    Derived2* derived2_ptr = dynamic_cast<Derived2*>(base_ptr);
    if (derived2_ptr) {
        std::cout << "Downcast to Derived2 successful\n";
    }
    else {
        std::cout << "Downcast to Derived2 failed\n";
    }

    delete base_ptr;
    return 0;
}

Обратите внимание, что использование RTTI может привести к некоторым издержкам производительности, поскольку требует хранения и обработки дополнительной информации, сгенерированной 
компилятором, во время выполнения.

______________________________________________________________________________________
Приведение типов

Приведение типов — это процесс преобразования значения из одного типа данных в другой. В C++ существует четыре различных метода приведения типов:

1) Приведение в стиле C : это синтаксис, унаследованный от C, и он выполняется путем простого помещения целевого типа данных в круглые скобки перед приводимым значением. Пример:

int a = 10;
float b = (float)a;


2) static_cast: это наиболее часто используемый метод приведения типов в C++. Он выполняется во время компиляции, и его следует использовать, когда у вас есть явное преобразование 
между типами данных. Этот тип приведения выполняет проверку во время компиляции и выдает ошибку, если допустимое преобразование между заданными типами невозможно. static_cast обычно 
безопаснее, чем приведение в стиле C, поскольку оно не выполняет небезопасную реинтерпретацию данных и позволяет лучше проверять типы.
Пример:

int a = 10;
float b = static_cast<float>(a);


3) dynamic_cast: этот метод специально используется для безопасного преобразования указателей и ссылок между базовыми и производными классами в иерархии классов. Это тип оператора 
приведения в C++, который используется специально для полиморфизма. 
Пример:

class Base {};
class Derived : public Base {};

Base* base_ptr = new Derived();
Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr);


4) reinterpret_cast: это приведение изменяет тип указателя, ссылки или целочисленного значения. Его также называют побитовым приведением, поскольку оно меняет способ интерпретации 
компилятором базовых битов. это тип приведения в C++, который позволяет изменять тип указателя или целого числа без изменения представления данных. Обычно он используется, когда 
требуемое преобразование слишком низкоуровневое или не поддерживается другими методами приведения, такими как static_cast. Используйте его reinterpret_castтолько в том случае, если у 
вас есть глубокое понимание того, что вы делаете, поскольку это не гарантирует, что полученное значение будет иметь смысл. 
Пример:

int* a = new int(42);
long b = reinterpret_cast<long>(a);


5) const_cast: этот метод приведения позволяет удалять или добавлять константность переменной. Другими словами, он позволяет вам модифицировать объект const или volatile или изменить
указатель или ссылку на тип const или volatile. Это полезно в определенных сценариях, когда вам нужно передать constпеременную в качестве аргумента или когда параметр функции требует 
неконстантного типа, но вы хотите, чтобы переменная оставалась постоянной во всем коде.Обычно это не рекомендуется, но может быть полезно в определенных ситуациях, когда вы не можете 
контролировать константность переменной.
Пример:

const int a = 10;
int* ptr = const_cast<int*>(&a);  // const_cast from const int* to int*
*ptr = 20;  // Not recommended, use with caution



______________________________________________________________________________________
Память программы

В ОЗУ компьютера выделяется место в памяти для нашей программы. Это место памяти делится на 3 области:
1) data - static memory (статическая память). В ней храняться глобальные переменные, переменные объявленные в namespace(не локальные), локальные статические переменные, 
строки литералы, таблицы виртуальных функций и некоторая другая информация, не являющеяся кодом, которая существует в течении всего времени жизни программы.
2) text - непосредственно код нашей программы в двоичном виде (машинный код для процессора).
3) stack - стек (автоматическая память). Здесь хранятся локальные переменные.

Статическая память и стек это разная память. Есть статическая память, есть динамическая и есть стек.

		ОЗУ
	/-----------------------------------------------\
	|						|
	|	Область памяти для нашей программы	|
	|      /---------------------\			|
	|      | data | text | stack |			|
	|      \---------------------/			|
	|						|
	\-----------------------------------------------/

int main() {
	int x = 5; // Переменная будет храниться на стеке
}

Стек работает как структура данных стек. У нас в рантайме процессором поддерживается стекпойнтер изначально указывающий на адрес начало стека. Когда мы вводим новую локальную 
переменную, делается пуш на этот стек. Например мы создали переменную типа int. От начала стека стекпойнтер смещается на 4 байта. Теперь в области памяти между началом и 
адресом стекпойнтера храниться данный int. При создании ещё одного int стекпойнтер смещается ещё на 4 байта. Если мы выходим из области видимости второго int, стекпойнтер 
смещается обратно на 4 байта, и считается что память была очищена.


При вызове функции мы тоже занимаем стек:

void f(int y) {
	std::cout << y + 1 << std::endl;
}

int main() {
	int x = 5;
	f(x);
}

Это примерное понимание работы вызова функции:
В данном случае на стек пушиться переменная x типа int, т.е. стекпойнтер смешается от начала на 4 байта. Далее вызывется функция f. Вызов f означает что нам нужно на стек
теперь положить ещё и переменную y, т.к. y это новая локальная переменная для новой области видимости. Указатель сдвигается ещё на 4 байта. Но это не всё. Когда мы 
вызываем функцию, недостаточно просто положить все локальные переменные на стек, нужно ещё положить адрес возврата. Когда процессор исполняет код и видит вызов функции, 
он понимает на какой адрес ему прыгнуть, чтобы исполнить код этой функции, потому что когда компилятор компилировал код, он вызов этой функции превратил в прыжок на конкретный
адрес, и вызывая функцию процессор знает адрес на которой находиться реализация этой функции (она находиться в области памяти text). Но проблема в том, что когда выходим
назад из функции, негде не записано куда выходить, ведь функцию могли вызывать из разных мест и процессору нужно знать адрес кода для выполнения следующей инструкции. Этот
адресс возврата запоминается на стеке в виде указателя, т.е. этот указатель говорит куда прыгать обратно для дальнейшего выполнения программы. Скорее всего этот указатель
пушиться на стек ещё до переменной y. 

Размер стека фиксирован и равен по умолчанию 8 Мб(на разных системах по разному). У любой программы есть стек. Размер data определяется тем, сколько у нас есть глобальных 
переменных и прочей статической информации. Размер text определяется размером бинарного кода программы.

Стек можно переполнить (stack over flow), если сделать локальных переменных или вызовов функций больше чем 8 Мб. Например бесконечная рекурсия. При переполнении стека 
ОС убивает программу, но происходит это не сразу. Когда мы превзошли разрешённые адреса, начинается UB. Если память свободна то программа продолжить работу, пока не дойдёт 
до занятой памяти и тогда программа умрёт.


8 Мб бывает недостаточно, и для того чтобы хранить большие данные нужна динамическая память. Динамическая память выделяется в рантайме.

int* p = new int; 

В этот момент наша программа попросит у ОС дополнительную память размером sizeof(int) (в данном случае) байт вдобавок. Когда ОС выдаст память, нам вернётся указатель на первый
байт из тех, что нам выдали. Для освобождения память:

delete p;

После этого память на которую указывает p больше не наша и за обращение к ней нас могут убить. Поэтому указатель нужно занулить nullptr.

!!!! НЕЛЬЗЯ писать delete p, pp; (В этом случае удалиться только p.) delete (p, pp); тоже нельзя. (В этом случае удалиться только pp.)



Статическая переменна:

void f() {
	static int x = 0;    		// локальная статическая переменная
	std::cout << ++x << "\n";
	f();
}

int main() {
 	f();
}

Статик значит что я прошу чтобы переменная x лежала в области памяти не стековой, а в статической (область data), т.е. чтобы за ней был закреплён один и тот же адресс на всём
протяжении жизни программы. В функции void когда мы в первый раз зайдём в эту функцию переменная x будет проинициализированна 0. Во всех остальных вызовах функции ничего уже
не будет с этой переменной, она уже создана и проинициализированна, а память под неё уже была выделена зарание. Это называется локальная статическая переменная. Статическая 
переменная может быть любого размера как и динамически созданная(не зависит от 8Мб т.к. она не на стеке).

int Arr[10'000'000]; 		// Стек овер флоу
static int Arr2[10'000'000]; 	// Всё норм поскольку переменная находится в области data и размер выделенной памяти регулируется при компиляции.



______________________________________________________________________________________
Размер структуры(класса). Сколько в памяти занимает класс?

Сколько в памяти занимает произвольная структура?

Зависит от платформы. Допустим у нас x32 и память у нас автоматически выравнивается и она будет кратна 32 битам. Например у нас не будет размер какой то структуры 11 байтам. 
Сайзоф пустого объекта считается 1.




Очень упрощённо размер класса (структуры) это размер всех её полей, с точностью до выравнивания.

Если бы просто в структуре было одно поле типа int, то её размер был бы как и у этого поля int, т.е. 4 байта.
struct S {		// Размер 4 байта		
	int x = 1;					Байты в памяти: 1234
};							Данные:		int|	(| для того чтобы показать что занимаем 4 байта)

Если бы было только одно поле типа double, то и размер структуры был бы размером с типа double, т.е. 8 байт.

struct S {		// Размер 8 байта
	double d = 3.14;				Байты в памяти: 12345678
};							Данные:		double||

Если бы было 2 int то размер был бы 8 байт.
struct S {		// Размер 8 байта		Байты в памяти: 12345678
	int x = 1;					Данные: 	int|int|
	int y = 2;
};

Но если мы сделаем структуру с одним полем int (4 байта) и с одним double (8 байт), то размер будет не 12, а 16 байт.
struct S {		// Но рамер структуры 16 байт, а не 12.
	int x = 1;	// 4 байта 			Байты в памяти: 1234567812345678
	double d = 3.14;// 8 байт			Данные:		int|    double||
};

S s1;
S s2;

S arr[2] = {s1,s2};


В памяти:	
		структура s1    структура s2
Байты в памяти: 12345678123456781234567812345678
Данные:		int|    double||int|    double||


Дело в том, что 8-ми байтные числа кладутся по адресам, кратным 8. Так же и сама структура(класс) кладётся по адресам, кратным 8-ми, для того, чтобы между несколькими 
экземплярами класса не было неиспользованных промежутков(экземпляры шли в притык), например в массиве структур. Однако если бы была структура из 3ёх int, то в этом нет 
необходимости, поскольку int нужно класть по адресам кратным лишь 4, и такие структуры можно класть в массив без выравнивания.


struct S {		// Размер 12 байт		Байты в памяти: 123456781234
	int x = 1;					Данные: 	int|int|int|
	int y = 2;
	int z = 3;
}

S s1;
S s2;

S arr[2] = {s1,s2};


В памяти:	
		структура s1|структура s2    
Байты в памяти: 123456781234567812345678
Данные:		int|int|int|int|int|int|


Вложенные классы:
Обычный класс:
struct S {		// Рамер структуры 24 байт
	int x = 1;	// 4 байта 			Байты в памяти: 123456781234567812345678
	double d = 3.14;// 8 байт			Данные:		int|    double||c
	char c; 	// 1 байт							это char (Он занимает только 1 байт (1 БАЙТ А НЕ 1 БИТ, потому что байт минимальная единица измерения памяти)
};

Класс с вложенным классом:

struct S {			// Размер S равен 16 байт, поскольку в структуре S Мы не объявляли новых полей.
	int x = 1;		// 4 байта 
	double d = 3.14;	// 8 байт

	struct SS {
		char c;		// 1 байт
	};
};




#########################
Порядок в котором мы определяем члены в классе влияет на размер класса, потому что компилятор может добавить отступы (паддинги (padding)) для соблюдения требования выравниванию памяти. 

char a;		// 1 byte
int b;		// 4 bytes
char c:		// 1 byte
double d;	// 8 byte

	 |-----|-----|-----|-----|
char a   |  a  |  p  |  p  |  p  |	char + 3 bytes padding
	 |-----|-----|-----|-----|
int b	 |  b  |  b  |  b  |  b  |	int b (4 bytes)
	 |-----|-----|-----|-----|
char c	 |  c  |  p  |  p  |  p  |	char c + 3 bytes padding
	 |-----|-----|-----|-----|
	 |  d  |  d  |  d  |  d  | 	double (4 bytes)
double d |-----|-----|-----|-----|			(8 bytes)
	 |  d  |  d  |  d  |  d  |	double (4 bytes)	
	 |-----|-----|-----|-----|	

Вообщем 6 байт паддингов (p)


Чтобы минимизировать объём памяти сначала нужно указывать самые большие типы данных.

double d;	// 8 byte
int b;	// 4 bytes
char a;	// 1 byte
char c:	// 1 byte


	 |-----|-----|-----|-----|
double d |  d  |  d  |  d  |  d  | 	double (4 bytes)
	 |-----|-----|-----|-----|			(8 bytes)
	 |  d  |  d  |  d  |  d  |	double (4 bytes)	
	 |-----|-----|-----|-----|
int b	 |  b  |  b  |  b  |  b  |	int b (4 bytes)
	 |-----|-----|-----|-----|
char a	 |  a  |  c  |  p  |  p  |	char a + char c + 2 bytes padding
char c	 |-----|-----|-----|-----|

Вообщем 2 байта паддингов





______________________________________________________
Операторы привидения типа

Если у вас есть несколько симантических разных типов, хотя  физически они представляются одинаково, то строгая типизация  даёт возможность избежать того, что можно перепутать
порядок где нибудь. Coordinate(double x, double y). Долгота - 55.00 Широта - 37.00 - Москва, Долгота - 37.00 Широта - 55.00 - Иран.

Для таких целей я могу создать отдельный класс для долготы и широты.

struct Latitude {
	double value;

	explicit Latitude(double value) : value(value){} 	// Запрет на неявный вызов конструктора

	explicit operator double() const {			// Оператор приведения типа. Мы разрешили кастовать из Latitude в double. Возвращаемый тип писать не нужно.
		return value;					
	}
};

struct Longitude {
	double value;

	explicit Longitude(double value) : value(value){}
};

Но я хочу чтобы нельзя было, чтобы нельзя неявно создать из double ничего из этого. И я хочу чтобы к double нельзя неявно было прикастовать ничего из этого. (Имеется в виду
оба класса). По умолчанию компилятор будет разрешать неявное преобразование.

explicit не даст создать объект если мы положем тип double а не Latitude или Longitude соответственно.


Обратно: Если мы хотим из Latitude или Longitude получать обратно дабл нам нужно переопределить тип. Чтобы избежать неявного каста мы должны написать explicit. Явный каст это
static_cast. 

Кодстайл - оператор приведения типа лучше делать explicit. Приведение типа даже к bool нужно делать explicit. 



______________________________________________________________________________________
###################################################################
______________________________________________________________________________________
Allocators and memory management
Idea and basic usage of allocators

У всех стандартных контейнеров есть последний шаблонный параметр аллокатор, по умолчанию это всегда std::allocator. 

Представим контейнер std::list и допустим мы в него кладём элементы, например int. Мы кладём в него элементы, затем удаляем, затем опять кладём. Каждый раз когда мы кладём в лист
новый элемент(insert) в листе вызывается оператор new. Так происходит и с map и с set, и при реалокации vector. По сути каждая вставка одного int это вызов оператора new, а мы 
знаем что вызов оператора new это долго. Это может быть дольше чем спуск по дереву в map. Когда мы делаем вставку в map, вся асемптатическая сложность оценивается без учёта того,
что выделяется динамическая память, при этом выделение динамической памяти это сложный алгоритм. Но это не единственная проблема, другая проблема вот в чём: почему вообще нам 
нужна динамическая память? Мы же можем завести массив или лист на стеке. Почему бы не завести связный список который использует стековую память а не динамическую? Стандартный лист
не предоставляет нам такой возможности. У нас может быть лист всего лишь из 100 элементов, он заведомо уместится на стеке и казалось бы можно спокойно завести его на стеке и не
выделять динамическую память, но в том формате который мы видели такой опции нет, только через динамическую память, причём new на каждый insert. Это кажется не всегда уместно, 
иногда казалось бы что можно сделать проще и быстрее. Именно для этого существует понятние аллокатор.

Аллокатор это класс который является промежуточным звеном между контейнером и вызовом оператора new. Мы можем добавить такую прослойку, и заставить контейнер обращаться не к 
оператору new, а к чему то другому. Аллокатор в C++ позволяет кастомизировать поведение контейнера, при выделении памяти. 

Нужно понимать следующий стек вызовов: У нас есть контейнер, который обращается к аллокатору, который обращается к оператору new, который обращается к функции malloc, которая
обращается к ОС:

 Container -> Allocator -> operator new -> malloc() -> OS

Оффтоп:
Алгоритм который реализован в функции malloc также иногда называется аллокатором, потому что функцию malloc тоже можно заменить на чтото другое, поскольку у malloc есть разные 
реализации, и malloc тоже можно подменить на разные реализации которые называются кастомными аллокаторами, но это аллокаторы уровня языка C. 


Продолжим:
Простейший аллокатор - std::allocator. У аллокатора есть 4 основных метода: 
allocate() - заменяет обращение к оператору new и оно просто выделяет память. Здесь нужно различать аллокацию и конструирование. Когда мы говорим allocate(count) это значит что мы
не хотим создать count объектов типа T, а хотим просто выделить память под столько объектов. Это ровно то, что вызывает вектор, когда ему нужно сделать reserve().

Непраивльная реализация класса allocator:

template <typename T>
struct allocator {
	T* allocate(size_t count) {
		//new reinterpret_cast<T*>(new char[count * sizeof(T)]); 	// Старая реализация
		return operator_new(count * sizeof(T)); 			// Это уже лучше. Подробности в теме new и delete
	}
	void deallocate(T* ptr, size_t count) {
		//delete[] reinterpret_cast<char*>(ptr);			// Старая реализация
		operator_delete(ptr);					// Подробности в теме new и delete
	}

	template <typename U, typename... Args>		
	void construct(U* ptr, const Args&... args) {		// По адресу конструирую объект типа U, Args это то из чего мы будем конструировать этот объект
		new (ptr) U(args...);				// Проблема в том что мы будем копировать лишний раз в T(args...)
	}							// construct должен уметь конструировать даже объекты типа отличного от T.

	template <typename U>					// Дестрой тоже должен вызываться от другого типа. Потому что на аллокаторе от Node мы будем вызывать деструктор T.
	voide destroy(U* ptr) {
		ptr->~U();
	}

	template<typename U>					// Конструктор от другого аллокатора с любым другим U. В случае стандартного аллокатора конструктор тривиальный.
	allocator(allocator<U>) {}				// Потом объясним зачем это
	
	template <typename U>					// Мета функция, которая позволяет получить такой же аллокатор, но от другого T. 
	struct rebind {						// Потом объясним зачем это
		using other = allocator<U>;
	};
};


Вернёмся к реализации вектора. Теперь с учётом нашего знания об аллокаторах мы можем исправить реализацию вектора. Добавим шаблонный параметр аллокатор, который по умолчанию 
равен std::allocator<T>, и он используется всегда вместо оператора new напрямую. Также исправим старую реализацию, и нужно добавить конструктор от аллокатора (здесь не 
реализовано).


template <typename T, typename Alloc = std::allocator<T>>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;
	Alloc alloc_;				// Храним объект аллокатора, это 4-ое и последнее поле которе хранит в себе вектор.

public:
	void reserve(size_t newcap) {
		if (newcap <= cap_)							
			return;

		//T* newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)]); 	// Старая реализация
		T* newarr = alloc_.allocate(newcap);					// Новая реализация с учётом аллокатора
			
		size_t index = 0;
				
		try {
			T* newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)]); 	
			for(; index < sz_; ++index) {				
				//new(newarr + index) T(arr[index]); 			// Старая реализация
				alloc_.construct(newarr + index, arr_[index]);		// Новая реализация с учётом аллокатора	
			}		
		} catch(...) {
			for(size_t oldindex = 0; oldindex < index; ++oldindex) {
				(newarr + oldindex)->~T();				// Старая реализация
				alloc_.destroy(newarr + oldindex);			// Новая реализация с учётом аллокатора	
			}
			//delete[] reinterpret_cast<char*>(newarr);			// Старая реализация
			alloc_.deallocate(newarr, newcap);				// Новая реализация с учётом аллокатора
			throw;
		}		
	
		for (size_t index = 0; index < sz; ++index) {				
			//(arr_ + index)->~T();						// Старая реализация
			alloc_.destroy(arr_ + index);					// Новая реализация с учётом аллокатора
		}
		//delete[] reinterpret_cast<char*>(arr_);				// Старая реализация
		alloc_.deallocate(arr_, cap);						// Новая реализация с учётом аллокатора

		arr_ = newarr;								
		cap_ = newcap;								
	}	

	void push_pack(const T& value) {			
		if(sz == cap_) {
			reserve(cap_ > 0 ? cap_ * 2 : 1); 	
		}
	}
};


В любой стандартный контейнер можно отдать аллокатор параметром в конструктор, при этом для полей будут созданы аллокаторы по умолчанию.
Так же в любом контейнере есть метод get_allocator который даёт копию текущего аллокатора данного контейнера.


Какое поведение может быть у нестандартного аллокатора? Виды нестандартных аллокаторов:
1) PoolAllocator - изначально выделяет большой массив, а когда его просят allocate, он из этого массива выдаёт кусочки. Т.е. это аллокатор, который сам поддерживает мемори 
менеджмент, просто он заранее выделяет большой массив и дальше им распоряжается. Таким образом оператор new будет вызван только один раз, а дальше весь мемори менеджмент
происходит локально.
2) StackAllocator - это аллокатор, который вообще не обращается к new. Этот аллокатор выделяет всё на стеке. Этого можно добиться тем, что в конструктор аллокатора изначально
принимать массив, например std::array. 

int main() {
	std::array<char, 1000000> arr;			// Массив из миллиона char
	StackAllocator alloc(arr);			// Создаём аллокатор

	std::list<int, StackAllocator<int>> lst		// Лист от данного аллокатора. 
}

Получается у нас прям на стеке создался аллокатор, который сконструировался от этого массива. Этот массив может передасться по ссылке или указателю. Т.е. массив находится на 
стеке, однако аллокатор управляет им, как будто это его память. Теперь мы можем создать другой контейнер используя наш аллокатор, например лист. Этот лист будет храниться на 
стеке. Так можно сделать с любым контейнером. 


Первая проблема: Пока у нас vector то всё нормально, но когда у нас уже std::list то он вообще-то аллоцирует не int, а ноды, как и map или unordered_map, который ещё 
аллоцирует массив указателей и форвард лист. Мы понимаем что вообще то, когда мы имеем дело с аллокатором в контейнере, возможна ситуация, что нам нужно аллоцировать не тот
тип, от которого был аллокатор. Аллокатор предназначен для типа T, и дали нам аллокатор от типа T, но контейнеру может быть нужно аллоцировать не тип T, а чтото другое.

Для решения этой проблемы был добавлен костыль во все аллокаторы. Представим что мы реализовываем лист. Мы хотим реализовать аллокатор не на тип T, а на ноду, но у нас проблема
в том, что мы даже объявить его не можем т.е. назвать тип, потому что Alloc это тип std::allocator, с уже фиксированным шаблонным параметром T, а мы хотим std::allocator но с 
другим T, мы не можем написать Alloc с большой буквы потому что уже будет с фиксированным T. Как нам назвать тип того аллокатора, который мы хотим здесь иметь в поле, если мы
знаем только Alloc большое, которые уже с фиксированным другим T. Для этого был придумал костыль: В аллокаторе был придуман такая метафункция rebind , которая позволяет получить 
такой же аллокатор, но от другого T. Для того чтобы имея alloc от T, получить alloc от U, мы должны воспользоваться этой метафункцией. 


Вторая проблема:
Конструктор по умолчанию мы будет инициализировать аллокатором по умолчанию, но что если у нас конструктор от аллокатора? У нас опять проблема: у нас аллокатор одного типа, а дали
нам аллокатор другого типа, это значит, что все аллокаторы должны уметь конструироваться от таких же аллокаторов с любым другим T. Короче аллокаторы умеют конструироваться от 
таких же аллокаторов но с другим типом.
 

template <typename T, typename Alloc = std::allocator<T>>
class list {
	struct BaseNode {
		BaseNode* prev;
		BaseNode* next;
	};
	struct Node: BaseNode {
		T value;
	}
	
	BaseNode fakeNode;
	size_t count;	
	// Alloc alloc; 								// Этот аллокатор нам не подходит
	typename Alloc::template rebind<Node>::other alloc;				// Алоокатор. У нас двоёное зависимое имя, здесь нужно писать template
	
	list(const Alloc): fakeNode{неважно чем}, count(неважно чем), alloc(alloc) {}	// Конструктор от аллокатора
};

Примерно так мы создаём лист по умолчанию. BaseNode аллоцировать не нужно, она лежит на стеке, алоцировать нам нужно только настоящие ноды. Но когда мы аллоцировали ноду, нам 
нужно вызвать construct T, это объясняет почему в реализации аллокатора у нас construct от произвольного U, потому что в реальности в листе мы будем вызывать construct от типа T
на аллокаторе типа Node. Мы не хотим создавать аллокатор типа T, каждый раз заново, когда нам нужно сконструировать в ноде объект типа T. 

Зачем нам вообще construct в аллокаторе, почему мы не можем писать placement new? Потому аллокатор должен нас полностью абстрогировать от new, потому что оператор new глобально 
может быть переопределён. Смысл аллокатора в том чтобы полностью отделить контейнер от вызова new, т.е. контейнеры никогда не обращаются к new напрямую, даже при конструировании.
destroy также должен уметь вызываться от другого типа, потому что на аллокаторе от Node мы будем вызывать деструктор T.

Шаблонный аллокатор хорош тем что он прячет в себе new reinterpret_cast<T*>(new char[count * sizeof(T)]); Мы из контейнера просто говорим чтобы он выделил n штук, и аллокатор сам
знает что значит в контексте размера сколько это штук, а контейнеру не нужно думать о размещении в памяти. 


Почему бы аллокатор не сделать шаблонным-шаблонным аргументом? Ведь казалось бы это идеальное место где это стоит использовать. Проверим:

template <typename T, template <typename> Alloc = std::allocator>			// Шаблонный-шаблонный аргумент
class list {
	
	// ...

	// typename Alloc::rebind<Node>::other alloc;					// Теперь нам не нужна эта функция 
	Alloc<Node> alloc;								// и мы можем написать так.
	
	// ...	
};

К сожалению это нельзя сделать, потому что у аллокатора могут быть другие шаблонные параметры. Никто не обещал что у всех аллокаторов ровно один шаблонный параметр, и хуже того
никто не обещал что все шаблонные параметры аллокатора это будут типы, а не числа например. Например: 

std::array<char, 1000000> arr;
StackAllocator<int, 1000000> alloc(arr);		// Стэк аллокатор вполне может быть с шаблонным параметром числа, сколько в нём байт.
std::list<int, StackAllocator<int, 1000000>> lst;

Это разумно чтобы у нас аллокатор от фиксированного пула знал какой размер пула у него, и это было зашито в шаблонный параметр, чтобы мы не могли один аллокатор присвоить другому,
если у них разные размеры пула. Поэтому мы не можем зашить набор шаблонных параметров аллокатора, даже запись template <typename T, template <typename...> Alloc = std::allocator> 
не помогла бы здесь, потому что среди шаблонных параметров могут быть не только типы, а например и числа. Поэтому эта идея не работает. 


####################
Чему равен размер вектора от int? 24 или нет?

std::main() {
	std::vector<int> v;
	static_assert(size_of(v) == 24);	// true or false
}

Да действительно размер вектора от int равен 24, но почему же так, ведь в векторе есть ещё аллокатор. У вектора есть четвёртое поле и это аллокатор. Тем не менее на размер объекта
это не влияет, потому что в stl имеются разного рода оптимизации, в данном случае это Empty Base Optimization аллокатора. (лекция 35 52.00) class std::vector наследуется от 
Vector_base, при наследовании с помощью Empty Base Optimization в потомке нет аллокатора, он есть в классе выше, поэтому наследник занимает меньше памяти.

Т.е. чтобы занять меньше памяти можно унаследоваться от аллокатора:

template <typename T, typename Alloc = std::allocator<T>>
class vector: private Alloc {					// оптимизация. В настоящем std::vector устроено похитрее

};

Это нужно чтобы аллокатор не занимал лишнюю память, ведь аллокатор в подавляющем большинстве случаев это пустой тип. Т.е. стандартный аллоктор занимает 0 байт, в нём нет полей, и
поэтому хранить его отдельным полем в классе расточительно, поэтому можно просто сделать EBO, унаследовав контейнер от аллокатора и тем самым сэкономить поле. Начиная с C++20 
придуман более хитрый способ этого добиться: атрибут [[no_unique_address]] Alloc alloc; который делать тоже самое, позволяет поле хранить на адресе совпадающем с каким то другим
полем.


______________________________________________________________________________________
Stateful allocators and allocator_traits (Нестандартные аллокаторы)

Можно придумать разные примеры нестандартных аллокаторов: PoolAllocator, StackAllocator. Есть ещё FreeListAllocator - это аллокатор изначально, когда мы просим выделить ноды он их
выделяет, а когда мы просим их освободить, он на самом деле их не освобождает, он просто складывает их в свой собственный лист свободных нод и не отдаёт их обратно в систему, а
просто хранит лист выделенных нод. И когда мы просим снова выделить ноду, если у него есть готовые свободные ноды, он отдаёт их нам, чтобы не ходить к new.

Оффтоп: PoolAllocator, StackAllocator, FreeListAllocator это не классы из stl, там таких аллокаторов нет. Это теоритическое умопостроение на тему того, как мог бы выглядить 
нестандартный аллокатор. Например в boost есть несколько нестандартных аллокаторов.

Продолжаем:
Как должен выглядит конструктор копирования для нестандартных аллокаторов? Рассмотрим PoolAllocator, который хранит огромный массив и управляет этой памятью. Что мы должны делать,
когда мы копируем этот аллокатор? Когда мы копируем аллокатор, мы хотим чтобы он ссылался на тот же массив, но не копировал этот массив ни в коем случае. Это важно! Копирование
аллокатора не подразумевает копирование пула! Аллокатор это очень легковесная штука всегда, так же как и итератор. Например в stl функция GetAllocator возвращает нам копию 
аллокатора по значению, и вообще много где аллокатор принимается по значению, потому что копирование аллокатора считается дешёвым всегда, потому что аллокатор подразумевает 
всегда маленький объект. А пул, которым он управляет это отдельный объект, и вот его копирование это уже отдельная история. Но копирование аллокатора обычно неподразумевает 
копирование пула.

У нас возникает та же проблема RAII, нам нужны умные указатели а именно shared_ptr, который будет считать кол-во указателей на данный аллокатор, прежде чем его уничтожить.
Может появиться идея не использовать shared_ptr, а хранить в аллокаторе статическое поле int, которое будет поддерживать счётчик ссылок как в std::shared_ptr. Так нельзя!
Нельзя хранить статический int, потому что тогда у нас будет общий int на вообще все аллокаторы. Не на один и тот же пул, а на вообще все пулы сразу. 
Но можно не хранить shared_ptr, а завести отдельный класс пул, в котором можно будет заниматься управлением этого массива, и сам пул вообще запретить копировать. А аллокатору 
просто хранить указатель на пул и не удалять его. Пул будет существовать в единственном экземпляре, и разные аллокаторы шарят между собой этот массив. Сам аллокатор массив не 
удаляет. 


###################
Что такое allocator_traits. Если мы будем создавать свой аллокатор, мы поймём, что ему точно также нужна будет функция construct, которая будет выглядить абсолютно точно также как
и в реализации выше. Так же нужна будет функция destroy, структура rebind, разные using, который будут одинаковые во всех аллокаторах. Всё это наводит на мысль, что неплохо было 
бы завести некоторую структуру над аллокатором. Примерно как было с iterator_traits, так же и allocator_traits. Это такая структура, которая для всех аллокаторов предопределяет 
некоторые функции и юсинги, чтобы в каждом аллокаторе не нужно было писать их заново. Точно также как и в iterator_traits у нас автоматически определяется iterator_category,
value_type и т.д. если мы их не определили (некоторое работает только начиная с C++20), точно так же и allocator_traits это структура которая за нас определяет функцию 
construct, функцию destroy, структуру rebind, если в нашем аллокаторе её небыло. В реализации стандартного аллокатора выше на самом деле нет этих функиций, начиная с какого то
C++ они были от туда удалены, и перемещены в allocator_traits. И стандартные контейнеры на самом деле обязаны обращаться не к аллокатору напрямую, а к allocator_traits. 

template <typename Alloc>
struct allocator_traits {

	template <typename U, typename... Args>
	static void construct(Alloc& alloc, U* ptr, const Args&... args) {
		if constexpr (/* Если Alloc имеет метод construct*/) {		// Пока что так, мы ещё это не умеем писать. 
			alloc.construct(ptr, args...);				// То вызываем его, потому что он может быть нестандартным
		} else {
			new (ptr) U(args...);
		}
	}
	
	// Аналогично есть функция destroy, которая примерно также выглядит.
	// Ещё здесь есть метафункция rebind_alloc, которая работает как rebind для всех аллокаторов. Аллокатор может написать свой rebind, и тогда allocator_traits::rebind_alloc 
	// 	будет обращаться к нему. Если в аллокаторе нет своего rebind, то в allocator_traits есть мета функция rebind_alloc, которая делает то, что делала бы функция
	//	rebind в аллокаторе. 
	// Так же ещё в allocator_traits есть методе allocate и deallocate для унификации, чтобы всё можно было делать в allocator_traits.
};


Все методы в allocator_traits статические. Например construct статический, потому что объектов allocator_traits мы никогда не создаём. allocator_traits это такой набор 
метафункций, мы не создаём объектов allocator_traits, мы только обращаемся к нему как к некоторым метафункциям.


Теперь мы можем дополнить схему стек вызовов:

 Container -> allocator_traits -> Allocator -> operator new -> malloc() -> OS

Задача: написать лист с кастомным аллокатором и одним из главных требований будет чтобы этот лист работал быстрее чем этот лист со стандартным аллокатором. Профит в том, что 
когда мы делаем лист на стековом аллокаторе, и делаем очень много вставок и удалений, это будет работать гораздо быстрее, чем лист со стандартным аллокатором, потому что 
стандартный аллокатор подразумевает вызов оператора new на каждый insert. 


Снова вернёмся к реализации вектора и снова переработаем её. Теперь вектор всё должен вызывать через allocator_traits. По стандарту с C++11 все обращения к аллокатору идут через
allocator_traits.


template <typename T, typename Alloc = std::allocator<T>>
class vector {
	T* arr_;
	size_t sz_;
	size_t cap_;
	Alloc alloc_;				

	using AllocTraits = std::allocator_traits<Alloc>;				// Новый юсинг

private:	
	template <bool IsConst>
	class base_iterator {
	public:
		using pointer_type = std::conditional_t<IsConst, const T*, T*>;		// Тип указателя
		using reference_type = std::conditional_t<IsConst, const T&, T&>;	// Тип ссылки
		using value_type = T;							// value_type говорит нам о том, какой тип лежит в контейнере.
	
	private:	
		pointer_type ptr;
		base_iterator(T* ptr): ptr(ptr){}

		friend class vector<T>;			
	public:
		base_iterator(const base_iterator&) = default;		
		base_iterator& operator=(const base_iterator&) = default; 

		reference_type operator*() const {				
			return *ptr;	
		}
		pointer_type operator->() const {				
			return ptr;
		}

		base_iterator& operation++() { 			
			++ptr;	
			return this;
		}
		base_iterator operator ++(int) {			
			base_iterator copy = *this;
			++ptr;
			return copy;
		}

		operator base_iterator<true>() const {
			return {ptr};
		}		
	};


public:
	using iterator = base_iterator<false>;					// Итератор
	using const_iterator = base_iterator<true>;				// Константный итератор
	using reverse_iterator = std::reverse_iterator<iterator>;		// Реверс итератор
	using const_reverse_iterator = std::reverse_iterator<const_iterator>;	// Константный реверс итератор
	
	iterator begin() {			// begin с обычным итератором
		return {arr_};
	}
	
	iterator end() {			// end с обычным итератором
		return {arr_ + sz_};
	}

	const_iterator begin() const {		// begin с const_iterator
		return {arr_};
	}

	const_iterator end() const {		// end с const_iterator
		return {arr_ + sz_};
	}

	const_iterator cbegin() const {		// cbegin() возвращает const_iterator для любого контейнера (имеется ввиду неконстантного и константного)
		return {arr_};
	}

	const_iterator cend() const {		// cend() возвращает const_iterator для любого контейнера
		return {arr_ + sz_};
	}


	void reserve(size_t newcap) {
		if (newcap <= cap_)							
			return;

		T* newarr = AllocTraits::allocate(alloc, newcap);				// Новая реализация с учётом allocator_traits 
			
		size_t index = 0;
				
		try {
			T* newarr = reinterpret_cast<T*>(new char[newcap * sizeof(T)]); 	
			for(; index < sz_; ++index) {				
				AllocTraits::construct(alloc, newarr + index, arr_[index]);	// Новая реализация с учётом allocator_traits 
			}		
		} catch(...) {
			for(size_t oldindex = 0; oldindex < index; ++oldindex) {
				AllocTraits::destroy(alloc, newarr + oldindex);			// Новая реализация с учётом allocator_traits 
			}
			AllocTraits::deallocate(alloc, newarr, newcap);				// Новая реализация с учётом allocator_traits 
			throw;
		}		
	
		for (size_t index = 0; index < sz; ++index) {				
			AllocTraits::destroy(alloc, arr_ + index);				// Новая реализация с учётом allocator_traits 
		}
		AllocTraits::deallocate(alloc, arr_, cap);					// Новая реализация с учётом allocator_traits 

		arr_ = newarr;								
		cap_ = newcap;								
	}	

	void push_pack(const T& value) {			
		if(sz == cap_) {
			reserve(cap_ > 0 ? cap_ * 2 : 1); 	
		}
	}
};



______________________________________________________________________________________
Allocator aware containers (Контейнер заботящийся об аллокаторе)

На самом деле пока мы реализовывали все контейнеры которые мы изучили, мы не думали правильно об аллокатре. Даже вектор с реализацией allocator_traits это вcё ещё не считается что
мы правильно используем аллокатор. Allocator aware containers должен ещё думать о некоторых других неочевидных вопросах, когда работает с аллокатором. Какие ещё проблемы связанные
с аллокаторами появляются, когда мы реализовываем контейнер? Мы уже поняли что всё нужно делать через аллокатор, вызывать allocator_traits постоянно, но что входит в понятие 
allocator aware containers кроме того, что всё нужно вызывать через аллокатор? 

Что должен делать контейнер когда он копируется? Он должен копировать аллокатор, или он должен создавать новый аллокатор такого же типа но по умолчанию? В этом вопросе всё не так 
однозначно. Иногда нам могло бы хотется, чтобы контейнер копировал аллокатор, а иногда нам бы хотелось чтобы контейнер создавал новый аллокатор при своём копировании, а не
копировал исходный аллокатор. Копирование аллокатора это дешёвая операция, и это значит сделать второй аллокатор, который будет указывать на тот же пул, что и исходный аллокатор. 
Но может быть мы хотим чтобы при копировании контейнера происходило не это, а создавался новый пул под этот контейнер. Контейнеру нужно решить как вести себя с аллокатором:
делать копию аллокатора или делать новый аллокатор. Ответить на этот вопрос ему должен сам аллокатор, т.е. контейнер при своём копировании спрашивает у аллокатора что с ним 
делать. И для этого существует специальный метод select_on_container_copy_construction(). Этот метод есть в allocator_traits, но его может определить и сам аллокатор. Он 
возвращает аллокатор по значению, и он вызывается контейнером, когда контейнер копируется. Он может вернуть копию исходного аллокатора, либо создать новый аллокатор. В зависимости
от этого при копировании контейнера у нас будет либо копироваться аллокатор либо создаваться новый, и в терминах пула если у нас пулл аллокатор, это значит либо новый контейнер
будет на том же пуле или на новом пуле памяти. Если мы не определим в аллокаторе этот метод то allocator_traits доопределить его автоматически и по умолчанию он будет возвращать
исходный аллокатор. 

Аналогичный вопрос возникает при присваивании контейнера. У аллокатора есть метафункция(структура )propagate_on_container_copy_assignment. Эта мета функция ничего не должна 
возвращать, там просто либо true либо false должно быть написано в компайл тайме, т.е. либо она является std::true_type или std::false_type. std::true_type это структура в которой
просто написано static const bool value = true; И вот когда мы присваиваем один контейнер к другому мы должны посмотреть на вот эту метафункцию, а если там true то присвоить 
аллокатор, а иначе не трогать аллокатор. 


Представим что мы пишем оператор присваивания у вектора (Присваиваем вектору другой вектора):

// В классе вектора
vector& operator=(const vector other) {
	T* newarr = AllocTraits::allocate(alloc_, other, cap_);			// Выделили память под cap штук объектов типа T
	size_t i = 0;
	try {
		for (; i < other.sz_; ++i) {				// Проходим по всему вектору
			AllocTraits::construct(alloc_, newarr + i, other[i]);	// Копируем
		}
	} catch (...) {
		for (size_t j = 0; j < i; ++j) }
			AllocTraits::destroy(alloc_, newarr + j);
		}
		AllocTraits::deallocate(alloc_, newarr, ther.cap_);
		throw;
	}	
	
	for (size_t i = 0; i < sz_; ++i) {
		AllocTraits::destroy(alloc_, arr_ + i);
	}
	AllocTraits::deallocate(alloc_, arr_, cap_);

	arr_ = newarr;
	sz_ = other.sz_;
	cap_ = other.cap_;
}

Это хорошая реализация оператора присваивания. Однако все ровно есть проблемы: мы не учитываем тот факт, что нам может быть нужно взять чужой аллокатор. Мы здесь написали 
реализацию оператора присваивания, а аллокатор не присвоили себе. Представим что у нас вектор на каком то пуле, т.е. аллокатор берёт память из какого то пула. И другой вектор с
аллокатором на каком то другом пуле. И вот мы делаем присваивание и у нас при такой реализации получится что мы выделяем память на своём собственном пуле, а не на пуле другого 
ветора. В принципе это разумно но это учитывает не все случаи, при такой реализации аллокатор намертво привязан к контейнеру, его никто не подменит, мы присвоили контейнер, а 
аллокатор остался тем же. Но вектор в stl должен учитывать возможность забрать себе тот аллокатор. Поэтому нам нужно добавить точку кастомизации, нам нужно либо присваивать 
аллокатор либо неприсваивать в зависимости от того, propagate_on_container_copy_assignment true или false. Данная реализация была для случая когда он false, т.е. мы не забираем
чужой аллокатор себе. Представим что propagate_on_container_copy_assignment равняется true. 

Для того чтобы решить копировать аллокатор при присваивании или не копировать, нужно спросить сам аллокатор. Тут мы приходим к очень важно проблеме: мы должны свои старые объекты
удалять старым аллокатором, а новые объекты выделить уже новым аллокатором, но при этом для гарантии безопасности старые объекты мы должны удалить позже, чем выделили новые 
объекты. Если propagate_on_container_copy_assignment == false мы работаем со всеми методами нашим старым аллокатором, а если == true, то мы выделение памяти, конструирование мы 
делаем новым аллокатором, а освобождение делаем старым аллокатором. В конце метода мы присваиваем нашему аллокатору новый аллокатор (для случая == true). 

Однако у нас появляется ещё одна проблема: что если возникнет исключение при самом присваивании alloc_ = newalloc? Эта проблема решена радикальным образом: в требованиях аллокатора
оператор присваивания не кидает исключений, как и в конструкторе копирования. 

// В классе вектора
vector& operator=(const vector other) { 
	Alloc newalloc = AllocTraits::propagate_on_container_copy_assignment::value ?	// Выбираем какой alloc будет старый или новый
		other.alloc_ : alloc_;
	
	T* newarr = AllocTraits::allocate(newalloc, other, cap_);			// Выделили память под cap штук объектов типа T
	size_t i = 0;
	try {
		for (; i < other.sz_; ++i) {					// Проходим по всему вектору
			AllocTraits::construct(newalloc, newarr + i, other[i]);		// Копируем
		}
	} catch (...) {
		for (size_t j = 0; j < i; ++j) }
			AllocTraits::destroy(newalloc , newarr + j);
		}
		AllocTraits::deallocate(newalloc , newarr, ther.cap_);
		throw;
	}	
	
	for (size_t i = 0; i < sz_; ++i) {
		AllocTraits::destroy(alloc_, arr_ + i);
	}
	AllocTraits::deallocate(alloc_, arr_, cap_);

	arr_ = newarr;							// nothrow
	sz_ = other.sz_;
	cap_ = other.cap_;
	alloc_ = newalloc;							// Присваиваем новый аллокатор старому аллокатору.
}

Почему мы должны особождать тем же аллокатором, что и выделяли? У всех стандартных аллокаторов есть оператор сравнения и все стандартные аллокаторы равны. Однако если мы имеем дело
с нестандартными аллокаторами, то они уже не все равны. Аллокаторы считаются равными, если одним из них можно удалить то, что было выделено другим. Т.е. если у нас аллокаторы на пуле, то
они заведуют одним и тем же пулом, тогда они считаются равными. У нас могут быть два разных инстанса пул аллокатора, один смотрит на один пул, другой смотрит на другой пул, тогда мы не 
сможем освобождать первым аллокатором второй пул(и вторым аллокатором первый пул), это будет UB. Поэтому нам нужно чтобы аллокаторы были равны, прежде чем одним из них освобождать
то что было выделено другим. При копировании аллокатора должен получаться равный аллокатор.

Некоторые виды аллокаторов всегда равны друг другу и тогда не нужно этой возни с присваиванием одного аллокатора другому.  Допустим мы присвоили аллокатор, и оказалось что они всё ещё 
равны, новый аллокатор оказался равен старому аллокатору, тогда нет смысла удалять старую память и выделять новую память. В этом случае можно посмотреть а не хватает ли нам уже старой 
памяти, и на этой же памяти тем же самым аллокатором старое удалить и чтото новое сконструировать (Переиспользовать старую память). Получается что в первую очередь нам нужно проверить
равен ли новый аллокатор старому аллокатору, прежде чем выяснять нужно ли присваивать аллокатор. Т.е. сначала мы проверяем равны ли аллокаторы, потом только проверяем нужно ли 
присваивать аллокатор. Удаление старой памяти и выделение новой нужно, только если аллокатор нужно менять и ещё они не равны. 

В allocator_traits может быть метафункция is_always_equal которая в некоторых аллокаторах определена, и она просто говорит что аллокаторы равны и не нужно их сравнивать. Например все 
стандартные операторы равны, и ненужно вызвывать оператор сравнения, если можно просто в компайлтайме просто вызвать эту метафункцию, и таким образом не проверять аллокаторы на 
равенство. И только если это false, тогда нужно делать всё что мы написали выше. 



______________________________________________________________________________________
###################################################################
______________________________________________________________________________________
Перегрузка операторов new и delete в базовом сценарии

new overloading

Перегрузка операторов new и delete это более низкоуровневая вещь, чем переопределение аллокаторов. Все контейнеры взаимодействуют с new и delete только через аллокаторы, и если мы 
хотим высокоуровнево переопределить управление памятью для контейнеров, мы можем подменить аллокатор с помощью ООП. Но также мы можем сделать достаточно низкоуровневое 
действие, подменив глобальный оператор new. Подмена глобального оператора new будет означать, что все наши аллокаторы, которые чтото выделяют с помощью new, будут теперь это делать 
подругому.

Важная мысль про оператор new: Оператор new состоит из двух частей, первая из которых занимается выделением памяти, вторая вызовом конструктора на выделенной памяти, и перегрузить
можно только первую часть. Когда мы вызываем оператор new в стандартной форме, последовательно происходит две вещи: выделение памяти затем вызов конструктора (или конструкторов) типа 
T на этой памяти, и переопределить можно только первую часть. Нельзя сделать так чтобы оператор new не вызвал конструктор типа T, но можно сделать так что он не будет выделять память,
но тогда он вызовет конструктор на невыделенной памяти и это UB. Оператор new в любом случае вызовет конструктор по какому то поинтеру, и мы можем лишь переопределить что это будет
за поинтер. 

Первая часть оператора new - это функция operator_new, т.е. как раз эта функция выделяет память. Оператор new это не тоже самое что и ФУНКЦИЯ operator_new. Мы можем переопределить 
функцию operator_new, но это не тоже самое что оператор new (как я понял функция входит в состав оператора). Вот как раз эту функцию мы и будем переопределять. 

Оффтоп про placement new:
У placement new как раз отсутствует первая часть. placement new это такой new у которого отсутствует первая часть, но конструктор вызывается всё ровно. 

void* ptr = ...;		// Указатель на УЖЕ ВЫДЕЛЕННУЮ память
T* obj = new (ptr) T(args...);	// Создаём объект T по адресу ptr

Здесь T* obj = new (указатель на уже выделенную память) T(значение объекта);

Пример 1 (Chat GPT): Использование placement new с аллокаторами:

std::allocator<int> alloc;
int* ptr = alloc.allocate(1);	// Выделяем память под 1 int 
new (ptr) int(42);		// Конструируем int на выделенной памяти

// что то делаем с ним

p->~int();			// Вызываем деструктор вручную
alloc.deallocate(ptr, 1);	// Освобождаем память


Пример 2 (Chat GPT): Использование placement new с нестандартными типами

struct MyClass {
	int x;
	MyClass(int val): x(val) {}
	~MyClass(){}
};

int main() {
	alignas(MyClass) char buffer[sizeof(MyClass)];	// Выделяем память вручную. (alignas(MyClass) гарантирует, что buffer имеет правильное выравнивание для MyClass.
	MyClass* obj = new (buffer) MyClass(42);	// Конструируем объект в этом буфере
	
	// Что то делаем с этим

	obj->MyClass();				// Явно вызываем деструктор (В данном случае память освобождать не нужно)
}


ВАЖНО! 
1. Нужно явно вызывать деструктор. Если объект использует динамическую память, утечка неизбежна без вызова деструктора ~T().
2. placement new не выделяет память, поэтому освобождать нужно только сам объект (с помощью деструктора), а не память!
3. Нельзя вызывать delete на объекте, созданном через placement new, т.к. он ен был выделен new (free тоже).

Продолжаем.

Переопределение глобального оператора new:	(то реализация оператора new на оценку тройку)

void* operator_new(size_t n) {			// Это примитивные примеры переопределения. Стандартная функция выглядить не так.
	std:cout << n << " bytes allocated\n";
	return malloc(n);
}

Переопределение оператора delete:

void operator_delete(void* ptr) {
	free(ptr);
}


operator_new() и operator_new[]() это два разных оператора. Стандартный operator_new[]() просто в себе вызывает operator_new().

Переопределение operator_new[]:

void* operator_new[](size_t) {
	std::cout << n << " [] bytes allocated\n";
	return malloc(n);
}

Переопределение оператора delete[]:

void operator_delete[](void* ptr) {
	free(ptr);
}


Что будет если после такого переопределения мы попробуем создать вектор и добавить в него несколько элементов? Что нибудь выведется?

int main() {
	std::vector<int> v;
	for(int i = 0; i < 50; ++i) {
		v.push_back(i);
	}

	int* p = new int[100];
	delete[] p;
}

В консоль выведется следующее:
4 bytes allocated
8 bytes allocated
16 bytes allocated
32 bytes allocated
64 bytes allocated
128 bytes allocated
256 bytes allocated
400[] bytes allocated

n в operator_new(size_t n) это число байт, т.е. в эту функцию приходило числа, не кол-во сколько штук выделить, а сколько памяти выделить в байтах. 


Почему вектор вызывает просто operator_new() а не operator_new[](). Аллокатор сам вызывает эту функцию. Функция operator_new[]() это лишний оператор, который никогда не нужен на самом
деле, его никто не вызывает напрямую. Если нам нужно выделить сколько то байт памяти используя new, мы просто говорим operator_new(число байт) - это не вызывает конструктор.

Здесь мы можем вернуться обратно к реализации вектора, а точнее аллокатора. В функции allocate раньше мы вызывали оператор new[]: 
new char[count * sizeof(T)], который сначала вызывает функцию operator_new()[], а потом вызывает конструкторы данного типа в нужном количестве. Теперь мы можем изменить реализацию:

template <typename T>
struct allocator {
	T* allocate(size_t count) {
		//new reinterpret_cast<T*>(new char[count * sizeof(T)]); 	// Это кринж. Создаём массив чаров и потом его кастим к типу T.
		return operator new(count * sizeof(T)); 			// Новая реализация. Мы явно просим сделать только первую часть оператора new, без вызова конструкторов.
	}
	void deallocate(T* ptr, size_t count) {
		//delete[] reinterpret_cast<char*>(ptr);			// Это кринж
		operator delete(ptr);					// Просим сделать вторую часть оператора delete.
	}
	//...
}


Чтобы вызвать только вторую часть new:

template <typename U, typename... Args>		
	void construct(U* ptr, const Args&... args) {		
		new (ptr) U(args...);			// Вызов конструктора без выделения памяти	
	}


Когда мы пишем delete, сначала вызывается деструктор объекта, а потом на этом указателе вызывается функция operator_delete. Когда мы пишем delete[], сначала вызываются деструкторы в 
нужном количестве, а потом по этому указателю вызывается функция operator_delete[]. Т.е. алгоритм проходит по каждому объекту и вызывает у него деструктор. Вопрос, а как operator_delete[]
понимает сколько деструкторов вызвать? В нужном количестве это в каком, ведь ему дали только поинтер? 

int main() {
	std::cout << sizeof(std::string) << '\n';
	std::string* ps = new std::string[10];
	delete[] ps;
}

Мы видим такой вывод:
32				// Это sizeof(std::string)
328 [] bytes allocated		// Это operator_new[]()

Мы попросили выделить 10 строк, каждая из которых весит 32 байта. 10 * 32 = 320, а у нас выделилось 328. На самом деле, когда мы выделяем нетривиальный тип (типы у которых существуют
деструкторы), operator_new[]() нужно где-то записать сколько штук их было, чтобы оператор delete[] знал сколько деструкторов вызвать. operator_new[]() хранит это число перед началом массива.

Когда мы используем delete[], под капотом за нас в в operator_delete[] приходит указатель уже сдвинутый на 8, относительно начала нашего массива, потому что до того как мы пришли в 
operator_delete[], было вызвано n деструкторов. 

Пример:
Почему так? У нас есть класс Example, который хранит поинтер, в конструкторе new int, в деструкторе delete. Далее в main мы говорим что такое example: выделяем массив char размером Example,
и скастили указатель на example. Дальше во второй строчке по адресу example вызвали конструктор. Потом вызвали деструктор, и потом вызвали operator_delete[] от example. Это всё 
компилируется. Но, если мы закоментируем первые две строки в main, и раскоментируем строку 3, то будет CE. Казалось бы, что здесь не так? Мы создаём указатель на массив example размера 1,
потом вызываем вручную деструктор нулевого элемента этого массива, затем вызываем operator_delete[] от адреса. 


#include <new>

struct Example {
	int* x;
	Example(): x(new int) {}
	~Example() { delete x; }
};

int main() {
	// OK
	Example* example = reinterpret_cast<Example*>(new char[sizeof(Example)]);	//OK
	new (example) Example();

	// Example* example = new Example[1]; 					// Not OK, but why?

	example[0].~Example();
	operator_delete[](example);
}

Что не так? Мы передали в operator_delete[] несдвинутый example, потому что на самом деле, когда мы выделили память так: Example* example = new Example[1], new записал ещё 8 байт (в нашем 
случае число 1), которое говорит что память выделена под 1 объект. Когда мы создавали массив экзамплов как массив чаров скастованных к типу Example, то в operator_delete[]() мы его и 
передавали с квадратными скобочками, и мы попадали на тот же адрес, с которого начинался массив. Но когда мы стали создавать его сразу как массив Example с помощью new без лишник кастов,
а потом вручную решили вызвать деструктор и operator_delete[] вместо того чтобы написать просто delete[], мы промахнулись с адресом, потому что оказывается operator_delete[] неявно за нас 
делает сдвиг на 8 байт если тип был нетривиальным (у которого нужно вызывать деструктор). При использовании просто new без квадратных скобочек такой фигни не происходит.


#######################
Версии оператора new

У функции operator new есть множество перегрузок с разными параметрами:

void* operator new (std::size_t count, const std::nothrow_t& tag);
void* operator new[] (std::size_t count, const std::nothrow_t& tag);

std::nothrow_t это такой тип называемый тэгом (tag) - проще говоря это пустая структура, она нужна для того чтобы объявить переменную std::nothrow. Это нужно для того чтобы была версия 
оператора new который не бросает исключения. Существует версия оператора new, которая не бросает исключения, а просто возвращает nullptr если не получилось выделить память.

int* p = new(std::nothrow) int[100000000ul];
if (p == nullptr) {
	break;
}

Бывает new с произвольными параметрами. Такой new мы можем написать сами. size_t count сам неявно придётсамо придёт первым параметром, остальные параметры передаём вручную. Однако 
нужно будет правильно очистить память после такого объявления. Просто запись delete p; приведёт к утечке памяти, потому что если мы вызвали new с кастомными параметрами, то мы должны
вызывать и delete с таким же набором кастомных параметров. Т.е. delete должен вызваться с такой же сигнатурой, параметры должны быть такого же типа как и вызов new, однако численно они
могут отличаться.  

void* operator new (std::size_t count, user-defined-args...);

Например:

void* operator new (std::size_t count, int a, double b){
	std::cout << count << " bytes allocated with custom new" << a << ' ' << b << '\n';
	return malloc(count);
}

int main() {
	int* p = new(1, 3.14) int(5);	// Такой синаксис приведёт к тому, что будет вызвана наша новая реализация функции new с двумя доп. параметрами.
	
	// delete p; 			// Так неправильно UB.
}

Однако тут новая проблема - у опреатора delete нет синтаксиса вызова с кастомными параметрами, и поэтому его можно вызывать только так:

void* operator new (std::size_t count, int a, double b){
	std::cout << count << " bytes allocated with custom new" << a << ' ' << b << '\n';
	return malloc(count);
}

void operator delete(void* ptr, int a, double b) {
	std::cout << "Coustom delete called" << a << ' ' << b << '\n';
	return free(ptr);
}

int main() {
	int* p = new(1, 3.14) int(5);	// Такой синаксис приведёт к тому, что будет вызвана наша новая реализация функции new с двумя доп. параметрами.
	
	operator delete(p, 1, 5.25);
}

Если бы в параметре new был бы нетривальный тип, у которого есть конструктор и деструктор, то тогда нужно было бы вручную вызывать деструктор такого объекта, а только потом вызывать
оператор delete.

Однако существует случай когда компилятор автоматически вызывает оператор delete с кастомными параметрами. Представим класс, который в конструкторе кидает исключение, и мы решили
создать такой объект с помощью нестандартного new. Загоняем создание такого объекта под try. Мы вызываем new с кастомными параметрами, new сначала вызывает функцию operator_new(),
которая отрабатывает успешно, потом вызывает на этом месте конструктор S, но он кидает исключение. И вот у нас ситуация, что оператор new уже отработал, а конструктор кинул исключение.
В этот момент должен вызвать какой то оператор delete, потому что мы уже выделили память и её нужно очистить. Если мы в динамической памяти с помощью оператора new создаём какой-то
объект, и конструктор кидает исключение, то стандарт гарантирует нам, что под капотом за нас будет вызван оператор delete, от таких же параметров на этом же адресе, и только после этого
исключение полетит. Т.е. сейчас будет вызван кастомный оператор delete с теме же параметрами, с которыми был кастомный оператор new. Это гарантирует компилятор, иначе невозможно было 
бы с помощью new выделять объекты, которые могут кидать исключения.


struct S {
	S() { throw 1; }
};

int main() {
	try {
		S* p = new(1, 3.14) S();
	} catch(...) {
		std:: cout << "caught!";
	}
}


Что если бы мы например вызвали оператор new[] на 10 объектов и пятый из них кинул бы исключение? Вызвались ли деструкторы предшедствующих объектов? Да должны вызваться деструкторы
тех объектов, которые уже были созданы, и это опять должен сделать компилятор за нас.

struct S {
	inline static int count = 0;		// C++17.  Определяем переменную прям внутри класса, поскольку статические неконстантные переменные внутри класса определять нельзя.
	S() {
		++count;
		if(count == 5)
			throw 1;
		std::cout << "created S\n";
	}
	~S() {
		std::cout << "destroyed S\n";
	}
}; 

int main() {
	try {
		S* p = new S[10];
	} catch(...) {
		std:: cout << "caught!";
	}
}


Рассмотрим такую ситуацию, всё ли здесь нормально? 

struct Base {
	Base() { std::cout << "create Base\n"; }
	~Base() { std::cout << "destroyed Base\n"; }
};

struct Derived: public Base {
	Derived() { std::cout << "create Derived\n"; }
	~Derived() { std::cout << "destroyed Derived\n"; }
};

int main() {
	Base* b =new Derived;
	delete b;
}

Здесь указатель имеет тип базового класса, однако мы присваиваем тип наследуемого класса, мы так можем сделать. Указатель типа базового класса будет указывать на наследуемый класс. Однако 
поскольку деструктор базового класса Base невиртуальный, при delete p вызовется только деструктор базового класса Base, а деструктор наследуемого классе Derived невызовется. Будет 
некорректное поведение, потому что delete сначала вызывает деструктор, а потом освобождает память. А если к тому же в Derived выделялись какие либо ресурсы то они не освободятся и будет 
происходить утечка памяти:

struct Derived: public Base {
	int* p;
	Derived() { 
		p = new int;			// Выделяем память в конструкторе наследуемого класса
		std::cout << "create Derived\n";
	}
	~Derived() { 
		delete p;				// Очищаем память. Однако в нашем случае этот деструктор не будет вызван. Утечка памяти.
		std::cout << "destroyed Derived\n"; 
	}
};

Почему это некорректное поведение? Откуда оператор delete знает какой деструктор ему вызвать, и по какому поинтеру ему нужно освободить память? Представим что мы выделяем массив из
Derived:

struct Derived: public Base {
	Derived() { std::cout << "create Derived\n"; }
	~Derived() { std::cout << "destroyed Derived\n"; }
};

int main() {
	Base* b = new Derived[10];
	delete[] b;
}

delete[] должен сходить посмотреть какое кол-во Derived в массиве, и вызвать деструкторы поочереди. Но даже при условии что у нас нет никаких нетривиальных ресурсов, выделяемых в
Derived, это всё ровно некорректный код, потому что, delete[] идёт и вызывает деструкторы по этому массиву, думая что этот массив состоит из классов Base, а потом вызывает освобождение
памяти, думая что в массиве были Base, а не Derived. Если деструктор невиртуальный, то он никак не поймёт что за класс там был на самом деле, а следовательно все свои действия он будет 
совершать, думая что там класс Base: и кол-во памяти, которое под них выделено, и отступать вызывая деструкторы он будет по другим адресам, не по правильным, и код будет вызывать только 
деструктора Base. Поэтому это UB и это причина использования виртуального деструктора. 
Лекция 37 21.00 Видимо с delete[] даже с виртуальным деструктором это неработает!!!


Оператор new можно доопределить для своих типов. Например для этой структуры S мы можем её собственный оператор new написать. Тогда именно при выделении объектов S будет вызываться
этот оператор new, но глобально будет попрежнему вызываться старый оператор new. Все методы относящиеся к операторам new и delete, которые являются членами класса, считаются static 
поумолчанию. 

struct S {
	inline static int count = 0;	

	void* operator new(size_t = 0) {		// Прямо в классе оперделяем новый new. Это статические методы, static по умолчанию.
		std::cout << "operator new for S\n";
		return malloc(n);
	}
	void operator delete(void* ptr) {		// также определяем delete
		std::cout << "operator delete for S\n";
		return free(ptr);
	}

	void* operator new[](size_t = 0) {		// Прямо в классе оперделяем новый new[]
		std::cout << "operator new[] for S\n";
		return malloc(n);
	}
	void operator delete[](void* ptr) {		// также определяем delete[]
		std::cout << "operator delete[] for S\n";
		return free(ptr);
	}
	
	S() {
		++count;
		if(count == 5)
			throw 1;
		std::cout << "created S\n";
	}
	~S() {
		std::cout << "destroyed S\n";
	}
}; 

int main() {
	S* p = new S();
	delete p;

	S* p2 = new S[3];
	delete[] p2;
}



########################
Правильная реализация оператора new в STL (Стандартная реализация)
Лекция 37. 34:49 - ССЫЛКА НА ВСЕ СТАНДАРТНЫЕ РЕАЛИЗАЦИИ STL В LLVM

Предыдущая реализация много чего не учитывает, например здесь нет throw bad_alloc, если не получилось выделить память. 

В реализации оператора new нельзя выделить 0 байт, если мы скажем выделить оператору new 0 байт, то он всё ровно выделит 1 байт, потому что в C++ есть требование, что все объекты должны 
иметь разные адреса.

В случае неудачного выделения памяти оператор new кидает исключение, однако есть ещё один промежуточный слой - функция new_handler. Эта указатель на функцию из стандартной 
библиотеки, предназначение которой попытаться чтото сделать, прежде чем будет брошено bad_alloc в случае неудачного выделения памяти оператором new. По умолчанию по этому указателю 
там записан nullptr, поэтому ничего не вызывается и сразу кидается bad_alloc, но мы можем переопределить поведение оператора new ещё и на этой стадии. Есть такая функция
std::set_new_handler() (именно set а не get) и передать адрес какой то функции, и тогда эта функция будет вызываться оператором new в стандартном случае, если у него не удалось выделить 
память, вместо того, чтобы сразу бросать bad_alloc.

Крутимся в цикле пока нам удасться выделить память, т.е. пока можем, вызываем new_nandler (пока он есть, пока нам не повезло). Как только у нас получилось выделить память, или мы увидели что
std::new_nandler nullptr, мы выходим из цикла и возвращаем указатель. 

// Реализация оператора new
static void* operator_new_impl(std::size_t size) {
	if(size == 0)						// Нельзя выделить 0 байт
		size = 1;
	void* p;
	while((p = std::malloc(size)) == nullptr) {				// Запуск цикла. Пока указатель, полученный из malloc, равен nullptr. 
		// Если malloc фэйлится и у нас есть new_handler		
		// мы попытаемся вызвать std::new_handler 
		std::new_nandler nh = std::get_new_handler();
		if (nh)
			nh();
		else
			break;
	}
	return p;
}

// Точка входа в оператор new
_LIBCPP_MAKE_OVERRIDABLE_FUNCTION_DETECTABLE  _LIBCPP_WEAK void* operator new(std::size_t size) _THROW_BAD_ALLOC {
	void* p = operator_new_impl(size);
	if(p == nullptr)
		_throw_bad_alloc_shim();
	return p;
}

Остальные версии оператора new более мение выражаются через исходную версию. 

_LIBCPP_WEAK - это макрос, который делает слабый символ (который можно переоперделить). Как можно переопределять оператор new если в стандартной библиотеке уже есть определение
оператора new, ведь это наружает ODR - one definition rule, типо у нас уже есть определение оператора new в стандартной библиотеке, и вдруг мы определяем такой же оператор new с такой же
сигнатурой в той же глобальной области видимости, почему это работает и не оказывается ошибкой линкера? Потому что есть специальный вид функций, который помечен этим макросом
_LIBCPP_WEAK, который при переопределении просто замещаются, а не кидают ошибку линкера. Если у нас функция в стандартной библиотеке помечена этим макросом, то эта функция, когда
линковщик видет второе определение, он не кидает ошибку линкера, он просто забывает старое и использует новое, и поэтому оператор new можно переопределять. 


########################
Интересные вопросы:

Вопрос 1: Представим что у нас есть какой то тип, и мы хотим запретить создавать объекты этого типа на куче(динам. память), а хотим разрешить создавать только на стеке, что делать? Для этого 
типа мы можем опеределить свой оператор new, который будет равен delete, т.е. пропишем что для данного типа оператор new вызывать нельзя. Понято что мы можем в ручную с malloc и кастами
этого всё ровно добиться.

Вопрос 2: Представим что у нас есть какой то тип, и мы хотим запретить создавать объекты этого типа на стеке, т.е. хотим разрешить создавать только на куче, что делать? Один из способов
запретить создавать объекты на стеке заключаетсяв том, чтобы сделать деструктор приватным. Тогда его нельзя будет создать на стеке, потому что создание объекта на стеке подрузамевает 
автоматическую возможность вызова деструктора из него. Неважно сколько будет конструкторов, главное чтобы деструктор был приватным, ведь деструктор всего один. И на стеке такой объект
создать будет нельзя, но как добиться того чтобы этот объект можно было создавать на куче? Проблема будет в том что мы не сможем вызвать обычный delete, потому что когда мы вызываем
delete, он автоматически вызывает деструктор, а потом освобождает память. Если мы вызываем только operator_delete, то ктото за нас должен вызвать деструктор, а деструктор приватный вызвать
мы не можем. В C++20 был добавлен специальный оператор delete для решения этой проблемы: destroy deallocation functions. Данный delete имеет доп. параметр (тег) std::destroying_delete_t:

void T::operator delete (T* ptr, std::destroying_delete_t);

Эта функция, которая, будучи вызванной, избавляет нас от необходимости вызывать деструктор, т.е. если мы вызываем delete с этим доп. параметром, то это работает по другим правилам нежели
обычный delete, и деструктор автоматически тогда не вызывается уже, и мы сами в этой функции обязаны вызвать деструктор. На стеке мы не можем её вызвать, но мы можем это сделать на куче
потому что, ну например мы сделаем эту функцию другом для какого нибудь своего класса. Т.е. начиная с C++20 мы можем сказать что мы не хотим чтобы автоматически вызывался деструктор
за нас, а мы можем сами вызывать его в функции operator delete, передав туда std::destroying_delete_t. Т.е. нам нужно будет переоперделить оператор delete с таким параметром для своего типа, 
нам даже не нужно делать его френдом потому что это и так метод нашего класса, а деструктор сделать приватным.


______________________________________________________________________________________
Выравнивание и битовые поля (Alignments and bit fields)

Что не так со следующим кодом?

int main()  {
	int* a = new int[10];			// Создаём 10 int
	char* ac = reinterpret_cast<char*>(a);	// Кастим к указателю на char
	++ac;				// Инкрементируем указатель на char
	int* b = reinterpret_cast<int*>(ac);	// Указатель на char кастим обратно к указателю на int 

	*b = 1;
	int x = *b;
	std::cout << x;

	delete[] a;
}

Если этот код скомпилировать и запустить то вс нормально, но если запустить с санитайзерами, то код падает по той причине, что указатель на int должен быть кратен 4 байтам.  У нас возникает 
следующая проблема: у нас есть int который лежит по адресу начинающегося с некратному четырём.  Без санитайзера это бы отработало, но по стандарту это UB, потому что не все процессоры 
умеют так делать. У процессора память побита на кусочки размера например 8 байт, и если у нас int частью себя залез на одно 8-ми байтовое слово и другой частью на другое 8-ми байтовое 
слово, не все процессоры в состоянии на уровне асемблера прочитать такой int, т.е. не все процессоры умеют читать int по адресам на стыке двух машинных слов. Некоторы процессоры могут 
прочитать одно слово затем другое слово и склеить из них int, но нектороые процессоры неумеют так делать, и когда они видят что им нужно считать int который невлезает целиком в машинное 
слово, просто кидают исключение в процессоре и мы падаем с настоящим рантайм эррор. И вот поэтому так делать нельзя, потому что на некоторых процессорах код выше может упасть.  

С этой проблемой можно столькнуться например при написании своего стекового аллокатора. Когда мы выделили массив char а потом пошли выделять на нём int-ы, а потом например мы захотели 
создать из этого аллокатора аллокатор на double и идти выделять double. Выделяем 3 int, потом создаём из этого аллокатора аллокатор на double копией, а потом пойдём выделять double, 
получится  так, что если мы подряд выделяем у нас double ляжет на адрес не кратный 8-ми и всё упадёт. Пока мы не писали кастомный аллокатор, мы могли не думать про эту проблему, всё что 
выделяем оно автоматически выровнено как надо. Но когда мы пишем свой аллокатор в котором мы сами на стеке отсчитываем байты, нам нужно следить, чтобы если из нашего аллокатора, 
сделали аллоактор другого типа, чтобы этот тип лёг на адресу кратный нужному. Для этого есть разные способы:

Функция std::align() since C++11. Когда у нас есть какой нибудь указатель и мы хотим получить этот указатель, но выровненый по адресу нужной кратности (Лекция 37 58:30). Как узнать alignment 
т.е. по адресам кратным чему нужно класть? Для этого есть стандартный оператор std::alignof (C++11) - возвращает число обозначающие по какой кратности тип должен быть выровнен. Это не 
тоже самое что и sizeof. 


std::alignas()
Представим что мы на стеке заводим массив char и от него создаём стековый аллокатор. Но поскольку это массив char, он сам может начинаться с адреса некратному 4-ём, но мы бы хотели чтобы
сам массив начинался с адреса кратному 4-ём. Когда мы заводим переменную мы можем захотеть попросить для неё определённое выравнивание, большее чем стандартное по умолчанию. 
Например для массива char мы можем попросить чтобы он был выровнен по 4 а не просто по 1 как по умолчанию, для этого у нас есть спецификатор alignas. Его нужно написать перед 
объявлением переменных и типов, а также написать число выравнивания:

alignas(64) char[64]; 	// Массив char размером 64 выравниваем по 64 байта.

struct alignas(float) struct_float {
};

struct alignas(32) sse_t {	// Структура из 4 float
	float sse_data[4];	
};


std::aligned_alloc() - наряду с malloc и free. Мы можем попросить как бы malloc, но с конкретным выравниванием.  

Когда мы вызываем malloc или new какое у нас получается выравнивание? Стандартный malloc как и стандартный оператор new возвращает нам всегда адресс выравненый по максимально 
возможному выравниванию для стандартных типов, поэтому когда мы пользуемся ними чтобы выделить чтото в динамической памяти, нам не нужно думать о том, как выровнен он будет - он
мсегда будет выровнен надлежащим образом, только если мы хотим тип который выровнен сильнее чем максимальное выравнивание у стандартных типов, тогда нам нужно об этому думать 
(но мы с этим пока что не сталкивались.) Чтобы узнать какое выравнивание для стандартных типов считается максимальным есть тип тэг std::max_align_t - это тип у которого выравнивание 
максимально возможное у стандартных типов. Когда malloc выделяет память, он выравнивает её настолько, насколько должен быть выровнен max_align_t (В случае лектора это 16). 

std::cout << alignof(std::max_align_t) << '\n'; 


Битовые поля (Bit felds) - мы можем попросить чтобы поле структуры занимало определённое кол-во бит а не байт. Если у нас есть структура, в которой нужно хранить несколько числе, но они
все маленького диапазона, мы можем попросить упаковать их в один байт. Например если у нас два число от 0 до 7 и два числа от 0 до 3 тогда мы можем упаковать с помощью такого синтаксиса:

struct S {			// Структура с 3-ёх битным полем.
	unsigned int b : 3;	// Имя переменной двоеточие число бит. 
};

Если объявить несколько таких полей мы можем их выровнить и уложить их в 1 байт суммарно:

struct S {
	unsigned char b1 : 3;		// b1 занимает 3 бита 
	unsigned char       : 2;	// эти два бита пустые
	unsigned char b2 : 6;		// b2 занимает 6 бит
	unsigned char b3 : 2;		// b3 занимает 2 бита
};

int main() {
	S s;
	s.b1 = 0b111;		// Присваиваем бинарные значения. 
	s.b2 = 0b101111;
	s.b3 = 0b11;
}

Таким образом в 2 байта упаковано 3 маленьких числа. Однако не стоит присваивать значения которые больше максимально возможных это UB. 
Это нужно для работы с бинарными данными, например чтение бинарного файла и там есть что столько то бит отведено на этот флажок, столько то бит на этот флажок. Для удобства мы можем 
объявить структуру которая все эти флажки хранит внутри с нужной битностью, и просто реинтропредкастим биты которые мы прочитали в свою структуру и таким образом мы просто получаем
что у нас эти флаги действительно обозначают то что они должны обозначать. Так же мы можем ловить пакеты по сети.   


______________________________________________________________________________________
Scoped allocators.

Посмотрим на следующий код. Допустим мы хотим создать строку на кастомном аллокаторе. std::string это тоже тип у которого тоже может быть несатндартный аллоктаор.

Оффтоп:
std::string это элиес(сокращение) для std::basic_string

using string = std::basic_string<char, char_traits<char>, allocator<char>>;

std::char_traits - это класс с всякими метафункциями, позволяющими узнавать чтото про его парамтер. По умолчанию std::char_traits

Продолжаем:



#include <iostream>
#include <vector>
#include <string>
#include <scoped_allocator>

template <typename T>
using MyAlloc = std::allocator<T>;						// Предположим что это типа кастомный нестандартный аллокатор

int main () {
	using MyString = std::basic_string<char, std::char_traits<char>, MyAlloc<char>>;	// Создаём тип 
	
	MyAlloc<MyString> alloc;						// Объявляем тип строки на нестандартном аллокаторе. 

	std::vector<MyString, MyAlloc<MyString>> v(alloc);			// Вектор из MyString тоже с нестандартным аллокатором

	v.push_back("abc");
	v.push_back("cde");
}

Мы хотим создать вектор из MyString так, чтобы и сам вектор тоже был на нестандартном аллокаторе, т.е. мы всё хотим выделять на нестандартном аллокаторе и строки и вектор. И у ветора и у 
строки есть параметр аллокатора и нам нужно чтобы и у внешнего контейнера (вектора) был правильный аллокатор, и чтобы во внутренние свои объекты он тоже передал правильный аллоктор,
чтобы они в свою очередь выделяли свою память кастомным образом (например на пуле а не стандартным образом). 

Это проблема называется Scoped allocators - что если мы заложим контейнер из других конейнеров и хотим чтобы всё выделялось на нестандартном аллокаторе (на плуе например), то нам нужно
чтобы и у вектора был естандартный аллокатор, и у каждой из строк в этом векторе был нестандартный аллокатор. 

В этом коде есть проблема, здесь есть поведение, которое мы не хотим. Мы конечно создадим и вектор, и каждую из его строк на нестандартном аллокаторе, но это всё будут разные экземпляры 
этого аллокатора, ведь когда вектор будет добавлять в себя строку, он же не будет знать что ему нужно взять тот же объект аллокатора, от которого создан он сам, он создаст новый объект 
аллокатора для этой строки. Т.е. если MyAlloc это пулл аллокатор, то у нас будет столько пулов, сколько было добавлено строк в вектор. Тут нужно каждый раз когда мы кладём в вектор строку
указывать вторым параметром объект этого аллокатора, либо он будет создавать их по умолчанию, но это будет означать, что он будет создавать на каждую новую строку новый объект 
аллокатора, а мы бы хотели чтобы мы пользовались контейнером, который использует один и тот же объект аллокатора для себя и своих подобъектов. Для этого в стандартной библиотеке есть
класс scoped_allocator_adaptor (C++11):

std::vector<MyString, std::scoped_allocator_adaptor<MyAlloc<MyString>>> v(alloc); 	// Исправляем

Теперь этот вектор будет создавать все строки на одном и том же аллокаторе, даже если мы не указали явно на каком объекте аллокатора создавать очередную строку. Вопрос - как это 
реализовано? Это пример аллокатора с нестандартной функцией construct. Этот метод должен создать объект T, но не обычным способом, а он должен дополнительно передать экземпляр 
аллокатор в то что он создаёт. Когда вектор делает push_back() он создаёт очередную строку, он выделил память под объект string, и дальше он вызвает construct. construct это посуть placement new
но в момент когда мы должны вызвать placement new от строки с параметром конструктора (в нашем случае "abc"), мы должны ещё дополнительно передать аллокатор.  Т.е. мы должны создать 
строку не просто от аргумента который нам дали, а ещё дополнительно передать ей аллокатор. 
Частичная реализация функции construct в scoped_allocator_adaptor: 

template <typename Alloc>
struct scoped_allocator_adaptor {
	// Allocate и Deallocate у него стандартные
	Alloc alloc;	// Храним аллокатор
	
	template <typename T, typename... Args>
	void construct(T* ptr, const Args&... args) {
		alloc.construct(ptr, args..., alloc);
	}
};

В consturct мы хотим передать объект внутреннего аллокатора. В примере с вектором от строк Alloc это MyAlloc от MyString, а в MyString мы хотим отдать аллокатор от char а не от string, поэтому
нам нужно достать из нашего T нужный вид аллоктатора. Т.е. Alloc сейчас это аллокатор на строки, T сейчас это строка. Мы хотим создать нужный объект аллокатора для этой строки из нашего 
аллокатора. Как нам из строки узнать какой вид аллокатора она хочет получить? Для этого у нас есть allocator_type. Т.е. мы создали аллокатор на char из алокатор на string и передали в конструктор
строки. 

template <typename Alloc>
struct scoped_allocator_adaptor {
	// Allocate и Deallocate у него стандартные
	Alloc alloc;	// Храним аллокатор
	
	template <typename T, typename... Args>
	void construct(T* ptr, const Args&... args) {
		using InnerAlloc = typename T::allocator_type;	// Это уже будет аллокатор на char
		alloc.construct(ptr, args..., InnerAlloc(alloc));	
	}
};

Мы вызвали construct строки с аргументами конструктера и дополнительным последним аргументом аллокатор. И вот здесь мы можем заметить такую полезную особенность: у basic_string вообще
у всех конструктеров есть необязательный параметр аллокатор. Такое есть и во всех остальных контейнерах. Этим мы и пользуемся - мы просто вызываем у строки construct с таким же набором
аргументов как и раньше, но дополнительно передавая объект аллокатора. В итоге это приводит к тому что вызывается placement new с рагументами как раньше, но последним аргументом 
дополнительно объект аллокатора и мы попадаем в тот самый конструктор string, который принимает аллокатор последним аргументом. Т.о. мы создаём строку на том же самом аллокаторе т.е.
на копии нашего аллокатора, но с правильным типом.

Однако мы забыли проверить условие, что объект T, который там конструируется впринципе умеет принимать аллокаторы. Для этого есть специальная метафункция std::uses_allocator. 
(Лекция 38 23.00). Если у типа T есть using allocator_type который можно создать из того аллокатора, который у нас сейчас, то мы это и делаем, а иначе сконструируем как обычно. 

template <typename Alloc>						// Это упращённая реализация
struct scoped_allocator_adaptor {
	// Allocate и Deallocate у него стандартные
	Alloc alloc;	
	
	template <typename T, typename... Args>
	void construct(T* ptr, const Args&... args) {
		if constexpr (std::uses_allocator_v<T, Alloc>) {		// Если там есть внутренний тип с названием allocator_type и он таков, что их него можно создать  InnerAlloc
			using InnerAlloc = typename T::allocator_type;	
			alloc.construct(ptr, args..., InnerAlloc(alloc));
		} else {
			alloc.construct(ptr, args...);
		}			
	}
};

Из этого можно сделать вывод о том что бывают аллокаторы с нестандартным construct, также нужно обратить особое внимание на проблему Scoped allocators.


______________________________________________________________________________________
Очень много про кастомные аллокаторы:

https://habr.com/ru/articles/876804/



______________________________________________________________________________________
