Класс - это некоторый шаблон объектов.
Класс имеет свойства и функции(в ООП функции называют модулями).
Конкретный объект кофемолка - это экземпляр класса кофемолка.

Принципы ООП: 
1) Инкапсуляция - принцип независимости данных. Разработчик может скрыть внутренее устройство программы, а взаимодействие с ней организовать через интерфейс.
2) Наследование - один объект может наследовать свойства и методы другого объекта, и дополнять их своим функционалом.
3) Полиморфизм - возможность объекта вести себя по разному, в зависимости от ситуации. 

Полиморфизм делиться на статический и динамический.
Динамический полиморфизм это переопределение методов, используя одинаковые вызовы и сигнатуру мы получаем разное поведение. (На этапе работы программы).
Статический полиморфизм это то что разруливается на этапе компиляции. Переопределение функций по её сигнтауре и шаблонные функции. (На этапе компиляции).



______________________________________________________________________________________
Класс - это пользовательский тип данных. (Который мы можем написать сами)
class Human { //Класс это шаблон, который описывает переменную.
public: //Модификатор доступа
	int age; //Переменная в классе называются свойством класса.(Или полем).
	int weight; //Вот такие свойства класса, которые содержут какую нибудь характеристику, называются полем класса.
	string name; 

	void Print() { //Метод(функция) класса.
		cout << "Имя: " << name << "\nВес: " << weight << "\nВозраст: " << age;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Human firstHuman; // А это уже конкретный экземпляр (объект) этого класса.
	firstHuman.age = 30;
	firstHuman.weight = 80;
	firstHuman.name = "Ivanov Ivan Ivanovich";
	firstHuman.Print();//Вызов метода класса.

	Human secondHuman;
	secondHuman.age = 18;
	secondHuman.weight = 65;
	secondHuman.name = "Noname";
}


Пустая структура и пустой класс занимают стандартный размер 1 байт


______________________________________________________________________________________
Необычный синтаксис класса и структур

struct S {			
	int x = 1;		
	double d = 3.14;	

	struct SS {		// это называется Inner class (внутренний класс)
		char c;		
	}; 			// после определения структуры мы должны ставить ; поскольку синтаксис разрешает после определения структуры объявить переменную такого типа

	struct SS2 {
		char c;		
	} ss2; 			// переменная типа SS2

	struct {		// более того мы можем анонимно объявить структуру и сразу объявить переменную такого типа.
		char c;
	} ss3;
};

int main() {
	struct A {}; // Local class (Локальный класс, который существует только внутри функции)
}

______________________________________________________________________________________
Модификаторы доступа классов. public private protected

Если в классе не указан модификатор доступа, то по умолчанию считается, что стоит модификатор private.

class Point {  это равносильно этому:	class Point {  
	int x;				private:											
	int y;					int x;					
};						int y;
					};			

Если поля и методы описаны в модификаторе private, мы не можем получить к ним доступ из экземпляра (объекта) класса. Доступ к этому модификатору открыт только самому классу, 
либо же дружественным классам и функциям.

Модификатор public даёт доступ для полей и методов из объекта. 

class Point {
private:
	int z;
public:
	int x;
	int y;
};

int main()
{
	Point a;
	a.x = 1;//x и y описаны модификатором public, так что мы сможем с нимим работать. Переменная z описана private, с ней из объекта мы работать не можем.
	a.y = 2;
}

Модификатор protected так же не доступен для объекта, но он доступен для класса, который будет наследовать наш текущий класс. Модификатор private доступен только в своём классе.


______________________________________________________________________________________
Геттеры и сеттеры для класса(Методы get и set).
По принципу инкапсуляции, при работы с полями класса, мы не можем изменять их напрямую. Поэтому нужно создать интерфейс.
Геттеры (получение данных) и сеттеры (установить, присвоить данные) это обычные методы (функции) класса, нужные для взаимодействия с конкретным полем. Они должны быть под 
модификатором public.

Если метод должен чтото вернуть, т.е. получить от класса, его название должно начинаться со слова Get. Сеттер устанавливает значение для какого либо поля. Название должно 
начинаться со слова Set.
class Point {
private:
	int x;
	int y;
public:
	int GetX() {//Получаем значение x
		return x;
	}
	void SetX(int valueX) {//Устанавливаем значение для x
		x = valueX;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Point a;
	a.SetX(5);
	int result = a.GetX();
}


______________________________________________________________________________________
Пример инкапсуляции
У нас есть кофемолка. При нажатии на кнопку старт, она должна проверить напряжение сети. Если всё ок, начинаем делать кофе, иначе подать звук(пик) два раза.
class CoffeeGrinder {
private:
	bool CheckVoltage() {//Вызывается скрытая функция проверки вольтажа.
		return true;
	}
public:
	void Start() {//При нажатии на кнопку вызывается функция старта
		if (CheckVoltage())//Проверяем вольтаж
			cout << "Старт работы" << endl;
		else
			cout << "Beep Beep(звук)";
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	CoffeeGrinder a;
	a.Start();//Нажимаем на кнопку старт
}


______________________________________________________________________________________
Конструктор класса
Конструктор класса это конструкция(сущность) которая предназначена для того, чтобы инициализировать состояние класса в какое то начальное значение, нужное нам. Изначально поля
класса могут быть заполнены мусором. Для их инициализации нужно вызывать сеттеры, это плодит много кода. 
Конструктор класса это функция без возвращаемого значения.(даже не void). Мы не можем вызвать его в ручную, он вызывается сам при создании объекта. Если мы его не указали, он
добавляется сам. Такой конструктор называется конструктором по умолчанию, и выглядит он так:(он пустой).

class Point {
public:
	Point() //Это конструктор класса. Его имя такое же как и имя класса. 
	{
	
	}
};

Конструктор вызывается сам при создании класса. Он должен быть в модификаторе public. Так же мы можем создать свой конструктор.
class Point {
private:
	int x;
	int y;
public:
	Point(int valueX, int valueY) { //Наш собственный контруктор с параметрами.
		x = valueX, y = valueY; //Устанавливаем изначальные значения.
	}
};

int main()
{
	Point a(5, 44);//Теперь при создании объекта нужно указать параметры конструктора. 
}



______________________________________________________________________________________
Ситуация когда конструктор невозможно сгенирировать по умолчанию.

struct C {
	int& r;		// Если поле является ссылка, то такой класс нельзя сконструировать и сгенирировать по умолчанию, т.к. ссылки нельзя оставлять без инициализации
	const int c;	// Так же если константа является полем тоже нельзя сконструировать и сгенирировать конструкторпо умолчанию
	C() = default; 	// Не работает. Не сработает даже если оставить неявный конструктор	
};

В этом случае нам нужно будет инициализировать поля по умолчанию:

int x = 0;		// Глобальная переменная

struct C {
	int& r = x ;		
	const int c = 0;	
	C() = default; 	//  Сработает	
};



______________________________________________________________________________________
Перегрузка конструкторов класса.
С перегрузкой реализуем в некоторой степени полиформизм класса.
Очень похожа на перегрузку функции. При перегрузке конструктора класса мы можем инициализировать класс различными способами, в зависимости от ситуации.
Например нам нужно, чтобы при создании объекта с конструктором по умолчанию, в переменных был не мусор, а дефолтные настройки, например 0. Но при этом была возможность вызвать
конструктор и с параметрами.

class Point {
private:
	int x;
	int y;
public:
	Point() { //Конструктор по умолчанию
		x = 0, y = 0;
	}
	Point(int valueX, int valueY) { //Перегрузка конструктора. Этот конструктор с параметрами.
		x = valueX, y = valueY;
	}
	void Print() {
		cout << "X = " << x << ",\tY = " << y << endl;
	}
};

int main()
{
	Point a;
	a.Print(); //Выведет X = 0,	Y = 0

	Point b(5, 4);
	b.Print(); //Выведет X = 5,	Y = 4	
}


______________________________________________________________________________________
Деструктор
Деструктор противоположен конструктеру класса. Он срабатывает при разрушении объекта класса. Это тоже функция, и мы тоже её сами вызвать не можем. Уничтожение объекта класса 
происходит, когда он выходит из зоны видимости. Деструктор в классе может быть только один. Мы можем не писать его и тогда он добавится автоматически, либо описать его сами.
У деструктора нет параметров. Деструктор нужен для корректной очистки памяти, например освобождении динамической памяти, выделенной во время работы объекта класса.

class MyClass {
public:
	MyClass() {
		cout << "Вызвался конструктор" << endl;
	}
	~MyClass() { //Синтаксис деструктора. Тоже самое что и конструктор, только с тильдой.
		cout << "Вызвался деструктор" << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a;
	return 0;
}

Объекты уничтожаются в обратном порядке тому, как они создавались.
class MyClass {
	int data;
public:
	MyClass(int value) {
		data = value;
		cout << "Объект "<< data <<" Вызвался конструктор" << endl;//При создании объектов в консоль сначала выведется запись о создании объекта 1 потом об объекте 2.
	}
	~MyClass() {
		cout << "Объект " << data << " Вызвался деструктор" << endl;//При удалении объектов в консоль сначала выведется запись о удалении объекта 2 потом об объекте 1.
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a(1); //Создаём первый объект
	MyClass b(2); //Создаём второй объект
	return 0;
}


Если в классе есть поля, которые тоже являются объектами некоторых классов, то сначала выполниться код моего деструктора, а затем будет выполнятся код деструкторов полей.
Т.е. на момент выполнения кода деструктора моего класса, поля ещё будут существовать и к ним можно обращаться.


______________________________________________________________________________________
Ключевое слово this
Ключевое слово this это указатель объекта на самого себя(хранит адрес в памяти). Снаружи класса этот указатель мы использовать не можем, только внутри класса.

class Point {
private:
	int x;
	int y;
public:
	Point() { //Конструктор по умолчанию
		x = 0, y = 0;
	}
	void SetX(int x) {//Устанавливаем значение для x
		this->x = x;//С помощью this устанавливаем новое значение переменной x.
	}
};

int main()
{
	Point a;
	a.SetX(5);

	return 0;
}


______________________________________________________________________________________
Конструктор копирования
Конструктор копирования отвечает за копирование объекта. В классе есть конструктор копирования по умолчанию, который делает побитовое копирование.

Если мы в функцию передаём параметр по значению(без ссылки или указателя), то в функции создаётся локальная копия этого параметра. Все изменения которые мы делаем с этой копией
не отоброзятся на основной переменной. 

class MyClass {
public:
	MyClass() {							//1.1) Вызывается конструктор по умолчанию.
		cout << "Вызвался конструктор " << this << endl;
	}								//3) Вызов деструктора для локального класса в функции Foo. 5) Вызов деструктора для нашего класса a в
	~MyClass() {							//функции main.
		cout << "Вызвался деструктор " << this << endl;
	}
};

void Foo(MyClass value) {						//2.2) Вызов нашей функции. Поскольку параметр является параметром по значению, создаётся локальная 
	cout << "Вызвалась функция Foo" << endl;			//	копия нашего класса.
}									//2.3) Функция закончила работу. Выход из Область видимости локального класса. 
int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a; 							//1) Создаём наш класс
	Foo(a);//Мы вызываем 						//2) Вызываем функцию, в параметре которой указан наш класс(по значению).
	return 0;							
}									//4) Программа закончила работу. Выход из Область видимости нашего класса a.
	
Что будет выведено в консоль:
Вызвался конструктор 002BFA58
Вызвалась функция Foo
Вызвался деструктор 002BF974	(Появился вызов лишнего локального деструктора, который был в функции foo)
Вызвался деструктор 002BFA58

Когда мы передаём в функцию параметр по значению, вызывается Конструктор копирования, а не создания. Он у нас не описан, значит компилятор создаёт его сам по умолчанию. 
Поэтому мы не видим в консоли лог о создании локального класса.

Либо мы можем задать явное копирование класса.
int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a;
	MyClass a(10);
	MyClass b(a); 	//Явно копируем класс a

	return 0;
}

В этом случае мы можем наблюдать что опять конструктор вызвался один раз, а деструктор два раза. Это большая проблема. Например, если в конструкторе класса будет код, который
выделяет динамическую память, а в деструкторе мы будем её очищать, то поскольку деструктор вызывается два раза, то во второй раз мы будем обращаться к уже очищенной зоне в 
памяти, что вызовет ошибку. Ведь в этой зоне уже могут быть другие данные.(Тоесть два созданных класа указывают на одну и туже облать памяти).

class MyClass {
	int *data;		
public:
	MyClass(int size) {						//1.1) Вызов конструктора. 
		this->data = new int[size];				//1.2) Выделение динамической памяти по 10 элементов массива типа int.
		for (int i = 0; i < size; i++)
		{
			data[i] = i;
		}
		cout << "Вызвался конструктор " << this << endl;
	}
	~MyClass() {							//3.1) Уничтожается объект b(уничтожение идёт в обратном порядке.) 4) Вызыв деструктора объекта a.
		cout << "Вызвался деструктор " << this << endl;
		delete[] data;						//3.2) Освобождение памяти.	4.1) Попытка очистить уже очищенную область памяти. Вызов ошибки при 
	}								//					работе с динамической памятью.
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a(10);							//1) Создаём класс а с параметром 10.
	MyClass b(a);							//2) Вызов конструктора копирования. Выполняется побитовое копирование.(Идентичная копия класса a).

	return 0;							//3)Программа законичла работу. Начинается вызов деструкторов.
}


Для того, чтобы такой ситуации избежать, нам нужно описать конструктор копирования. Синтаксис конструктора копирования.

class MyClass {
	int *data;
	int arrSize;// Переменная для запоминания размера массива.
public:
	MyClass() {
		cout << "Вызвался конструктор " << this << endl;
	}
	MyClass(int size) {
		this->arrSize = size; 	//Запоминаем размер массива.
		this->data = new int[size];	//Создаём динамический массив.
		for (int i = 0; i < size; i++)  //Заполняем его.
		{
			data[i] = i;
		}
		cout << "Вызвался конструктор " << this << endl;
	}


	//Это конструктор копирования
	MyClass(const MyClass &other) { //Принимаем в параметр ссылку на объект, который хотим скопировать. Ставим const для того, чтобы ничего не изменить.
		this->arrSize = other.arrSize; //Копируем параметр arrSize 
		this->data = new int[other.arrSize];//Вместо тупого копирования указателя, создаём новый массив, с таким же кол-вом ячеек , как и в оригинальном объекте.
		for (int i = 0; i < other.arrSize; i++)//Копируем все значения из массива оригинального объекта в массив текущего объекта.
		{
			this->data[i] = other.data[i];
		}
		cout << "Вызвался конструктор копирования" << this << endl;
	}
	~MyClass() {
		cout << "Вызвался деструктор " << this << endl;
		delete[] data;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a(10);
	MyClass b(a);	//Вызов конструктора копирования.

	return 0;
}


Идиома:
COW string (copy on write) это такой способ реализации когда, мы конструктор коприрования оставляем тривиальным, а реально копирование делаем в момент когда ктото пытается
изменить копию. Т.е. это ленивое копирование.

______________________________________________________
Литеральный суффикс 

Помимо конструирования числа вашего объекта и оператора приведения есть ещё один способ как получить объект нашего класса из числа - это литеральный суффикс. Начина я C++11
можно определять кастомные литеральные суффиксы.

пример суффикса: 2.0f - это означает float

Мы можем определить свой литеральный суффикс: Для этого мы должны определить оператор кавычки:

class BigInteger {}
BigInteger operator''_bi(unsigned long long x) {
	return BigInteger;
}

int main() {
	BigInteger bi = 1_bi;
}

Особенность: В качестве параметра должны принять либо unsigned long long, либо const char*, либо long double. Дело в том, что числовые литералы могут быть длинными, и если 
уж мы определяем литеральный суффикс для числового литерала, то мы должны взять максимальный длинный числовой литерал.

Стандартная строка обладает литеральным суффиксом:

"abcdef"s; // Это имеет тип std::string C++ (Не просто C)


Коментарии по видио:
Получается, что создание собственного литерала довольно дорогое удовольствие, т.к. сначала будет создан объект из этого литерала, а потом будет вызываться конструктор
копирования: My x = 12_my; А затем ещё и деструктора для 12_my.

Это верно, если компилировать со стандартами раньше, чем C++17, и с флагом компиляции -fno-elide-constructors(этот флаг явно запрещает компилятору делать оптимизации 
промежуточных объектов, явно не прописанные в стандарте). Создалось бы аж целых три объекта, да. Если не включаться этот флаг, компиляторы и так умели это оптимизировать.
Начиная с C++17 то случай гарантированного нам стандарта RVO, так что полюбому (даже с этим флагом) будет только один объект создаваться сразу на нужном месте.



______________________________________________________________________________________
Перегрузка операторов (Присваивания)
При использовании операции присваивания мы можем натолкнуться на ту же проблему, что была изложена пунктом выше.

int main()
{
	MyClass a(10);
	MyClass b(2);

	a = b; //Объект a теперь думает что он объект b. Теперь они имеют одинаковый адрес. При вызове деструкторов одна и таже область памяти будет очищаться 2 раза.
	return 0;
}

Чтобы избежать данной проблемы нужно выполнить перегрузку оператора присваивания(=).

Важный момент: При создании объекта вот так: MyClass b = a; вызывается конструктор копирования, а не присваивания, потому что b ещё не создан. Запись MyClass b = a; 
	эквивалентна записи MyClass b(a);

По сути операторы это тоже функции. Компилятор запись a = b видит так: a присвоить (b); 
Для переопределения операторов применяестся ключевое слово operator, и далее сам оператор, который перегружаем. В параметрах должен быть тот же самый объект, который хотим 
присваивать. В данном случае это будет константная ссылка на объект класса. Ссылка, потому что нам не нужна копия этого объекта, нам нужно только посмотреть что в нём лежит.
Константная, потому что мы там ничего менять не собираемся. Так же оператор возвращает значение, и он должен возвращать ссылку на текущий объект. Поэтому в начале ставим не
void а MyClass &, и в конце стави return *this;

MyClass & operator = (const MyClass &other) {
	return *this;
}

После переопределения в объекте появилась ещё одна запись: 
int main()
{
	MyClass a(10);
	MyClass b(2);
	a.operator = (b); //Теперь это равнозначно, что и просто a = b;
	return 0;
}

Сначала в объекте в котороый мы хотим совершить копирование выполнить освобождение памяти. Перед освобождением памяти нужно делать проверку на nullptr. Потому что если память не
выделялась, мы и не должны её удалять.

class MyClass {
	int *data;
	int arrSize;// Переменная для запоминания размера массива.
public:
	MyClass() {
		cout << "Вызвался конструктор " << this << endl;
	}
	MyClass(int size) {
		this->arrSize = size;
		this->data = new int[size];
		for (int i = 0; i < size; i++)
		{
			data[i] = i;
		}
		cout << "Вызвался конструктор " << this << endl;
	}
	MyClass(const MyClass & other) {
		this->arrSize = other.arrSize; 
		this->data = new int[other.arrSize];
		for (int i = 0; i < other.arrSize; i++)
		{
			this->data[i] = other.data[i];
		}
		cout << "Вызвался конструктор копирования" << this << endl;
	}
	MyClass & operator = (const MyClass &other) {	//Перегрузка оператора
		cout << "Вызвался оператор = " << this << endl;
		this->arrSize = other.arrSize; //arrSize просто присваеваем новое значение, т.к. это не динамич. память.

		if (this->data != nullptr) { //Указывает ли указатель data на какую нибудь область памяти, где есть какие нибудь данные.
			delete[] this->data; //Если data указывает, значит данные там есть. Очищаем старую динамическую память
		}
			
		this->data = new int[other.arrSize];//Выделяется новая область памяти, согласно размеру и кол-ву элементов в том объекте, от которого мы копируем.(other).
		for (int i = 0; i < other.arrSize; i++)//По элементно копируем значния из other в this.
		{
			this->data[i] = other.data[i];
		}
		return *this;
	}

	~MyClass() {
		cout << "Вызвался деструктор " << this << endl;
		delete[] data;
	}
};



int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a(10);
	MyClass b(2);
	a = b;
	return 0;
}

В результате объекты a и b имеют разные адресса, разные области дин. памяти, но с одинаковыми значениями всех полей и данных.



##############################
Реализация строки

Нужно освободить то что у нас сейчас, и выделить новое на это новое переставить нашу строку.

У оператора присваивния должен быть тип ссылка на этот же объект. В нашем случае String&. если бы тип возвращаемого значения был бы void, мы бы лишались возможности
присваивать в строчке несколько String одну другой. За счёт того что оператор присваивания возвращает ссилку на тип, мы можем создать цепочку присваивания. Если бы тип 
возвращаемого значения был бы просто String без ссылки, это бы означало, что нам пришлось бы копировать строку каждый раз при возврате их оператора присваивания. Лишний 
вызов конструктора копирования.

return нужно сделать *this, поскольку мы хотим вернуть себя. this это указатель на себя, а поскольку нам нужна ссылка на себя, нам нужно разыменовать указатель.

#include <cstring>

class String {			// Реализовываем строку
	int* arr = nullptr;	// Указатель на область динамической памяти
	size_t sz = 0;		// Сколько элементов реально лежит
	size_t cap = 0;		// Под сколько элементов выделена память
private:
	String(size_t n) : arr(new char[n+1]), sz(n), cap(n+1) {
		arr[sz] = '\0';
	}

public:
	String() = default;
	String(size_t n, char c) : String(n) {			// Делегирующий конструктор
		memset(arr, c, n);
	}
	
	String(std::initializer_list<char> list) : String(list.size()) {
		std::copy(list.begin(), list.end(), arr);	
	}

	String(const String& other) : String(other.sz) { 	// Конструктор копирования
		memcpy(list.begin(), lost.end(), arr);
	} 
	
	~String() {
		delete[] arr;
	}

	/* Плохой оператор присваивания. 
	String& operator=(const String& other) {
		if(this == &other) return *this;		// Проверка на присваивание самому себе. Адресс от ссылки это не она сама, а адрес исходного объекта.
		delete[] arr;					// Освобождаем старый массив
		sz = other.sz;
		cap = other.cap;
		arr = new char[other.cap];
		memcpy(arr, other.arr, sz + 1);
		return *this;
	}
	*/


	/* Хороший оператор присваивания с использованием идиомы Copy and swap

	Копируем other. Еперь у нас есть наша строки, копия other, и оригинал other. Далее делаем своп копии other и своей строкой, т.е. теперь моя строка хранит указатель
	на копию строку other, а строка копии other хранит указатель на мой массив старый. return *this приводт к тому, что уничтожаются все локальные переменные. Т.е.
	уничтожается копия other, вызывается её деструктор, а её деструктор уничтожает массив, который был нашим раньше, на который сейчас указывает копия.
	
	String& operator=(const String& other) {
		String copy = other;		// копируем other
		swap(copy);			// меняем копию other и себя
		return *this;			// Возвращаем себя
	}
	*/
	
	// Ещё лучше. Присваивание самому себе работает.
	String& operator=(String other) {
		swap(other);			// меняем копию other и себя
		return *this;
	}
	
	void swap(String& other) {
		std::swap(arr, other.arr); 	// Работает за O(1), поскольку поля тривиальны. Не работало бы за O(1), если бы поля сами были бы объектами нетривиальными. 
		std::swap(sz, other.sz);
		std::swap(cap, other.cap);
	}
};

int main() {
	
}


______________________________________________________________________________________
Перегрузка оператора сложения
Результат сложения объектов одинакового класса (Point), тоже будет объект этого же класса (Point).

(В классе Point)
Point operator + (const Point& other) { //Создаём временный класс, записываем в него результаты сложений всех полей класса, и возвращаем его.
	Point temp;
	temp.x = this->x + other.x;
	temp.y = this->y + other.y;
	return temp;
}
int main()
{
	setlocale(LC_ALL, "Russian");
	Point a(5, 1);
	Point b(77, 12);
	
	Point c = a + b;

	return 0;
}


##############################
Сложение в обе стороны (определение бинарных операторов)

class Complex {
	double re = 0.0;
	double im = 0.0;
	Complex(double re) : re(re){}
	Complex(double re, double im) : re(re), im(im){}	

	// Такой оператор должен быть константым, потому что иначе я не смогу складывать комплексные числа в которых левый аргумент был константным комплексным числом.
	// Потому что этот оператор является членом класса, и к нему применяются все теже правила что и к обычным членам класса, т.е. его нельзя вызывать от 
	// константных объектов.
	Complex operator+(const Complex& other) const {
		return Complex{re + other.re, im + other.im};
	}
}

При определении оператора + существует проблема. Я бы хотел складывать не только комплексные числа друг с другом, а ещё в double. И конструтор Complex(double re) у нас
не explicit. Тем не мение я хочу написать Complex + double и получить Complex, и мог на оборот double + Complex = Complex. Если я хочу такой эффект, то у нас проблемы:
сейчас я не смогу сложить double + Complex

int main() {
	Complex c(1.0);
	c + 3.14;	// Корректно. Есть оператор + для типов Complex и double 
	3.14 + c; 	// Некорректно. Нет оператора + для типов double и Complex
}

Запись c + 3.14; для компилятора означает следующее: c.operator+(3.14); + это синтаксиеский сахар для .operator+. Это член класса.
Но мы не можем сделать 3.14 + c потому что левый аргумент не объект класса. Для левого аргумента, который не является объектом класса, не рассматриваются версии операторов
которые являются методами этого класса. Компилятор не будет рассматривать все возможные классы, которые могут скастовать double, чтобы у них вызвать соответствующий метод.

Поэтому существует следующий кодстайл, который гласит: Если нам нужно определить бинарные операторы (арифмитические или операторы сравнения) рекомендуется объявлять их 
вне класса. Т.е. не нужно делать их членами класса.

class Complex {
	double re = 0.0;
	double im = 0.0;
	Complex(double re) : re(re){}
	Complex(double re, double im) : re(re), im(im){}	
}

Complex operator+(const Complex& a, const Complex& b) {		// const уже не нужно
	return Complex{a.re + b.re, a.im + b.im};
};


Допустим мы теперь хотим определить оператор +=. Данный оператор уже должен быть членом класса, поскольку он берёт уже имеющийся объект класса и его модифицирует.

!!!! Это очень плохой код. Это очень неэффективно, работает в 2 раза медленее чем могло бы быть.

class Complex {
	double re = 0.0;
	double im = 0.0;
	Complex(double re) : re(re){}
	Complex(double re, double im) : re(re), im(im){}

	Complex& operator+=(const Complex& other) {
		*this = *this + other;
		return *this;
	}	
};

Complex operator+(const Complex& a, const Complex& b) {	// const уже не нужно
	return Complex{a.re + b.re, a.im + b.im};
};

Для Complex разницу мы не почувствуем, потому что скопировать объект Complex тривиально. А вот для объектов у которых нетривиальное копирование, например string, такая
реализация потребует двоекратного копирования string, вместо того, чтобы не копировать её вообще. Представим что к строке с длинной миллион мы хотим прибавть строку длинны 
один, и Capacity нам хватает. 

*this + other; Вот здесь будет создана новая строка длинной миллион один (1000001), полученная полным копированием исходных строк. 
*this = *this вот здесь будет выполнено присваивание одной строки другой строке. Т.е. ещё будет пробег от n, поэлементное присваивание нашей строки. Тут будет 2O(n), 
вместо того чтобы O(1) просто написать символ в конец.

Нужно делать наоборот: надо + выражать через +=, поскольку += это быстрая операция, а + это долгая операция всегда. Если у нас есть две сторки то += это операция, которая 
может работать за O(1), если вторая строка короткая. А + это операция, которая всегда работать за сумму длинн исходных строк. Поэтому если нам нужно реализовать +, нам 
никуда не деться от копирования исходных строк, но если нужно реализовать +=, то не в коем случае не нужно из него вызывать +. Поэтому правильно будет здесь:

class Complex {
	double re = 0.0;
	double im = 0.0;
	Complex(double re) : re(re){}
	Complex(double re, double im) : re(re), im(im){}

	Complex& operator+=(const Complex& other) {	// Изменяем operator+=
		re += other.re;
		im += other.im;
		return *this;
	}
};


RVO - return value optimization
Complex operator+(const Complex& a, const Complex& b) {	// Изменяем operator+. Это правильный вариант, не нужно облегчать код или делать чтото более умное
	Complex result = a;				// Да здесь происходит копирование 
	result += b;					// Здесь копирование зависит от capacity и релокации					
	return result; 					// Здесь не происходит копирования. Потому что компилятор умеет оптимизировать. Если мы возвращаем голую (без каких 
};							// либо выражений вокруг неё) локальную переменную по значению наружу из функции и под return стоит именна она, 
							// компилятор может оптимизировать это, таким образом, что просто зарание, вызывая эту функцию, создаёт эту 
							// переменную не на стеке за вызовом функции, а там где стоит ожидть её результат. Это называется RVO
							// RVO - return value optimization
							// Эта оптимизация работает только для локальных переменных внутри функции. Т.е. это не работает с параметрами
							// функций (аргументами, которые мы передали в функцию при вызове это не работает.)
/*
Complex operator+(const Complex& a, const Complex& b) {	// Так нельзя, появляется лишнее копирование. Всё работает за O(n). 
	Complex result = a;
	return result += b; 				// При return происходит ещё одно копирование
};
*/
/*
Complex operator+(Complex a, Complex b) {		// Так нельзя, появляется лишнее копирование. Всё работает за O(n)
	return a += b; 					// При return происходит ещё одно копирование
};
*/

Теперь у нас есть новая особенность:

int main() {
	Complex a(1.0);	
	Complex b(2.0);
	Complex c(3.0);

	a + b = c; // Скомпилируется ли это? a + b даст результат сложения, а это rvalue
}

Да это скомпилируется, хотя казалось бы слева находится rvalue. А с чего вы взяли что нельзя присваивать любым rvalue, а не только стандартным? Ни кто же не написал, что
присваивать можно только к lvalue, такого правила в стандарте по умолчанию нет, что оператор присваивания не работает для левого аргумента rvalue, если если это ваш
кастомный тип. Точно также как и const - если вы напишите что присваивание будет работать только для константных типов, то оно будет работать только для константных типов,
а если не напишите будет, работать для константных и для не константных. Т.е. мы можем присваивать к rvalue если это наш кастомный тип, а не стандартный.

Это можно оставить а можно забанить. Есть 2 способа решения:

1) написать const возвращаемым типом в переопределении оператора +

const Complex operator+(const Complex& a, const Complex& b) {

потому что оператор присваивания для константных типов по умолчанию запрещён. Ну потому что оператор присваивания присваивает поэлементно поля.

!!! НО так не пишите так. Это было актуально до C++11

2) Правильно избежать этой проблемы тем чтобы сказать, что оператор присваивания применим только к lvalue. Мы можем для произвольного метода, по анологии с тем как написать
const в конце конст квалифаер, ещё написать референс квалифаер, т.е. для каких видов value этот оператор применим. По умолчанию все методы применимы для любых видов 
value, включая оператор присваивания. Но я могу написать, что мой оператор присваивания применим только к lvalue. Для этого там где мы пишем const в конце метода, ножно
написать один &. А если мы хотим чтобы метод был применим только к rvalue, нужно было написать &&.

Complex operator=(const Complex& other) & {	// Только к lvalue

} 



______________________________________________________________________________________
Операторы побитового сдвига

Интересно в них то, что они для некоторых наборов типо ведут себя не как операторы побитового сдвига, а как нечто иное. Это когда левый аргумент istream ostream. Когда мы 
определяем свои типы, и хотим для них определить вывод в поток, то что нам нужно сделать, это как раз определить оператор меньше меньше и больше больше с левым аргументом,
который является потоком. 

Допустим мы хотим определить вывод в поток для строки.
1) Этот оператор должен быть внешней функцией, а не членом класса, потому что левый аргумент это поток, а не строка.
2) Возвращаемый тип должен быть ссылка на поток std::ostream&. Ссылка нужна для цепочки воврата в поток.

std::ostream& operator<<(std::ostream& out, const String& str);  // Ввод в поток	
std::istream& operator>>(std::istream& in, String& str);	 // Вввод из потока



______________________________________________________________________________________
Оператор сравнения

bool operator<(const Complex& a, const Complex& b) {		// Оператор меньше для комплексных чисел
	return a.re < b.re || a.re == b.re && a.in < b.im;
}

bool operator>(const Complex& a, const Complex& b) {
	return b < a;
}

Например если мы используем map для наших объектов, то эта структура требует компаратор, или когда мы в сортировку передаём свои объекты, подрузамевается по умолчанию ,что 
у нас определён оператор меньше. 

Именно МЕНЬШЕ, не больше и не равно. Компилятор в стандартных алгоритмах, все остальные сравнения выражает через МЕНЬШЕ. 

Оператор больше выражается через оператор меньше, как b < a. Т.е. не нужно писать отрицание что оператор b меньше или равен и не писать что он меньше или равне по отдельности,
потому что это будет работать в 2 раза дольше. Если мы отрицаем меньше или равно, то это значит, что вам нужно вычеслить меньше или равно и взять обратный противоположный 
результат.
Чтобы определить оператор меньше или равно, достаточно просто отрицать больше, а чтобы определить больше, достаточно просто отрицать меньше.
Равенство определяется как не меньше и не больше, а не равенство наоборот меньше или больше.

Мы можем написать так:

bool operator==(const Complex& other) const = default;  // Просто поэлеметно сравнит поля.



______________________________________________________________________________________
Перегрузка оператора равенства == и не равно !=
Когда мы проверяем два разных экземпляра на равенство мы проверяем состояниеэтих объектов, т.е. равны ли между собой их поля, и если эти поля содержут какие нибудь данные, 
одинаковые ли данные там находятся.

При перегрузке оператора мы должны передавать параметр для сравнения.
class Point {
private:
	int x;
	int y;
public:
	Point() {
		x = 0, y = 0;
		cout << this << " constructor" << endl;
	}
	Point(int valueX, int valueY) {
		x = valueX, y = valueY;
		cout << this << " constructor" << endl;
	}
	bool operator == (const Point & other) {				//Перегрузка оператора ==. this это объект a, other это объект b.
		return this->x == other.x && this->y == other.y;
	}
	bool operator != (const Point & other) {				//Перегрузка оператора !=
		return !(this->x == other.x && this->y == other.y);
	}
};
...
int main()
{
	setlocale(LC_ALL, "Russian");
	Point a(5, 1);
	Point b(9, 4);
	
	bool res = a == b; //Объект класса a, это тот объект, где лежит наша функция перегрузки, а объект b это передаваемый объект в параметр этой функции.
	bool res = a != b;

	return 0;
}



______________________________________________________
Оператор спейсшип <=> Three-way comparison(since C++20)

#include <compare> 

std::weak_ordering operator<=>(const Complex& other) const = default; 	// default - это фишка этого оператора для классов

Этот оператор введён, для того чтобы чтобы нам не приходилось каждый раз определять все предыдущие операторы сравнения под копирку, поскольку, почти всегда, за очень редким
исключением, когда мы определили оператор меньше, то операторы больше, меньше или равно, больше или равно определяются одинаково каждый раз с любыми типами. Так же если мы 
хотим уметь сравнивать не только свои объекты друг с другом, а ещё и другим типом, например у нас есть string и мы хотим сравнивать его с const char* не приводя const char*
ко второму string, потому что это не эффективно. При чём чтобы const char* стояла как слева, так и справа от string. И это означает, что тогда нам нужно написать уже не 4, а 
12 разных операторов. Оператор спейсшип приходит на помощь в этом деле. Работает он так: мы просто можем определить его так как написано выше, и у нас автоматически 
определятся все те операторы: меньше, больше, меньше равно, больше равно, равно равно и неравно. Работает это по следующему правилу: компилятор когда видит сравнение в 
нашем коде нашего типа, например a < b, он сначала ищет нет ли явно определённого нами оператора меньше. Если есть, он идёт в него, а если нет, он смотрит есть ли оператор 
спейсшип. Это лексикографическое меньше. Это лучше не только изза того что писать нужно меньше, а ещё тем, что оно быстрее работает. Объясню почему: представим что у нас есть
класс, в котором поля это длинные строки, а так же у нас определён оператор меньше:

bool operator<(const Complex& a, const Complex& b) {		
	return a.re < b.re || a.re == b.re && a.in < b.im;
}

и чтобы мне проверить, что он лексикографически меньше, я сначала вызываю меньше от двух строк, а потом, говорю равно от тех же двух строк  или ещё меньше от других двух 
строк (расшифровка того что написано в коде). Т.е. мы сравниваем строки в два пробега. Однако существует способ сравнивания одним пробегом по строке, а не двумя, чтобы не 
делать сравнение второй раз. Вот стандартный оператор спейсшип он делает именно так. С C++20 у всех стандартных типов удалены все операторы меньше больше и оставлен только
оператор спейсшип. Этот оператор возвращает некоторое специальное значение, одно из трёх: less (меньше), equivalent (равно) или geater(больше) (типо enam). И он, глядя на 
этот результат, понимает нужно ли сравнивать вторые куски или нет.

Можно написать что оператор равен default, но некоторые сравения доопределить свои.

!!!
Возвращаемый тип бывает 3ёх видов:
std::weak_ordering	(скорее всего для наших целей нужен будет этот возвращаемый тип)
std::стронг_orderig	(не знаю как правильно писать)
std::башел_ordreig

Вспоминаем все виды отношения порядка: (они все строгие)
1) Частичный порядок - пашел_ордирг. Это такой порядок, в котором для любых двух элементов, может быть одно из 4 возможных значения. Либо он больше, либо меньше, либо 
равен, либо он несравним. Скорее всего не получиться для такого порядка написать default, придётся реализовывать самому.

В C++ weak_ordering и Стронг_ордеринг имеют всего 3 возможных значения: less, more и equal.
2) Сильный порядок - Стронг_ордеринг. 
3) Слабый порядок - weak_ordering.

Разница между Сильным порядком и слабым(weak_ordering) заключается в том, как ведёт себя равенство, что означает что элементы равны.
Какими свойствами должен обладать предикат равенства: он должен обладать: равенство должно быть рефлексивно, симметрично, транзетивно и ещё сохраняться при вызове функций.
Т.е. для любой функции f, при подстановке в неё a и подстановки в неё b, Если a = b, то это f(a) = f(b). Это свойство отсутствует в weak_ordering, этим они и отличаются.
Т.е. weak_ordering это такой порядок, что он может нам вернуть равно, если на самом деле элементы не являются неразличимыми. У std::string порядок как раз weak_ordering. 
Потому что у нас могут быть например строки у которых capacity разные, хотя значения этих строк одинаковые. 

Стронг ордеринг это такое соглашение: если мы пишем стронг ордеринг, то тем самым мы заявляем, что этот порядок таков, что если результат a = b, то они неотличимы, то вызов 
любой функции от a это тоже самое что и вызов любой функции от b. А если мы пишем weak_ordering, то мы как бы отождевствляем некоторые элементы, хотя на самом деле они не 
равны в точности.

Пример типо Сравниваем string с const char*

std::weak_ordering operator<=>(const char* other) const {
	return std::weak_ordering::equivalent;			// Это не реализация, а заглушка для примера.
}

Фишка C++20: Если мы так напишем, то он и в обратную сторону тоже будет работать автоматически. Т.е. const char* может быть с любой стороны. Этот оператор нужно писать как 
член класса.


Сравнивание в операторе спейсшип
Предположим что я реализовал свой оператор спейсшип сам, а не = default, то операторы меньше, больше, меньше равно, больше равно доопределяются автоматически, а вот 
операторы равно равно и неравно не доопределяются. Нужно явно задефолтить эти операторы. Почему же не доопределются автоматиески? Потому что это не эффективно. Например 
сравниваем строки: мы проходим по всем символам до первого несоответствия. Однако для строк это неэффективно. Эффективно сначала проверить sizeof этих строк, а уже потом
бежать по строке. Поэтому проверку строк на равенство не нужно реализовывать через меньше, не только потому, что мы два раза будем пробегаться по строке, но и потому, что
в большенстве случаев нам не нужно пробегаться по строке, достаточно просто сравнить sizeof. Из этого следует: если в классе определён недефолтный оператор спейсшип, то 
вероятно, дефолтный оператор равно равно для него не подойдёт.

class Complex {
	std::weak_ordering operator<=>(const char* other) const {	// Не default, а своя реализация
		return std::weak_ordering::equivalent;			// Это не реализация, а заглушка для примера.
	}
};

int main(){
	Complex a(1.0);
	Complex a(2.0);

	a == b;			// Сравниваем 
}



______________________________________________________________________________________
Перегрузка инкремента и декремента

Перегрузка префиксной формы инкремента
Так как мы будем выполнять операцию над тем же самым объектом, с которым работаем, по этому мы должны возвращать ссылку на этот же объект. Нам не требуется создавать 
новый объект для этих операций.

(В классе Point)
Point & operator ++() { //Перегрузка префиксной формы инкремента.
	this->x++;
	this->y++;
	return *this;
}
...
int main()
{
	Point a(1, 1);
	++a; 		
	return 0;
}

Перегрузка постфиксной формы инкремента
Мы должны описать в параметре, что мы передаём какое нибудь значение типа int, чтобы компилятор понимал, что это перегрузка постфиксной формы. На деле ничего передавать мы не будем.
Сначала запоминаем текущее состояние объекта. Потом этот объект подвергаем операции постфиксного инкремента. Но возвращаем сохранённый объект, со старыми данными(без инкремента).


(В классе Point)
Point operator ++(int value) { //Перегрузка постфиксной формы инкремента. В этот раз знака амперсанта нет. Так возвратиться копия temp, и после уничтожения temp все будет ок.
	Point temp(*this);	//Нам нужно хранить текущее состояние объекта. Для этого создаём ещё один точно такой же объект, на момент вызова операции постфиксного инкремента.					
	this->x++;
	this->y++;
	return temp; 
}
...
int main()
{
	Point a(1, 1);
	Point b(2, 2);
	Point c = b + a++;	// c = (3,3), а не (4,4). Потому что a++ будет выполнено после присваивания значения объекту c.	
	return 0;
}

С декрементом всё тоже самое только где сейчас ++ ставим --.


#########################
Вторая вариация 

struct UserID {
	int value = 0;
	
	// Перегрузка префиксного инкримента
	UserID& operator++() {
		++value;
		return *this;
	}

	// Перегрузка постфиксного инкримента
	UserID operator++(int) {		// Принимаем фейковый аргумент типа int для обозначения постфиксного инкремента
		UserID copy = *this; 
		++value;
		return copy;
	}
};


______________________________________________________________________________________
Перегрузка оператора индексирования []

С классом мы можем работать точно так же как и с массивом. Для этого нам нужно перегрузить оператора индексирования.

class TestClass {
public:
	int & operator [] (int index) {	//Возвращаем значение по ссылке
		return arr[index];
	}
private:
	int arr[5]{ 5,44,4,987,69 };
};
int main()
{
	setlocale(LC_ALL, "Russian");
	TestClass a;
	cout << a[2] << endl;
	a[0] = 100;
	return 0;
}



______________________________________________________
Перегрузка () круглых скобочек

Мы можем переопределить в нашем классе perator(), тогда его можно будет вызывать как будто это функция.

struct Greater {				// Такой класс называется Функтор (Функциональный класс)
	// Преимущество в том, что можно делать поля 
	bool operator()(int x, int y) const {
		return x > y;
	}
};

int main() {
	std::vector<int> v(10);
	
	std::sort(v.begin(), v.end(), Greater()); // Greater() это Компаратор. Сортировка принимает объект Greater. Этот объект называется функциональным объектом.
}




______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________

Дружественные функции и классы

Дружественной функция по отношению к классу называется функция, которая хоть и не является членом класса, т.е. описана не внутри класса, а снаружи, она имеет доступ к закрытым полям класса.
В дружественной функции доступ к полям через this не работает. Мы можем получать доступ к полям класса через его объект.
На определение дружественной функции в классе не распространяются влияния модификаторов доступа (public, private, protected). Т.е. можем указать её в любом месте.
Функция может быть дружественной по отношению к нескольким классам.

class Point {
private:
	int x;								//Закрытые поля класса.
	int y;
public:
	Point() {
		x = 0, y = 0;
		cout << this << " constructor" << endl;
	}
	Point(int valueX, int valueY) {
		x = valueX, y = valueY;
		cout << this << " constructor" << endl;
	}
	void Print() {
		cout << "X = " << x << ",\tY = " << y << endl;
	}
	
	friend void ChangeX(Point& value);				//Определение (прототип) дружественной функции в классе (Разрешение функции обращаться к закрытым полям). (Как прототип функции).
};

void ChangeX(Point& value) {						//Дружественная функция, которая что-то делает.
	value.x = -1;
}

int main()
{
	setlocale(LC_ALL, "Russian");
	Point a(5, 12);
	ChangeX(a);							//Вызов	дружественной функции.					

	return 0;
}


______________________________________________________________________________________
Определение методов вне класса
class MyClass				//Определение класса.
{
public:
	void PrintMessage();		//Прототип(сигнатура) метода.

};

void MyClass::PrintMessage()		//Определение метода вне его класса. (Функция глобальна и она не пренадлежит ни одному из классов).
{
	cout << "Hello!" << endl;
}

int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a;
	a.PrintMessage();

	return 0;
}


______________________________________________________________________________________
Дружественный метод класса
Метод одного класса может быть дружественным к методу другого класса.

class Apple;											//Определение класса Apple. Для того чтобы класс Human знал, что класс Apple существует.
class Human;

class Human {
public:
	void TakeApple(Apple& apple);								//Сигнатура метода TakeApple.
		
	void EatApple(Apple& apple) {								//Этот метод не дружественный к классу Apple, и он не может получать доступ к полям класса Apple.

	}
};

class Apple {
public:
	Apple(int weight, string color) {
		this->weight = weight;
		this->color = color;
	}
private:
	int weight;
	string color;
	friend void Human::TakeApple(Apple& apple);						//Определение (прототип) дружественной функции для этого класса.
 };



int main()
{
	setlocale(LC_ALL, "Russian");
	Apple apple(150, "Red");
	Human human;
	human.TakeApple(apple);
	return 0;
}

void Human::TakeApple(Apple& apple) 								//Реализация метода. 
{
	cout << "TakeApple: " << "weight = " << apple.weight << " color = " << apple.color << endl;
}


______________________________________________________________________________________
Дружественные классы

Они нужны, если нам нужно чтобы все методы класса были видны для другого класса, при этом не описывая каждый метод отдельно.

class Apple;											//Определение класса Apple. Для того чтобы класс Human знал, что класс Apple существует.
class Human;

class Human {
public:
	void TakeApple(Apple& apple);								//Сигнатура метода TakeApple.

	void EatApple(Apple& apple) {								//Поскольку весь класс Human является дружественным, теперь он может получать 
												//	доступ к полям класса Apple.
	}
};

class Apple {
	friend Human; 										//Объявляем что класс Human является дружественным к нашему классу Apple.	
public:
	Apple(int weight, string color) {
		this->weight = weight;
		this->color = color;
	}
private:
	int weight;
	string color;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Apple apple(150, "Red");
	Human human;
	human.TakeApple(apple);
	return 0;
}

void Human::TakeApple(Apple& apple) 								//Реализация метода. 
{
	cout << "TakeApple: " << "weight = " << apple.weight << " color = " << apple.color << endl;
}



______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Константные объекты и функции const 

Объекты классов также могут представлять константы:
class Person 
{
public:
    std::string name;	// Имя
    unsigned age;	// Возраст

    Person(std::string p_name, unsigned p_age) {	
        name = p_name;
        age = p_age;
    }
};
int main()
{
    const Person tom{"Tom", 38};						// Константный экземпляр класса
    
    std::cout << "Name: " << tom.name << "\tAge: " << tom.age << std::endl;	// Мы можем получить данные константы
    
    // tom.name = "Tom";    // ! Ошибка						// но изменить их нельзя
    // tom.age = 38;        // ! Ошибка
}

Но при работе с константными объектами мы можем получить данные их полей, но изменить их не можем. Так, если в примере выше мы раскомментируем строку, то мы столкнемся с ошибкой на 
этапе компиляции, так как объект tom - константа.

tom.name = "Tom"; // ! Ошибка




################
Функции константного объекта
Константность объекта накладывает некоторые ограничения на вызов его функций. Например, в класс Person выше добавим функцию print() для вывода данных объекта:
class Person 
{
private:
    std::string name;	// Имя
    unsigned age;	// Возраст

public:
    Person(std::string p_name, unsigned p_age) {
        name = p_name;
        age = p_age;
    }
    void print() {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl; 	// Обычная функция
    }
};
int main()
{
    const Person tom{"Tom", 38};
    tom.print();    // ! Ошибка
}

Как ни странно, данный пример не скомпилируется из-за функции print, хотя в ней нет никакого изменения полей объекта. Потому что в любой функции класса теоретически можно изменять 
его поля, а компилятор не может определить, меняется ли значение в функции или нет. Поэтому одинаково отказывается компилировать и те функции, которые меняют состояние объекта, и 
те функции, которые его не меняют.

Для константного объекта можно вызывать только константные функции. Для определения таких функций после списка параметров ставится ключевое слово const:

class Person 
{
private:
    std::string name; 	// Имя
    unsigned age;	// Возраст

public:
    Person(std::string p_name, unsigned p_age){
        name = p_name;
        age = p_age;
    }
    
    void print() const {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;		// константная функция
    }
};
int main()
{
    const Person tom{"Tom", 38};
    tom.print();            // Name: Tom       Age: 38
    Person bob{"Bob", 42};
    bob.print();            // Name: Bob       Age: 42
}

В данном случае функция print определена как константная, поэтому ее можно вызвать как для константого, так и для неконстантного объекта. В любом случае в константной функции НЕ 
должно происходить изменение полей класса. В константых методах нельзя менять поля. Я могу вызывать только константые операции над полями.

Еще одно ограничение, с которым можно столкнуться, касается вызова в константной функции других функций этого же класса - константная функция может вызыть только константные функции
класса:

class Person 
{
private:
    std::string name;	// Имя
    unsigned age;	// Возраст

public:
    Person(std::string p_name, unsigned p_age){
        name = p_name;
        age = p_age;
    }
    std::string getName() const{
        return name;
    }
    unsigned getAge() const{
        return age;
    }
    void print() const {	
        std::cout << "Name: " << getName()  << "\tAge: " << getAge() << std::endl; 		// в константной функции можно  вызывать только константные функции 
    }
};
int main()
{
    const Person tom{"Tom", 38};
    tom.print();            // Name: Tom       Age: 38
    Person bob{"Bob", 42};
    bob.print();            // Name: Bob       Age: 42
}

Здесь дополнительно определены функции getName и getAge, которые соответственно возвращают имя и возраст. Обе эти функции константные, поэтому их можно вызвать в константной 
функции print.



################
Возвращение констант

Еще одно ограничение, связанное с константными функциями, состоит в том, что, если мы хотим возвратить из константной функции указатель или ссылку, то они указетель должен указывать
на константу, а ссылка должна быть константной. В чем это проявляется? Попробуем возвратить ссылку и указатель:

class Person 
{
private:
    std::string name;	// Имя
    unsigned age;	// Возраст

public:
    Person(std::string p_name, unsigned p_age){
        name = p_name;
        age = p_age;
    }
    
    const std::string& getName() const{		// возвращаем константную ссылку
        return name;
    }
    
    const unsigned* getAge() const{		// возвращаем указатель на константу
        return &age;
    }
    void print() const {
        std::cout << "Name: " << name  << "\tAge: " << age << std::endl;
    }
};
int main()
{
    const Person tom{"Tom", 38};
 
    std::string tom_name =tom.getName();
    const unsigned* tom_age = tom.getAge();
 
    std::cout << "Name: " << tom_name  << "\tAge: " << *tom_age << std::endl;
}

Здесь константная функция getName возвращает константную ссылку, а функция getAge - указатель на константу.



################
Ключевое слово mutable

Иногда бывает необходимо, чтобы какие-то данные константного объекта все-таки можно было менять. В этом случае для переменной, которую необходимо менять, можно использовать 
ключевое слово mutable. И даже если объект является константным, значение такой переменной можно изменить.

class Person 
{
public:
    std::string name;		// Имя
    mutable unsigned age;   	// переменную age можно изменить

    Person(std::string p_name, unsigned p_age){
        name = p_name;
        age = p_age;
    }
    void print() const {
        std::cout << "Name: " << name  << "\tAge: " << age << std::endl;
    }
};
int main()
{
    const Person tom{"Tom", 38};
    tom.age = 22;
    tom.print();    // Name: Tom       Age: 22
}




______________________________________________________________________________________
static

Представим, что в классе Apple мы описали какую нибудь переменную, например int Count. Если мы создаём в main несколько объектов класса, то у каждого такого объекта будет своя
переменная int Count (где то в отдельной области памяти будет лежать сам объект Apple, и далее в нём поле Count). Если же мы создаём переменную с модификатором static, то
такая переменная будет являться общей для всех объектов класса (Она у всех одинаковая, если поменять значение этой переменной у одного объекта, то поменяются значения
у всех объектов). Синтаксис: static int Count;

Мы можем обратиться напрямую к статической переменной, минуя объекты: Apple::Count.
Перед тем как использовать статическую переменную, нужно её проинициализировать. Делается это вне класса: int Apple::Count = 0;

class Apple {
public:
	static int Count;					//Объявление статической переменной.
	Apple(int weight, string color) {			//При создании объекта класса
		this->weight = weight;
		this->color = color;
		Count++;					//Увеличиваем кол-во яблок каждый раз при создании нового объекта.
	}
private:
	int weight;
	string color;
};
int Apple::Count = 0;						//Инициализация статической переменной(вне класса).

int main()
{
	setlocale(LC_ALL, "Russian");
	Apple apple(150, "Red");
	cout << Apple::Count << endl;
	return 0;
}


######################
Относиться не только к классам:
Если глобальную переменную пометить словом static, то она будет видна только внутри cpp файла в котором она есть.
static int f; // переменна в глобальной области
Это тоже самое что и создать анонимный namespace


______________________________________________________________________________________
Статические методы класса

Статические методы имеют такое же поведение, как и статические поля класса. Если написали статические метод, то он будет один единственный для всех объектов класса. Мы также
можем обращаться к нему напрямую, минуя обращения к объектам класса. 
В статических методах работа с нестатическими полями запрещена (поля не понимают к какому конкретно объекту они привязаны). Если же мы хотим написать статический 
метод, который должен работать с конкретными объектами класса, то мы должны в этот метод передавать либо ссылку либо указать на этот объект класса.

class Apple {
public:
	Apple(int weight, string color) {
		this->weight = weight;
		this->color = color;
		Count++;					
		id = Count;					//При создании объекта присваиваем ему новый id
	}
	int GetId() {						//Метод получения id
		return id;
	}
	static int GetCount() {
		return Count;
	}
	static void ChangetColor(Apple & apple, string color) { //Статический метод, который перекрашивает яблоки.
		apple.color = color;
	}
private:
	static int Count;
	int weight;
	int id;							//Поле id нашего класса						
	string color;
};
int Apple::Count = 0;						

int main()
{
	setlocale(LC_ALL, "Russian");
	Apple apple(150, "Red");
	Apple apple2(250, "Green");
	cout << apple.GetId() << endl;
	cout << apple2.GetId() << endl;
	cout << Apple::GetCount() << endl;			
	Apple::ChangetColor(apple, "Green");			//Вызов статического метода.
	return 0;
}


Статическое поле в классе можно проинициализировать, но нельзя определить. Определить это поле можно только вне класса. Статическое константное поле можно определить в классе.
Статический метод находиться в зоне видимиости класса. Мы можем вызвать статический метод, не используя объекты класса.

struct S {
	static int x;			// Определяем только x вне класса
	static const y = 2;		// Определяем y в классе

	static void f() {
		std::cout << "Hi";
	}
};

int S::x = 1;				// Определяем только x вне класса
	
int main() {				
	S::f();				// Вызов статического метода без объекта
}



______________________________________________________________________________________
Вложенные классы 

Вложенный класс (внутренний, inner) это класс, реализация которого описана внутри другого классе. А тот класс в который мы вкладываем другой класс называется объемлющий.
Вложенные классы обычно используют для внутренних нужд того класса, который его содержит.

class image { //Класс картинки
public:
	void GetImageInfo() { 			//Перебираем все пиксели
		for (int i = 0; i < LENGTH; i++){
			cout << "№ " << i << pixels[i].GetInfo() << endl;	//Вызов метода внутреннего класса Pixel.
		}
	}
private:
	class Pixel { 				//Класс пикселей(внутренний)
	public:
		Pixel(int r, int g, int b) {
			this->r = r;
			this->g = g;
			this->b = b;
		}
		string GetInfo() {
			return " Pixel: r = " + to_string(r) + " g = " + to_string(g) + " b = " + to_string(b);
		}
	private:
		int r;
		int g;
		int b;
	};

	static const int LENGTH = 5;
	Pixel pixels[LENGTH]{ 			//Вручную задали все пиксели.
		Pixel(0,6,64),
		Pixel(4,14,10),
		Pixel(111,4,24),
		Pixel(244,244,14),
		Pixel(11,179,64)
	};
};


int main()
{
	setlocale(LC_ALL, "Russian");
	image img;
	img.GetImageInfo();			//Вызов метода внешнего класса image.
	return 0;
}


______________________________________________________________________________________
Массив объектов класса

class Pixel { //Класс пикселей
public:
	Pixel() {
		r = g = b = 0;
	}
	Pixel(int r, int g, int b) {
		this->r = r;
		this->g = g;
		this->b = b;
	}
	string GetInfo() {
		return " Pixel: r = " + to_string(r) + " g = " + to_string(g) + " b = " + to_string(b);
	}
private:
	int r;
	int g;
	int b;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	const int LENGTH = 5;
	//Pixel p(11, 44, 112);
	Pixel arr[LENGTH]{			//Создание статического массива в котором хранятся объекты класса Pixel
		Pixel(0, 6, 64),
		Pixel(4, 14, 10),
		Pixel(111, 4, 24),
		Pixel(244, 244, 14),
		Pixel(11, 179, 64)
	};

	cout << arr[0].GetInfo() << endl;
	arr[0] = Pixel(11, 44, 112);
	cout << arr[0].GetInfo() << endl;

	Pixel *arr2 = new Pixel[LENGTH];	//Создание динамического массива в котором хранятся объекты класса Pixel
	arr2[0] = Pixel(11, 44, 112);
	cout << arr2[0].GetInfo() << endl;
	delete []arr2;
		
	return 0;
}


______________________________________________________________________________________
Агрегация и композиция

Эти понятия описывают отношения между классами. И агрегация и композиция это включение одного класс в другой, но с некоторыми отличиями. Агрегация позволяет использовать тот
класс который мы включаем в другой класс и ещё в других местах с другими классами. (отношение «часть - целое» между двумя равноправными объектами, Оба объекта могут 
существовать независимо). А композиция это более строгий вариант агригации. При композиции класс, который включается в другой класс без этого класса просто не может 
существовать, и нужен только для его служебных целей.

Пример композиции: В классе Human описан класс Brain, и класс Brain без класса Human никак существовать не может. Мозг инкапсулирован в человека.
class Human {						//Класс человек
public:
	void Think() {					//В человеке есть метод думать. При вызове метода думать у человека, вызывается метод думать у внутреннего класса мозг.   
		brain.Think();				//Делегируем метод думать другому классу.
	}
private:
	class Brain{					//В private секции класа человек есть внутренний класс мозг
	public:
		void Think() {				//У мозга есть метод думать
			cout << "Я думаю!" << endl;
		}
	};
	Brain brain;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Human human;
	human.Think(); //Вызываем метод думать у человека. В классе думать у человека, вызыватся метод думать у внутренего класса мозг.
		
	return 0;
}

Пример Агрегация: Класс Cap описан отдельно от класса Human. В классе Human есть метод посмотреть на кепку. Так же у нас есть отдельный класс Model( типо манекен). У него тоже
есть метод посмотреть на кепку. Класс кепке не зависит от других классов.

class Cap {					//Класс кепка
public:
	string GetColor() {			//Получить цвет кепки.
		return color;
	}
private:
	string color = "red";
};

class Human {					//Класс человек
public:
	void InspectTheCap() {			//Метод посмотреть на кепку.
		cout << "Моя кепка " << cap.GetColor() << " цвета."<< endl;	//Вызов метода класса кепка
	}
private:
	Cap cap;
};

class Model {					//Класс манекен
public:
	
	void InspectTheCap() {			//Метод посмотреть на кепку.
		cout << "Кепка " << cap.GetColor() << " цвета." << endl;	//Вызов метода класса кепка
	}
private:
	Cap cap;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Human human;
	human.InspectTheCap();
		
	return 0;
}


______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________

Наследование в ООП 

Наследование это механизм, когда один объект может наследовать свойства и поведение другого объекта, и использовать их. Так же к методам, которые он унаследовал, 
он может добавить чтото своё. Класс, от которого мы будем унаследовать свойства называется базовым или родительским классом. Класс, который мы унаследовали от этого базового 
класса, называется производным (дочерним, потомок, наследник).
Синатаксис наследования:

class Human { 			//Базовый класс.

};

class Student : public Human{ 	//Класс Student является дочерним от класса Human.

};




Пример наследования:

class Human {
public:
	string name = "Иванов Иван";
};

class Student : public Human{
public:
	string group;
	void Learn() {
		cout << "Я учусь!"<< endl;
	}
};

class ExtramuralStudent : public Student {
public:
	void Learn() {
		cout << "Я бываю в универе реже обычного студента!" << endl;
	}
};

class Professor : public Human {
public:
	string subject;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Student st;
	st.Learn();
	Professor pr;
	ExtramuralStudent extraSt;
	extraSt.Learn();
		
	return 0;
}


Конструкторы при наследовании не наследуются.


______________________________________________________________________________________
Модификаторы доступа при наследовании private public protected

Если переменные или функции в базовом классе являются закрытыми, то есть объявлены со спецификатором private то, производный класс хотя и наследует эти переменные и функции, но не 
может к ним обращаться.

Однако иногда возникает необходимость в таких переменных и функциях базового класса, которые были бы доступны в производных классах, но не были бы доступны извне. То есть тот же 
private, только с возможностью доступа для производных классов. И именно для определения уровня доступа подобных членов класса используется спецификатор protected. 


Модификаторы доступа к конкретным полям и методам:

class A {
public:
	string msgOne = "Сообщение один"; 	// Доступно откуда угодно
protected:
	string msgThree = "Сообщение три"; 	// доступно только из производных(дочерних) классов
private:
	string msgTwo = "Сообщение два";  	// Недоступно ниоткуда.

};

class B : public A {
public:
	void PrintMsg() {
		cout << msgOne << endl; //Так как поле msgOne public, мы можем его использовать.
		cout << msgThree << endl; //Так как поле msgThree protected, класс наследника без проблем к нему обращается, но у нас не получится обратиться к полю через объект класса B.
		//cout << msgTwo << endl; //Так как поле msgTwo private, то мы не можем его использовать нигде, кроме того класса где мы его описали.
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	B b;
	b.PrintMsg(); // Метод public, его вызов всегда возможен.
	b.msgOne; // Поле public, его вызов всегда возможен.
	//b.msgTwo; // Поле private, его вызов возможен только в том классе, где мы его описали.
	//b.msgThree; // Поле protected, его вызов может быть только в классе, где его описали, и в унаследованных от него классах.
		
	return 0;
}





###################
Уровень доступа членов базового класса

Как мы увидели, спецификатор доступа - public, private, protected играют большую роль в том, к каким именно переменным и функциям базового класса могут обращаться производные классы.
Однако на доступ также влияет спецификатор доступа базового класса, применяемый при установке наследования:

class B : public A

Так, в примере выше мы используем спецификатор public. И здесь мы также можем использовать три варианта: public, protected или private. Если спецификатор базового класса явным 
образом не указан:

class B : A

то по умолчанию применяется спецификатор private (При наследовании структур, если спецификатор доступа не укзаан, то по умолчанию применяется спецификатор public).

Таким образом, в базовом классе при определении переменных и функций мы можем использовать три спецификатора для управления доступом: public, protected или private. И те же три 
спецификатора мы можем использовать при установке наследования от базового класса. Эти спецификаторы накладываются друг на друга и образуют 9 возможных комбинаций.


Свойства модификаторов доступа для полей и методов, которые были в родительском классе и были унаследованы в дочерний класс с модификатором наследования public никак не 
меняются.
Если же модификатор доступа дочернего класса будет private, то все поля, которые мы унаследовали от родительского класса, поменяют свой модификатор доступа на private.
Если же модификатор доступа дочернего класса будет protected, то этот модификатор повлияет только на public поля. Они станут protected.

			Исходный модификатор доступа
-------------------------------------------------------------------- 		
	     	|	       |	 |	     |
		|     public   | private | protected |
  		|	       |	 |	     |
--------------------------------------------------------------------
     		|	       |	 |	     |
     public  	|     public   | private | protected |
   наследование	|	       |	 |	     |
--------------------------------------------------------------------
         	|	       |	 |	     |
     private	|     private  | private | private   |
   наследование	|	       |	 |	     |
--------------------------------------------------------------------
		|	       |	 |	     |
     protected  |    protected | private | protected |
   наследование |	       |	 |	     |
--------------------------------------------------------------------


Ещё раз: вот 3 модификатора:

1) public
2) protected
3) private

Если модификтор наследования будет private, то всё измениться на private:
1) private
2) private
3) private

Если модификтор наследования будет protected, то измениться только public на protected:
1) protected
2) protected
3) private

Если модификтор наследования будет public, то ничего не изменится:
1) public
2) protected
3) private

Снизу вверх.




#################
Установка публичного доступа using

Рассмотрим пример. Пусть спецификатором базового класса будет private:

class Person
{
public:
    Person(std::string name, unsigned age)
    {
        this->name = name;
        this->age = age;
    }
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
protected:
    std::string name;   // доступно из производных классов
private:
    unsigned age;
};

class Employee: private Person
{
public:
    Employee(std::string name, unsigned age, std::string company): Person(name, age)
    {
        this->company = company;
    }
    void printEmployee() const
    {
        print();    // функция print внутри класса Employee доступна
        std::cout << name << " works in " << company << std::endl;
    }
private:
    std::string company;    // компания
};
 
int main()
{
    Employee employee {"Bob", 42, "Microsoft"};
    employee.printEmployee();   // Bob works in Microsoft
    // employee.print();       // функция print недоступна
}




Что делать, если в примере выше для класса Employee мы все таки хотим вызвать функцию print? 
Мы можем восстановить уровень доступа с помощью ключевого слова using:

class Person
{
public:
    Person(std::string name, unsigned age)
    {
        this->name = name;
        this->age = age;
    }
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
protected:
    std::string name;   // доступно из производных классов
private:
    unsigned age;
};

class Employee: private Person
{
public:
    Employee(std::string name, unsigned age, std::string company): Person(name, age)
    {
        this->company = company;
    }
    using Person::print;
    void printEmployee() const
    {
        std::cout << name << " works in " << company << std::endl;
    }
private:
    std::string company;    // компания
};
 
int main()
{
    Employee employee {"Bob", 42, "Microsoft"};
    employee.print();  // Name: Bob       Age: 42 - функция доступна
}


В классе Employee мы устанавливаем уровень доступ к функции print базового класса Person как public:
using Person::print;


После этого функция print будет иметь свой первоначальный спецификатор доступа - public и будет доступна вне класса Employee:
employee.print();    // Name: Bob       Age: 42 - функция доступна

Подобным образом можно сделать публичной и переменную name, несмотря на то, что в базовом классе Person она определена как protected:
using Person::name;

Однако если переменные и функции определены в базовом классе как приватные сделать их публичными нельзя.

#########################
Второй пример using

Можно внести имена из одной области видимости в другую используя using:

struct Base {
protected:
	void f(){};
};

struct Derived : Base {
	using Base::f;
};

С помощью этого то что вам в наследнике доступно привнести во вне. Когда у нас написан using то с точки зрения внешнего пользователя важно какая приватность у этого using, и
уже не важно какая приватность у исходного метода, поскольку мы решаем на уровне дочернего класса, а в базовый класс не лезем. Не работает с private.


Видимость и доступность полей.

struct Base {
	int x = 1;
};

struct Derived : Base {
	int x = 2;
};

int main() {
	Derived d;
	std::cout << d.x;	// Вывод в консоль: 2
	std::cout << d.Base::x;	// Вывод в консоль: 1
}



______________________________________________________________________________________
Видимость и доступность методов при наследовании

Видимость и доступность это разное. Видимость это то что попало к нам в область видимости. Доступность это то что нам можно использовать с точки зрения уровня доступа. 
Сначала выбирается область видимости, потом делается перегрузка, потом проверяется приватность. Приватность никак не влияет на наличие или отсутствие у нас каких либо
полей и методов, они есть у нас всегда даже при private. Просто при наследовании с модификатором private у нас к ним нет доступа.


Создаём объект наследуемого класса, и вызываем из него функцию f. 

struct Base {
	void f(int){
		std::cout << 1;
	}
};

struct Derived : Base {
	void f(double){
		std::cout << 2;
	}
};

int main() {
	Derived d;
	d.f(0); 
}

У нас есть f(int) в классе Base, и f(double) в классе Derived. Мы вызываемся от int 0, но мы вызываемся
у Derived. Что будет? Выведется f от Base или произойдёт конверсия в Derived? Или CE?  Это работает по такому принципу: у нас не происходит
никакой перегрузки функции в данном случае, у нас происходит затмение имён, одна функция замещает другую. Функция f() В Derived замещает имя f()  в Base, в данном случае 
именна из Base просто не рассматриваются. Выберется f(double). У родителя метод f просто скрыт. Чтобы обратиться к нему явно можно использовать квалифайт id:

d.Base::f(0);

Есть 3 этапа вызова:
1) Сначала мы берём кандидатов на перегрузку из области видимости
2) Потом выбираем кто победил в перегрузке 
3) И затем уже проверяем приватность


______________________________________________________________________________________
Порядок вызова конструкторов при наследовании

Конструкторы при наследовании не наследуются.

Пример: Класс А родительский. Класс B является наследником класса А. Класс С является наследником класса В. При создания объекта класса С, сначала полностью создаётся объект класса
родителя (A), инициализируются все его поля и вызвается его конструктор, потом инициализируются поля наследника (B) и вызывается его конструктор, и только потом инициализируются 
все поля класса C и вызвается его конструктор.

	/-------------------------------\
	|/------------------------\	|
	||/------------------\	  |	|
	|||		     |	  |	|
	|||	Класс A	     |	  |	|
	|||		     |	  |	|
	|||		     |	  |	|
	||\------------------/	  |	|
	||			  |	|
	||	    Класс B	  |	|
	|\------------------------/	|
	|				|
	|		  Класс C	|	
	\-------------------------------/


class A {
public:
	A() {
		cout << "Конструктор вызвался класса A!" << endl;
	}
};

class B : public A {
public:
	B() {
		cout << "Конструктор вызвался класса B!" << endl;
	}
};

class C : public B {
public:
	C() {
		cout << "Конструктор вызвался класса C!" << endl;
	}
};
int main()
{
	setlocale(LC_ALL, "Russian");
	C c;							//Создаём только объект класса С!
		
	return 0;
}

Вывод в консоли:
Конструктор вызвался класса A!
Конструктор вызвался класса B!
Конструктор вызвался класса C!

При наследовании класс С не может существовать без класса В. Класс В не может существовать без класса А. 
Порядок вызова деструкторов при наследовании:

Конструктор вызвался класса A!
Конструктор вызвался класса B!
Конструктор вызвался класса C!

Деструктор вызвался класса С!
Деструктор вызвался класса B!
Деструктор вызвался класса А!


При разрушении объекта деструктором класса, сначала отрабатывает деструктор, а уже за тем разрушаются поля класса. Т.е. из деструктора ещё валидно обращаться к полям и 
методам моего класса, и класса родителя.


######################

Можно создать дефолтный конструктор базового класса. Но если это не подходит, то можно в конструкторе наследника указать чем приинициализировать базовый класс:

struct Base {
	int x;
	Base(int x) : x(x){}
};

struct Derived : Base {
	double y;
	Derived(double y) : Base(0), y(y){} 	// Указываем что Base инициализируется от int = 0
};


______________________________________________________________________________________
Вызов конструктора базового класса из конструктора класса-наследника

Как мы выяснили при создании дочернего класса B, сначала создаётся класс А с конструктором по умолчанию. Но если нам нужен конкретный конструктор класса А, нам нужно явно
его указать.

class A {
public:	
	A() {					//1.2) Создаём объект класса A  с конструктором по умолчанию.
		msg = "Пустое сообщение.";
	}
	A(string msg) {				//1.2) Создаём объект класса A  с конкретным конструктором.
		this->msg = msg;
	}
	void PrintMsg() {
		cout << msg << endl;
	}
private:
	string msg;
};

class B : public A {
public:
	B() :A() {				//1.1) Конструктор по умолчанию класса B. Вызываем конструктор по умолчанию класса A. (Явно указываем конструктор класса А).
		cout << "Конструктор вызвался класса B!" << endl;
	}
	B(string str):A(str) {			//2.1) Вызываем конкретный конструктор класса A. (Явно указываем конструктор класса А).
		cout << "Конструктор вызвался класса B!" << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	B b1;					//1) Создание класса B с конструктором по умолчанию
	b1.PrintMsg();
	B b2("Наша новая строка");		//2) Создание класса B с конкретным конструктором
	b2.PrintMsg();
		
	return 0;
}



______________________________________________________________________________________
Подключение конструктора базового класса

Если бы у нас было бы полное соответствие по параметрам между двумя классами, то мы могли бы и не определять отдельный конструктор для Employee, а подключить конструктор базового 
класса:


class Person
{
public:
    Person(std::string name, unsigned age)
    {
        this->name = name;
        this->age = age;
    }
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
private:
    std::string name;       							//  имя
    unsigned age;           							// возраст
};
class Employee: public Person
{
public:
    using Person::Person;   							// подключаем конструктор базового класса
};
  
int main()
{
    Person person {"Tom", 38};
    person.print();     // Name: Tom       Age: 38
  
    Employee employee {"Bob", 42};
    employee.print();   // Name: Bob       Age: 42
}


Здесь в классе Employee подключаем конструктор базового класса с помощью ключевого слова using:
	
using Person::Person;

Таким образом, класс Employee фактически будет иметь тот же конструктор, что и Person с теми же двумя параметрами. И этот конструктор мы также можем вызвать для создания 
объекта Employee.



______________________________________________________________________________________
Запрет наследования

Иногда наследование от класса может быть нежелательно. И с помощью спецификатора final мы можем запретить наследование:

class Person final
{
};

После этого мы не сможем унаследовать другие классы от класса Person. И, например, если мы попробуем написать, как в случае ниже, то мы столкнемся с ошибкой:

class Employee : public Person
{
};



______________________________________________________________________________________
Скрытие функционала базового класса

С++ позволяет определять в производном классе переменные и функции с теми же именами, что имеют переменные и функции в базовом классе. В этом случае переменные и функции 
производного класса будут скрывать одноименные переменные и функции базового класса.

Скрытие функций

Производный класс может определить функцию с тем же именем, что и функция в базовом классе, с тем же или другим списком параметров. Для компилятора такая функция будет существовать 
независимо от базового класса. И подобное определение функции в производном классе не будет переопределением функции из базового класса.

class Person
{
public:
    Person(std::string name, unsigned age) : name(name), age(age)
    {}
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
private:
    std::string name;
    unsigned age;
};

class Employee: public Person
{
public:
    Employee(std::string name, unsigned age, std::string company): 
        Person(name, age), company(company)
    { }
    void print() const
    {
        std::cout << "Works in " << company << std::endl;
    }
private:
    std::string company;
};
 
int main()
{
    Employee tom{"Tom", 38, "Google"};
    tom.print(); 							// Works in Google
}

Здесь класс Person, который представляет человека, определяет функцию print(), которая выводит значение переменных name и age. Класс Employee, который представляет сотрудника 
компании и является производным от класса Person, также определяет функцию print(), которая выводит значение переменной company. В итоге объект Employee будет использовать 
реализацию функции print класса Employee, а не класса Person.

Функция print в Employee скрывает функцию print класса Person. Однако иногда может потребоваться возможность вызвать реализацию функции, которая определена именно в базовом классе. 
В этом случае можно использовать оператор ::

базовый_класс::функция

class Person
{
public:
    Person(std::string name, unsigned age) : name(name), age(age)
    {}
    void print() const
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
private:
    std::string name;
    unsigned age;
};
class Employee: public Person
{
public:
    Employee(std::string name, unsigned age, std::string company): 
        Person(name, age), company(company)
    { }
    void print() const
    {
        Person::print();    						// вызываем функцию print из базового класса
        std::cout << "Works in " << company << std::endl;
    }
private:
    std::string company;
};
 
int main()
{
    Employee tom{"Tom", 38, "Google"};
    tom.print();
}

Здесь вызов Person::print() представляет обращение к функции print базового класса Person. В итоге мы получим другой консольный вывод:

Name: Tom  Age: 38
Works in Google



______________________________________________________________________________________
Скрытие переменных

Производный класс может иметь переменные с тем же именем, что и базовый класс, Хотя такие ситуации могут привести к путанице, и, возможно, представляют нелучший вариант наименования
переменных. Тем не менее мы можем так делать. Например:

class Integer
{
public:
    Integer(unsigned value): value(value)
    { }
    void printInteger() const
    {
        std::cout << value << std::endl;
    }
protected:
    unsigned value;
};
class Decimal: public Integer
{
public:
    Decimal(unsigned i_value, unsigned d_value): Integer(i_value), value(d_value)
    { }
    void printDecimal() const
    {
        std::cout << Integer::value << "." << value << std::endl;
    }
protected:
    unsigned value;
};
 
int main()
{
    Decimal decimal{12345, 3456};
    decimal.printInteger(); // 12345
    decimal.printDecimal(); // 12345.3456
}

Здесь класс Integer представляет целое число, значение которого хранится в переменной value. Этот класс наследуется классом Decimal, который представляет дробное число. Целая часть 
хранится в поле value класса Integer. А для хранения дробной части определена своя переменная value. Причем переменная value в Integer имеет спецификатор protected, поэтому 
теоретически мы могли бы обращаться к ней в классе Decimal. Однако поскольку в Decimal определена своя переменная value, то она скрывает переменную value и базового класса.

Чтобы все таки обратиться к переменной value из базового класса, надо использовать оператор ::

базовый_класс::переменная

например:

Integer::value

Стоит учитывать, что таким образом мы можем обратиться только к переменным со спецификаторами public и protected. К приватным же переменным базового класса мы так обратиться не 
можем.


______________________________________________________________________________________
Размещение объектов в памяти при наследовании

Какой будет размер следущего класса Derived? Правельный ответ 16, потому что поля должны лежать в порядке объявления, сначала лежит кусок соответствующий Base, потом Derived. 
Поскольку double я не должен класть по адресу некратному 8, придётся сделать беддинг между Base и Derived и получиться 16.

struct Base {
	int x;
};

strict Derived : Base {
 	double y;
};

int main() {
	std::cout << sizeof(Derived);
}



Сколько весит пустая структура?

Полностью пустая структура занимает 1 байт в памяти, поскольку это минимум сколько может занимать объект в памяти, потому что у разных объектов должны быть разные веса.
Если бы sizeof пустой структуры был бы 0, я мог бы объявить массив таких структур размера 100, и этот массив тоже был бы размером 0. И тогда адресс начала и конца этого
массива ничем бы не отличались. Адреса разных объектов должны быть разными, мы должны уметь отличать объекты по их адресам. Банально, чтобы в оператору присванивания 
мы могли проверить на присваивание самому себе. если бы у нас небыло правило, что не бывает объектов размера 0, то проверка в операторе была бы некорректна в случае с 
объектом размера 0. C++ гарантирует нам что у разных объектов разные адреса. Так что у структуры Empty размер 1 байт:

struct Empty{};	// Размер 1 байт



Сколько сейчас будет весить Derived? В Base нет ни одного поля. Наличие методов не влияет на размер, если только это не виртуальные методы.  

struct Base {			// размер 1 байт
	void f(){};
};

strict Derived : Base {
 	double y;		// размер 8 байт
	void g(){};
};

Правильный ответ - 8. 

Это называется EBO - Empty Base Optimization

Правило такое: если у нас есть пустой класс, то размер его самого по себе 1, но если вы делаете пустой класс чьим то наследником, то ему разрешается ничего в памяти не 
занимать, потому что мы не нарушаем правила, что у разных объектов разные адреса. В данном случае поле y это будет всё что есть в Derived, а Base не будет весить ничего. 



______________________________________________________________________________________
Конструктор копирования

Если у нас в наследнике нет копи конструктора, то он неявно генирируется и при этом использует копи конструктор родителя, а если его там нет, то он тоже неявно генирируется, 
а если его нельзя сгенирировать, то это CE. Анологично с оператором присваивания и с деструктором. 


Наследование конструкторов
В C++11 добавили фичу под названием наследование конструкторов. Мы можем написать using на конструктор. Например я хочу создать класс Derived, от всего того же что и класс
Base, не переписывая все его конструкторы. Конструкторы копирования и перемещения не наследуются!

struct Base {
	int x;
	Base(int x) : x(x) {}
	Base(const Base& other) : x(other.x) {std::cout << "Copy";}	// Конструкторы копирования не наследуются. При копировании наследника, наследник сгенирирует
};									// тривиальный конструктор копирования по умолчанию

struct Derived : Base {
	int y = 0;
	using Base::Base; 			// Наследуем все конструкторы от Base
	Derived(int x, int y) : Base(x), y(y){}	// при этом можем создавать и свои конструкторы
};

Теперь Derived можно создавать от int, так же как и Base. При этом все поля Derived автоматически инициализируются по умоланию.



______________________________________________________________________________________
Приведение типов при наследовании

Derived это частный случай Base. Это означает, то что если мы ожидаем где то Base, то туда можно было бы и отдать Derived.

strict Base {
	int x = 1;
};

strict Derived : Base {
	int y = 2;
};

void f(&Base) {			// Мы ожидаем тип Base. 
	std::cout << b.x;
}

int main() {
	Derived d;
	f(d);			// Но тип Derived тоже подходит, т.к. это наследник Base.
}

Если у меня есть наследник, а функция принимает родителя, то её можно подсунуть наследника вместо родителя, и всё будет корректно работать. Потому что наследник умеет всё 
тоже, что и родитель, и возможно чтото ещё. В этом случае произойдёт неявный каст. В обратную сторону это не работает.

Мы принимали Base в функции f по ссылке, однако по значению тоже можно принять. В этом случае произойдёт явление которое называется срезка при копировании.

Slicing (срезка при копировании) - будет неявно сгенирирован конструктор Base от Derived, который просто заберёт у Derived ту часть, которую относилась к Base. Т.е.
создастся новый объект типа Base при копировании. В обратную сторону нельзя.

Публичное наследование:
Таблица Derived -> Base cast:
		 |copy(Slicing) | ptr 	| ref
implicit(неявный)|  +		| +	|  +		+ означает что работает
static_cast      |  +		| +	|  +
reinterpret_cast | CE		| +	|  +

Таблица Base -> Derived cast:
		 |copy(Slicing) | ptr 	| ref
implicit(неявный)|	CE	| CE	|  CE
static_cast	 |	CE	| +UB	|  +UB		+UB - possible UB	
reinterpret_cast |	CE	| +UB	|  +UB


Приватное наследование:
Таблица Derived -> Base cast:
		 |copy(Slicing) | ptr 	| ref
implicit(неявный)|	CE	| CE	|  CE		CE Потому что private
static_cast	 |	CE	| CE	|  CE
reinterpret_cast |	CE	| +	|  +

Таблица Base -> Derived cast:				Всё тоже самое
		 |copy(Slicing) | ptr 	| ref
implicit(неявный)|	CE	| CE	|  CE
static_cast	 |	CE	| +UB	|  +UB		+UB - possible UB	
reinterpret_cast |	CE	| +UB	|  +UB




______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Виртуальные функции и их переопределение (Полиморфизм, virtual, override)

При вызове функции программа должна определять, с какой именно реализацией функции соотносить этот вызов, то есть связать вызов функции с самой функцией. В С++ есть два типа 
связывания - статическое и динамическое.

Когда вызовы функций фиксируются до выполнения программы на этапе компиляции, это называется статическим связыванием (static binding), либо ранним связыванием (early binding). 
При этом вызов функции через указатель определяется исключительно типом указателя, а не объектом, на который он указывает. Например:

class Person
{
public:
    Person(std::string name): name{name}
    { }
    void print() const
    {
        std::cout << "Name: " << name << std::endl;
    }
private:
    std::string name;       					//  Имя
};

class Employee: public Person
{
public:
    Employee(std::string name, std::string company): Person{name}, company{company}
    { }
    void print() const
    {
        Person::print();
        std::cout << "Works in " << company << std::endl;
    }
private:
    std::string company;    					// Компания
};
  
int main()
{
    Person tom {"Tom"};						// Создаём объект базового класса 
    Person* person {&tom};					// Создаём указатель на объект базового класса
    person->print();     					// Вызываем функцию print. Поскольку тип указателя Person, Вызывается функция базового класса. Она выводит: Name: Tom
 
    Employee bob {"Bob", "Microsoft"};				// Создаём объект дочернего класса
    person = &bob;						// Указателю на базовый класс присваиваем адрес объекта дочеренго класса
    person->print();    					// Вызываем функцию print. Всё ровно вызывается функция базового класса, поскольку тип указателя Person. Она выводит: Name: Bob	
}

В данном случае класс Employee наследуется от класса Person, но оба этих класса определяют функцию print(), которая выводит данные об объекте. В функции main создаем два объекта и 
поочередно присваиваем их указателю на тип Person и вызываем через этот указатель функцию print. Однако даже если этому указателю присваивается адрес объекта Employee, то все равно 
вызывает реализация функции из класса Person:

Employee bob {"Bob", "Microsoft"};
person = &bob;
person->print();    // Name: Bob

То есть выбор реализации функции определяется НЕ типом объекта, А типом указателя. Консольный вывод программы:

Name: Tom
Name: Bob



______________________________________________________________________________________
Динамическое связывание и виртуальные функции

Другой тип связывания представляет динамическое связывание (dynamic binding), еще называют поздним связыванием (late binding), которое позволяет на этапе выполнения решать, функцию 
какого типа вызвать. Для этого в языке С++ применяют виртуальные функции. Для определения виртуальной функции в базовом классе функция определяется с ключевым словом virtual. 
Причем данное ключевое слово можно применить к функции, если она определена внутри класса. А производный класс может переопределить ее поведение.

Определение:
1) Виртуальная функция - это такая функция, что если по ссылке или указателю на базовый класс её вызвать, то всё ровно вызовется версия дочернего класса.
2) Виртуальная функция - это такая функция, что решение какую версию выбрать принимается в рантайме а не в компайлтайме. 

Итак, сделаем функцию print в базовом классе Person виртуальной:

class Person
{
public:
    Person(std::string name): name{name}
    { }
    virtual void print() const  				// Виртуальная функция
    {
        std::cout << "Name: " << name << std::endl;
    }
private:
    std::string name;
};

class Employee: public Person
{
public:
    Employee(std::string name, std::string company): Person{name}, company{company}
    { }
    void print() const
    {
        Person::print();
        std::cout << "Works in " << company << std::endl;
    }
private:
    std::string company;
};
  
int main()
{
    Person tom {"Tom"};						// Создаём объект базового класса 
    Person* person {&tom};					// Создаём указатель на объект базового класса
    person->print();     					// Вызываем функцию print. Поскольку тип указателя Person, Вызывается функция базового класса. Она выводит: Name: Tom
    
    Employee bob {"Bob", "Microsoft"};				// Создаём объект дочернего класса
    person = &bob;						// Указателю на базовый класс присваиваем адрес объекта дочеренго класса
    person->print();    					// Вызываем функцию print. Поскольку данная функция в базовом классе теперь виртуальная, а дочерний класс 
								//	переопределил её, теперь она выводит: Name: Bob\nWorks in Microsoft
}

Таким образом, базовый класс Person определяет виртуальную функцию print, а производный класс Employee переопределяет ее. В первом же примере, где функция print не была виртуальной, 
класс Employee не переопределял, а СКРЫВАЛ ее. Теперь при вызове функции print для объекта Employee через указатель Person* будет вызываться реализация функции именно класса 
Employee. Соответственно тепепрь мы получим другой консольный вывод:

Name: Tom
Name: Bob
Works in Microsoft

В этом и состоит отличие переопределения виртуальных функций от скрытия.

Класс, который определяет или наследует виртуальную функцию, еще назвается полиморфным (polymorphic class). То есть в данном случае Person и Employee являются полиморфными классами.

Стоит отметить, что вызов виртуальной функции через имя объекта всегда (А не через указатель) разрешается статически. 

Employee bob {"Bob", "Microsoft"};
Person p = bob;
p.print();  // Name: Bob - статическое связывание


Динамическое связывание возможно только через указатель или ссылку.

Employee bob {"Bob", "Microsoft"};
Person &p {bob};    		// присвоение ссылке
p.print();  			// динамическое связывание
 
Person *ptr {&bob};    		// присвоение адреса указателю
ptr->print();  			// динамическое связывание

При определении вирутальных функций есть ряд ограничений. Чтобы функция попадала под динамическое связывание, в производном классе она должна иметь тот же самый набор параметров и 
возвращаемый тип, что и в базовом классе. Например, если в базовом классе виртуальная функция определена как константная, то в производном классе она тоже должна быть константной. 
Если же функция имеет разный набор параметров или несоответствие по константности, то мы будем иметь дело со скрытием функций, а не переопределением. И тогда будет применяться 
статическое связывание.

Также статические функции не могут быть виртуальными.


##########################
Ещё пару объяснений

Пример с равенством фигур
Представим что у нас на плоскости есть 2 круга. У них одинаковый радиус, но разные центры, они сдвинуты относительно друг друга. Вопрос: эти два круга равны? 
В стандартном понимании геометрии да, они равны.
Однако что такое круг, круг это множество точек. Множества точек первого и второго круга равны? Нет. Потому что для множества точек равенство определено иначе, чем для
частных случаев множеств точек. Мы задаём один и тот же вопрос про одни и теже объекты, но в зависимости о того задаём мы вопрос как про частный случай, или как про общий
случай, по разному применяются операции. В зависимости от того как мы назвали объект, мы обратились к нему как к частному или как к общему представителю своего класса,
некоторые операции могут начать работать по разному. Эта та идея которая стоит за понятием виртуальных и невиртуальных функций.

struct Base{
	void f(){
		std::сout << 1;
	}
};

struct Derived : Base{
	void f(){
		std::сout << 2;
	}
};

int main() {
	Derived d;
	Base& b = d;
	b.f();		// Выведиться 1, а не 2
}

Если мы просто объявим функции так, то это будет работать как в случае с равенством кругов. Как добиться того, чтобы вызвался метод Derived ,а не Base? Сделать функцию
виртуальной.

struct Base{
	virtual void f(){
		std::сout << 1;
	}
};

struct Derived : Base{
	void f(){
		std::сout << 2;
	}
};

int main() {
	Derived d;
	Base& b = d;
	b.f();		// Выведиться 2, а не 1
}

Виртуальная функция, это такая функция, что будучи вызванной у объекта по ссылке родителя, она всё ровно работает как версия от наследника. Функция f() в Derived тоже 
виртуальная автоматически, потому что она по сигнатуре совпадает с той, которая унаследована и была там виртуальной. Тоже самое от указателя.

int main() {
	Derived d;
	Base&* b = &d;
	b->f();		// Выведиться 2, а не 1
}

Но без * и & выведется 1, потому что никакого наследника уже нет.

int main() {
	Derived d;
	Base& b = d;
	b.f();		// Выведиться 1, а не 2
}


Тип, в котором есть хотябы одна виртуальная функция называется полиморфным типом. В том числе тип, в котором хотябы одна виртуальная функция унаследована.

Утечка памяти:

struct Base{
	virtual void f(){
		std::сout << 1;
	}
};

struct Derived : Base {
	int *p = new int(0);
	void f() {
		std::сout << 2;
	}
	~Derived() {
		delete p;
	}
};

int main() {
	Base *b = new Derived();	// Неявный каст от указателя на наследника к указателю на родителя.
	delete b;
}

Здесь утечка памяти. Деструктор, как и любой метод, он вызывается от того типа, от которого наша переменная. Если мы делаем delete b, где b указатель на Base, а не на 
Derived, то и деструктор вызовется от Base, но он тривиальный, и таким образом деструктор Derived не выполнится.

delete состоит из двух частей. Он вызывает десктруктор и освобождая память.
new выделяет память и вызывает конструктор на этой памяти.
Это ключевое отличии new от malloc и delete от free. new вызывает конструктор, а malloc просто выделяет память и объект на ней никокого не создаётся.

Чтобы вызвался деструктор того типа, который был там на самом деле, а не того типа, которого мы переменную завели, нужно чтобы деструктор базового класса тоже был виртуальным.

virtual ~Base() = default;


#############
Более сложные примеры с виртуальными функциями.

Пример того как можно облажаться, чуть чуть ошибившись в сигнатуре наследника.
Если функция отличается сигнатурой, она не становиться виртуальной. 

struct Base{
	virtual void f() const {
		std::сout << 1;
	}
};

struct Derived : Base {
	void f() {
		std::сout << 2;
	}
};

int main() {
	Derived d;
	Base& b = d;
	b.f();		// Выведется 1 а не 2
}

Выведется 1 а не 2, потому что у нас не совпадает сигнатура в наследнике(нет const), а это значит что эта функция не является виртуальной, и не переопределяет ту, которая в 
родителе. И даже если я напишу в объявлении функции f в классе Derived слово virtual это не поможет, потому что это будут две разные виртуальные функции теперь. Поэтому в 
c++ было добавлено следующее ключевое слово, которое позволяет избежать такой проблемы: слово override. Это важное правило кодстайла, которое нужно применять при написании
виртуальных функций. Когда мы переопределяем виртуальную функцию, нужно всегда писать слово override. Оно говорит компилятору, что мы хотим переопределить каую то виртуальную
функцию из родителя. Наличие слова override поведения программы никак не меняется, просто при неправильной сигнатуре будет CE. Чтобы избежать неинтуитивного поведения.

struct Derived : Base {
	void f() const override {
		std::сout << 2;
	}
};

Если будте одинаковая сигнатура, но не будет совпадать возвращаемый тип будет CE. 

Ключевое слово final улучшает скорость работы кода. Оно не добовляет никакой функциональности, оно просто запрещает переоперделять функцию, но и так же оно позволяет делать
компилятору некие оптимизации, знаяя что никто ниже эту функцию не переопределяет. final это автоматически означает и override, но не наоборот.

Также из слов virtual, override и final нужно максимум одно. Если мы определяем новую виртуальную функцию мы пишем virtual. Если мы переопределяем уже существующую мы пишем 
override и virtual из него автоматически следует. И если мы доопределяем последнюю функцию, то пишем final, override автоматически следует из него, а virtual следует из 
override. final более строгое чем override, override более строгое чем virtual.

Прикол:

int override = 5; // Это компилируется, переменные можно так назвать.

Слова override и final это не просто ключевые слова, а контекст депендед(контекстно зависимые) ключевые слова.


#############

struct Granny {
	virtual void f() const override {
		std::сout << 1;
	}
};

struct Mom : Granny {
	void f() const override {
		std::сout << 2;
	}
};

struct Son : Mom {
private:
	void f() const final {
		std::сout << 3;
	}
};

int main() {
	Mom d;
	Granny& b = d;
	b.f();		// Вывод: 2
}

Виртуальные функции это рантайм явления, а приватность это компайл тайм явление. То какая именно функция будет выбрана определяется в рантайме, и определяется в зависимости 
от того, что под объектом лежит на самом деле. А легален ли этот вызов определяется в компайлтайме, и в компайлтайме компилятор никак не может определить какая функция будет 
выбрана, и он не может кинуть нам CE, просто оп той причине, что он не знает в какую функцию мы попадём в реальности в приватную или публичную.

int main() {
	Mom m;
	Granny g;
	
	int x;
	std::cin >> x;			// Вводим число с клавиатуры в рантайме
	
	Granny& gg = (x % 2 ? m : g);	// В зависимости от того чётный ли x выбирается тип 

	gg.f();				// Вывод функции в консоль
}



#############

Скомпилируется ли?
struct Mom {
	virtual void f() {		// Виртуальная функция
		std::сout << 1;
	}
};

struct Dad {				
	void f() {			// Невиртуальная функция
		std::сout << 2;
	}
};

struct Son : Mom, Dad {			// Наследование от класса с виртуальной и невиртуальной f().
	void f() override{		// Тоже виртуальная функция.
		std::сout << 3;
	}
};

int main() {
	Son s;
}



______________________________________________________________________________________
Ключевое слово override

Чтобы явным образом указать, что мы хотим переопредлить функцию, а не скрыть ее, в производном классе после списка параметров функции указывается слово override

class Person
{
public:
    Person(std::string name): name{name}
    { }
    virtual void print() const  				// Виртуальная функция
    {
        std::cout << "Name: " << name << std::endl;
    }
private:
    std::string name;
};

class Employee: public Person
{
public:
    Employee(std::string name, std::string company): Person{name}, company{company}
    { }
    void print() const override 				// Явным образом указываем, что функция переопределена
    {
        Person::print();
        std::cout << "Works in " << company << std::endl;
    }
private:
    std::string company;
};
  
int main()
{
    Person tom {"Tom"};
    Person* person {&tom};
    person->print();     		// Name: Tom

    Employee bob {"Bob", "Microsoft"};
    person = &bob;
    person->print();     		// Name: Bob
                        		// Works in Microsoft
}

То есть здесь выражение

void print() const override

указывает, что мы явным образом хотим переопределить функцию print. Однако может возникнуть вопрос: в предыдущем примере мы не указывали override для вирутальной функции, 
но переопределение все равно работало, зачем же тогда нужен override? Дело в том, что override явным образом указывает компилятору, что это переопределяемая функция. И если она не 
соответствует виртуальной функции в базовом классе по списку параметров, возвращаемому типу, константности, или в базовом классе вообще нет функции с таким именем, то компилятор 
при компиляции сгенерирует ошибку. И по ошибке мы увидим, что с нашей переопределенной функцией что-то не так. Если же override не указать, то компилятор будет считать, что речь 
идет о скрытии функции, и никаких ошибок не будет генерировать, компиляция пройдет успешно. Поэтмоу при переопределении виртуальной функции в производном классе лучше указывать 
слово override.

Интересно: При этом стоит отметить, что виртуальную функцию можно переопределить по всей иерархии наследования в том числе не в прямых производных классах.



______________________________________________________________________________________
Принцип выполнения виртуальных функций

Стоит отметить, что виртуальные функции имеют свою цену - объекты классов с виртуальными функциями требуют немного больше памяти и немного больше времени для выполнения. Поскольку 
при создании объекта полиморфного класса (который имеет виртуальные функции) в объекте создается специальный указатель (Один единственный). Этот указатель используется для вызова 
любой виртуальной функции в объекте. Специальный указатель указывает на таблицу указателей функций, которая создается для класса (для каждого класса своя таблица). Эта таблица, 
называемая виртуальной таблицей или vtable, содержит по одной записи для каждой виртуальной функции в классе.

Когда функция вызывается через указатель на объект базового класса, происходит следующая последовательность событий

1. Указатель на vtable в объекте используется для поиска адреса vtable для класса.

2. Затем в таблице идет поиск указателя на вызываемую виртуальную функцию.

3. Через найденный указатель функции в vtable вызывается сама функция. В итоге вызов виртуальной функции происходит немного медленнее, чем прямой вызов невиртуальной функции, 
	поэтому каждое объявление и вызов виртуальной функции несет некоторые накладные расходы.




person->print()		   Person tom			   vtable для класса Person
	   |	    /---------------------\		/----------------------------\
	   |	    |    данные объекта   |		| указатель на виртуальную   |
	   |	    |---------------------|	/-----> | функцию print()	     | --------> print()
	   |	    |  stad::string name  |	|	|----------------------------|
	   |	    |---------------------|	|	|			     |
	   \------> | указатель на vtable | ----|	\----------------------------/
		    \---------------------/
		




______________________________________________________________________________________
Запрет переопределения

С помощью спецификатора final мы можем запретить определение в производных классах функций, которые имеют то же самое имя, возвращаемый тип и список параметров, что и 
виртуальная функция в базовом классе. Например:

class Person
{
public:
    virtual void print() const final	// запрет
    {
         
    }
};
class Employee : public Person
{
public:
    void print() const override     	// Ошибка!!!
    {
         
    }
};

Также можно переопределить функцию базового класса, но запретить ее переопределение в дальнейших производных классах:

class Person
{
public:
    virtual void print() const 		// переопределение разрешено
    {
         
    }
};
class Employee : public Person
{
public:
    void print() const override final   // в классах, производных от Employee переопределение запрещено
    {
         
    }
};




______________________________________________________________________________________
Преобразование типов

Объект производного класса одновременно является объектом базового класса. Поэтому преобразования ИЗ производного типа В базовый выполняются автоматически.

class Person
{
public:
    Person(std::string name): name{name} 
    {  }
    void print() const
    {
        std::cout << "Person " << name << std::endl;
    }
private:
    std::string name;
};
 
class Employee: public Person
{
public:
    Employee(std::string name): Person{name} {}
};
 
int main()
{
    Employee employee{"Bob"};
    employee.print();    			// Person: Bob
 
    // преобразуем в базовый тип
    Person person1{employee};    		// через конструктор копирования		Это неявные преобразования
    person1.print();        			// Person: Bob
 
    Person person2{"Tom"};
    person2 = employee;   			// через операцию присваивания			Это неявные преобразования
    person2.print();        			// Person: Bob
}

Здесь класс Person является базовым, а Employee производным. Поэтому компилятор может автоматически преобразовать объект Employee в тип Person. Это можно 
сделать с помощью конструктора копирования:

Person person1{employee};

Или через операцию присваивания:

Person person2{"Tom"};
person2 = employee;

Но также можно выполнять преобразования явным образом, например, с помощью функции static_cast():

int main()
{
    Employee employee{"Bob"};
    employee.print();    				// Person: Bob
 
    // преобразуем в базовый тип
    Person person1{static_cast<Person>(employee)};    	// через конструктор копирования
    person1.print();        				// Person: Bob
 
    Person person2{"Tom"};
    person2 = static_cast<Person>(employee);   		// через операцию присваивания
    person2.print();        				// Person: Bob
}




______________________________________________________________________________________
Преобразование указателей

Указатель на объект производного класса можно преобразовать автоматически В указатель на объект базового типа:

class Person
{
public:
    Person(std::string name): name{name} {  }
    virtual void print() const
    {
        std::cout << name << std::endl;
    }
    std::string getName() const {return name;}
private:
    std::string name;
};
 
class Employee: public Person
{
public:
    Employee(std::string name, std::string company): Person{name}, company{company}{}
    void print() const override
    {
        std::cout << getName() << " (" << company << ")" << std::endl;
    }
    std::string getCompany() const { return company;}
private:
    std::string company;
};

int main()
{
    Employee bob{"Bob", "Google"};

    // преобразуем в указатель на базовый тип
    Person* person{&bob};
    person->print();    			// Bob (Google)
}

В данном случае указатель на объект Person получает адрес объекта Employee.

Подобным образом можно создать указатель производного класса и преобразовать автоматически в указатель на базовый тип

int main()
{
    Employee bob{"Bob", "Google"};
    Employee* employee = &bob;
 
    // преобразуем в указатель на базовый тип
    Person* person{employee};
    person->print();    			// Bob (Google)
}

То же самое касается ссылок:

int main()
{
    Employee sam{"Sam", "Microsoft"};
    // ссылка базового типа ссылается на объект производного класса
    Person &person1 {sam};
    person1.print();    			// Sam (Microsoft)
 
 
    Employee &employee{sam};
    // преобразуем ссылку производного класса в ссылку базового класса
    Person &person2 {employee};
    person2.print();    			// Sam (Microsoft)
}

В некоторых случаях возможно приведение в обратную сторону- от базового к производному. Но, во-первых, автоматически оно не выполняется, для этого надо использовать функции 
преобразования, в частности, static_cast(). Во-вторых, будет оно работать или нет, зависит от типа объекта. Чтобы можно было привести объект базового класса, например, Person, к 
указателю производного класса, например Employee, указатель базового класса должен указывать на объект класса Employee (или классов, производных от Employee). Если это не так, то 
результат приведения не определен. Например:

int main()
{
    Employee sam{"Sam", "Microsoft"};

    // указатель базового класса указывает на объект производного класса
    Person* person {&sam};

    // обратное преобразование - из базового типа в производный
    Employee* employee{static_cast<Employee*>(person)};
    employee->print();  // Sam (Microsoft)
}

Здесь указатель person, хоть и представляет указатель на тип Person, в реальности указывает на объект Employee. Поэтому с помощью функции static_cast() этот указатель можно 
привести к типу Employee*.

Но возьмем другую ситуацию:

int main()
{
    Person tom{"Tom"};
    Person* person {&tom};

    // обратное преобразование - из базового типа в производный
    Employee* employee{static_cast<Employee*>(person)};
    employee->print();  				// Sam (Microsoft)
    std::cout << employee->getCompany() << std::endl;   // ???
}

Здесь указатель person указывает на объект Person. Однако с помощью функции static_cast мы можем успешно его привести к указателю на Employee. Теоретически через подобный указатель 
мы можем обратиться к функции getCompany, которая определена в классе Employee. Но в классе Person ее нет, и поэтому при попытке к ней обратиться программа завершится с ошибкой. 
Поэтому если нет уверенности, что объект представляет определенный производный класс, то лучше не выполнять подобные преобразования из базового типа в производный.



#####################
Преобразование smart-указателей

smart-указатели на базовый класс также могут указывать на объект производного класса

int main()
{
    std::unique_ptr<Person> bob{std::make_unique<Employee>("Bob", "Google")};
    bob->print();    								// Bob (Google)
 
    std::shared_ptr<Person> tom{std::make_shared<Employee>("Tom", "Microsoft")};
    tom->print();    								// Tom (Microsoft)
 
    std::shared_ptr<Employee> sam{std::make_shared<Employee>("Sam", "Jetbrains")};
    std::shared_ptr<Person> person{sam};
    person->print();    							// Sam (Jetbrains)
}




______________________________________________________________________________________
Динамическое преобразование типов

Динамическое приведение типов, в отличие от статического, выполняется во время выполнения программы. Для этого применяется функция dynamic_cast<>(). Также как и для static_cast, в 
угловых скобках указывается тип, к которому выполняется преобразование, в круглые скобки передается преобразуемый объект:

dynamic_cast<тип_в_который_преобразуем>(преобразуемый_объект)

Но эту функцию можно применять только к указателям и ссылкам на полиморфные типы классов, которые содержат хотя бы одну виртуальную функцию. Причина в том, что только указатели на 
типы полиморфных классов содержат информацию, которая необходима функции dynamic_cast для проверки правильности преобразования. Конечно, типы, между которыми выполняется 
преобразование, должны быть указателями или ссылками на классы в одной иерархии классов.

Есть два вида динамического приведения. Первый — это преобразование от указателя на базовый класс к указателю на производный класс - так называемое нисхолящее преобразование или 
downcast (базовые классы в иерархии помещаются вверху, а производные внизу, поэтому преобразование идет сверху вниз). Второй тип — преобразование между базовыми типами в одной 
иерархии (при множественном наследовании) - кросскаст (crosscast).

Рассмотрим следующую программу:

class Book      									// класс книги
{
public:
    Book(std::string title, unsigned pages): title{title}, pages{pages}{}
    std::string getTitle() const {return title;}
    unsigned getPages() const {return pages;}
    virtual void print() const 
    {
        std::cout << title << ". Pages: " << pages << std::endl;
    }
private:
    std::string title;  								// название книги
    unsigned pages;     								// количество страниц
};

class File  										// класс электронного файла
{
public:
    File(unsigned size): size{size}{}
    unsigned getSize() const {return size;}
    virtual void print() const 
    {
        std::cout << "Size: " << size << std::endl;
    }
private:
    unsigned size;     									// размер в мегабайтах
};
 
class Ebook : public Book, public File     						// класс электронной книги
{
public:
    Ebook(std::string title, unsigned pages, unsigned size): Book{title, pages}, File{size}{}
    void print() const override
    {
        std::cout << getTitle() << "\tPages: " << getPages() << "\tSize: " << getSize() << "Mb" << std::endl;
    }
};
 
int main()
{
    Ebook cppbook{"About C++", 350, 6};
    Book* book = &cppbook;  				// указывает на объект Ebook

    // динамическое преобразование из Book в Ebook
    Ebook* ebook{dynamic_cast<Ebook*>(book)};
    ebook->print();  					// About C++       Pages: 350      Size: 6Mb
}

Здесь у нас есть класс Book, который представляет книгу с переменными title и pages для хранения названия книги и количества страниц. А также есть класс File, который представляет 
электронный файл, в котором для хранения размера определено поле size. Класс электронной книги Ebook наследуется от обоих классов.

Чтобы динамическое преобразование было возможно, базовые классы определяют виртуальную функцию print.

В функции main создаем один объект типа Ebook и его адрес передаем указателю book, который представляет базовый тип Book*. Поскольку этот указатель все таки хранит адрес объекта 
Ebook, то мы можем привести его к указателю на Ebook:

Ebook* ebook{dynamic_cast<Ebook*>(book)};
ebook->print();  // About C++       Pages: 350      Size: 6Mb

Далее через указатель мы сможем обращаться к функционалу класса Ebook.

Стоит отметить, что в данном случае динамическое преобразование не имеет смысла, так как мы итак могли бы вызвать у указателя book функцию print и за счет виртуальности функции 
получили бы тот же самый результат. Преобразование нужно, если нам необходимо обратиться к каким-то членам производного класса, которые не определены в базовом. Например, класс Book 
не имеет функции getSize(), и чтобы обратиться к ней могло потребоваться преобразование.

В примере выше был приведен так называемый downcast. Теперь рассмотрим crosscast:

int main()
{
    Ebook cppbook{"About C++", 350, 6};
    Book* book = &cppbook;  			// указывает на объект Ebook

    // динамическое преобразование из Book в File - crosscast
    File* file{dynamic_cast<File*>(book)};
    file->print();  				// About C++       Pages: 350      Size: 6Mb
}

Преобразование из указателя на Book в указатель на File является кросскастом и в данном случае возможно, потому что указатель book хранит адрес объекта Ebook, который также 
наследуется от File.

Но подобные преобразования не всегда выполняются успешно. В этом случае функция dynamic_cast() возвращает указатель nullptr, и после получения результата мы можем проверить 
на это значение:

int main()
{
    Book cppbook{"About C++", 350};
    Book* book = &cppbook;  					// указывает на объект Book

    // динамическое преобразование из Book в File - crosscast
    File* file{dynamic_cast<File*>(book)};
 
    // проверяем результат
    if(file)    						// если file !=nullptr
    {
        file->print();
    }
    else
    {
        std::cout << "The book is not a file" << std::endl;
    }
}

В данном случае указатель book хранит адрес объекта Book и поэтому не может быть преобразован к типу указателя на File. Поэтому вызов dynamic_cast<File*>(book) возвратит nullptr. 
После этого мы можем проверить результат и в зависимости от результата проверки выполнить опреленные действия.



##################
Константность

Обратите внимание, что если преобразуемый указатель является указателем на константу, то тип указателя, к которому выполняется приведение, также должен представлять указатель 
на константу:

int main()
{
    const Ebook cppbook{"About C++", 350, 6};
    const Book* book = &cppbook;  		// указатель на константу

    // преобразование в указатель на константу
    const Ebook* file{dynamic_cast<const Ebook*>(book)};
    file->print();
}

Если необходимо выполнить приведение из указателя на константу в обычный указатель (не на константу), то сначала надо выполнить приведение к указателю того же типа, что 
и исходный, с помощью функции const_cast<T>():

int main()
{
    const Ebook cppbook{"About C++", 350, 6};
    const Book* const_book = &cppbook; 	 		// указатель на константу

    // преобразование из указателя на константу в обычный указатель того же типа
    Book* book {const_cast<Book*>(const_book)};

    // преобразуем указатели
    Ebook* file{dynamic_cast<Ebook*>(book)};
    file->print();
}



###############
Преобразование ссылок

Функция dynamic_cast также может применяться к ссылкам (из ссылки на базовый тип в ссылку на производный тип):

int main()
{
    Ebook cppbook{"About C++", 350, 6};
    Book& book {cppbook};  		// ссылка на Ebook

    // преобразуем в ссылку на Ebook
    Ebook& file{dynamic_cast<Ebook&>(book)};
    file.print();
}

В данном случае ссылка book в реальности ссылается на объект Ebook, поэтому эту ссылку можно преобразовать в ссылку Ebook&. Но что, если ссылку book не ссылается на объект Ebook:

int main()
{
    Book cppbook{"About C++", 350};
    Book& book {cppbook};  			// ссылка на Book

    // преобразуем в ссылку на Ebook
    Ebook& file{dynamic_cast<Ebook&>(book)};  	// ! Ошибка std::bad_cast
    file.print();
}

В этом случае при преобразовании мы столкнемся с ошибкой, и программа завершит свое выполнение. Если с указателями мы могли бы проверить результат на nullptr, то в случае с ссылками мы этого сделать не можем.
Однако, чтобы избежать некорректного преобразования ссылок мы опять же можем преобразовывать в соответствующий тип указателя

int main()
{
    Book cppbook{"About C++", 350};
    Book& book {cppbook};  			// ссылка на Book

    // преобразуем в ссылку на указатель на Ebook
    Ebook* file{dynamic_cast<Ebook*>(&book)};
    if(file)
        file->print();
    else
        std::cout << "Object is not a file" << std::endl;
}



################
Преобразование smart-указателей

Для динамического преобразования смарт-указателей std::shared_ptr применяется функция std::dynamic_pointer_cast<T>():

int main()
{
    // указатель std::shared_ptr<Book> указывает на объект Ebook
    std::shared_ptr<Book> book{std::make_shared<Ebook>("About C++", 350, 6)};

    // динамическое преобразование из Book в Ebook
    std::shared_ptr<Ebook> ebook{std::dynamic_pointer_cast<Ebook>(book)};
    ebook->print();  // About C++       Pages: 350      Size: 6Mb
}

В данном случае указатель book, который представляет тип std::shared_ptr<Book> в реальности указывает на объект Ebook. Поэтому его можно привести к типу указателя 
std::shared_ptr<Ebook>. Если же преобразование невозможно, то функция возвращает nullptr:

int main()
{
    // указатель std::shared_ptr<Book> указывает на объект Ebook
    std::shared_ptr<Book> book{std::make_shared<Book>("About Java", 280)};

    // динамическое преобразование из Book в Ebook
    std::shared_ptr<Ebook> ebook{std::dynamic_pointer_cast<Ebook>(book)};
    if(ebook)   // if (ebook != nullptr)
    {
        ebook->print();
    }
    else
    {
        std::cout << "Object is not e-book" << std::endl;
    }
}

В данном случае указатель book указывает на объект Book. Поэтому при преобразовании в указатель на объект Ebook функция возвратит nullptr.



______________________________________________________________________________________
Особенности динамического связывания

Динамическое связывание при передаче параметров

Если необходимо обеспечить динамическое связывание при передаче параметров в функцию, то такой параметр должен представлять ссылку или указатель на объект базового типа:

class Person
{
public:
    Person(std::string name): name{name} { }
    virtual void print() const  							// виртуальная функция
    {
        std::cout << name << std::endl;
    }
    std::string getName() const {return name;}
private:
    std::string name;
};

class Employee: public Person
{
public:
    Employee(std::string name, std::string company): Person{name}, company{company}{ }
    void print() const override 							// функция переопределена
    {
        std::cout << getName() << " (" << company << ")" << std::endl;
    }
private:
    std::string company;
};
 
void printPerson(const Person& person) 							// В качестве параметра принимает константную ссылку на объект типа Person (базового класса)
{
    person.print();
}
  
int main()
{
    Person tom {"Tom"};
    Employee bob {"Bob", "Microsoft"};
    printPerson(tom);   			// Tom
    printPerson(bob);   			// Bob (Microsoft)
}

В данном случае функция printPerson в качестве параметра принимает константную ссылку на объект типа Person, коим в реальности также может быть объект Employee. Поэтому при вызове 
функции print программа будет динамически решать, какую именно реализацию функции вызвать.



##################
Динамическое связывание и коллекции

Объекты базовых и производных классов можно хранить в одной коллекции, например, массиве. Например:

class Person
{
public:
    Person(std::string name): name{name} { }
    virtual void print() const  							// виртуальная функция
    {
        std::cout << name << std::endl;
    }
    std::string getName() const {return name;}
private:
    std::string name;
};

class Employee: public Person
{
public:
    Employee(std::string name, std::string company): Person{name}, company{company}{ }
    void print() const override 							// функция переопределена
    {
        std::cout << getName() << " (" << company << ")" << std::endl;
    }
private:
    std::string company;
};
 
void printPerson(const Person& person) 
{
    person.print();
}
  
int main()
{
    Person tom {"Tom"};
    Employee bob {"Bob", "Microsoft"};
    Employee sam {"Sam", "Google"};

    Person people[]{tom, bob, sam};	// Массив хранит объекты типа Person. Объекты дочернего класс Employee тоже могут быть там, но они автоматически кастятся в тип Person.
    for(const auto& person: people)	
    {
        person.print();
    }
}


Здесь массив people хранит объекты Person, в качестве которых также могут выступать объекты Employee. Однако при такой организации каждый объект Employee, который помещается в 
массив, преобразуется в объект Person. В итоге при переборе такого массива вызывается функция print из класса Person:

Tom
Bob
Sam

Если мы хотим обеспечить для элементов массива динамическое связывание, то такие объекты должны представлять указатели. Например, используем указатели:

int main()
{
    Person tom {"Tom"};
    Employee bob {"Bob", "Microsoft"};
    Employee sam {"Sam", "Google"};

    Person* people[]{&tom, &bob, &sam}; 	// массив указателей
    for(const auto& person: people)
    {
        person->print();
    }
}

Здесь массив хранит адреса всех объектов, соотвественно получим совсем другой вывод:

Tom
Bob (Microsoft)
Sam (Google)




______________________________________________________________________________________
Переопределение спецификатора доступа

Стоит отметить, что виртуальные функции позволяют нам обойти ограничения на доступ к функциям. Например, сделаем функцию print в классе Employee приватной:

class Person
{
public:
    Person(std::string name): name{name}
    { }
    virtual void print() const  							// виртуальная функция
    {
        std::cout << "Name: " << name << std::endl;
    }
private:
    std::string name;
};

class Employee: public Person
{
public:
    Employee(std::string name, std::string company): Person{name}, company{company}
    { }
private:
    void print() const override 							// функция переопределена
    {
        Person::print();
        std::cout << "Works in " << company << std::endl;
    }
    std::string company;
};
  
int main()
{
    Employee bob {"Bob", "Microsoft"};
    Person* person {&bob};
    //bob.print();            // так нельзя - функция приватная
    person->print();        // а так можно
}

Поскольку теперь функция print в Employee приватная, мы не можем вне класса вызвать эту функцию напрямую для объекта Employee:

Employee bob {"Bob", "Microsoft"};
bob.print();    // так нельзя - функция приватная

Зато можем вызвать эту реализацию через указатель на тип Person:

Person* person {&bob};
person->print();        // а так можно




______________________________________________________________________________________
Абстрактный класс. Чисто виртуальная функция. pure virtual function 

pure - чистый в смысле без примисей.

Иногда возникает необходимость определить класс, который не предполагает создания конкретных объектов. Например, класс фигуры. В реальности есть конкретные фигуры: квадрат, 
прямоугольник, треугольник, круг и так далее. Однако абстрактной фигуры самой по себе не существует. В то же время может потребоваться определить для всех фигур какой-то общий класс,
который будет содержать общую для всех функциональность. И для описания подобных сущностей используются абстрактные классы.

Абстрактные классы - это классы, которые содержат или наследуют без переопределения хотя бы одну чистую виртуальную функцию. Абстрактный класс определяет интерфейс для 
переопределения производными классами.

Что такое чистые виртуальные функции (pure virtual functions)? Это функции, которые не имеют определения. Цель подобных функций - просто определить функционал без реализации, а 
реализацию определят производные классы. Чтобы определить виртуальную функцию как чистую, ее объявление завершается значением "=0". Например, определим абстрактный класс, который 
представляет геометрическую фигуру:

class Shape
{
public:
    virtual double getSquare() const = 0;     // площадь фигуры
    virtual double getPerimeter() const = 0;  // периметр фигуры
};

Класс Shape является абстрактным, потому что он содержит как минимум одну чистую виртуальную функцию. А в данном случае даже две таких функции - для вычисления площади и периметра 
фигуры. И ни одна из функций не имеет никакой реализации. В данном случае обе функции являются константными, но это необязательно. Гловно, чтобы любой производный класс от Shape 
должен будет предоставить для этих функций свою реализацию.

При этом мы не можем создать объект абстрактного класса:

Shape shape{};

Для применения абстрактного класса определим следующую программу:

class Shape
{
public:
    virtual double getSquare() const = 0;     			// площадь фигуры
    virtual double getPerimeter() const = 0;  			// периметр фигуры
};
class Rectangle : public Shape  				// класс прямоугольника
{
public:
    Rectangle(double w, double h) : width(w), height(h)
    { }
    double getSquare() const override
    {
        return width * height;
    }
    double getPerimeter() const override
    {
        return width * 2 + height * 2;
    }
private:
    double width;   						// ширина
    double height;  						// высота
};

class Circle : public Shape     				// круг
{
public:
    Circle(double r) : radius(r) 
    { }
    double getSquare() const override
    {
        return radius * radius * 3.14;
    }
    double getPerimeter() const override
    {
        return 2 * 3.14 * radius;
    }
private:
    double radius;  						// радиус круга
};
  
int main()
{
    Rectangle rect{30, 50};
    Circle circle{30};
      
    std::cout << "Rectangle square: " << rect.getSquare() << std::endl;
    std::cout << "Rectangle perimeter: " << rect.getPerimeter() << std::endl;
    std::cout << "Circle square: " << circle.getSquare() << std::endl;
    std::cout << "Circle perimeter: " << circle.getPerimeter() << std::endl;
}

Здесь определены два класса-наследника от абстрактного класса Shape - Rectangle (прямоугольник) и Circle (круг). При создании классов-наследников все они должны либо определить для 
чистых виртуальных функций конкретную реализацию, либо повторить объявление чистой виртуальной функции. Во втором случае производные классы также будут абстрактными.

В данном же случае и Circle, и Rectangle являются конкретными классами и реализуют все виртуальные функции.

Консольный вывод программы:

Rectangle square: 1500
Rectangle perimeter: 160
Circle square: 2826
Circle perimeter: 188.4

Стоит отметить, что абстрактный класс может определять и обычные функции и переменные, может иметь несколько конструкторов, но при этом нельзя создавать объекты этого абстрактного 
класса. Например:

class Shape
{
public:
    Shape(int x, int y): x{x}, y{y}
    {}
    virtual double getSquare() const = 0;     						// площадь фигуры
    virtual double getPerimeter() const = 0;  						// периметр фигуры
    void printCoords() const
    {
        std::cout << "X: " << x << "\tY: " << y << std::endl;
    }
private:
    int x;
    int y;
};
class Rectangle : public Shape  							// класс прямоугольника
{
public:
    Rectangle(int x, int y, double w, double h) : Shape{x, y}, width(w), height(h)
    { }
    double getSquare() const override
    {
        return width * height;
    }
    double getPerimeter() const override
    {
        return width * 2 + height * 2;
    }
private:
    double width;   									// ширина
    double height;  									// высота
};

class Circle : public Shape     							// круг
{
public:
    Circle(int x, int y, double r) : Shape{x, y}, radius(r) 
    { }
    double getSquare() const override
    {
        return radius * radius * 3.14;
    }
    double getPerimeter() const override
    {
        return 2 * 3.14 * radius;
    }
private:
    double radius;  									// радиус круга
};
  
int main()
{
    Rectangle rect{0, 0, 30, 50};
    rect.printCoords();     		// X: 0    Y: 0
 
    Circle circle{10, 20, 30};
    circle.printCoords();   		// X: 10   Y: 20
}

В данном случае класс Shape также имеет две переменных, конструктор, который устанавливает их значения, и невиртуальную функцию, которая выводит их значения. В производных классах также 
необходимо вызвать этот конструктор. Однако объект абстрактного класса с помощью его конструктора мы создать не можем.



______________________________________________________________________________________
Абстрактный класс. Чисто виртуальная функция. pure virtual function (2ой пример упрощённый)

Чисто виртуальные функции, означает что эта функция пустая. В такой функции не написана реализация. Такой класс в котором присутствует чисто виртуальная функции является
абстрактным. Экземпляры абстрактного класса компилятор не позволяет создавать. В абстрактном классе могут быть и не виртуальные методы.

class Weapon {			  		//Абстрактный класс.
public:
	virtual void Shoot() = 0; 		//Чисто виртуальная функция (Полностью абстрактный метод). Обозначается = 0.
};

class Gun : public Weapon{	  		//Класс пистолет потомок класса оружие
public:
	virtual void Shoot() override{		//Переопределение виртуального метода Shoot
		cout << "Выстрел" << endl;
	}
};

class SubmachineGun : public Gun {		//Класс пистолет-пулемёт потомок класса оружие
public:
	void Shoot() override{ 			//Переопределение виртуального метода Shoot
		cout << "Выстрел" << " Выстрел" << " Выстрел" << endl;
	}
};

class Bazooka : public Weapon {			//Класс Базука потомок класса оружие
public:
	void Shoot() override {			//Переопределение виртуального метода Shoot
		cout << "Взрыв" << endl;
	}
};

class Knife : public Weapon {			//Класс нож потомок класса оружие
public:
	void Shoot() override {			//Переопределение виртуального метода Shoot
		cout << "Взмах ножом" << endl;
	}
};

class Player {					//Отдельный класс игрок
public:
	void Shoot(Weapon *weapon) {		//Эта функция вызывает функцию Shoot для объекта(оружия), заданного в параметре. В параметре у нас стоит тип базового класса,
		weapon->Shoot();		//но указатель класса может ссылаться на все унаследованные классы. Поэтому здесь вызовется метод класса, который будет 
	}					//указан в параметре.
};

int main()
{
	setlocale(LC_ALL, "Russian");

	Player player;
	Knife knife;
	player.Shoot(&knife);			//Вызов функции Shoot для объекта player с параметром knife.
		
	return 0;
}



______________________________________________________________________________________
Виртуальный деструктор класса 

Основная цель виртуального деструктора - обеспечить корректное уничтожение объектов производного класса при удалении через указатель на базовый класс. Когда объект удаляется через 
указатель на базовый класс, без виртуального деструктора в этом базовом классе, вызывается деструктор только базового класса. Это означает, что любые ресурсы, выделенные производным
классом, не будут освобождены, что приведёт к утечке памяти или другим проблемам с ресурсами. Виртуальный деструктор гарантирует, что при удалении объекта через указатель на базовый
класс сначала вызовется деструктор производного класса, а затем деструкторы всех базовых классов по цепочке наследования. Это обеспечивает полную и корректную очистку объекта.

Если не переопределять деструктор базового класса, можно столкнуться с утечкой памяти:

class A {
public:
	A(){
		cout << "Выделена динамическая память, объект класса А" << endl;
	}
	virtual ~A() {									//Если убрать virtual от сюда и override в деструкоре класса B, будет утечка памяти.
		cout << "Освобождена динамическая память, объект класса А" << endl;
	}
};

class B : public A{
public:
	B() {
		cout << "Выделена динамическая память, объект класса B" << endl;
	}
	~B() override {
		cout << "Освобождена динамическая память, объеыкт класса B" << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	A *bptr = new B;//В указатель типа базового класса присвоили ссылку типа класса наследника. Если в деструкторе класса А нет ключевого слова virtual, то здесь будет 
			//происходит утечка памяти в объекте B. В таком случае деструктор базового класса не будет виртуальным. Поэтому в момент использования ключевого слова 
	delete bptr;	//delete, компилятор видит что указатель у нас типа A, он и вызвал деструктор только объекта A. Чтобы этого не происходило, нужно для деструктора 
			//объекта А использовать слово virtual.
	return 0;
}

Благодаря тому, что у нас есть виртуальный деструктор в базовом классе, у нас вызывается и переопределённый деструктор класса наследника и деструктор базового класса, 
т.о. мы не получим утечку памяти.

Виртуальный деструктор необходим, если: 
1) Вы работаете с наследованием и объектами базового класса м.б. расширены в производных классах
2) Вы удаляете объекты через указатель на базовый класс.

Не добавляйте виртуальный деструктор в классы, которые не предназначены для наследования или где нет динамического выделения памяти.

Виртуального конструктора в языке С++ не существует


______________________________________________________________________________________
Чисто виртуальный деструктор

Чисто виртуальный деструктор похож по своей сути на чисто виртуальные функции. Такой класс в котором присутствует чисто виртуальный деструктор является
абстрактным. Экземпляры абстрактного класса компилятор не позволяет создавать. (ХЗ за чем он хаха)

В момент очистки стека от объектов, вызовется деструктор класс В, затем деструктор класса А. Но поскольку деструктор класса А чисто виртуальный, то там ничего нет, поэтому 
будет ошибка(компилятор не сможет его вызвать). Чтобы решить эту проблему, нам нужно вынести определение этого деструктора вне класса (в деструкторе ничего не должно быть
написано).


class A {
public:
	A(){
		
	}
	virtual ~A() = 0; //Чисто виртуальный деструктор.
};
A::~A() {}; //Выносим определение виртуального деструктора вне класса.

class B : public A{
public:
	B() {
		
	}
	~B() override {
		
	}
};


______________________________________________________________________________________
Делегирующие конструкторы

Это синтаксическаий сахар. Допустим у нас есть класс Человек с полями имя, возраст и вес. При создании объекта этого класса нам нужно инициализировать все эти поля. Что если
нам нужно реализовать логику работы этого класса таким образом, чтобы мы могли создавать экземпляр, при этом инициализировав лишь некоторые из полей. А так же должен быть 
конструктор который инициализирует все поля. Мы можем описать много разных конструкторов для решения этой задачи, но тогда их будет тяжело и долго править. Для того чтобы 
этого избежать можно использовать делегирующие конструкторы.

class Human {
public:
	Human() {							//Конструктор по умолчанию. Все параметры неизвестны.
		this->Name = "NULL";
		this->Age = 0;
		this->Weight = 0;
	}
	Human(string Name) : Human() {					//Конструктор, в котором инициализируется только имя
		this->Name = Name;
	}
	Human(string Name, int Age) : Human(Name) {			//Конструктор, в котором инициализируется только возраст
		this->Age = Age;
	}
	Human(string Name, int Age, int Weight) : Human(Name, Age) { 	//Конструктор, в котором инициализируется только вес
		this->Weight = Weight;
	}
	string Name;
	int Age;
	int Weight;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Human human1;
	Human human2("Дима");
	Human human3("Дима", 23);
	Human human4("Дима", 23, 78);					
}

В коментах:
Так же кину код, которые решает задачу из видео намного проще(функции с параметрами по умолчанию):

Human(string name, int age = 0, int weight = 0)
    {
      this->name = name;
      this->age = age;
      this->weight = weight;
    }


______________________________________________________________________________________
Вызов виртуального метода базового класса

Как вызвать виртуальный метод базового класса в классе наследнике. Если мы хотим вызвать переопределённый метод базового класса в классе наследнике, более того, в переопределяемом,
методе, нужно явно дать понять компилятору какой мы метод вызываем( в нашем случае метод базового класса:) ::Msg::GetMsg(). Если этого не сделать, метод GetMsg() будет вызывать
сам себя в этом же классе бесконечно.

class Msg {						//Класс хранит сроковое сообщение и возвращает его в методе GetMsg().
public:
	Msg(string msg) {
		this->msg = msg;
	}
	virtual string GetMsg() {
		return msg;
	}
private:
	string msg;
};

class BraketsMsg : public Msg{ 				//Наследник класса Msg. Добавляет сообщению из Msg две квадратные скобки.
public:
	BraketsMsg(string msg) : Msg(msg) {
	}
	string GetMsg() override {			//Переопределение базового вертуального метода.
		return "[" + ::Msg::GetMsg() + "]"; 	// Если не указать явно метод базовго класса, то GetMsg будет вызывать сама себя в классе BraketsMsg бесконечно.
	}
};

class Printer { 					//Выводит в консоль сообщение из класса Msg.
public:
	void Print(Msg *msg) {				//В параметре ссылка на базовый класс, значит по мимо базового можно указывать и наследников.
		cout << msg->GetMsg() << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Msg m("Привет!");

	Printer p;
	p.Print(&m);

	BraketsMsg b("Привет!");					
	p.Print(&b);

	return 0;
}


____________________________
RTTI and dynamic cast

Динамик каст это каст в рантайме. static_cast уже при компиляции понятно успешно или нет, он либо успешный либо CE. dynamic_cast это каст, который может в рантайме выдать
ошибку RE, а может отработать правильно. 

struct Base {
	int x = 0;
	virtual void f() {}
	virtual ~Base() = default;
};

struct Derived : Base {
	int y = 0;
	void f() override {}
};

int main() {
	Derived d;
	Base& b = d;
	dynamic_cast<Derived&>(b).y;	// Меняем тип с Base на Derived и спрашиваем поле y.
}

static_cast, если там был не Derived, даст UB и мы никак в рантайме не проверим получили ли мы настоящий Derived ли это UB. dynamic_cast если там был не Derived, кинет ошибку
std_bad_cast.

Если мы не хотим работать с исключениями, то мы можем делать каст к указателю, а не к ссылке. dynamic_cast если под этим указателем реально лежал Derived а не Base, не смотря
на то что тип Base у вырожения, он вернёт указатель на этот Derived и у нас будет корректное привидение типа, а если нет он вернёт nullptr.
 
int main() {
	Derived d;
	Base& b = d;
	Derived* pd = dynamic_cast<Derived*>(&b);	// Каст
	if (pd) {					// Если не nullptr, то чтото делаем
		// Что то сделать
	}
} 

Это работает только для типов с виртуальными функциями, потому что для типов без виртуальных функций в рантайме нет способа узнать что это за тип на самом деле, ведь тип с 
виртуальными функциями (полиморфный тип), это как раз такой тип, про который в рантайме для него поддерживается какая то специальная информация, по которой в рантайме 
понятно что это на самом деле, и в зависимости от этого понятно что вызвать. Это и означает что такое наличие виртуальной функции у типа. Если в классе нет ни одной 
виртуальной функции, то динамик каст делать нельзя, это будет CE (source type is not polymorphic).

dynamic_cast это дорогая операция, потому что чтобы сделать dynamic_cast в рантайме, нужно сходить по некоторому указателю, который храниться в нашем объекте, найти там
vtable (Правильно понял или нет?), по ней посмотреть что там написано, и в зависимости от этого понять какой же это реально тип, и в зависимости от этого понять можно 
dynamic_cast делать к тому что мы просим или нет, в зависимости от этого сдвинуть пойнтер или нет. 

Это называется механизм RTTI (RunTime Type Information).

На  самом деле для полиморфных типов компилятор поддерживает специальную структуру, в которой хранит информацию о том, что это за тип на самом деле. Т.е. в каждом объекте 
полиморфного типа есть скрытый указатель, который указывает на нечто, где написано что это на самом деле за тип. Т.е. не нужно в своём типе заводить поля, следящие что это
за тип реально, за вас это делает RTTI.



####################
оператор typeid Узнать явно что сейчас за тип

По мимо привидения типа с помощью dynamic_cast, мы можем явно спросить какой тип у нас сейчас. Это работает если тип полиморфный с помощью RTTI.

Этот оператор возвращает мне некоторый специальный тип, который называется std::type_info, в котором вообщем то нет ничего полезного кроме оператора сравнения и метода name().
Оператор сравнения позволяет нам сравнивать на равенство два typeinfo, и равенство будет тогда, и только тогда, когда это одинаковые типы. Метод name() возвращает 
const char, в котором написано название типа.


int main() {
	Derived d;
	Base& b = d;

	std::cout << typeid(b).name() << '\n'; 		// Выводим имя типа b (7Derived, где 7 длина)
}

Эта штука выводит нам название типа, который реально был под ссылкой, а не тип переменной, от которой вызвались. 

В отличии от dynamic_cast, typeid работает и не для полиморфных типов, но для них он просто выводит тип переменной.


####################
Ещё доп инфа
1) От любого полиморфного типа всегда можно делать dynamic_cast к void*, а от неполиморвного нельзя. 

2) Ещё всегда можно делать dynamic_cast вверх, от наследника к родителю, даже если тип неполиморфный, потому что каст вверх всегда валидный, в этом случае dynamic_cast работает 
как static_cast. Некоторые ошибочно думают, что всегда когда есть каст  между родителем и наследником нужно делать dynamic_cast, но это не правда, dynamic_cast нужно 
использовать только в рантайме, в остальных случаях лучше использовать static_cast. Однако в при касте вниз dynamic_cast будет полезен поскольку если мы случайно ошибёмся то
будет CE, а с static_cast будет UB, т.е. dynamic_cast может засейвить. 

При касте вниз при виртуальном наследовании, при том что виртуальный предок полиморфный, dynamic_cast корректно отрабатывает, static_cast даёт CE, reinterpret_cast даёт UB.


3) dynamic_cast может кастовать вбок. От мамы к папе при множествнном наследовании. static_cast неоткуда узнать что мама и папа каие то совместимые типы, но dynamic_cast, 
логично, может посмотреть и узнать что тип на самом деле сын. Представим что у нас есть ссылка на маму, а мы хотим её скастовать к ссылке на папу. dynamic_cast идёт в таблицу,
смотрит что на самом деле у нас это тип сын и понимает, чтобы сделать каст к папе нужно сдвинуться на некоторое кол-во байт, потому что он знает как сын в памяти размещается,
это известно ещё на этапе компиляции. Для этого полиморфным должна быть только мама, полиморфным должен быть тот, от кого делается каст, а не к кому. Т.е. от наследника к 
родителю можно делать каст с любым типом, а каст вниз и в бок возможны, только если исходный тип полиморфный. Это логично, потому что именно у исходного типа мы берём 
указатель и смотрим какой тип. 

При касте в бок от мамы к папе, dynamic_cast корректно отрабатывает, static_cast даёт CE, reinterpret_cast даёт UB.


4) Если мы никогда не используем наследника по ссылке на родителя то полиморфизм не нужен.



______________________________________________________________________________________
Расположение виртуальных объктов в памяти (Memory layout of polymorphic objects)

Если у нас в классе есть хотябы одна виртуальная функция, то sizeof от такого класса уже минимум 8 из-за размера указателя, потому что если есть виртуальная функция, это 
значит, что у этого объект должен быть указатель на vtable.

struct Base {			// sizoof(Base) == 8, размер одного поинтера.
	virtual void f(){}
};

API это интерфейс того как должны вести себя функции, а ABI это бинарный интерфейс того, как это всё компилятор по отношению к ОС и процессору должен в памяти распологать.

Таблица виртуальных функций (vtable) - это структура данных, хранящаяся в статической памяти одна на тип, в которой перечисленны адреса виртуальных функций этого типа. Это
таже самая таблица, с которой мы сталкивались, обсуждая виртуальное наследование. Что виртуальное наследование, что виртуальные функции разрешаются через одну и туже структуру
данных vtable. В этой таблице хранятся как адреса виртуальных предков, так и адреса вертуальных методов. 

В нашем случае для класса Base в vtable хранятся две вещи: адрес функции &Base::f, а ещё хранится адрес &Base::typeinfo. Base::typeinfo это структура данных, которая лежит 
отдельно и в ней написано просто название типа Base. Указатель на vtable ведёт на нулевое смещение адреса. Если бы было несколько виртуальных функций, то их адреса были бы 
перечислены в порядке объявления.

Расположение объктов в памяти:

			Указатель на vtable класса Base
				   |----------|
				   |vtable ptr| 
				   |----------|
			     	        ||
			     	        ||
			     	        ||
			     	        \/
		vtable класса Base	нулевое смещение
		        |---------------|--------|
			|&Base::typeinfo|&Base::f|
		        |---------------|--------|
				 |
  |------------------|		 |
  |название типа Base|<----------/
  |------------------|




Теперь представим что у нас есть наследник Derived, а ещё в классе Base есть невритуальная функция. Наличие невиртуальных методов никак не влияет на размер объекта.

struct Base {			// sizoof(Base) == 16, из-за выравнивания.
	virtual void f(){}
	void h(){}
	int x = 0;
};

struct Derived : Base {
	void f() override{}
	virtual void g(){}
	int y;
};


Расположение объктов в памяти:
Класс Base:
	      Указатель на vtable класса Base  поле x
				   |----------|---|---------------------|
				   |vtable ptr| x | ... пейдинг 4 байта |
				   |----------|---|---------------------|
			     	        ||
			     	        ||
			     	        ||
			     	        \/
		vtable класса Base	нулевое смещение
		        |---------------|--------|
			|&Base::typeinfo|&Base::f|
		        |---------------|--------|
				 |
  |------------------|		 |
  |название типа Base|<----------/
  |------------------|


Класс Derived:

          Указатель на vtable класса Derived, поле x класса Base, поле y 
				   |----------|-- |---|
				   |vtable ptr| x | y |
				   |----------|---|---|
			     	        ||
			     	        ||
			     	        ||
			     	        \/
		vtable класса Derived	нулевое смещение
		     |------------------|-----------|-----------|
		     |&Derived::typeinfo|&Derived::f|&Derived::g|
		     |------------------|-----------|-----------|
				 |
  |---------------------|        |
  |название типа Derived|<-------/
  |---------------------|


############
Каким образом работает вызов виртуальной функции?

Типы переменных могут не совпадать с типом объектов, которые лежат под ними. Никогда переменная не может поменять тип после объявления, но то что под ней лежит может оказаться
другим.

Derived d;
Base& b = d;
b.f();

Происходит вызов b.f(); компилятор видит что эта f виртуальная, а значит вызов этой функции нельзя транслировать просто в call по какому то адресу. Вот если было бы b.h(),
то вызов этой функции в ассемблерном коде просто превратился в call по адресу, потому что адрес функции h() известен до запуска программы, на этапе линковки. Но с виртуальными
функциями так не работает, потому что адрес того, что реально должно быть вызвано, неизвестен ни на этапе компиляции, ни на этапе линковки. И стало быть, чтобы эту функцию 
вызвать, нужно сходить в vtable и там найти указатель на соответствующую функцию. 

В случае если b.f() это Base, мы идём по указателю в таблицу vtable для класса Base (разыминовываем указатель), дальше компилятор знает, что f() это первая по счёту из 
виртуальных функций этого объекта, значит в этом месте куда мы пришли прямо с того адреса прочитать 8 байт и интерпретировать их как указатель. Этот указатель и будет 
указателем на функцию, которую нам нужно вызвать. Получается что в рантайме вызов виртуальной функции это два разыменования указателя вместо одного.

В случае если b.f() это Derive, мы идём по указателю в таблицу vtable для класса Derived, а от туда находим функцию f() класса Derived.

dynamic_cast работает по такому же принципу, мы идём по указателю в vtable, находит там typeinfo, идём в typeinfo, смотрит что там написано, и в зависимости от этого понимает
какой тип на самом деле. Поняв какой там тип на самом деле, он понимает кидать ошибку или всё ок, и если всё корректно, то зная от какого типа мы вызывались и зная какой
тип мы хотим, он знает на сколько сдвинуть указатель. 

Пример 2. прдставим следующее наследование: 

	Granny 		void w(), int g;
	  /\
	  ||
	  ||
	 Mom		virtual void f(), int m;
	  /\
	  ||
 	  ||
 	 Son		void f() override, int s;


Как будет выглядить объект сына в памяти?

Объект сына полиморфный, поэтому начинаем с указателя на vtable

	
	ptr vtable, g,m,s,... паддинг
	/\	   /\
	||	   ||
	||	   ||
	||	начало объекта Granny
	||
	||
    начала объекта Сын и мама

Что должно происходить при каст от сына к бабушке. Бабушка не полиморфная, поэтому она не должна начинаться с указателя на table. Если виртуальные функции появились не на 
самом верхнем уровне иеархии, то нужно сдвинуть указатель. Это может сделать как static_cast так и dynamic_cast. Но если я это сделают с помощью dynamic_cast, то обратно
dynamic_cast мы уже не сможем, потому что source type is not polymorphic, бабушка исходный тип при касте обратно, но она не полиморфна.



______________________________________________________________________________________
Какие ещё бывают неожиданные (неочивидные) эффекты (проблемы) при использовании виртуальных функций (Лекция 22)

1) Может ли виртуальная функция статической? Это глупость, это CE.

static virtual void f(){} 	// CE

2) Виртуальные функции нельзя оставлять без определения, даже если мы их не вызываем, кроме ситуации когда это pure virtual functions.

struct Base {
	int x;
	virtual void f();
};

struct Derived : Base {
				// Функция f() неопределена, ошибка линкера.
};

int main() {
	Derived d;
}

Это объясняет зачем нужно писать = 0. В отличие от обычной функции,  виртуальную функцию мы не можем оставить без определения, потому что для виртуальных функций компилятор 
должен сгенирировать vtable для типов Base и Derived, а в этих таблицах он должен положить указатель на адрес этих функций, но нельзя взять адрес у функций, у которой нет 
определения, поэтому оставить виртуальную функцию без определения это всегда ошибка линкера, только если мы специально не напишем = 0.

3) Этот вопрос задают часто на собесах
Я создаю объект Derived, и первым делом нужно вызвать конструктор Base. При вызове конструктора Base, мы вызываем функцию h(), которая является чисто виртуальной функцией. В данном
случае будет ошибка линкера, по причине того что я из конструктора пытаюсь вызвать чисто виртуальную функцию. Если мы вызываем чисто виртуальную функцию из конструктора, то 
механизм виртуальных функций отключается, функция начинает быть не виртуальной а обычной, чтобы избежать UB. Тоже самое если функция вызывается из списка инициализации.

struct Base {
	virtual void h() = 0;
	void f() {
		std::cout << "f";
		//h();
	}
	Base() {
		std::cout << "Base";
		h();			// Вызов чисто виртуальной функции из конструктора. Ошибка линкера.
		//f();
	}
	
	virtual ~Base() = default;
};

struct Derived : Base {
	int x;
	void h() override {
		std::cout << "h" << x;
	}
	Derived() {
		std::cout << "Derived";
	}
};

int main() {
	Derived d;
}



3.2) Что будет если мы будет вызывать чисто виртуальную функцию не прямо из конструктора, а из другой функции?

struct Base {
	virtual void h() = 0;
	void f() {
		std::cout << "f";
		h();			// 2) в которой есть вызов чисто виртуальной функции
	}
	Base() {
		std::cout << "Base";
		//h();			
		f();			// 1) Вызов функции, 
	}
	
	virtual ~Base() = default;
};

struct Derived : Base {
	int x;
	void g() {			// 3) если бы мы вызывали f от сюда, то мы бы шли в функцию Base::f(), в которой потом вызывалась функция Derived::h().
		f();
	}
	void h() override {
		std::cout << "h" << x;
	}
	Derived() {
		std::cout << "Derived";
	}
};

int main() {
	Derived d;
}

Т.е. мы можем вызвать функцию h() из двух мест: 1) из класс Derived методом g() который переносит нас в базовый класс в метод f(), в котором вызывается h(), 2) и из класса Base 
методом f(), однако при вызове функции из класса Base, функция h() является чисто виртуальной, и не имеет определения. Это не CE, поскольку в компайлтайме это незадетектить, 
поскольку метод f() мы можем вызвать из правильного и непревильного места. Ответ: будет runtime error со словами: pure virtual function call. Откуда взялся этот текст? Кто понял
что произошёл вызов чисто виртуального метода? В виртуальной таблице Base, по адресу по которому должна лежать f(), лежит указатель на некоторое специальное место, в котором 
специальный код нагенирировал специальную заглушку которая делает следующее: она выводит на экран этот текст и дальше вызывает функцию std::terminate, которая вызывает функцию
std::abort. Т.е. там есть заглушка в vtable для чисто виртуальных методов, в котором лежит не nullptr, а указатель на некоторую валидную функцию, у которой в теле написано 
крешнись вот с таким сообщением об ошибке.

Тоже самое и с деструктором. Если я из деструктора Base обращусь к f() будет тоже самое. 

Помере того как мы создаём наш объект, виртуальная таблица и наш вертуальный указатель претерпивает изменения. На самом деле, когда создаётся полиморфный объект, нужно понимать, 
что существует ещё один этап перед началом создания родителя до инициализации его полей - инициализация vptr. Когда мы создаём полиморфный объект, сначала должен создасться 
его родитель, и первым делом vptr инициализируется указателем на таблицу родителя, чтобы пока мы работаем с создание родителя, у нас нет ещё Derived (мы не можем ссылаться на 
таблицу Derived), сначала подставляется vptr на таблицу родителя, потом инициализируются поля родителя, потом тело конструктора родителя. На момент когда мы находимся в теле 
констурктора родителя, наш vptr указывает на таблицу родителя. Дальше начинает создаваться Derived. После того, как отработал конструктор родителя, vptr автоматически 
переставляется на таблицу Derived, после этого создаются поля Derived и выполняется тело конструктора Derived. Т.е. по мере того как мы создаём наш объект, если у нас много 
предков, наш собственный vptr перед созданием очередного предка, переставляется на соответствующую таблицу, чтобы мы не попали случайно в метод предка, который ещё не существует.

Как это работает при виртуальном наследовании?
Тут возникает необходимость construction vtable. Т.е. на самом деле помимл всего этого, ещё должна отдельно существовать таблица мамы внутри сына и папы внутри сына при 
конструировании: если я сейчас мама, я конструируюсь, ещё сын не создан, у меня должен быть отдельный указатель на таблицу для мамы которая создаётся, будучи частью сына, и вот
на эту таблицу ставиться указатель перед тем, как начнутся инициализироваться поля мамы. Только потом отрабатывает конструктор мамы, потом тоже самое с папой, только у папы
указатель уже другой, потому что папа инициализируется на другом куске памяти, потом все эти указатели переставляются. 

А откуда берутся все эти указатели?
Существует ещё одна таблица: virtual table of tables. Эта таблица, в которой перечислены все эти указатели в правильном порядке, и соответственно, когда у нас сложный граф 
наследования, по мере конструирования нашего объекта, наши виртуальные указатели подряд ставятся по этой таблице куда надо. 

Всё происходит в обратном порядке, когда объект уничтожается: Сначало отрабатывает деструктор наследника, уничтожаются поля наследника, vptr переставляется обратно на таблицу
мамы, после этого отрабатывает тело деструктора мамы, уничтожается поля мамы, и всё снимается со стека.


4) Пример с параметрами по умолчанию. Что выведется?

struct Base {
	virtual void f(int x = 1) {
		std::cout << "Base" << x;
	}
};

struct Derived : Base {
	void f(int x = 2) override {
		std::cout << "Derived" << x;
	}
};

int main() {
	Derived d;
	Base &b = d;
	b.f();
}

Ответ: выведется Derived 1. 
Компилятору нужно вызвать f, а f это функция с одним аргументом, у него нет версии f() с нулём аргументов. В компайлтайме нужно сгенирировать ассемблерный код, в котором будет 
написано: положи на стек аргументы и пойди по адресу вызвови f. Аргументов у функции один, и в компайл тайме нужно решить что это за аргумент. Аргумент по умолчанию нужно
подсатвить в компайлтайме, мы не можем на рантайм отложить подстановку аргументов в функцию. Компилятору ничего не остаётся кроме как передать в функцию тот аргумент, который
он в состаянии сейчас передать. Он видит тип Base и кладёт 1 в компайлтайме туда, а в реальности попадает в версию Derived уже в рантайме.


5) virtual pointers to members (Виртуальные указатели на члены)

Пусть у меня будет указатель на метод мамы. Что выведется?

struct Mother {
	int x = 0;
	virtual void f() {
		std::cout << x;
	}
};

struct Father {
	int y = 1;
	virtual void g() {
		std::cout << y;
	}
};

struct Son : Mother, Father {
	int z = 2;
	void f() override {
		std::cout << z;
	}
	void g() override {
		std::cout << z;
	}
};

struct S {			// Класс просто для проверки он не участвует в вопросе.
	long long a;
	long long b;
};

int main() {
	void (Mother::* p)() = &Mother::f;

	Son son;
	Mother& m = son;
	(m.*p)();
	std::cout << '\n';

	// Это просто для проверки
	std::cout << sizeof(p) << ' ';
	S s = reinterpret_cast<S&>(p);
	std::cout << sizeof(s) << ' ' << s.a << ' ' << s.b << '\n';
}


Ответ: Выведется 2.
Если я вызываю метод он должен продолжать вести себя как виртуальный метод, т.е. выберется версия сына а не мамы. Как это реализовано? Этот указатель состоит из 16 байт, в которых
первые 8 байт показывают сдвиг относительно начала виртуальной таблицы, а вторые 8 байт показывают сдвиг относительно начала объекта. Пока я брал f у мамы или у папы, это были 
первые из их виртуальных методов, поэтому нужно было просто первый метод от папы взять и сдвинуться либо не сдвигаться, но когда я взял адрес на виртуальный метод сына, у меня их
там уже 2, и если я беру адрес f, то это как бы сдвиг 0 относительно начала виртуальной табилцы, а если я беру g у сына, то это сдвиг 8 относительно начала виртуальной таблицы. 
Первое число показывает насколько байт относительно начала виртуальной таблицы нужно искать адрес этого метода. Почему там единица последним битом? А потому что надо же как то 
отличить виртуальный указатель от невиртуальных. Обычные указатели на методы хранят в первых 8 байтах реальные адреса, но эти адреса никогда не нечётные, и чтобы для виртуальных
указателей на методов поведение было другим, последним битиком ставится единица, чтобы в рантайме стало понятно, что это виртуальный указатель, значит само число означает не 
адрес функции, а сдвиг относительно начала виртуальной таблицы. Т.о. мы не меняя размер указателя на метод, вкодируем в него сдвиг, относительно начала виртуальной таблицы, 
вместо того, чтобы кодировать адрес настоящей функции. Так работают указатели на виртуальные методы изнутри.



______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Множественное наследование

Мы можем унаследовать один класс от нескольких других классов, и в таком случае класс наследник получит характеристики и возможности поведения всех своих классов предков.

class Car {						//Класс машина
public:
	void Drive() {
		cout << "Я еду!" << endl;
	}
};

class Airplane {					//Класс самолёт
public:
	void Fly() {
		cout << "Я лечу!" << endl;
	}
};

class FlyingCar : public Car, public Airplane{		//Класс летающая машина. Наследник обоих классов.

};
int main()
{
	setlocale(LC_ALL, "Russian");

	FlyingCar fc;					//Объект такого класса может и летать и ездить.
	fc.Drive();		
	fc.Fly();

	Car *ptrc = &fc;
	Airplane *ptrA = &fc;
	
	return 0;
}


______________________________________________________________________________________
Порядок вызова конструкторов при множественном наследовании

При создания класса наследника со множественным наследованием, создаются все классы предки. Конструкторы классов предков создаются в порядке их описания в наследовании.

class FlyingCar : public Car, public Airplane{
public:
	FlyingCar()
	{
		cout << "Конструктора FlyingCar вызван" << endl; //Для быстрого описания конструктора по умолчанию, пишем ctor и нажимаем tab.
	}
};

Сначалы вызовется конструктор Car, затем Airplane, затем FlyingCar.


______________________________________________________________________________________
Порядок вызова деструкторов при множественном наследовании

Как обычно, в обратном порядке.


______________________________________________________________________________________
Одинаковые методы в множественном наследовании

Что если у двух базовых классов есть метод, который одинаково называется? 

class Car {
public:
	void Use() {
		cout << "Я еду!" << endl;
	}
};

class Airplane {
public:
	void Use() {
		cout << "Я лечу!" << endl;
	}
};

class FlyingCar : public Car, public Airplane{
public:
};
int main()
{
	setlocale(LC_ALL, "Russian");

	FlyingCar fc;
	((Car)fc).Use(); //Вызываем метод класса Car (Приведение в стиле С).
	fc.Car::Use();	 //И через оператор разрешения области видимости
	
	return 0;
}



______________________________________________________________________________________
Двойственность при одинаковых названиях в Множественном наследовании

В примерах выше все классы имели функции, которые называются по разному. Но посмотрим, что будет в следующем случае:

class Book    						// класс книги
{
public:
    Book(unsigned pages): pages(pages) { }
    void print()
    {
        std::cout << pages << " pages" << std::endl;
    }
private:
    unsigned pages; 					// количество страниц
};
 
class File    						// класс электронного файла
{
public:
    File(double size): size(size) { }
    void print()
    {
        std::cout << size << "Mb" << std::endl;
    }
private:
    double size;  					// размер файла
};
							// класс электронной книги
class Ebook : public Book, public File   
{
public:
    Ebook(std::string title, unsigned pages, double size): 
        Book{pages}, File{size}, title{title}
    { }
    void printTitle()
    {
        std::cout << "Title: " << title << std::endl;
    }
private:
    std::string title;
};
 
int main()
{
    Ebook cppbook {"About C++", 320, 5.6};
    cppbook.print();    				// Ошибка компиляции
}

Здесь базовые классы Book и File имеют функцию с одним и тем же именем - print(). В итоге у нас получается двойственность, и такой код просто не скомпилируется.

Чтобы решить проблему, мы можем указать, из какого конкретного класса мы хотим вызвать функцию print:

int main()
{
    Ebook cppbook {"About C++", 320, 5.6};
    cppbook.Book::print();    // 320 pages
    cppbook.File::print();    // 5.6Mb
}

В качестве альтернативы мы можем выполнять операцию преобразования к нужному типу и затем вызывать функцию:

int main()
{
    Ebook cppbook {"About C++", 320, 5.6};
    static_cast<Book&>(cppbook).print();    // 320 pages
    static_cast<File&>(cppbook).print();    // 5.6Mb
}


______________________________________________________________________________________
Двойственное наследование и виртуальные базовые классы

Еще одной формой двойственности при наследовании может быть наследование от нескольких классов, которые косвенно или напрямую наследуются от одного и того же класса. Например:

class Person
{
public:
    Person(std::string name): name{name} 
    { 
        std::cout << "Person created" << std::endl;
    }
    ~Person() 
    { 
        std::cout << "Person deleted" << std::endl;
    }
    void print() const
    {
        std::cout << "Person " << name << std::endl;
    }
private:
    std::string name;
};
 
class Student: public Person
{
public:
    Student(std::string name): Person{name} {}
};

class Employee: public Person
{
public:
    Employee(std::string name): Person{name} {}
};
								// работающий студент
class StudentEmployee: public Student, public Employee
{
public:
    StudentEmployee(std::string name): Student{name}, Employee{name} {}
};
 
int main()
{
    StudentEmployee bob{"Bob"};
    //bob.print();
}

Здесь в основе иерархии классов находится класс человека - Person, от которого наследуются класс рабочего Employee и класс студента Student. Но у нас может быть работающий студент. 
И для этого определяем класс StudentEmployee, который наследуется от Student и Employee. Подобных ситуаций, конечно, лучше избегать, но тем не менее они то же могут встречаться. 
И если мы запустим программу, то увидим, что для одного объекта StudentEmployee два раза вызывается конструктор и деструктор класса Person:

Person created
Person created
Person deleted
Person deleted

Более того, мы видим, что вызов bob.print() не компилируется.

Для решения этой проблемы в C++ применяются виртуальные базовые классы - при установке наследования перед именем базового класса указывается ключевое слово virtual. Применим 
вирутальные классы:

class Person
{
public:
    Person(std::string name): name{name} 
    { 
        std::cout << "Person created" << std::endl;
    }
    ~Person() 
    { 
        std::cout << "Person deleted" << std::endl;
    }
    void print() const
    {
        std::cout << "Person " << name << std::endl;
    }
private:
    std::string name;
};
 
class Student: public virtual Person
{
public:
    Student(std::string name): Person{name} {}
};

class Employee: public virtual Person
{
public:
    Employee(std::string name): Person{name} {}
};
										// работающий студент
class StudentEmployee: public Student, public Employee
{
public:
    StudentEmployee(std::string name): Person{name}, Student{name}, Employee{name}  {}
};
 
int main()
{
    StudentEmployee bob{"Bob"};
    bob.print();
}

Теперь при определении классов Student и Employee базовый класс Person указан как виртуальный:

class Student: public virtual Person
class Employee: public virtual Person

В итоге для объекта StudentEmployee мы сможем вызвать функцию print.

А консольный вывод будет следующим:

Person created
Person Bob
Person deleted

Таким образом, мы видим, что теперь конструктор и деструктор класса Person вызываются только один раз.


______________________________________________________________________________________
Проблемы множественного наследования

Главная проблема множественного наследования в том, что будет если мы несколько раз наследуемся от одного и того же базового класса через промежуточных родителей.

	Mom	     Dad
	int m;	    int d;		
 	|	     |
 	|	     |
 	\--> Son <--/
     	    int s;

class Son : public Mom, public Dad{};

Мы имеем множественное наследование. У каждого класса есть поле с типом int. Вопрос: как будет выглядить в памяти объект класса Son, и сколько он будет занимать
байт? Он будет занимать 12 байт. В памяти сначала будут расположены родители, затем наследник: Mom Dad Son. Кладуться они в том порядке в котором мы их перечислили.

Проблема 1) 
Допустим если у нас есть функция void f(Dad*) можно ли туда отдать сына? Ведь адрес Dad не такой как адрес Son. Дело в том, что подобъект Dad в этом объекте
он начинается с адреса на 4 больше чем сам исходный объект. Т.е. получается когда я пытаюсь дать в функцию по ссылке или указателю на папу сына, неявный каст должен 
сдвинуть адрес объекта. Если я беру адрес сына и превращаю его неявно в адрес папы, то указатель должен сдвинуться на 4. При неявных кастах, иногда разрешается 
изменение численного значения указателя.

Пример неявного каста одного поинтера к другому, при котором численное значение поинтера меняется. После этого каста, адрес s и p это будут разные числа. 
Son s;
Dad* p = &s;

Сдвиг указателя происходит при касте радителя, который был указан не первым при наследовании.

В стандартной библиотеке есть пример множественного наследования: iostream - одновременно наследник istream и ostream.

Проблема 2) Что если поля или методы родителей называются одинаково?
Если объявить в сыне метод, который затмевает по названию методы родителей, то туда уже поиск имён не пойдёт. Но если мы в сыне не объявили метод, а в маме и папе
был метод с одинаковым названием, причём не обязательно с одинаковыми аргументами, то будет перегрузка между методами родителей. Методы мамы и папы считаются 
равноправными, и компилятор делает перегрузку между ними. Так же мы можем явно указать каким полем или методом мы хотим воспользоваться.

Проблема 3) Ромбовидное наследование (Diamond problem)

		Granny
		  int g;
		  /\
		 /  \
		/    \
	      Mom    Dad
	     int m; int d;
	        \    /
		 \  /
		  \/
		 Son
		 int s;
		 
Допустим мы созадём объект сына. Как это будет выглядить в памяти, и сколько памяти он будет занимать. Занимать он будет 20 байт. Потому что на самом деле будет
два экземпляра бабушки в сыне. Т.е. правильно будет нарисовать вот так:

	Granny	 Granny	    По типу обе бабушки совпадают
	int g;	 int g;
	   |	  |
	   |	  |
	  Mom    Dad
	  int m; int d;
	    \	 /
	     \  /
	      \/
	      Son
	     int s;

Как это будет выглядить в памяти: Сначала у сына лежит мама и мама в свою очередь начинается с бабукши.
Granny Mom Granny Dad Son. - Так будет лежать в памяти объект сына.

Что будет если я у такого объекта попытаюсь обратиться к полю g? Ошибка из-за неодназначности. Если у бабушкисуществует любой метод и мы попытаемся обратиться к 
нему через объекта класса сына это тоже будет неоднозначно, поскольку методы могут пользоваться полями, а поля завият от какой бабушки мы вызвались, так что 
неможет быть так, что этот метод можно понять двояко. Это и есть проблема ромбовидного наследования. 

Проблема 4) Каст к Бабушке

Granny& g = s; // CE По причине неодназначный каст. Непонятно к какой бабукши происходит каст 

static_cast<Mom::Granny>(s) // тоже CE, поскольку для static_cast важен тип, а тип Granny которая в маме и Granny просто это один и от же тип.

Чтобы скаститься к бабушке, нужно сначала скаститься к маме. Ну или сначала к папе, потом у бабушке.

Допустим у меня есть объект сына и мы скастили его до объекта мамы. От мамы мы не можем скаститься к папе. Такой каст запрещён. Каст от бабушки к напрямую к сыну 
тоже неопределён.  Т.е. От бабушки к маме например а от мамы к сыну можно, но напрямую от бабушки к сыну нельзя.


######################
Представим что я унаследовался от мамы, которая наследница бабушки, и также унаследовался напрямую от бабушки. Мы получим такое наследование:

	Granny
	   |
	   |
	  Mom   Granny
	   \    /
	    \  /
	     \/
	    Son
		 
Как теперь обратиться к правой бабушке? s.Granny::g это неодназначность. Если так унаследоваться, то получиться новая ситуация, которая называется 
unacsessible base class. Т.е. если мы допустили такое наследования, то у нас получились поля и методы к которым мы никак не можем обратиться напрямую. У нас простонет 
синтаксиса. Это очень плохое наследование.


######################
Указатели на методы

Указатель на метод хранит в себе адрес функции, по которой этот метод вызывается.

	Mom	      Dad
	foid f()    void f()
	 \	     /
	  \	    /
	   \	   /
	    \     /
	     \   /
	      \ /
	      Son
	    void f()
		  
Представим что есть сын, а ещё есть 

void (Mom::* p)() = &Mom::f

Мы берём указатель на метод мамы и по этому указателю вызываем метод сына.
(s.*p)(); // так можно делать, поскольку метод мамы у сына присутствует.

Однако, если мы берём метод папы, всё становиться сложнее

void (Dad::* p)() = &Dad::f // так вроде нельзя сделать
void (Son::* ps)() = p;	// так вроде можно

Указатель на методы устроены сложнее чем указатели на функции. sizeof(p) это 16, а не 8. Указатели на функции, это просто указатели, они занимают 8 байт, а вот указатели на 
методы, занимают в 2 раза больше чем обычные указатели. Представте что у папы есть метод f и мы вызываемся от сына. Внутри этой функции, мы должны понимать, что на самом деле
поля, с уоторыми мы сейчас собираемся работать, они сдвинуты отностительно начала нашего объекта, от которого мы вызвались.

Указатель на метод состоит из двух частей: Он хранит адрес функции, и число сдвига. Число сдвига это число, показывающее на сколько байт начала того объекта, чей этот метод,
сдвинуто относительно начала того объекта, от которого мы вызвались. В основном это число будет 0, но в данном случае это число будет 4, потому что мы вызвали папин метод 
от сына, и в методе мы должны понимать, что ссылка на объект(адрес объекта, от которого мы работаем как будто) она на 4 правее относительно начала того объекта. Указатели на 
методы нельзя хранить как обычные указатели.



______________________________________________________________________________________
Что такое интерфейс в ООП

Один раз, человек научившись кататься на велосипеде, никогда не забудет как это делать, даже если поедет на другом типе велосипеда, потому что он уже освоил навык езды на 
велике. То есть человек освоил интерфейс управления велосипеда.
Интерфейс это фактически методы с модификатором public, с помощью которых мы можем взаимодействовать с какой то сущностью. Интерфекс это некая договорённость, о том, как 
можно с чем то взаимодействовать. Интерфейс это чисто абстрактный класс, в котором все методы чисто виртуальны.


class IBicycle { 							//Наш интерфейс
public:
	void virtual TwistTheWheel() = 0;				//Виртуальные методы всех велосипедов
	void virtual Ride() = 0;
};

class SimpleBicycle : public IBicycle{ 					//Принято говорить что мы не наследуем, а реализовываем интерфейс.(Обычный велик).
public:
	void TwistTheWheel() override {					//Переопределяем методы базового класса под спортивный велик.
		cout << "метод TwistTheWheel() SimpleBicycle" << endl;
	}
	void Ride() override {						//Переопределяем методы базового класса под спортивный велик.
		cout << "метод Ride() SimpleBicycle" << endl;
	}
};

class SportBicycle : public IBicycle { 					//Реализовываем интерфейс спортивного велика.
public:
	void TwistTheWheel() override {					//Переопределяем методы базового класса под спортивный велик.
		cout << "метод TwistTheWheel() SportBicycle" << endl;
	}
	void Ride() override {						//Переопределяем методы базового класса под спортивный велик.
		cout << "метод Ride() SportBicycle" << endl;
	}
};

class Human {
public:
	void RideOn(IBicycle & bicycle) { 				//В параметре принимаем ссылку на любой объект, который реализует интерфейс IBicycle. 
		cout << "Крутим руль" << endl;
		bicycle.TwistTheWheel();				//Вызываем метод TwistTheWheel() класса, который был передан в параметре.
		cout << endl << "Поехали" << endl;
		bicycle.Ride();						//Вызываем метод Ride() класса, который был передан в параметре.
		cout << endl;
	}
};
int main()
{
	setlocale(LC_ALL, "Russian");
	SimpleBicycle sb;
	SportBicycle sportB;

	
	Human h;
	h.RideOn(sb);							//Вызываем метод RideOn класса Human с параметром sp (обычный велик).
	h.RideOn(sportB);						
	
	
	return 0;
}

Т.е. человеку не важно на обычном или спортивном велике он поедет, если их реализация одинаковая.


______________________________________________________________________________________
Виртуальное наследование. Ромбовидное наследование.


class Component {							//Базовый класс.
public:
	Component(string companyName) {		
		cout << "конструктор Component " << endl;
		this->companyName = companyName;
	}
	string companyName;						//Производитель компонента
};
class GPU : public Component {						//Класс GPU унаследован от класса Component
public:
	GPU(string companyName) : Component(companyName) {
		cout << "конструктор GPU " << endl;
	}
};	
class Memory : public Component {					//Класс Memory унаследован от класса Component
public:
	Memory(string companyName) : Component(companyName) {
		cout << "конструктор Memory " << endl;
	}
};
class GraphicCard : public GPU, public Memory {				//Класс GraphicCard унаследован от двух классов: GPU и Memory
public:
	GraphicCard(string GPUcompanyName, string MemorycompanyName) : GPU(GPUcompanyName), Memory(MemorycompanyName) { //В данном случае Для вызова предков нужно передать
		cout << "конструктор GraphicCard " << endl;								//параметры, которые мы получили при создании текущего					
	}														//класса.
};
int main()
{
	setlocale(LC_ALL, "Russian");
	GraphicCard gc("AMD", "Sumsung");				//Создаём объект класса GraphicCard. Передаём в параметрах двух производителей.
	
	return 0;
}

Мы создаём объект класса GraphicCard, передаём в него параметры двух производителей (GPU видюхи и её Memory). Класс GraphicCard унаследован от двух классов: GPU и Memory. Для 
его создания, нужно создать все классы предков. В классе GPU тоже есть предок - класс Component, создаём его. И в классе Memory предком тоже является класс Component. Он тоже
создаётся. Вывод в консоль:

конструктор Component 
конструктор GPU
конструктор Component
конструктор Memory
конструктор GraphicCard

Общая картина: В классе GraphicCard содержутся два класса GPU и Memory, которые оба содержут по классу Component. (Самый базовый класс Component включается в наш класс 
GraphicCard два раза). 

	/-------------------------------------------------------\
	|/------------------------\  /------------------------\ |
	||  /------------------\  |  |	/------------------\  | |
	||  |		       |  |  |	|		   |  | |
	||  |  Класс Component |  |  |	|  Класс Component |  | |
	||  |		       |  |  |	|	           |  | |
	||  |		       |  |  |	|		   |  | |
	||  \------------------/  |  |  \------------------/  | |
	||			  |  |			      | |
	||	   Класс GPU	  |  |	   Класс Memory	      |	|
	|\------------------------/  \------------------------/	|
	|							|
	|		  Класс GraphicCard			|	
	\-------------------------------------------------------/

В текущей схеме наследования это не является проблемой, но в некоторых случаях это будет являтся проблемой.

Таже самая схема, только классы другие. 
Проблема в том, что данные о кол-ве HP у нашего орка война хранятся в двух местах. Нам нужно чтобы каласс Character был в этой структуре всего один раз(а не два). В этом и есть
суть ромбовидного наследования. Для того чтобы класс Orc и класс Warrior ссылались на один и тот же экземпляр класса Character, если они оба присутствуют в классе наследнике,
нам нужно использовать в модификаторах наследования ключевое слово virtual (Пример: class Orc : public virtual Character). 

class Character {						//Класс персонаж
public:
	Character()
	{
		cout << "конструктор Character " << endl;
	}
	int HP;
};
class Orc : public virtual Character {				//Класс Орк
public:
	Orc()
	{
		cout << "конструктор Orc " << endl;
	}
};
class Warrior : public virtual Character {			//Класс Воин
public:
	Warrior()
	{
		cout << "конструктор Warrior " << endl;
	}
};
class OrcWarrior : public Orc, public Warrior {			//Класс ОркВоин
public:
	OrcWarrior()
	{
		cout << "конструктор OrcWarrior " << endl;
	}
};
int main()
{
	setlocale(LC_ALL, "Russian");
	OrcWarrior ow;
	return 0;
}

Общая картина:
			/----------------\
			|		 |
		/----->	| класс Characte | <-----\
		|	|		 |	 |
		|	\----------------/  	 |
		|				 |
	/----------------\           	/----------------\
	|		 |		|		 |
	| класс Orc 	 |		| класс Warrior  |
	|		 |		|		 |
	\----------------/		\----------------/
		^				 ^
		|	/----------------\       |
		|	|		 |       |
		\-----  |класс OrcWarrior|  -----/
			|		 |
			\----------------/


В разных ситуациях нужно применять разный тип наследования.


Решение проблемы ромбовидного наследования это явно указать из какого класса мы берём поле:

class A { 			// Базовый класс
public:
    int h; 			// Поле базового класса
};
class B: public A { 		// Класс наследник
};
class C: public A{ 		// Класс наследник
};
class D: public B, public C { 	// Класс наследник с двумя базовыми классами
};

int main()
{
    D d;
    //d.h; 			// Не работает - h не является однозначным.
    d.C::h = 7; 		// Явно указываем из какого базового класса мы берём поле.
    
    return 0;
}



############################
Подробное объяснение

Представим следующую иеархию:

	   Granny
	     /\
	    /  \
	Mom	Dad
	    \  /
	     \/
	    Son

Нам не нравиться, что когды мы два раза наследуемся от одного и тогоже, через разных промежуточных родителей, у нас получается две копии Granny. Мы хотим возможность 
наследования, чтобы копия была одна. Такая возможность есть, для этого наследование можно объявить виртуальным. 

struct Mom : public virtual Granny {};
struct Dad : public virtual Granny {};
struct Son : public Mom, public Dad{};

Мы пишем virtual перед каждым упоминанием той самой бабушки, которой мы не хотим дублировать. Это приводит к тому, что в графе наследования бабушка становиться всего одна, 
копии её больше нет. И теперь если мы сделаем:

Son s;
s.g(); 
// Или так
Granny& g = s; // Всё будет работать однозначно

Это круто, но как это часто бывает, пытаясь решить одну проблему мы породили 5 новых.

Как это работает?

Представим, что у нас есть такое наследование:

	   Granny
	   int g;
	     /\
	    /  \
	Mom	Dad
	int m;  int d;
	    \  /
	     \/
	    Son
	    int s;

Сколько байт в памяти будет занимать объект класса Son? Вроде бы 40. Как это будет выглядить в памяти: В начале объекта мы храним указатель, который указывает на специальную 
структуру данных в статической памяти (vtable), в которой перечислены сдвиги относительно начала объекта до всех виртуальных предков. Т.е. для класса мама будет создана 
таблица, в которой написаны какие сдвиги относительно начала мама до виртуальных предков. Для класса Dad и Son так же будет создана такая таблица. И в самом конце бабушка.

Память:

указатель на таблицу1, Mom, указатель на таблицу2, Dad, Son, Granny. 
|			  | |			      | 
--------------------------- --------------------------- 
     подобъект мамы		подобъект папы			
	


Схема таблиц:

   --------------	    ------------
Mom| 	12	|	Dad |	12     |
   --------------	    ------------
Какие сдвиги		Какие сдвиги
относительно Mom	относительно Dad
на виртуальных 
предков


	       -------------
	   Son |    32	   |
	       -------------
	   Какие сдвиги
	   относительно Son


Для каждого из типов Mom, Dad, Son, в статической памяти будет создана некоторая структура данных (vtable), в которой будет для каждого виртуального предка статически 
перечислин сдивг относительно начала объекта этого предка. Для Mom это будет 12, потому что для Mom Granny начинается тут: 

указатель на таблицу1, Mom, Granny

Для Dad аналогично, а для Son Granny начинаестся аж вот тут:
 
|указатель на таблицу1, Mom ..., указатель на таблицу2, Dad, Son, Granny...|
 |8 байт		8        8		        8 |  4    4
 |							  |
 ----------------------------------------------------------
			32

... пейндинг (сдвиг), чтобы следующий пойнтер положить по адресу кратному 8.

И того sizeof(Son) = 40.

Таблица vtable существует в единственном экземпляре для каждого типа.

указатель мамы и папы указывают на vtable сына, а не на их собственные vtable (Если мама и папа часть сына).

static_cast вниз при виртуальном наследовании не работает (В верх работает) т.е. от Granny к виртуальному Mom :
static_cast<Son>(g); // CE. В обратную сторону работает, но нетривиально.

static_cast от Mom к Son и Dad к Son работает. В обратную сторону тоже.

В vtable также храниться специально число, которое называется top offset. Это число показывает наколько моё текущее положение сдвинуто относительно начала объекта.


Что будет если один и тот же класс одновременно унаследовал виртуально и невиртуально?
struct Mom : public virtual Granny {};
struct Dad : public Granny {};

Это будет работать, но проблема дублирования не решена.
указатель на таблицу1, Mom, невиртуальная Granny, Dad, Son, виртуальная Granny.


Что будет если мама и папа будт виртуальными а бабушка нет?
virtual struct Mom : public Granny {};
virtual struct Dad : public Granny {};

1)указатель таблицу сына, в которой указаны сдвиги мамы и папы, 2) Сын, 3) Виртуальная мама(Бабушка, Мама), 4) Виртуальный папа(Бабушка Папа).
             ||										       ^				  ^
	     ||										       |				  |
	     \/										       |				  |
	 mptr, dptr									       |				  |
	   |     |									       |				  |
	   |     \----------------------------------------------------------------------------------------------------------------/
	   |										       |
	   \-----------------------------------------------------------------------------------/



Что будет, если

	W  V  W		V - наследован виртуально, W невритуально
	 \/ \/
	 B   C
	  \ /
	   A

В классе V есть метод f(), и в классе B я переопределил метод f(). Если я вызыву A.f(), то какой выбериться?
По правилам поиска имён метод B.f() должен затмить метод V.f(), но дело в том, что по графу наследования может случиться так, что у нас есть несколько путей до одного и того
же класса, и по одним из путей у нас перекрытие есть, а по другому нет. При виртуальном наследовании ломается логика. Поиск имён работает так: Если хоть по одному пути имя
перекрыто, то остальные пути считаются что они не рассматриваются. Вызовется та функци, которая перекрывает.

Если в классе W есть метод g(), и в классе B есть метод g(), то это уже неодназначность, потому можно дойти как до правого W.g() ерез невиртуальных предков только, а можно
дойти до B.g() и это 2 разных g. Т.е. есть 2 пути до g.



______________________________________________________________________________________
Расположение виртуальных объктов в памяти при множественном наследовании (Memory layout of polymorphic objects with multiple inheritance) (Лекция 22)

Невиртуальное наследование:
Предположим что все они полиморфные, т.е. у бабушки есть virtual void f()

virtual void f(); virtual void f()
	Granny	 Granny
	int g;	 int g;    		По типу обе бабушки совпадают
	   |	  |
	   |	  |
	  Mom    Dad
	  int m; int d;
	    \	 /
	     \  /
	      \/
	      Son
	     int s;


Как будет выглядить объект сына? Поскольку он полиморфный, он должен начинаться с указателя на vtable. Поинтер для мамы и сына одинаковый, поэтому для них этот поинтер можно
сделать общим. А вот папа нуждается в отдельном поинтере.

Таблица памяти:
	vtable Mom_in_Son, g, m, vtable Dad_in_Son, g, d, s, ... паддинг


Что будет если в сыне мы переопределим функцию f()? Наследование невиртуальное, поэтому на самом деле у нас 2 f(), поэтому s.f() это неоднозначность. Если я переопределю f() 
в маме и папе, то всё ровно это неоднозначность. Но если я переопределю f() в сыне это не будет неоднозначность, по правилу поиска имён она будет затмевать выше лежащие f(), 
по правилам переопределения виртуальных функций, вызов f() от любого из этих Granny будет приводить к вызову f() этого сына.

!!!! Следующий абзац может быть неправильным.
https://www.youtube.com/watch?v=WdA2Lk601CI&list=PLmSYEYYGhnBviRYhIDty-CSTDS16a3whl&index=22
17.45


У нас отдельно есть таблица для Mom_in_Son и Dad_in_Son. Mom_in_Son это просто vtable для Son и Mom, а Dad_in_Son отдельная таблица для папы внутри сына. В Dad_in_Son адреса
у функций дургие, и функции могут быть перечислины в другом порядке, которые у папы были по очереди первые а в сыне они стали не первые, и даже те функции которые у сына и 
мамы есть, у папы они могут требовать вызов с другим сдвигом. Там есть такая штука называемая non-virtual thunk. Если мы у папы попытаемся вызвать метод f(), то нам нужно 
вызвать как будто метод f() просто у сына, но помнить дополнительно, что считать начало своего объекта на 16 байт правее (в данном случае), чем там считали нормально. 
non-virtual thunk это такая пред пред функция, которая вызывается перед тем, как вызвать f(). Т.е. в таблице Dad_in_Son написано вместо вызова f(), сначала сдвинься на 16 
байт вправо, а потом вызови f(). 

Если у сына функция f() переопределена, то в этой таблице адрес f() в vtable Mom_in_Son будет такой же что и в vtable Dad_in_Son, но её нужно будет вызывать с разным сдвигом. 
Сдвиг делается на число, которое называется top offset. 

С этого момента инфа верная
Т.е. у нас есть таблица Dad_in_Son, тут есть top offset, потом адрес &Son typeinfo, потом адрес &thunk который на самом деле просто делает сдвиг this -= 16 и call Son::f().
this -= 16 это и есть top offset.



###########
Виртуальное наследование

Представим что Granny виртуальная

	   Granny 	virtual void f();
	   int g;
	     /\
	    /  \
	Mom	Dad
	int m;  int d;
	    \  /
	     \/
	    Son
	    int s;

Когда наследование виртуальное помимо top offset появляется ещё virtual offset, т.е. в каждой таблице должно быть написано как далеко мы от начала объекта, а ещё как далеко от нас
начало виртуального предка.

Как выглядит сын теперь:
Сначало идёт указатель на vtable_m, m, ... пейдинг, указатель на vtable_d, d, s, указатель на vtable_g, g, ... пейдинг

Получилось 3 таблицы: 1) таблица vtable_m обычного сына, она же мама в сыне, 2) vtable_d таблица папа внутри сына, 3) таблица vtable_g бабушки внутри сына.

Таблица зависит не только от типа самого, но и от того, какой он в графе наследования, потому что этого зависят сдвиги.

Таблица сына (vtable_m): virtual offset - 32, top offset - 0, &Son typeinfo, &Son::f.
Таблица Dad in Son (vtable_d): virtual offset - 16, top offset - 16, &Son typeinfo, &thunk - потому, что если я из папы вызываю f(), то мне нужно сдвинуть this на 16.
Таблица Granny in Son (vtable_g): virtual offset нет, поскольку нет виртуальных предков, top offset - 32, &Son typeinfo, &thunk

На самом деле виртуальных таблиц ещё больше, например construction vtables, virtual table of tables. Короче много заморочек, виртуальность нужно использовать аккуратно.

Блог чувака которы хорошо разобрался в наследовании и виртуальности:
https://shaharmike.com/



______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________

Потоковый ввод вывод в файл. Перегрузка оператора << и >>

#include <iostream>
#include <fstream> // Работа с файлами в стиле C++
#include <string> // Работа со строками
#include <Windows.h>//Для русских букв в файле

using namespace std;

class Point {							//Наш класс
public:
    Point()
    {
        x = y = z = 0;
    }
    Point(int x, int y, int z)
    {
        this->x = x;
        this->y = y;
        this->z = z;
    }
    int x, y, z;
};

//Перегрузка операторов << и >>
ostream& operator<<(ostream& os, const Point& point) {     	//Возвращает ссылку на объект ostream
    os << point.x << " " << point.y << " " << point.z;
    return os;
}
istream& operator>>(istream& is, Point& point) {            	//Считывание из файла
    is >> point.x >> point.y >> point.z;
    return is;
}

int main()
{
    setlocale(LC_ALL, "Russian");
    Point p(233, 34, 565);
    //cout << p;

    string path = "myFile.txt";
    fstream fs;
    fs.open(path, fstream::in | fstream::out | fstream::app);
    if (!fs.is_open())
        cout << "Ошибка открытия файла" << endl;
    else {
        cout << "Файл окрты" << endl;
        fs << p << "\n";                                    	//Запись объекта в файл

        while (!fs.eof()) {                                 	//Считывание из файла
            Point p2;
            fs >> p2;
            cout << p << endl;
        }
    }
    fs.close();
    
    return 0;
}


______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________

С++ try catch. Обработка исключений

#include <iostream>
#include <fstream> // Работа с файлами в стиле C++
#include <string> // Работа со строками
#include <Windows.h>//Для русских букв в файле

using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    string path = "myFile.txt";
	ifstream fin;
	fin.exceptions(ifstream::badbit | ifstream::failbit); 	//Включить обработку исключительных ситуаций для ifstream.

	try 							//Пробуем чтото выполнить. Если чтото в этом блоке поломается код в этом блоке дальше выполняться не будет.
	{
		cout << "Попытка открыть файл" << endl;
		fin.open(path);
		cout << "Файл успешно открыт!" << endl;
	}
	catch (const std::exception& ex)			//Если чтото пошло не так, то будет работать следующий блок
	{
		cout << ex.what() << endl;
		cout << "Ошибка открытия файла" << endl;
	}


    return 0;
}


______________________________________________________________________________________
Генерация исключений. throw

throw необходимо использовать в том случае, если в методе нашего класса, либо же какой то логике, состояние данных, которые мы получили, каким то образом не соответствует тому
состояниию, которое мы задумывали для корректной работы нашего класса.

void Foo(int value) { 
	if (value < 0) 						//Например value не может быть меньше нуля
		//throw value;					//бросаем исключение
		throw exception("Число меньше 0");
	cout << "Переменная = " << value << endl;
}
int main()
{
	setlocale(LC_ALL, "Russian");
	
	try {
		Foo(55);
	}
	//catch(const int ex) { 				//То что ловит блок catch должно соответствовать типу данных throw (в нашем случае int)
	catch (const exception &ex) {
		cout << "Мы поймали " << ex.what() << endl;
	};
	
	return 0;
}


______________________________________________________________________________________
Несколько блоков catch

Нужен чтобы поймать разные типы исключений

void Foo(int value) { 
	if (value < 0) 						//Например value не может быть меньше нуля	
		throw "Число меньше 0"; 			//бросаем исключение
	if(value == 0) 						//И нулём тоже не может быть
		throw exception("Число равно 0"); 		//бросаем исключение
	if (value == 1) 					//И 1 тоже нельзя
		throw 1;

	cout << "Переменная = " << value << endl;
}
int main()
{
	setlocale(LC_ALL, "Russian");
	
	try {
		Foo(1);
	}
								//То что ловит блок catch должно соответствовать типу данных throw (в нашем случае int)
	catch (const exception &ex) {
		cout << "Блок 1 Мы поймали " << ex.what() << endl;
	}
	catch (const char *ex) {
		cout << "Блок 2 Мы поймали " << ex << endl;
	}
	catch (...) { 						//Ловим абсолютно всё, что бросил exception. Этот обработчик нужно ставить последним.
		cout << "Что то пошло не так" << endl;
	}
	
	return 0;
}


______________________________________________________________________________________
Свой класс exception

Стандартный exception ограничен по функционалу. При ошибке нет дополнительной информации. Чтобы получать доп. информацию можно создать собственный наследоваемый от стандартного
exception класс.

class MyException : public exception{					//Класс исключения, наследоваемый от стандартного exception
public:
	MyException(const char *msg, int dateState):exception(msg) 	//Для вывода стандартных сообщений 
	{
		this->dateState = dateState;
	}
	int GetDateState() { return dateState; } 			//Метод для получения данных на момент исключения
private:
	int dateState; 							//Состояние информации на момент исключения
};

void Foo(int value) { 
	if (value < 0) 
		throw exception ("Число меньше 0"); 
	if (value == 1) 
		throw MyException("Число = 1", value); 			//Передаём класс исключения при поимке исключения

	cout << "Переменная = " << value << endl;
}
int main()
{
	setlocale(LC_ALL, "Russian");
	
	try {
		Foo(1);
	}
	catch (MyException &ex) {
		cout << "Блок 1 Мы поймали " << ex.what() << endl;
		cout << "Состояние данныx: " << ex.GetDateState() << endl;
	}
	
	return 0;
}


______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________

Перечисляемый тип enum

Это перечисляемый тип который служит для объявления символических имён представляющие целочисленные константы.
Например состояние компьютера (включён или выключен) можно описать типом bool: true - включён, false - выключен. Но что если состояний больше? Например сон или гибернация?
Тогдамы можем закодировать эти состояния в int: 0 - выключен, 1 - включён, 2 - сон, 3 - гибернация. Но тогда нужно постоянно помнить об этой кодировке.
enum решает эту проблему.

class PC {
public:
	enum PCState { 							//Состояния компьютера
		OFF,							// Равно 0
		ON,							// Равно 1
		SLEEP							// Равно 2
		//TEST = 150 						//Можем присваивать свои значения
	};

	PCState GetState() { return State; } //Пишем геттер и сеттер для переменной State
	void SetState(PCState State) { this->State = State; }
private:
	PCState State;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	
	//PCState s;
	//s = PCState::OFF;
	PC pc;
	pc.SetState(PC::PCState::ON); 					//PC:: - класс в котором находится переменная enum. PCState::ON - её значение.

	switch (pc.GetState())
	{
	case PC::PCState::OFF:
		cout << "Выключен" << endl;
	case PC::PCState::ON:
		cout << "Включён" << endl;
	case PC::PCState::SLEEP:
		cout << "Спит" << endl;
	}

	return 0;
}



#################################
enum class C++11

enum это именнованные глобальные константы типа int 

enum E {
	White,		// это = 0
	Gray,		// это = 1
	Black		// это = 2
};

int main() {
	E e = White;
	int e = Gray;	// Плохо, что мы можем писать вот - так.
}

Это всё очень устаревшее и так писать не стоит. В C++11 появились enum class которые лишены недостатком обычных enum. В отличии от обычного enum, enum class не вносит эти
константы в глобальную область видимости и запрещает неявные конверсии в int и из int. 

enum class E {
	White,		// это = 0
	Gray,		// это = 1
	Black		// это = 2
};

int main() {
	E e = E::White;
	int e = Gray;	// так уже нельзя
}

static_cast можно делать. Так же явно можно опеределять значения констант:

enum class E {
	White = 2
	Gray,		// это = 3. +1 от предыдущей
	Black		// это = 4. +1 от предыдущей
};

Можно писать после названия enum двоеточие и написать в каком типе хранить enum (тип должен быть обязательно целочисленный)

enum class E : int8_t {
	White 
	Gray,		
	Black	
};



______________________________________________________________________________________
Пространства имен

Имена объктов могут совпадать, например если над проектом работают более 1 разработчика либо если в процессе подключить чужую библиотеку. Тогда будет ошибка.
Глобальное пространство определяется само.
Ключевое слово using с указанием namespace который мы хотим использовать, позволяет нам использовать все функции, все классы, всё что лежит в этом пространстве имён, без
явного указания пространства имён: 
С using namespace std; мы можем написать просто cout << << endl;
Без придётся явно указать пространство имён: std::cout << << endl; 	


//глобальное пространство имён определяется само.

using namespace std; 					//В namespace std лежат все стандартные с++ классы, функции, и т.д.								

namespace firstNS { 					//Первое пространство имён
	void Foo() {
		cout << "Foo firstNS" << endl;
	}
}
namespace secondNS { 					//Второе пространство имён
	void Foo() {
		cout << "Foo secondNS" << endl;
	}
}

int main()
{
	setlocale(LC_ALL, "Russian");

	firstNS::Foo(); 				//Вызов функции Foo из первого пространства имён (Явно указали)
	secondNS::Foo(); 				//Вызов функции Foo из второго пространства имён (Явно указали)

	return 0;
}



Так же в пространстве имён могут быть ещё пространства имён:

namespace thirdNS {
	void Foo() {					//И тут Foo
		cout << "Foo thirdNS" << endl;
	}

	namespace secondNS {				//И тут Foo
		void Foo() {
			cout << "Foo secondNS" << endl;
		}
	}	
}

int main()
{
	setlocale(LC_ALL, "Russian");
	thirdNS::secondNS::Foo();			//Но компилятор не ругается ведь пространства имён разные.
	thirdNS::Foo();

	return 0;
}


______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Шаблоны классов

Шаблоны классов нужны когда мы хотим чтобы наш класс работал с разными типами данных, и нам не нужно было бы для каждого типа данных писать свою реализацию. Такие классы называют
обобщёнными классами.

template - это шаблон. typename - говорит что у нас здесь будут использоваться обобщённые типы данных. T - название обобщённого типа данных.

template<typename T> 
class MyClass{

};


Реализация:

template<typename T>
class MyClass {
public:
	MyClass(T value)
	{
		this->value = value;
	}
	void DataTypeSize() { // Узнаём сколько весит в байтах наша переменная типа T
		cout << sizeof(value) << endl;
	}
private:
	T value;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	int a = 5;
	double b = 5.3423;

	MyClass<int> c1(a); //Указываем с каким типом данных будет работать наш класс.
	c1.DataTypeSize();

	MyClass<double> c2(b);
	c2.DataTypeSize();
	return 0;
}



С двумя обобщёнными переменнами:

class Point {
public:
	Point()
	{
		x = y = z = 0;
	}
	Point(int x, int y, int z) {
		this->x = x;
		this->y = y;
		this->z = z;
	}
	int x, y, z;
};

template<typename T1, typename T2>
class MyClass {
public:
	MyClass(T1 value, T2 value2)
	{
		this->value = value;
		this->value2 = value2;
	}
	void DataTypeSize() { // Узнаём сколько весит в байтах наша переменная типа T
		cout << "value " << sizeof(value) << endl;
		cout << "value2 " << sizeof(value2) << endl;
	}
private:
	T1 value;
	T2 value2;
};
int main()
{
	setlocale(LC_ALL, "Russian");

	int a = 5;
	Point p;
	MyClass<int, Point> c(a, p);
	c.DataTypeSize();

	return 0;
}


______________________________________________________________________________________
Наследование шаблонных классов

class Point {
public:
	Point()
	{
		x = y = z = 0;
	}
	Point(int x, int y, int z) {
		this->x = x;
		this->y = y;
		this->z = z;
	}
	int x, y, z;
};

template<typename T1>									//Основной класс
class TypeSize {
public:
	TypeSize(T1 value)
	{
		this->value = value;
	}
	void DataTypeSize() { 								// Узнаём сколько весит в байтах наша переменная типа T
		cout << "value " << sizeof(value) << endl;
	}
protected:
	T1 value;
};

template<typename T1>
class TypeInfo : public TypeSize<T1> { 							//Наследник TypeSize с обобщённым типом T1
public:
	TypeInfo(T1 value):TypeSize<T1>(value) 						//Вызов конструктора базового класса
	{

	}
	void ShowTypeName() {
		cout << "Название типа: " << typeid(this->value).name() << endl; 	//Вывод имени типа объекта в параметре
	}
};
int main()
{
	setlocale(LC_ALL, "Russian");

	int a = 5;
	TypeInfo<int> c(a);
	c.ShowTypeName();
	c.DataTypeSize();

	Point b;
	TypeInfo<Point> d(b);
	d.ShowTypeName();
	d.DataTypeSize();

	return 0;
}


______________________________________________________________________________________
Специализация шаблона класса

Нужна для того, если мы захотим чтобы наш класс работал как то по особенному с определённым типом данных при шаблонах класса.

template<typename T>
class Printer {
public:
	void Print(T value){
		cout << value << endl;
	}
};

template<>						//Специализация определённого типа
class Printer<string> {					//Тип string в шаблоне обрабатывается по особенному.
public:
	void Print(string value) {
		cout << "___" << value << "___" << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	int a = 5;
	string b = "123";

	Printer<int> p1;
	p1.Print(a);

	Printer<string> p2;
	p2.Print(b);

	return 0;
}


______________________________________________________________________________________
Структуры

Структура очень похожа на класс. В отличии от класса, у структуры по умолчанию все поля и методы являются public. При наследовании классов по умолчанию также модификатор 
private, а у структур public. У структур так же есть конструкторы и деструкторы.

class MyClass {					//Класс
	int a = 10;
	void Print() { cout << a << endl; }
};

struct MyStruct {				//Структура
	int a = 22;
	void Print() { cout << a << endl; }
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass m;
	MyStruct s;

	//m.a = 10;	 			//Не работает потому что private по умолчанию.
	//m.Print(); 				//Не работает потому что private по умолчанию.
	s.a = 23;				//Работает, потому что по умолчанию public
	s.Print();				//Работает, потому что по умолчанию public

	return 0;
}




______________________________________________________________________________________
Умные указатели

Указатели обычно нужны для выделения дополнительной динамической памяти. После выделения памяти программист должен позаботиться об её очистке, чтобы не было утечек. 
Если мы используем умный указатель, нам не нужно будет следить за тем, чтобы освобождать память самостоятельно, это произойдёт автоматически.
Умный указатель это объектная оболочка для каких то типов данных. Раз это объектная оболочка, значит это тоже класс. Он должен работать с любыми типами данных, поэтому при 
написании умного указателя мы будем использовать шаблоны классов.

Когда мы будем создавать объект класса, мы должны будем передать какой то указатель, на какую то область данных, где храняться наши данные. Пока класс жив, у нас будет 
переменная, которая указывает на эту область. В момент когда объект класса будет уничтожаться, у него вызовется деструктор, в котором будет очищена динамически выделенная память.

Для получения данных указаетля на уровне объекта класса умного указателя, нужно перегрузить оператор *.

template<typename T>
class SmartPointer {					//Класс умный указатель.
public:
	SmartPointer(T *ptr) 				//Получаем указатель на какой то объект, память под который мы выделили.
	{
		this->ptr = ptr; 			//сохраняем адрес в памяти на который указывает указатель.
		cout << "Constructor" << endl;
	}
	~SmartPointer() 				//При уничтожении объекта класса вызывается деструктор 
	{
		delete ptr; 				//Память должна очищаться
		cout << "Destructor" << endl;
	}
	T& operator*() { 				//Перегрузка оператора * для получения данных по указателю. Получаем ссылку на данные, чтобы не получить новую копию.
		return *ptr;
	}
private:
	T *ptr;						//Указатель который указывает на любой тип данных.
};

int main()
{
	setlocale(LC_ALL, "Russian");
	
	int *ptr = new int(5); 				//Обычный указатель. Для сравнения.
	cout << ptr << endl; 				//Получим адресс в памяти
	cout << *ptr << endl; 				//Для получения данных (значения), а не адресса, указатель нужно разименовать.
	delete ptr;					//Удаление обычного указателя.

	//Неявное преобразование типов через конструктор.
	SmartPointer<int> pointer = new int(5); 	//Создание умного указателя. Оператор new возвращает адрес данных в памяти (В нашем случае типа int). 
	cout << *pointer << endl; 			//Получение данных по указателю (Перегрузка).
	*pointer = 77; 					//Присваиваем новые данные.
	cout << *pointer << endl; 			//Получение данных по указателю (Перегрузка).

	return 0;
}


В нашем случае, когда мы выйдем из области видимости функции main, вызовется деструктор класса, и очистится динамически выделенная память.



______________________________________________________________________________________
Типы умных указателей auto_ptr | unique_ptr | shared_ptr

#include <memory> //Библиотека для типов умных указателей. 

Если у нас есть два указателя, которые ссылаются на одну и туже область памяти, то при вызове деструктора первого объекта динамические данные удалятся, а при вызове деструктора 
второго объекта вызовется ошибка очистки уже учищенной памяти. (Уже встречали эту проблему выше в темах Конструктор копирования и Перегрузка операторов (Присваивания)).

SmartPointer<int> sp1 = new int(5); //Создание умного указателя. 	
SmartPointer<int> sp2 = sp1; //sp2 ссылается на sp1. При вызове деструктора sp2 будет ошибка.

Умные указатели решают эту проблему.

auto_ptr устаревший указатель, похожий на unique_ptr.

//auto_ptr<int> ap1 = new int(5);	//Такая запись не работает
auto_ptr<int> ap1(new int(5));		//Присваиваем умному указателю ap1 значение 5 типа int.
auto_ptr<int> ap2(ap1);			//При присваивании ap2 указателя ap1, ap1 автоматически теряет связь с данными(его указатель затирается) и работать с данными теперь 
					//может только указатель ap2. 

Ошибки больше нет, но это не решение проблемы.

На смену auto_pt пришёл unique_ptr (unique - уникальный). В нём запретили такую ситуацию, когда два указателя могут ссылаться на одну и ту же область памяти.

unique_ptr<int> up1(new int(5));
//unique_ptr<int> up2(up1);		//Радикальное решение. Мы просто не можем передать один указатель другому.

unique_ptr<int> up2;
up2 = move(up1);			//Для смены владельца данных. Тепрь up2 указывает на область в памяти а up1 пустой.
up1.swap(up2);				//Аналог функции move. Меняем владельца обратно.

int *p = up1.get(); 			//Возвращает указатель в его сыром(чистом) виде. Вытенем из up1 обычный стандартный указатель примиивного вида.
					//Из умного в стандартный указатель. В auto_ptr тоже есть.

int *p2 = new int(5);
unique_ptr<int> up3(p2);
up3.reset(); 				//Затирает данные на который указывает указатель и затем up3 стал пустым
	
int *p3 = new int(5);
unique_ptr<int> up4(p3);
up4.release(); 				//Данные остаются в памяти, но указатель о них забывает.


Самый полезный указатель shared_ptr (shared - общий). Указатели shared_ptr могут ссылаться на одни и теже данные. Когда объекты shared_ptr начнут уничтожаться, при выходе их из
зоны видимости, ошибки не возникнет, потому что данные будут уничтожены только в тот момент, когда будет уничтожен самый последний shared_ptr, который ссылается на эти данные.
Это работает так, когда мы создаём какой то один указатель типа shared_ptr и где то в динамической памяти выделяем место, присваиваем туда данные, в классе shared_ptr начинает
работать счётчик ссылок. Каждый раз, когда добавляется новый объект типа shared_ptr, который указывает на теже самые данные, счётчик увеличивает своё значение. Чтобы одни и теже
данные не затирались несколько раз, в деструкторе класса shared_ptr есть проверка, которая смотрит сколько ссылок осталось на данные. Если количество ссылок больше одной, то 
удаляется только указатель. Если ссылка осталась последней, то очищаются и данные и ссылка.

shared_ptr<int> sp1(new int(5));
shared_ptr<int> sp2(sp1);



______________________________________________________________________________________
Динамический массив и умные указатели

Об освобождении динамической памяти заботится shared_ptr. Для массива <int[]> не забыть указать квадратные скобки.
int size = 5;
int *arr = new int[size]{ 1, 6, 44, 9, 8 };
shared_ptr<int[]> ptr(arr); 					//Массив динамической памяти
//shared_ptr<int[]> sp1(new int[size]{ 1, 6, 44, 9, 8 }); 	//Тоже самое

for (int i = 0; i < size; i++)
{
	cout << ptr[i] << endl;
}

А чтобы создать двумерный массив надо так:

const int size = 5;
shared_ptr<int[][size]> ptr(new int[size][size]);


______________________________________________________________________________________
Ключевые слова default и delete (C++11)

Вспомним, что у класса есть методы, которые компилятор умеет генерировать самостоятельно:

Конструктор по умолчанию
Конструктор копирования
Оператор присваивания
Деструктор

Если, например, определить конструктор с параметрами, то компилятор уже не будет генерировать конструктор по умолчанию, однако может быть ситуация когда конструктор по умолчанию, который генерирует 
компилятор нас вполне устраивает и мы хотели бы что бы компилятор нам его сгенерировал. В С++11 появилась возможность явно попросить компилятор нам его сгенерировать:

struct SomeType
{
    SomeType() = default; // просим компилятор о генерации конструктора по умолчанию
    SomeType(int value);  // пользовательский конструктор с параметрами
}

Аналогично ключевое слово default будет работать с остальными методами.

Точно так же появилась возможность попросить компилятор не генерировать какой-то из методов. В старом стандарте нам приходилось хитрить, и объявлять конструктор копирования и оператор присваивания как 
private чтобы сделать класс, который не копируется, в новом стандарте:

struct NonCopyable
{
    NonCopyable(const NonCopyable &) = delete; 			// Защитить от копирования
    NonCopyable & operator=(const NonCopyable &) = delete;      // Защита от оператора присваивания
}

Более того, можно так же удалять функции:

template<class T>
void foo(T const * p) { ... }

// запретить функции принимать указатель на char:
void foo(char const *) = delete;



______________________________________________________________________________________
Защитить класс (объект) от копирования и перемещения(почему = delete смотри выше)

class A {
    A(const A&) = delete; // Защитить от копирования
    A(A&&) noexcept = delete; // Защита от перемещения
    A& operator=(const A&) = delete; // Защита от оператора присваивания
    A& operator=(const A&&) noexcept = delete; // Защита от оператора перемещения
};


##############
Вторая реализация и ньюанс: Защиты от копирования в c++ не существует.

class A {
public:
	A(const A& ref) = delete; 		// Защитить от копирования
	A(A&& ref) = delete; 			// Защита от перемещения
	A& operator=(const A& ref) = delete; 	// Защита от оператора присваивания
	A& operator=(A&& ref) = delete; 	// Защита от оператора перемещения

	static A& get() { 			// Синглтон Майерса
		static A a;
		return a;
	}
private:
	A() = default; 				// Стандартный приватный конструктор, для того чтобы объект нельзя было создать.
	int x = 2334;				// Данные класса, для примера
};


int main() {
	//A a; 					// Создать несколько экземпляров не можем
	
	A& a = A::get(); 			//Создаём единственно возможный экземпляр с помощью синглтона. Объект защищён
	//A a1 = a; 				// Копирование запрещено
	//A a2 = std::move(a); 			// Перемещение запрещено
	// 
	//
	// Объект кажется полностью защищённым от копирования, однако в c++ полностью от этого защититься нельзя.

	char buff[sizeof(A)]; 			// Буфферр для копирования
	for (size_t i = 0; i < sizeof(A); i++) { // Бежим по размеру этого буффера
		buff[i] = ((char*)&a)[i]; 	// Сохраняем в этот буфер данные, скащинные в char. Забираем адресс нашей переменной a, кастим адресс в указатель на char, дальше с ним работаем как с 
	}					// обычным массивом. Обращаемся к i-ому байту и копируем его в буффер. 
	A* ptr = (A*)buff; 			// Кастим обратно в тип класса A. Всё, мы скопировали объект.
	return 0;
}

Singleton (Одиночка) — порождающий шаблон проектирования, гарантирующий, что в однопоточном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому 
экземпляру.

Непосредственно защитить от копирования в c++ мы не можем, но от повторного создания и повреждения изначального объекта можем.



______________________________________________________________________________________







