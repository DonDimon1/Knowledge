Класс - это некоторый шаблон объектов.
Класс имеет свойства и функции(в ООП функции называют модулями).
Конкретный объект кофемолка - это экземпляр класса кофемолка.

Принципы ООП: 
1) Инкапсуляция - принцип независимости данных. Разработчик может скрыть внутренее устройство программы, а взаимодействие с ней организовать через интерфейс.
2) Наследование - один объект может наследовать свойства и методы другого объекта, и дополнять их своим функционалом.
3) Полиморфизм - возможность объекта вести себя по разному, в зависимости от ситуации.

______________________________________________________________________________________
Класс - это пользовательский тип данных. (Который мы можем написать сами)
class Human { //Класс это шаблон, который описывает переменную.
public: //Модификатор доступа
	int age; //Переменная в классе называются свойством класса.(Или полем).
	int weight; //Вот такие свойства класса, которые содержут какую нибудь характеристику, называются полем класса.
	string name; 

	void Print() { //Метод(функция) класса.
		cout << "Имя: " << name << "\nВес: " << weight << "\nВозраст: " << age;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Human firstHuman; // А это уже конкретный экземпляр (объект) этого класса.
	firstHuman.age = 30;
	firstHuman.weight = 80;
	firstHuman.name = "Ivanov Ivan Ivanovich";
	firstHuman.Print();//Вызов метода класса.

	Human secondHuman;
	secondHuman.age = 18;
	secondHuman.weight = 65;
	secondHuman.name = "Noname";
}

______________________________________________________________________________________
Модификаторы доступа классов. public private protected

Если в классе не указан модификатор доступа, то по умолчанию считается, что стоит модификатор private.

class Point {  это равносильно этому:	class Point {  
	int x;				private:											
	int y;					int x;					
};						int y;
					};			

Если поля и методы описаны в модификаторе private, мы не можем получить к ним доступ из экземпляра (объекта) класса. Доступ к этому модификатору открыт только самому классу, 
либо же дружественным классам и функциям.

Модификатор public даёт доступ для полей и методов из объекта. 

class Point {
private:
	int z;
public:
	int x;
	int y;
};

int main()
{
	Point a;
	a.x = 1;//x и y описаны модификатором public, так что мы сможем с нимим работать. Переменная z описана private, с ней из объекта мы работать не можем.
	a.y = 2;
}

Модификатор protected так же не доступен для объекта, но он доступен для класса, который будет наследовать наш текущий класс. Модификатор private доступен только в своём классе.


______________________________________________________________________________________
Геттеры и сеттеры для класса(Методы get и set).
По принципу инкапсуляции, при работы с полями класса, мы не можем изменять их напрямую. Поэтому нужно создать интерфейс.
Геттеры (получение данных) и сеттеры (установить, присвоить данные) это обычные методы (функции) класса, нужные для взаимодействия с конкретным полем. Они должны быть под 
модификатором public.

Если метод должен чтото вернуть, т.е. получить от класса, его название должно начинаться со слова Get. Сеттер устанавливает значение для какого либо поля. Название должно 
начинаться со слова Set.
class Point {
private:
	int x;
	int y;
public:
	int GetX() {//Получаем значение x
		return x;
	}
	void SetX(int valueX) {//Устанавливаем значение для x
		x = valueX;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Point a;
	a.SetX(5);
	int result = a.GetX();
}


______________________________________________________________________________________
Пример инкапсуляции
У нас есть кофемолка. При нажатии на кнопку старт, она должна проверить напряжение сети. Если всё ок, начинаем делать кофе, иначе подать звук(пик) два раза.
class CoffeeGrinder {
private:
	bool CheckVoltage() {//Вызывается скрытая функция проверки вольтажа.
		return true;
	}
public:
	void Start() {//При нажатии на кнопку вызывается функция старта
		if (CheckVoltage())//Проверяем вольтаж
			cout << "Старт работы" << endl;
		else
			cout << "Beep Beep(звук)";
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	CoffeeGrinder a;
	a.Start();//Нажимаем на кнопку старт
}


______________________________________________________________________________________
Конструктор класса
Конструктор класса это конструкция(сущность) которая предназначена для того, чтобы инициализировать состояние класса в какое то начальное значение, нужное нам. Изначально поля
класса могут быть заполнены мусором. Для их инициализации нужно вызывать сеттеры, это плодит много кода. 
Конструктор класса это функция без возвращаемого значения.(даже не void). Мы не можем вызвать его в ручную, он вызывается сам при создании объекта. Если мы его не указали, он
добавляется сам. Такой конструктор называется конструктором по умолчанию, и выглядит он так:(он пустой).

class Point {
public:
	Point() //Это конструктор класса. Его имя такое же как и имя класса. 
	{
	
	}
};

Конструктор вызывается сам при создании класса. Он должен быть в модификаторе public. Так же мы можем создать свой конструктор.
class Point {
private:
	int x;
	int y;
public:
	Point(int valueX, int valueY) { //Наш собственный контруктор с параметрами.
		x = valueX, y = valueY; //Устанавливаем изначальные значения.
	}
};

int main()
{
	Point a(5, 44);//Теперь при создании объекта нужно указать параметры конструктора. 
}

______________________________________________________________________________________
Перегрузка конструкторов класса.
С перегрузкой реализуем в некоторой степени полиформизм класса.
Очень похожа на перегрузку функции. При перегрузке конструктора класса мы можем инициализировать класс различными способами, в зависимости от ситуации.
Например нам нужно, чтобы при создании объекта с конструктором по умолчанию, в переменных был не мусор, а дефолтные настройки, например 0. Но при этом была возможность вызвать
конструктор и с параметрами.

class Point {
private:
	int x;
	int y;
public:
	Point() { //Конструктор по умолчанию
		x = 0, y = 0;
	}
	Point(int valueX, int valueY) { //Перегрузка конструктора. Этот конструктор с параметрами.
		x = valueX, y = valueY;
	}
	void Print() {
		cout << "X = " << x << ",\tY = " << y << endl;
	}
};

int main()
{
	Point a;
	a.Print(); //Выведет X = 0,	Y = 0

	Point b(5, 4);
	b.Print(); //Выведет X = 5,	Y = 4	
}


______________________________________________________________________________________
Деструктор
Деструктор противоположен конструктеру класса. Он срабатывает при разрушении объекта класса. Это тоже функция, и мы тоже её сами вызвать не можем. Уничтожение объекта класса 
происходит, когда он выходит из зоны видимости. Деструктор в классе может быть только один. Мы можем не писать его и тогда он добавится автоматически, либо описать его сами.
У деструктора нет параметров. Деструктор нужен для корректной очистки памяти, например освобождении динамической памяти, выделенной во время работы объекта класса.

class MyClass {
public:
	MyClass() {
		cout << "Вызвался конструктор" << endl;
	}
	~MyClass() { //Синтаксис деструктора. Тоже самое что и конструктор, только с тильдой.
		cout << "Вызвался деструктор" << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a;
	return 0;
}

Объекты уничтожаются в обратном порядке тому, как они создавались.
class MyClass {
	int data;
public:
	MyClass(int value) {
		data = value;
		cout << "Объект "<< data <<" Вызвался конструктор" << endl;//При создании объектов в консоль сначала выведется запись о создании объекта 1 потом об объекте 2.
	}
	~MyClass() {
		cout << "Объект " << data << " Вызвался деструктор" << endl;//При удалении объектов в консоль сначала выведется запись о удалении объекта 2 потом об объекте 1.
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a(1); //Создаём первый объект
	MyClass b(2); //Создаём второй объект
	return 0;
}


______________________________________________________________________________________
Ключевое слово this
Ключевое слово this это указатель объекта на самого себя(хранит адрес в памяти). Снаружи класса этот указатель мы использовать не можем, только внутри класса.

class Point {
private:
	int x;
	int y;
public:
	Point() { //Конструктор по умолчанию
		x = 0, y = 0;
	}
	void SetX(int x) {//Устанавливаем значение для x
		this->x = x;//С помощью this устанавливаем новое значение переменной x.
	}
};

int main()
{
	Point a;
	a.SetX(5);

	return 0;
}


______________________________________________________________________________________
Конструктор копирования
Конструктор копирования отвечает за копирование объекта. В классе есть конструктор копирования по умолчанию, который делает побитовое копирование.

Если мы в функцию передаём параметр по значению(без ссылки или указателя), то в функции создаётся локальная копия этого параметра. Все изменения которые мы делаем с этой копией
не отоброзятся на основной переменной. 

class MyClass {
public:
	MyClass() {							//1.1) Вызывается конструктор по умолчанию.
		cout << "Вызвался конструктор " << this << endl;
	}								//3) Вызов деструктора для локального класса в функции Foo. 5) Вызов деструктора для нашего класса a в
	~MyClass() {							//функции main.
		cout << "Вызвался деструктор " << this << endl;
	}
};

void Foo(MyClass value) {						//2.2) Вызов нашей функции. Поскольку параметр является параметром по значению, создаётся локальная 
	cout << "Вызвалась функция Foo" << endl;			//	копия нашего класса.
}									//2.3) Функция закончила работу. Выход из Область видимости локального класса. 
int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a; 							//1) Создаём наш класс
	Foo(a);//Мы вызываем 						//2) Вызываем функцию, в параметре которой указан наш класс(по значению).
	return 0;							
}									//4) Программа закончила работу. Выход из Область видимости нашего класса a.
	
Что будет выведено в консоль:
Вызвался конструктор 002BFA58
Вызвалась функция Foo
Вызвался деструктор 002BF974	(Появился вызов лишнего локального деструктора, который был в функции foo)
Вызвался деструктор 002BFA58

Когда мы передаём в функцию параметр по значению, вызывается Конструктор копирования, а не создания. Он у нас не описан, значит компилятор создаёт его сам по умолчанию. 
Поэтому мы не видим в консоли лог о создании локального класса.

Либо мы можем задать явное копирование класса.
int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a;
	MyClass a(10);
	MyClass b(a); 	//Явно копируем класс a

	return 0;
}

В этом случае мы можем наблюдать что опять конструктор вызвался один раз, а деструктор два раза. Это большая проблема. Например, если в конструкторе класса будет код, который
выделяет динамическую память, а в деструкторе мы будем её очищать, то поскольку деструктор вызывается два раза, то во второй раз мы будем обращаться к уже очищенной зоне в 
памяти, что вызовет ошибку. Ведь в этой зоне уже могут быть другие данные.(Тоесть два созданных класа указывают на одну и туже облать памяти).

class MyClass {
	int *data;		
public:
	MyClass(int size) {						//1.1) Вызов конструктора. 
		this->data = new int[size];				//1.2) Выделение динамической памяти по 10 элементов массива типа int.
		for (int i = 0; i < size; i++)
		{
			data[i] = i;
		}
		cout << "Вызвался конструктор " << this << endl;
	}
	~MyClass() {							//3.1) Уничтожается объект b(уничтожение идёт в обратном порядке.) 4) Вызыв деструктора объекта a.
		cout << "Вызвался деструктор " << this << endl;
		delete[] data;						//3.2) Освобождение памяти.	4.1) Попытка очистить уже очищенную область памяти. Вызов ошибки при 
	}								//					работе с динамической памятью.
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a(10);							//1) Создаём класс а с параметром 10.
	MyClass b(a);							//2) Вызов конструктора копирования. Выполняется побитовое копирование.(Идентичная копия класса a).

	return 0;							//3)Программа законичла работу. Начинается вызов деструкторов.
}


Для того, чтобы такой ситуации избежать, нам нужно описать конструктор копирования. Синтаксис конструктора копирования.

class MyClass {
	int *data;
	int arrSize;// Переменная для запоминания размера массива.
public:
	MyClass() {
		cout << "Вызвался конструктор " << this << endl;
	}
	MyClass(int size) {
		this->arrSize = size; 	//Запоминаем размер массива.
		this->data = new int[size];	//Создаём динамический массив.
		for (int i = 0; i < size; i++)  //Заполняем его.
		{
			data[i] = i;
		}
		cout << "Вызвался конструктор " << this << endl;
	}


	//Это конструктор копирования
	MyClass(const MyClass &other) { //Принимаем в параметр ссылку на объект, который хотим скопировать. Ставим const для того, чтобы ничего не изменить.
		this->arrSize = other.arrSize; //Копируем параметр arrSize 
		this->data = new int[other.arrSize];//Вместо тупого копирования указателя, создаём новый массив, с таким же кол-вом ячеек , как и в оригинальном объекте.
		for (int i = 0; i < other.arrSize; i++)//Копируем все значения из массива оригинального объекта в массив текущего объекта.
		{
			this->data[i] = other.data[i];
		}
		cout << "Вызвался конструктор копирования" << this << endl;
	}
	~MyClass() {
		cout << "Вызвался деструктор " << this << endl;
		delete[] data;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a(10);
	MyClass b(a);	//Вызов конструктора копирования.

	return 0;
}


______________________________________________________________________________________
Перегрузка операторов (Присваивания)
При использовании операции присваивания мы можем натолкнуться на ту же проблему, что была изложена пунктом выше.

int main()
{
	MyClass a(10);
	MyClass b(2);

	a = b; //Объект a теперь думает что он объект b. Теперь они имеют одинаковый адрес. При вызове деструкторов одна и таже область памяти будет очищаться 2 раза.
	return 0;
}

Чтобы избежать данной проблемы нужно выполнить перегрузку оператора присваивания(=).

Важный момент: При создании объекта вот так: MyClass b = a; вызывается конструктор копирования, а не присваивания, потому что b ещё не создан. Запись MyClass b = a; 
	эквивалентна записи MyClass b(a);

По сути операторы это тоже функции. Компилятор запись a = b видит так: a присвоить (b); 
Для переопределения операторов применяестся ключевое слово operator, и далее сам оператор, который перегружаем. В параметрах должен быть тот же самый объект, который хотим 
присваивать. В данном случае это будет константная ссылка на объект класса. Ссылка, потому что нам не нужна копия этого объекта, нам нужно только посмотреть что в нём лежит.
Константная, потому что мы там ничего менять не собираемся. Так же оператор возвращает значение, и он должен возвращать ссылку на текущий объект. Поэтому в начале ставим не
void а MyClass &, и в конце стави return *this;

MyClass & operator = (const MyClass &other) {
	return *this;
}

После переопределения в объекте появилась ещё одна запись: 
int main()
{
	MyClass a(10);
	MyClass b(2);
	a.operator = (b); //Теперь это равнозначно, что и просто a = b;
	return 0;
}

Сначала в объекте в котороый мы хотим совершить копирование выполнить освобождение памяти. Перед освобождением памяти нужно делать проверку на nullptr. Потому что если память не
выделялась, мы и не должны её удалять.

class MyClass {
	int *data;
	int arrSize;// Переменная для запоминания размера массива.
public:
	MyClass() {
		cout << "Вызвался конструктор " << this << endl;
	}
	MyClass(int size) {
		this->arrSize = size;
		this->data = new int[size];
		for (int i = 0; i < size; i++)
		{
			data[i] = i;
		}
		cout << "Вызвался конструктор " << this << endl;
	}
	MyClass(const MyClass & other) {
		this->arrSize = other.arrSize; 
		this->data = new int[other.arrSize];
		for (int i = 0; i < other.arrSize; i++)
		{
			this->data[i] = other.data[i];
		}
		cout << "Вызвался конструктор копирования" << this << endl;
	}
	MyClass & operator = (const MyClass &other) {	//Перегрузка оператора
		cout << "Вызвался оператор = " << this << endl;
		this->arrSize = other.arrSize; //arrSize просто присваеваем новое значение, т.к. это не динамич. память.

		if (this->data != nullptr) { //Указывает ли указатель data на какую нибудь область памяти, где есть какие нибудь данные.
			delete[] this->data; //Если data указывает, значит данные там есть. Очищаем старую динамическую память
		}
			
		this->data = new int[other.arrSize];//Выделяется новая область памяти, согласно размеру и кол-ву элементов в том объекте, от которого мы копируем.(other).
		for (int i = 0; i < other.arrSize; i++)//По элементно копируем значния из other в this.
		{
			this->data[i] = other.data[i];
		}
		return *this;
	}

	~MyClass() {
		cout << "Вызвался деструктор " << this << endl;
		delete[] data;
	}
};



int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a(10);
	MyClass b(2);
	a = b;
	return 0;
}

В результате объекты a и b имеют разные адресса, разные области дин. памяти, но с одинаковыми значениями всех полей и данных.


______________________________________________________________________________________
Перегрузка оператора равенства == и не равно !=
Когда мы проверяем два разных экземпляра на равенство мы проверяем состояниеэтих объектов, т.е. равны ли между собой их поля, и если эти поля содержут какие нибудь данные, 
одинаковые ли данные там находятся.

При перегрузке оператора мы должны передавать параметр для сравнения.
class Point {
private:
	int x;
	int y;
public:
	Point() {
		x = 0, y = 0;
		cout << this << " constructor" << endl;
	}
	Point(int valueX, int valueY) {
		x = valueX, y = valueY;
		cout << this << " constructor" << endl;
	}
	bool operator == (const Point & other) {				//Перегрузка оператора ==. this это объект a, other это объект b.
		return this->x == other.x && this->y == other.y;
	}
	bool operator != (const Point & other) {				//Перегрузка оператора !=
		return !(this->x == other.x && this->y == other.y);
	}
};
...
int main()
{
	setlocale(LC_ALL, "Russian");
	Point a(5, 1);
	Point b(9, 4);
	
	bool res = a == b; //Объект класса a, это тот объект, где лежит наша функция перегрузки, а объект b это передаваемый объект в параметр этой функции.
	bool res = a != b;

	return 0;
}


______________________________________________________________________________________
Перегрузка оператора сложения
Результат сложения объектов одинакового класса (Point), тоже будет объект этого же класса (Point).

(В классе Point)
Point operator + (const Point& other) { //Создаём временный класс, записываем в него результаты сложений всех полей класса, и возвращаем его.
	Point temp;
	temp.x = this->x + other.x;
	temp.y = this->y + other.y;
	return temp;
}
int main()
{
	setlocale(LC_ALL, "Russian");
	Point a(5, 1);
	Point b(77, 12);
	
	Point c = a + b;

	return 0;
}


______________________________________________________________________________________
Перегрузка инкремента и декремента

Перегрузка префиксной формы инкремента
Так как мы будем выполнять операцию над тем же самым объектом, с которым работаем, по этому мы должны возвращать ссылку на этот же объект. Нам не требуется создавать 
новый объект для этих операций.

(В классе Point)
Point & operator ++() { //Перегрузка префиксной формы инкремента.
	this->x++;
	this->y++;
	return *this;
}
...
int main()
{
	Point a(1, 1);
	++a; 		
	return 0;
}

Перегрузка постфиксной формы инкремента
Мы должны описать в параметре, что мы передаём какое нибудь значение типа int, чтобы компилятор понимал, что это перегрузка постфиксной формы. На деле ничего передавать мы не будем.
Сначала запоминаем текущее состояние объекта. Потом этот объект подвергаем операции постфиксного инкремента. Но возвращаем сохранённый объект, со старыми данными(без инкремента).


(В классе Point)
Point operator ++(int value) { //Перегрузка постфиксной формы инкремента. В этот раз знака амперсанта нет. Так возвратиться копия temp, и после уничтожения temp все будет ок.
	Point temp(*this);	//Нам нужно хранить текущее состояние объекта. Для этого создаём ещё один точно такой же объект, на момент вызова операции постфиксного инкремента.					
	this->x++;
	this->y++;
	return temp; 
}
...
int main()
{
	Point a(1, 1);
	Point b(2, 2);
	Point c = b + a++;	// c = (3,3), а не (4,4). Потому что a++ будет выполнено после присваивания значения объекту c.	
	return 0;
}

С декрементом всё тоже самое только где сейчас ++ ставим --.


______________________________________________________________________________________
Перегрузка оператора индексирования []

С классом мы можем работать точно так же как и с массивом. Для этого нам нужно перегрузить оператора индексирования.

class TestClass {
public:
	int & operator [] (int index) {	//Возвращаем значение по ссылке
		return arr[index];
	}
private:
	int arr[5]{ 5,44,4,987,69 };
};
int main()
{
	setlocale(LC_ALL, "Russian");
	TestClass a;
	cout << a[2] << endl;
	a[0] = 100;
	return 0;
}


______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________

Дружественные функции и классы

Дружественной функция по отношению к классу называется функция, которая хоть и не является членом класса, т.е. описана не внутри класса, а снаружи, она имеет доступ к закрытым полям класса.
В дружественной функции доступ к полям через this не работает. Мы можем получать доступ к полям класса через его объект.
На определение дружественной функции в классе не распространяются влияния модификаторов доступа (public, private, protected). Т.е. можем указать её в любом месте.
Функция может быть дружественной по отношению к нескольким классам.

class Point {
private:
	int x;								//Закрытые поля класса.
	int y;
public:
	Point() {
		x = 0, y = 0;
		cout << this << " constructor" << endl;
	}
	Point(int valueX, int valueY) {
		x = valueX, y = valueY;
		cout << this << " constructor" << endl;
	}
	void Print() {
		cout << "X = " << x << ",\tY = " << y << endl;
	}
	
	friend void ChangeX(Point& value);				//Определение (прототип) дружественной функции в классе (Разрешение функции обращаться к закрытым полям). (Как прототип функции).
};

void ChangeX(Point& value) {						//Дружественная функция, которая что-то делает.
	value.x = -1;
}

int main()
{
	setlocale(LC_ALL, "Russian");
	Point a(5, 12);
	ChangeX(a);							//Вызов	дружественной функции.					

	return 0;
}


______________________________________________________________________________________
Определение методов вне класса
class MyClass				//Определение класса.
{
public:
	void PrintMessage();		//Прототип(сигнатура) метода.

};

void MyClass::PrintMessage()		//Определение метода вне его класса. (Функция глобальна и она не пренадлежит ни одному из классов).
{
	cout << "Hello!" << endl;
}

int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass a;
	a.PrintMessage();

	return 0;
}


______________________________________________________________________________________
Дружественный метод класса
Метод одного класса может быть дружественным к методу другого класса.

class Apple;											//Определение класса Apple. Для того чтобы класс Human знал, что класс Apple существует.
class Human;

class Human {
public:
	void TakeApple(Apple& apple);								//Сигнатура метода TakeApple.
		
	void EatApple(Apple& apple) {								//Этот метод не дружественный к классу Apple, и он не может получать доступ к полям класса Apple.

	}
};

class Apple {
public:
	Apple(int weight, string color) {
		this->weight = weight;
		this->color = color;
	}
private:
	int weight;
	string color;
	friend void Human::TakeApple(Apple& apple);						//Определение (прототип) дружественной функции для этого класса.
 };



int main()
{
	setlocale(LC_ALL, "Russian");
	Apple apple(150, "Red");
	Human human;
	human.TakeApple(apple);
	return 0;
}

void Human::TakeApple(Apple& apple) 								//Реализация метода. 
{
	cout << "TakeApple: " << "weight = " << apple.weight << " color = " << apple.color << endl;
}


______________________________________________________________________________________
Дружественные классы

Они нужны, если нам нужно чтобы все методы класса были видны для другого класса, при этом не описывая каждый метод отдельно.

class Apple;											//Определение класса Apple. Для того чтобы класс Human знал, что класс Apple существует.
class Human;

class Human {
public:
	void TakeApple(Apple& apple);								//Сигнатура метода TakeApple.

	void EatApple(Apple& apple) {								//Поскольку весь класс Human является дружественным, теперь он может получать 
												//	доступ к полям класса Apple.
	}
};

class Apple {
	friend Human; 										//Объявляем что класс Human является дружественным к нашему классу Apple.	
public:
	Apple(int weight, string color) {
		this->weight = weight;
		this->color = color;
	}
private:
	int weight;
	string color;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Apple apple(150, "Red");
	Human human;
	human.TakeApple(apple);
	return 0;
}

void Human::TakeApple(Apple& apple) 								//Реализация метода. 
{
	cout << "TakeApple: " << "weight = " << apple.weight << " color = " << apple.color << endl;
}



______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________

static

Представим, что в классе Apple мы описали какую нибудь переменную, например int Count. Если мы создаём в main несколько объектов класса, то у каждого такого объекта будет своя
переменная int Count (где то в отдельной области памяти будет лежать сам объект Apple, и далее в нём поле Count). Если же мы создаём переменную с модификатором static, то
такая переменная будет являться общей для всех объектов класса (Она у всех одинаковая, если поменять значение этой переменной у одного объекта, то поменяются значения
у всех объектов). Синтаксис: static int Count;

Мы можем обратиться напрямую к статической переменной, минуя объекты: Apple::Count.
Перед тем как использовать статическую переменную, нужно её проинициализировать. Делается это вне класса: int Apple::Count = 0;

class Apple {
public:
	static int Count;					//Объявление статической переменной.
	Apple(int weight, string color) {			//При создании объекта класса
		this->weight = weight;
		this->color = color;
		Count++;					//Увеличиваем кол-во яблок каждый раз при создании нового объекта.
	}
private:
	int weight;
	string color;
};
int Apple::Count = 0;						//Инициализация статической переменной(вне класса).

int main()
{
	setlocale(LC_ALL, "Russian");
	Apple apple(150, "Red");
	cout << Apple::Count << endl;
	return 0;
}


______________________________________________________________________________________
Статические методы класса

Статические методы имеют такое же поведение, как и статические поля класса. Если написали статические метод, то он будет один единственный для всех объектов класса. Мы также
можем обращаться к нему напрямую, минуя обращения к объектам класса. 
В статических методах работа с нестатическими полями запрещена (поля не понимают к какому конкретно объекту они привязаны). Если же мы хотим написать статический 
метод, который должен работать с конкретными объектами класса, то мы должны в этот метод передавать либо ссылку либо указать на этот объект класса.

class Apple {
public:
	Apple(int weight, string color) {
		this->weight = weight;
		this->color = color;
		Count++;					
		id = Count;					//При создании объекта присваиваем ему новый id
	}
	int GetId() {						//Метод получения id
		return id;
	}
	static int GetCount() {
		return Count;
	}
	static void ChangetColor(Apple & apple, string color) { //Статический метод, который перекрашивает яблоки.
		apple.color = color;
	}
private:
	static int Count;
	int weight;
	int id;							//Поле id нашего класса						
	string color;
};
int Apple::Count = 0;						

int main()
{
	setlocale(LC_ALL, "Russian");
	Apple apple(150, "Red");
	Apple apple2(250, "Green");
	cout << apple.GetId() << endl;
	cout << apple2.GetId() << endl;
	cout << Apple::GetCount() << endl;			
	Apple::ChangetColor(apple, "Green");			//Вызов статического метода.
	return 0;
}



______________________________________________________________________________________
Вложенные классы 

Вложенный класс (внутренний, inner) это класс, реализация которого описана внутри другого классе. А тот класс в который мы вкладываем другой класс называется объемлющий.
Вложенные классы обычно используют для внутренних нужд того класса, который его содержит.

class image { //Класс картинки
public:
	void GetImageInfo() { 			//Перебираем все пиксели
		for (int i = 0; i < LENGTH; i++){
			cout << "№ " << i << pixels[i].GetInfo() << endl;	//Вызов метода внутреннего класса Pixel.
		}
	}
private:
	class Pixel { 				//Класс пикселей(внутренний)
	public:
		Pixel(int r, int g, int b) {
			this->r = r;
			this->g = g;
			this->b = b;
		}
		string GetInfo() {
			return " Pixel: r = " + to_string(r) + " g = " + to_string(g) + " b = " + to_string(b);
		}
	private:
		int r;
		int g;
		int b;
	};

	static const int LENGTH = 5;
	Pixel pixels[LENGTH]{ 			//Вручную задали все пиксели.
		Pixel(0,6,64),
		Pixel(4,14,10),
		Pixel(111,4,24),
		Pixel(244,244,14),
		Pixel(11,179,64)
	};
};


int main()
{
	setlocale(LC_ALL, "Russian");
	image img;
	img.GetImageInfo();			//Вызов метода внешнего класса image.
	return 0;
}


______________________________________________________________________________________
Массив объектов класса

class Pixel { //Класс пикселей
public:
	Pixel() {
		r = g = b = 0;
	}
	Pixel(int r, int g, int b) {
		this->r = r;
		this->g = g;
		this->b = b;
	}
	string GetInfo() {
		return " Pixel: r = " + to_string(r) + " g = " + to_string(g) + " b = " + to_string(b);
	}
private:
	int r;
	int g;
	int b;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	const int LENGTH = 5;
	//Pixel p(11, 44, 112);
	Pixel arr[LENGTH]{			//Создание статического массива в котором хранятся объекты класса Pixel
		Pixel(0, 6, 64),
		Pixel(4, 14, 10),
		Pixel(111, 4, 24),
		Pixel(244, 244, 14),
		Pixel(11, 179, 64)
	};

	cout << arr[0].GetInfo() << endl;
	arr[0] = Pixel(11, 44, 112);
	cout << arr[0].GetInfo() << endl;

	Pixel *arr2 = new Pixel[LENGTH];	//Создание динамического массива в котором хранятся объекты класса Pixel
	arr2[0] = Pixel(11, 44, 112);
	cout << arr2[0].GetInfo() << endl;
	delete []arr2;
		
	return 0;
}


______________________________________________________________________________________
Агрегация и композиция

Эти понятия описывают отношения между классами. И агрегация и композиция это включение одного класс в другой, но с некоторыми отличиями. Агрегация позволяет использовать тот
класс который мы включаем в другой класс и ещё в других местах с другими классами. (отношение «часть - целое» между двумя равноправными объектами, Оба объекта могут 
существовать независимо). А композиция это более строгий вариант агригации. При композиции класс, который включается в другой класс без этого класса просто не может 
существовать, и нужен только для его служебных целей.

Пример композиции: В классе Human описан класс Brain, и класс Brain без класса Human никак существовать не может. Мозг инкапсулирован в человека.
class Human {						//Класс человек
public:
	void Think() {					//В человеке есть метод думать. При вызове метода думать у человека, вызывается метод думать у внутреннего класса мозг.   
		brain.Think();				//Делегируем метод думать другому классу.
	}
private:
	class Brain{					//В private секции класа человек есть внутренний класс мозг
	public:
		void Think() {				//У мозга есть метод думать
			cout << "Я думаю!" << endl;
		}
	};
	Brain brain;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Human human;
	human.Think(); //Вызываем метод думать у человека. В классе думать у человека, вызыватся метод думать у внутренего класса мозг.
		
	return 0;
}

Пример Агрегация: Класс Cap описан отдельно от класса Human. В классе Human есть метод посмотреть на кепку. Так же у нас есть отдельный класс Model( типо манекен). У него тоже
есть метод посмотреть на кепку. Класс кепке не зависит от других классов.

class Cap {					//Класс кепка
public:
	string GetColor() {			//Получить цвет кепки.
		return color;
	}
private:
	string color = "red";
};

class Human {					//Класс человек
public:
	void InspectTheCap() {			//Метод посмотреть на кепку.
		cout << "Моя кепка " << cap.GetColor() << " цвета."<< endl;	//Вызов метода класса кепка
	}
private:
	Cap cap;
};

class Model {					//Класс манекен
public:
	
	void InspectTheCap() {			//Метод посмотреть на кепку.
		cout << "Кепка " << cap.GetColor() << " цвета." << endl;	//Вызов метода класса кепка
	}
private:
	Cap cap;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Human human;
	human.InspectTheCap();
		
	return 0;
}


______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________

Наследование в ООП 

Наследование это механизм, когда один объект может наследовать свойства и поведение другого объекта, и использовать их. Так же к методам, которые он унаследовал, 
он может добавить чтото своё. Класс, от которого мы будем унаследовать свойства называется базовым или родительским классом. Класс, который мы унаследовали от этого базового 
класса, называется производным (дочерним, потомок, наследник).
Синатаксис наследования:

class Human { 			//Базовый класс.

};

class Student : public Human{ 	//Класс Student является дочерним от класса Human.

};

Пример наследования:

class Human {
public:
	string name = "Иванов Иван";
};

class Student : public Human{
public:
	string group;
	void Learn() {
		cout << "Я учусь!"<< endl;
	}
};

class ExtramuralStudent : public Student {
public:
	void Learn() {
		cout << "Я бываю в универе реже обычного студента!" << endl;
	}
};

class Professor : public Human {
public:
	string subject;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Student st;
	st.Learn();
	Professor pr;
	ExtramuralStudent extraSt;
	extraSt.Learn();
		
	return 0;
}


______________________________________________________________________________________
Модификаторы доступа при наследовании private public protected

Модификаторы доступа к конкретным полям и методам.

class A {
public:
	string msgOne = "Сообщение один";
private:
	string msgTwo = "Сообщение два";
protected:
	string msgThree = "Сообщение три";
};

class B : public A {
public:
	void PrintMsg() {
		cout << msgOne << endl; //Так как поле msgOne public, мы можем его использовать.
		//cout << msgTwo << endl; //Так как поле msgTwo private, то мы не можем его использовать нигде, кроме того класса где мы его описали.
		cout << msgThree << endl; //Так как поле msgThree protected, класс наследника без проблем к нему обращается, но у нас не получится обратиться к полю через объект класса B.
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	B b;
	b.PrintMsg(); // Метод public, его вызов всегда возможен.
	b.msgOne; // Поле public, его вызов всегда возможен.
	//b.msgTwo; // Поле private, его вызов возможен только в том классе, где мы его описали.
	//b.msgThree; // Поле protected, его вызов может быть только в классе, где его описали, и в унаследованных от него классах.
		
	return 0;
}


Модификаторы доступа при наследовании.
Свойства модификаторов доступа для полей и методов, которые были в родительском классе и были унаследованы в дочерний класс с модификатором наследования public никак не 
меняются.
Если же модификатор доступа дочернего класса будет private, то все поля, которые мы унаследовали от родительского класса, поменяют свой модификатор доступа на private.
Если же модификатор доступа дочернего класса будет protected, то этот модификатор повлияет только на public поля. Они станут protected.

			Исходный модификатор доступа
-------------------------------------------------------------------- 		
	     	|	       |	 |	     |
		|     public   | private | protected |
  		|	       |	 |	     |
--------------------------------------------------------------------
     		|	       |	 |	     |
     public  	|     public   | private | protected |
   наследование	|	       |	 |	     |
--------------------------------------------------------------------
         	|	       |	 |	     |
     private	|     private  | private | private   |
   наследование	|	       |	 |	     |
--------------------------------------------------------------------
		|	       |	 |	     |
     protected  |    protected | private | protected |
   наследование |	       |	 |	     |
--------------------------------------------------------------------


______________________________________________________________________________________
Порядок вызова конструкторов при наследовании

Пример: Класс А родительский. Класс B является наследником класса А. Класс С является наследником класса В. 

	/-------------------------------\
	|/------------------------\	|
	||/------------------\	  |	|
	|||		     |	  |	|
	|||	Класс A	     |	  |	|
	|||		     |	  |	|
	|||		     |	  |	|
	||\------------------/	  |	|
	||			  |	|
	||	    Класс B	  |	|
	|\------------------------/	|
	|				|
	|		  Класс C	|	
	\-------------------------------/


class A {
public:
	A() {
		cout << "Конструктор вызвался класса A!" << endl;
	}
};

class B : public A {
public:
	B() {
		cout << "Конструктор вызвался класса B!" << endl;
	}
};

class C : public B {
public:
	C() {
		cout << "Конструктор вызвался класса C!" << endl;
	}
};
int main()
{
	setlocale(LC_ALL, "Russian");
	C c;							//Создаём только объект класса С!
		
	return 0;
}

Вывод в консоли:
Конструктор вызвался класса A!
Конструктор вызвался класса B!
Конструктор вызвался класса C!

При наследовании класс С не может существовать без класса В. Класс В не может существовать без класса А. 
Порядок вызова деструкторов при наследовании:

Конструктор вызвался класса A!
Конструктор вызвался класса B!
Конструктор вызвался класса C!

Деструктор вызвался класса С!
Деструктор вызвался класса B!
Деструктор вызвался класса А!


______________________________________________________________________________________
Вызов конструктора базового класса из конструктора класса-наследника

Как мы выяснили при создании дочернего класса B, сначала создаётся класс А с конструктором по умолчанию. Но если нам нужен конкретный конструктор класса А, нам нужно явно
его указать.

class A {
public:	
	A() {					//1.2) Создаём объект класса A  с конструктором по умолчанию.
		msg = "Пустое сообщение.";
	}
	A(string msg) {				//1.2) Создаём объект класса A  с конкретным конструктором.
		this->msg = msg;
	}
	void PrintMsg() {
		cout << msg << endl;
	}
private:
	string msg;
};

class B : public A {
public:
	B() :A() {				//1.1) Конструктор по умолчанию класса B. Вызываем конструктор по умолчанию класса A. (Явно указываем конструктор класса А).
		cout << "Конструктор вызвался класса B!" << endl;
	}
	B(string str):A(str) {			//2.1) Вызываем конкретный конструктор класса A. (Явно указываем конструктор класса А).
		cout << "Конструктор вызвался класса B!" << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	B b1;					//1) Создание класса B с конструктором по умолчанию
	b1.PrintMsg();
	B b2("Наша новая строка");		//2) Создание класса B с конкретным конструктором
	b2.PrintMsg();
		
	return 0;
}


______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Виртуальные методы класса (Полиморфизм, virtual, override)

Виртуальные фунцкии это один из способов реализации полиформизма (переопределение методов). С помощью таких функций мы можем описать какой нибудь класс, который будет выполнять 
некоторый код. Далее от этого класса мы можем унаследовать какой то другой класс и определить поведение этого класса, с использованием тех же самых методов, что были и в 
базовом классе, но как то по другому. Т.е. классы буду иметь одни и теже методы, но вести они себя будут по разному.

Ключевое свлово virtual позволяет нам реализовать функцию в базовом класси таким образом, чтобы в классе наследнике переопределить её поведение.
Синтаксис: указываем виртуальную функцию(функцию, которую можно переопределить)

class Gun {
public:
	virtual void Shoot() {			//Виртуальная функция(метод)
		cout << "Выстрел" << endl;
	}
};

//Переопределяем метод Shoot в дочернем классе

class SubmachineGun : public Gun{		//Дочерний класс
public:
	void Shoot() override{			//Переопределение метода 
		cout << "Выстрел" << "Выстрел" << "Выстрел" << endl;
	}
};

class Player {
public:
	void Shoot(Gun *gun) {
		gun->Shoot();
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	Gun gun;
	Gun *weapon = &gun; 		//Указатель на объект базового класса может ссылаться как на объект именно того класса, каким он является (свой собственный тип),
	weapon->Shoot();			//Вызвался метод класса Gun

	SubmachineGun submachineGun;		//Объект унаследованного класса.
	weapon = &submachineGun; 	//либо же на любой другой класс, унаследованный от базового класса.
	weapon->Shoot();			//Вызвался метод класса SubmachineGun
	
	Player player;			//Объект класса player;
	player.Shoot(&gun);		//Объект вызывает фунцкию, которая вызывает функцию shoot переданного в параметре класса. (Дали игроку оружее).
		
	return 0;
}


______________________________________________________________________________________
Абстрактный класс. Чисто виртуальная функция.

Чисто виртуальные функции, означает что эта функция пустая. В такой функции не написана реализация. Такой класс в котором присутствует чисто виртуальная функции является
абстрактным. Экземпляры абстрактного класса компилятор не позволяет создавать. В абстрактном классе могут быть и не виртуальные методы.

class Weapon {			  		//Абстрактный класс.
public:
	virtual void Shoot() = 0; 		//Чисто виртуальная функция (Полностью абстрактный метод).
};

class Gun : public Weapon{	  		//Класс пистолет потомок класса оружие
public:
	virtual void Shoot() override{		//Переопределение виртуального метода Shoot
		cout << "Выстрел" << endl;
	}
};

class SubmachineGun : public Gun {		//Класс пистолет-пулемёт потомок класса оружие
public:
	void Shoot() override{ 			//Переопределение виртуального метода Shoot
		cout << "Выстрел" << " Выстрел" << " Выстрел" << endl;
	}
};

class Bazooka : public Weapon {			//Класс Базука потомок класса оружие
public:
	void Shoot() override {			//Переопределение виртуального метода Shoot
		cout << "Взрыв" << endl;
	}
};

class Knife : public Weapon {			//Класс нож потомок класса оружие
public:
	void Shoot() override {			//Переопределение виртуального метода Shoot
		cout << "Взмах ножом" << endl;
	}
};

class Player {					//Отдельный класс игрок
public:
	void Shoot(Weapon *weapon) {		//Эта функция вызывает функцию Shoot для объекта(оружия), заданного в параметре. В параметре у нас стоит тип базового класса,
		weapon->Shoot();		//но указатель класса может ссылаться на все унаследованные классы. Поэтому здесь вызовется метод класса, который будет 
	}					//указан в параметре.
};

int main()
{
	setlocale(LC_ALL, "Russian");

	Player player;
	Knife knife;
	player.Shoot(&knife);			//Вызов функции Shoot для объекта player с параметром knife.
		
	return 0;
}


______________________________________________________________________________________
Виртуальный деструктор класса 

Основная цель виртуального деструктора - обеспечить корректное уничтожение объектов производного класса при удалении через указатель на базовый класс. Когда объект удаляется через 
указатель на базовый класс, без виртуального деструктора в этом базовом классе, вызывается деструктор только базового класса. Это означает, что любые ресурсы, выделенные производным
классом, не будут освобождены, что приведёт к утечке памяти или другим проблемам с ресурсами. Виртуальный деструктор гарантирует, что при удалении объекта через указатель на базовый
класс сначала вызовется деструктор производного класса, а затем деструкторы всех базовых классов по цепочке наследования. Это обеспечивает полную и корректную очистку объекта.

Если не переопределять деструктор базового класса, можно столкнуться с утечкой памяти:

class A {
public:
	A(){
		cout << "Выделена динамическая память, объект класса А" << endl;
	}
	virtual ~A() {									//Если убрать virtual от сюда и override в деструкоре класса B, будет утечка памяти.
		cout << "Освобождена динамическая память, объект класса А" << endl;
	}
};

class B : public A{
public:
	B() {
		cout << "Выделена динамическая память, объект класса B" << endl;
	}
	~B() override {
		cout << "Освобождена динамическая память, объеыкт класса B" << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	A *bptr = new B;//В указатель типа базового класса присвоили ссылку типа класса наследника. Если в деструкторе класса А нет ключевого слова virtual, то здесь будет 
			//происходит утечка памяти в объекте B. В таком случае деструктор базового класса не будет виртуальным. Поэтому в момент использования ключевого слова 
	delete bptr;	//delete, компилятор видит что указатель у нас типа A, он и вызвал деструктор только объекта A. Чтобы этого не происходило, нужно для деструктора 
			//объекта А использовать слово virtual.
	return 0;
}

Благодаря тому, что у нас есть виртуальный деструктор в базовом классе, у нас вызывается и переопределённый деструктор класса наследника и деструктор базового класса, 
т.о. мы не получим утечку памяти.

Виртуальный деструктор необходим, если: 
1) Вы работаете с наследованием и объектами базового класса м.б. расширены в производных классах
2) Вы удаляете объекты через указатель на базовый класс.

Не добавляйте виртуальный деструктор в классы, которые не предназначены для наследования или где нет динамического выделения памяти.

Виртуального конструктора в языке С++ не существует

______________________________________________________________________________________
Чисто виртуальный деструктор

Чисто виртуальный деструктор похож по своей сути на чисто виртуальные функции. Такой класс в котором присутствует чисто виртуальный деструктор является
абстрактным. Экземпляры абстрактного класса компилятор не позволяет создавать. (ХЗ за чем он хаха)

В момент очистки стека от объектов, вызовется деструктор класс В, затем деструктор класса А. Но поскольку деструктор класса А чисто виртуальный, то там ничего нет, поэтому 
будет ошибка(компилятор не сможет его вызвать). Чтобы решить эту проблему, нам нужно вынести определение этого деструктора вне класса (в деструкторе ничего не должно быть
написано).


class A {
public:
	A(){
		
	}
	virtual ~A() = 0; //Чисто виртуальный деструктор.
};
A::~A() {}; //Выносим определение виртуального деструктора вне класса.

class B : public A{
public:
	B() {
		
	}
	~B() override {
		
	}
};


______________________________________________________________________________________
Делегирующие конструкторы

Это синтаксическаий сахар. Допустим у нас есть класс Человек с полями имя, возраст и вес. При создании объекта этого класса нам нужно инициализировать все эти поля. Что если
нам нужно реализовать логику работы этого класса таким образом, чтобы мы могли создавать экземпляр, при этом инициализировав лишь некоторые из полей. А так же должен быть 
конструктор который инициализирует все поля. Мы можем описать много разных конструкторов для решения этой задачи, но тогда их будет тяжело и долго править. Для того чтобы 
этого избежать можно использовать делегирующие конструкторы.

class Human {
public:
	Human() {							//Конструктор по умолчанию. Все параметры неизвестны.
		this->Name = "NULL";
		this->Age = 0;
		this->Weight = 0;
	}
	Human(string Name) : Human() {					//Конструктор, в котором инициализируется только имя
		this->Name = Name;
	}
	Human(string Name, int Age) : Human(Name) {			//Конструктор, в котором инициализируется только возраст
		this->Age = Age;
	}
	Human(string Name, int Age, int Weight) : Human(Name, Age) { 	//Конструктор, в котором инициализируется только вес
		this->Weight = Weight;
	}
	string Name;
	int Age;
	int Weight;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Human human1;
	Human human2("Дима");
	Human human3("Дима", 23);
	Human human4("Дима", 23, 78);					
}

В коментах:
Так же кину код, которые решает задачу из видео намного проще(функции с параметрами по умолчанию):

Human(string name, int age = 0, int weight = 0)
    {
      this->name = name;
      this->age = age;
      this->weight = weight;
    }


______________________________________________________________________________________
Вызов виртуального метода базового класса

Как вызвать виртуальный метод базового класса в классе наследнике. Если мы хотим вызвать переопределённый метод базового класса в классе наследнике, более того, в переопределяемом,
методе, нужно явно дать понять компилятору какой мы метод вызываем( в нашем случае метод базового класса:) ::Msg::GetMsg(). Если этого не сделать, метод GetMsg() будет вызывать
сам себя в этом же классе бесконечно.

class Msg {						//Класс хранит сроковое сообщение и возвращает его в методе GetMsg().
public:
	Msg(string msg) {
		this->msg = msg;
	}
	virtual string GetMsg() {
		return msg;
	}
private:
	string msg;
};

class BraketsMsg : public Msg{ 				//Наследник класса Msg. Добавляет сообщению из Msg две квадратные скобки.
public:
	BraketsMsg(string msg) : Msg(msg) {
	}
	string GetMsg() override {			//Переопределение базового вертуального метода.
		return "[" + ::Msg::GetMsg() + "]"; 	// Если не указать явно метод базовго класса, то GetMsg будет вызывать сама себя в классе BraketsMsg бесконечно.
	}
};

class Printer { 					//Выводит в консоль сообщение из класса Msg.
public:
	void Print(Msg *msg) {				//В параметре ссылка на базовый класс, значит по мимо базового можно указывать и наследников.
		cout << msg->GetMsg() << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	Msg m("Привет!");

	Printer p;
	p.Print(&m);

	BraketsMsg b("Привет!");					
	p.Print(&b);

	return 0;
}



______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Множественное наследование

Мы можем унаследовать один класс от нескольких других классов, и в таком случае класс наследник получит характеристики и возможности поведения всех своих классов предков.

class Car {						//Класс машина
public:
	void Drive() {
		cout << "Я еду!" << endl;
	}
};

class Airplane {					//Класс самолёт
public:
	void Fly() {
		cout << "Я лечу!" << endl;
	}
};

class FlyingCar : public Car, public Airplane{		//Класс летающая машина. Наследник обоих классов.

};
int main()
{
	setlocale(LC_ALL, "Russian");

	FlyingCar fc;					//Объект такого класса может и летать и ездить.
	fc.Drive();		
	fc.Fly();

	Car *ptrc = &fc;
	Airplane *ptrA = &fc;
	
	return 0;
}


______________________________________________________________________________________
Порядок вызова конструкторов при множественном наследовании

При создания класса наследника со множественным наследованием, создаются все классы предки. Конструкторы классов предков создаются в порядке их описания в наследовании.

class FlyingCar : public Car, public Airplane{
public:
	FlyingCar()
	{
		cout << "Конструктора FlyingCar вызван" << endl; //Для быстрого описания конструктора по умолчанию, пишем ctor и нажимаем tab.
	}
};

Сначалы вызовется конструктор Car, затем Airplane, затем FlyingCar.


______________________________________________________________________________________
Порядок вызова деструкторов при множественном наследовании

Как обычно, в обратном порядке.


______________________________________________________________________________________
Одинаковые методы в множественном наследовании

Что если у двух базовых классов есть метод, который одинаково называется? 

class Car {
public:
	void Use() {
		cout << "Я еду!" << endl;
	}
};

class Airplane {
public:
	void Use() {
		cout << "Я лечу!" << endl;
	}
};

class FlyingCar : public Car, public Airplane{
public:
};
int main()
{
	setlocale(LC_ALL, "Russian");

	FlyingCar fc;
	((Car)fc).Use(); //Вызываем метод класса Car (Приведение в стиле С).
	fc.Car::Use();	 //И через оператор разрешения области видимости
	
	return 0;
}


______________________________________________________________________________________
Что такое интерфейс в ООП

Один раз, человек научившись кататься на велосипеде, никогда не забудет как это делать, даже если поедет на другом типе велосипеда, потому что он уже освоил навык езды на 
велике. То есть человек освоил интерфейс управления велосипеда.
Интерфейс это фактически методы с модификатором public, с помощью которых мы можем взаимодействовать с какой то сущностью. Интерфекс это некая договорённость, о том, как 
можно с чем то взаимодействовать. Интерфейс это чисто абстрактный класс, в котором все методы чисто виртуальны.


class IBicycle { 							//Наш интерфейс
public:
	void virtual TwistTheWheel() = 0;				//Виртуальные методы всех велосипедов
	void virtual Ride() = 0;
};

class SimpleBicycle : public IBicycle{ 					//Принято говорить что мы не наследуем, а реализовываем интерфейс.(Обычный велик).
public:
	void TwistTheWheel() override {					//Переопределяем методы базового класса под спортивный велик.
		cout << "метод TwistTheWheel() SimpleBicycle" << endl;
	}
	void Ride() override {						//Переопределяем методы базового класса под спортивный велик.
		cout << "метод Ride() SimpleBicycle" << endl;
	}
};

class SportBicycle : public IBicycle { 					//Реализовываем интерфейс спортивного велика.
public:
	void TwistTheWheel() override {					//Переопределяем методы базового класса под спортивный велик.
		cout << "метод TwistTheWheel() SportBicycle" << endl;
	}
	void Ride() override {						//Переопределяем методы базового класса под спортивный велик.
		cout << "метод Ride() SportBicycle" << endl;
	}
};

class Human {
public:
	void RideOn(IBicycle & bicycle) { 				//В параметре принимаем ссылку на любой объект, который реализует интерфейс IBicycle. 
		cout << "Крутим руль" << endl;
		bicycle.TwistTheWheel();				//Вызываем метод TwistTheWheel() класса, который был передан в параметре.
		cout << endl << "Поехали" << endl;
		bicycle.Ride();						//Вызываем метод Ride() класса, который был передан в параметре.
		cout << endl;
	}
};
int main()
{
	setlocale(LC_ALL, "Russian");
	SimpleBicycle sb;
	SportBicycle sportB;

	
	Human h;
	h.RideOn(sb);							//Вызываем метод RideOn класса Human с параметром sp (обычный велик).
	h.RideOn(sportB);						
	
	
	return 0;
}

Т.е. человеку не важно на обычном или спортивном велике он поедет, если их реализация одинаковая.


______________________________________________________________________________________
Виртуальное наследование. Ромбовидное наследование.


class Component {							//Базовый класс.
public:
	Component(string companyName) {		
		cout << "конструктор Component " << endl;
		this->companyName = companyName;
	}
	string companyName;						//Производитель компонента
};
class GPU : public Component {						//Класс GPU унаследован от класса Component
public:
	GPU(string companyName) : Component(companyName) {
		cout << "конструктор GPU " << endl;
	}
};	
class Memory : public Component {					//Класс Memory унаследован от класса Component
public:
	Memory(string companyName) : Component(companyName) {
		cout << "конструктор Memory " << endl;
	}
};
class GraphicCard : public GPU, public Memory {				//Класс GraphicCard унаследован от двух классов: GPU и Memory
public:
	GraphicCard(string GPUcompanyName, string MemorycompanyName) : GPU(GPUcompanyName), Memory(MemorycompanyName) { //В данном случае Для вызова предков нужно передать
		cout << "конструктор GraphicCard " << endl;								//параметры, которые мы получили при создании текущего					
	}														//класса.
};
int main()
{
	setlocale(LC_ALL, "Russian");
	GraphicCard gc("AMD", "Sumsung");				//Создаём объект класса GraphicCard. Передаём в параметрах двух производителей.
	
	return 0;
}

Мы создаём объект класса GraphicCard, передаём в него параметры двух производителей (GPU видюхи и её Memory). Класс GraphicCard унаследован от двух классов: GPU и Memory. Для 
его создания, нужно создать все классы предков. В классе GPU тоже есть предок - класс Component, создаём его. И в классе Memory предком тоже является класс Component. Он тоже
создаётся. Вывод в консоль:

конструктор Component 
конструктор GPU
конструктор Component
конструктор Memory
конструктор GraphicCard

Общая картина: В классе GraphicCard содержутся два класса GPU и Memory, которые оба содержут по классу Component. (Самый базовый класс Component включается в наш класс 
GraphicCard два раза). 

	/-------------------------------------------------------\
	|/------------------------\  /------------------------\ |
	||  /------------------\  |  |	/------------------\  | |
	||  |		       |  |  |	|		   |  | |
	||  |  Класс Component |  |  |	|  Класс Component |  | |
	||  |		       |  |  |	|	           |  | |
	||  |		       |  |  |	|		   |  | |
	||  \------------------/  |  |  \------------------/  | |
	||			  |  |			      | |
	||	   Класс GPU	  |  |	   Класс Memory	      |	|
	|\------------------------/  \------------------------/	|
	|							|
	|		  Класс GraphicCard			|	
	\-------------------------------------------------------/

В текущей схеме наследования это не является проблемой, но в некоторых случаях это будет являтся проблемой.

Таже самая схема, только классы другие. 
Проблема в том, что данные о кол-ве HP у нашего орка война хранятся в двух местах. Нам нужно чтобы каласс Character был в этой структуре всего один раз(а не два). В этом и есть
суть ромбовидного наследования. Для того чтобы класс Orc и класс Warrior ссылались на один и тот же экземпляр класса Character, если они оба присутствуют в классе наследнике,
нам нужно использовать в модификаторах наследования ключевое слово virtual (Пример: class Orc : public virtual Character). 

class Character {						//Класс персонаж
public:
	Character()
	{
		cout << "конструктор Character " << endl;
	}
	int HP;
};
class Orc : public virtual Character {				//Класс Орк
public:
	Orc()
	{
		cout << "конструктор Orc " << endl;
	}
};
class Warrior : public virtual Character {			//Класс Воин
public:
	Warrior()
	{
		cout << "конструктор Warrior " << endl;
	}
};
class OrcWarrior : public Orc, public Warrior {			//Класс ОркВоин
public:
	OrcWarrior()
	{
		cout << "конструктор OrcWarrior " << endl;
	}
};
int main()
{
	setlocale(LC_ALL, "Russian");
	OrcWarrior ow;
	return 0;
}

Общая картина:
			/----------------\
			|		 |
		/----->	| класс Characte | <-----\
		|	|		 |	 |
		|	\----------------/  	 |
		|				 |
	/----------------\           	/----------------\
	|		 |		|		 |
	| класс Orc 	 |		| класс Warrior  |
	|		 |		|		 |
	\----------------/		\----------------/
		^				 ^
		|	/----------------\       |
		|	|		 |       |
		\-----  |класс OrcWarrior|  -----/
			|		 |
			\----------------/


В разных ситуациях нужно применять разный тип наследования.


______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________

Потоковый ввод вывод в файл. Перегрузка оператора << и >>

#include <iostream>
#include <fstream> // Работа с файлами в стиле C++
#include <string> // Работа со строками
#include <Windows.h>//Для русских букв в файле

using namespace std;

class Point {							//Наш класс
public:
    Point()
    {
        x = y = z = 0;
    }
    Point(int x, int y, int z)
    {
        this->x = x;
        this->y = y;
        this->z = z;
    }
    int x, y, z;
};

//Перегрузка операторов << и >>
ostream& operator<<(ostream& os, const Point& point) {     	//Возвращает ссылку на объект ostream
    os << point.x << " " << point.y << " " << point.z;
    return os;
}
istream& operator>>(istream& is, Point& point) {            	//Считывание из файла
    is >> point.x >> point.y >> point.z;
    return is;
}

int main()
{
    setlocale(LC_ALL, "Russian");
    Point p(233, 34, 565);
    //cout << p;

    string path = "myFile.txt";
    fstream fs;
    fs.open(path, fstream::in | fstream::out | fstream::app);
    if (!fs.is_open())
        cout << "Ошибка открытия файла" << endl;
    else {
        cout << "Файл окрты" << endl;
        fs << p << "\n";                                    	//Запись объекта в файл

        while (!fs.eof()) {                                 	//Считывание из файла
            Point p2;
            fs >> p2;
            cout << p << endl;
        }
    }
    fs.close();
    
    return 0;
}


______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________

С++ try catch. Обработка исключений

#include <iostream>
#include <fstream> // Работа с файлами в стиле C++
#include <string> // Работа со строками
#include <Windows.h>//Для русских букв в файле

using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    string path = "myFile.txt";
	ifstream fin;
	fin.exceptions(ifstream::badbit | ifstream::failbit); 	//Включить обработку исключительных ситуаций для ifstream.

	try 							//Пробуем чтото выполнить. Если чтото в этом блоке поломается код в этом блоке дальше выполняться не будет.
	{
		cout << "Попытка открыть файл" << endl;
		fin.open(path);
		cout << "Файл успешно открыт!" << endl;
	}
	catch (const std::exception& ex)			//Если чтото пошло не так, то будет работать следующий блок
	{
		cout << ex.what() << endl;
		cout << "Ошибка открытия файла" << endl;
	}


    return 0;
}


______________________________________________________________________________________
Генерация исключений. throw

throw необходимо использовать в том случае, если в методе нашего класса, либо же какой то логике, состояние данных, которые мы получили, каким то образом не соответствует тому
состояниию, которое мы задумывали для корректной работы нашего класса.

void Foo(int value) { 
	if (value < 0) 						//Например value не может быть меньше нуля
		//throw value;					//бросаем исключение
		throw exception("Число меньше 0");
	cout << "Переменная = " << value << endl;
}
int main()
{
	setlocale(LC_ALL, "Russian");
	
	try {
		Foo(55);
	}
	//catch(const int ex) { 				//То что ловит блок catch должно соответствовать типу данных throw (в нашем случае int)
	catch (const exception &ex) {
		cout << "Мы поймали " << ex.what() << endl;
	};
	
	return 0;
}


______________________________________________________________________________________
Несколько блоков catch

Нужен чтобы поймать разные типы исключений

void Foo(int value) { 
	if (value < 0) 						//Например value не может быть меньше нуля	
		throw "Число меньше 0"; 			//бросаем исключение
	if(value == 0) 						//И нулём тоже не может быть
		throw exception("Число равно 0"); 		//бросаем исключение
	if (value == 1) 					//И 1 тоже нельзя
		throw 1;

	cout << "Переменная = " << value << endl;
}
int main()
{
	setlocale(LC_ALL, "Russian");
	
	try {
		Foo(1);
	}
								//То что ловит блок catch должно соответствовать типу данных throw (в нашем случае int)
	catch (const exception &ex) {
		cout << "Блок 1 Мы поймали " << ex.what() << endl;
	}
	catch (const char *ex) {
		cout << "Блок 2 Мы поймали " << ex << endl;
	}
	catch (...) { 						//Ловим абсолютно всё, что бросил exception. Этот обработчик нужно ставить последним.
		cout << "Что то пошло не так" << endl;
	}
	
	return 0;
}


______________________________________________________________________________________
Свой класс exception

Стандартный exception ограничен по функционалу. При ошибке нет дополнительной информации. Чтобы получать доп. информацию можно создать собственный наследоваемый от стандартного
exception класс.

class MyException : public exception{					//Класс исключения, наследоваемый от стандартного exception
public:
	MyException(const char *msg, int dateState):exception(msg) 	//Для вывода стандартных сообщений 
	{
		this->dateState = dateState;
	}
	int GetDateState() { return dateState; } 			//Метод для получения данных на момент исключения
private:
	int dateState; 							//Состояние информации на момент исключения
};

void Foo(int value) { 
	if (value < 0) 
		throw exception ("Число меньше 0"); 
	if (value == 1) 
		throw MyException("Число = 1", value); 			//Передаём класс исключения при поимке исключения

	cout << "Переменная = " << value << endl;
}
int main()
{
	setlocale(LC_ALL, "Russian");
	
	try {
		Foo(1);
	}
	catch (MyException &ex) {
		cout << "Блок 1 Мы поймали " << ex.what() << endl;
		cout << "Состояние данныx: " << ex.GetDateState() << endl;
	}
	
	return 0;
}


______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________

Перечисляемый тип enum

Это перечисляемый тип который служит для объявления символических имён представляющие целочисленные константы.
Например состояние компьютера (включён или выключен) можно описать типом bool: true - включён, false - выключен. Но что если состояний больше? Например сон или гибернация?
Тогдамы можем закодировать эти состояния в int: 0 - выключен, 1 - включён, 2 - сон, 3 - гибернация. Но тогда нужно постоянно помнить об этой кодировке.
enum решает эту проблему.

class PC {
public:
	enum PCState { 							//Состояния компьютера
		OFF,							// Равно 0
		ON,							// Равно 1
		SLEEP							// Равно 2
		//TEST = 150 						//Можем присваивать свои значения
	};

	PCState GetState() { return State; } //Пишем геттер и сеттер для переменной State
	void SetState(PCState State) { this->State = State; }
private:
	PCState State;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	
	//PCState s;
	//s = PCState::OFF;
	PC pc;
	pc.SetState(PC::PCState::ON); 					//PC:: - класс в котором находится переменная enum. PCState::ON - её значение.

	switch (pc.GetState())
	{
	case PC::PCState::OFF:
		cout << "Выключен" << endl;
	case PC::PCState::ON:
		cout << "Включён" << endl;
	case PC::PCState::SLEEP:
		cout << "Спит" << endl;
	}

	return 0;
}


______________________________________________________________________________________
Пространства имен

Имена объктов могут совпадать, например если над проектом работают более 1 разработчика либо если в процессе подключить чужую библиотеку. Тогда будет ошибка.
Глобальное пространство определяется само.
Ключевое слово using с указанием namespace который мы хотим использовать, позволяет нам использовать все функции, все классы, всё что лежит в этом пространстве имён, без
явного указания пространства имён: 
С using namespace std; мы можем написать просто cout << << endl;
Без придётся явно указать пространство имён: std::cout << << endl; 	


//глобальное пространство имён определяется само.

using namespace std; 					//В namespace std лежат все стандартные с++ классы, функции, и т.д.								

namespace firstNS { 					//Первое пространство имён
	void Foo() {
		cout << "Foo firstNS" << endl;
	}
}
namespace secondNS { 					//Второе пространство имён
	void Foo() {
		cout << "Foo secondNS" << endl;
	}
}

int main()
{
	setlocale(LC_ALL, "Russian");

	firstNS::Foo(); 				//Вызов функции Foo из первого пространства имён (Явно указали)
	secondNS::Foo(); 				//Вызов функции Foo из второго пространства имён (Явно указали)

	return 0;
}



Так же в пространстве имён могут быть ещё пространства имён:

namespace thirdNS {
	void Foo() {					//И тут Foo
		cout << "Foo thirdNS" << endl;
	}

	namespace secondNS {				//И тут Foo
		void Foo() {
			cout << "Foo secondNS" << endl;
		}
	}	
}

int main()
{
	setlocale(LC_ALL, "Russian");
	thirdNS::secondNS::Foo();			//Но компилятор не ругается ведь пространства имён разные.
	thirdNS::Foo();

	return 0;
}


______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Шаблоны классов

Шаблоны классов нужны когда мы хотим чтобы наш класс работал с разными типами данных, и нам не нужно было бы для каждого типа данных писать свою реализацию. Такие классы называют
обобщёнными классами.

template - это шаблон. typename - говорит что у нас здесь будут использоваться обобщённые типы данных. T - название обобщённого типа данных.

template<typename T> 
class MyClass{

};


Реализация:

template<typename T>
class MyClass {
public:
	MyClass(T value)
	{
		this->value = value;
	}
	void DataTypeSize() { // Узнаём сколько весит в байтах наша переменная типа T
		cout << sizeof(value) << endl;
	}
private:
	T value;
};

int main()
{
	setlocale(LC_ALL, "Russian");
	int a = 5;
	double b = 5.3423;

	MyClass<int> c1(a); //Указываем с каким типом данных будет работать наш класс.
	c1.DataTypeSize();

	MyClass<double> c2(b);
	c2.DataTypeSize();
	return 0;
}



С двумя обобщёнными переменнами:

class Point {
public:
	Point()
	{
		x = y = z = 0;
	}
	Point(int x, int y, int z) {
		this->x = x;
		this->y = y;
		this->z = z;
	}
	int x, y, z;
};

template<typename T1, typename T2>
class MyClass {
public:
	MyClass(T1 value, T2 value2)
	{
		this->value = value;
		this->value2 = value2;
	}
	void DataTypeSize() { // Узнаём сколько весит в байтах наша переменная типа T
		cout << "value " << sizeof(value) << endl;
		cout << "value2 " << sizeof(value2) << endl;
	}
private:
	T1 value;
	T2 value2;
};
int main()
{
	setlocale(LC_ALL, "Russian");

	int a = 5;
	Point p;
	MyClass<int, Point> c(a, p);
	c.DataTypeSize();

	return 0;
}


______________________________________________________________________________________
Наследование шаблонных классов

class Point {
public:
	Point()
	{
		x = y = z = 0;
	}
	Point(int x, int y, int z) {
		this->x = x;
		this->y = y;
		this->z = z;
	}
	int x, y, z;
};

template<typename T1>									//Основной класс
class TypeSize {
public:
	TypeSize(T1 value)
	{
		this->value = value;
	}
	void DataTypeSize() { 								// Узнаём сколько весит в байтах наша переменная типа T
		cout << "value " << sizeof(value) << endl;
	}
protected:
	T1 value;
};

template<typename T1>
class TypeInfo : public TypeSize<T1> { 							//Наследник TypeSize с обобщённым типом T1
public:
	TypeInfo(T1 value):TypeSize<T1>(value) 						//Вызов конструктора базового класса
	{

	}
	void ShowTypeName() {
		cout << "Название типа: " << typeid(this->value).name() << endl; 	//Вывод имени типа объекта в параметре
	}
};
int main()
{
	setlocale(LC_ALL, "Russian");

	int a = 5;
	TypeInfo<int> c(a);
	c.ShowTypeName();
	c.DataTypeSize();

	Point b;
	TypeInfo<Point> d(b);
	d.ShowTypeName();
	d.DataTypeSize();

	return 0;
}


______________________________________________________________________________________
Специализация шаблона класса

Нужна для того, если мы захотим чтобы наш класс работал как то по особенному с определённым типом данных при шаблонах класса.

template<typename T>
class Printer {
public:
	void Print(T value){
		cout << value << endl;
	}
};

template<>						//Специализация определённого типа
class Printer<string> {					//Тип string в шаблоне обрабатывается по особенному.
public:
	void Print(string value) {
		cout << "___" << value << "___" << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	int a = 5;
	string b = "123";

	Printer<int> p1;
	p1.Print(a);

	Printer<string> p2;
	p2.Print(b);

	return 0;
}


______________________________________________________________________________________
Структуры

Структура очень похожа на класс. В отличии от класса, у структуры по умолчанию все поля и методы являются public. При наследовании классов по умолчанию также модификатор 
private, а у структур public. У структур так же есть конструкторы и деструкторы.

class MyClass {					//Класс
	int a = 10;
	void Print() { cout << a << endl; }
};

struct MyStruct {				//Структура
	int a = 22;
	void Print() { cout << a << endl; }
};

int main()
{
	setlocale(LC_ALL, "Russian");
	MyClass m;
	MyStruct s;

	//m.a = 10;	 			//Не работает потому что private по умолчанию.
	//m.Print(); 				//Не работает потому что private по умолчанию.
	s.a = 23;				//Работает, потому что по умолчанию public
	s.Print();				//Работает, потому что по умолчанию public

	return 0;
}




______________________________________________________________________________________
Умные указатели

Указатели обычно нужны для выделения дополнительной динамической памяти. После выделения памяти программист должен позаботиться об её очистке, чтобы не было утечек. 
Если мы используем умный указатель, нам не нужно будет следить за тем, чтобы освобождать память самостоятельно, это произойдёт автоматически.
Умный указатель это объектная оболочка для каких то типов данных. Раз это объектная оболочка, значит это тоже класс. Он должен работать с любыми типами данных, поэтому при 
написании умного указателя мы будем использовать шаблоны классов.

Когда мы будем создавать объект класса, мы должны будем передать какой то указатель, на какую то область данных, где храняться наши данные. Пока класс жив, у нас будет 
переменная, которая указывает на эту область. В момент когда объект класса будет уничтожаться, у него вызовется деструктор, в котором будет очищена динамически выделенная память.

Для получения данных указаетля на уровне объекта класса умного указателя, нужно перегрузить оператор *.

template<typename T>
class SmartPointer {					//Класс умный указатель.
public:
	SmartPointer(T *ptr) 				//Получаем указатель на какой то объект, память под который мы выделили.
	{
		this->ptr = ptr; 			//сохраняем адрес в памяти на который указывает указатель.
		cout << "Constructor" << endl;
	}
	~SmartPointer() 				//При уничтожении объекта класса вызывается деструктор 
	{
		delete ptr; 				//Память должна очищаться
		cout << "Destructor" << endl;
	}
	T& operator*() { 				//Перегрузка оператора * для получения данных по указателю. Получаем ссылку на данные, чтобы не получить новую копию.
		return *ptr;
	}
private:
	T *ptr;						//Указатель который указывает на любой тип данных.
};

int main()
{
	setlocale(LC_ALL, "Russian");
	
	int *ptr = new int(5); 				//Обычный указатель. Для сравнения.
	cout << ptr << endl; 				//Получим адресс в памяти
	cout << *ptr << endl; 				//Для получения данных (значения), а не адресса, указатель нужно разименовать.
	delete ptr;					//Удаление обычного указателя.

	//Неявное преобразование типов через конструктор.
	SmartPointer<int> pointer = new int(5); 	//Создание умного указателя. Оператор new возвращает адрес данных в памяти (В нашем случае типа int). 
	cout << *pointer << endl; 			//Получение данных по указателю (Перегрузка).
	*pointer = 77; 					//Присваиваем новые данные.
	cout << *pointer << endl; 			//Получение данных по указателю (Перегрузка).

	return 0;
}


В нашем случае, когда мы выйдем из области видимости функции main, вызовется деструктор класса, и очистится динамически выделенная память.



______________________________________________________________________________________
Типы умных указателей auto_ptr | unique_ptr | shared_ptr

#include <memory> //Библиотека для типов умных указателей. 

Если у нас есть два указателя, которые ссылаются на одну и туже область памяти, то при вызове деструктора первого объекта динамические данные удалятся, а при вызове деструктора 
второго объекта вызовется ошибка очистки уже учищенной памяти. (Уже встречали эту проблему выше в темах Конструктор копирования и Перегрузка операторов (Присваивания)).

SmartPointer<int> sp1 = new int(5); //Создание умного указателя. 	
SmartPointer<int> sp2 = sp1; //sp2 ссылается на sp1. При вызове деструктора sp2 будет ошибка.

Умные указатели решают эту проблему.

auto_ptr устаревший указатель, похожий на unique_ptr.

//auto_ptr<int> ap1 = new int(5);	//Такая запись не работает
auto_ptr<int> ap1(new int(5));		//Присваиваем умному указателю ap1 значение 5 типа int.
auto_ptr<int> ap2(ap1);			//При присваивании ap2 указателя ap1, ap1 автоматически теряет связь с данными(его указатель затирается) и работать с данными теперь 
					//может только указатель ap2. 

Ошибки больше нет, но это не решение проблемы.

На смену auto_pt пришёл unique_ptr (unique - уникальный). В нём запретили такую ситуацию, когда два указателя могут ссылаться на одну и ту же область памяти.

unique_ptr<int> up1(new int(5));
//unique_ptr<int> up2(up1);		//Радикальное решение. Мы просто не можем передать один указатель другому.

unique_ptr<int> up2;
up2 = move(up1);			//Для смены владельца данных. Тепрь up2 указывает на область в памяти а up1 пустой.
up1.swap(up2);				//Аналог функции move. Меняем владельца обратно.

int *p = up1.get(); 			//Возвращает указатель в его сыром(чистом) виде. Вытенем из up1 обычный стандартный указатель примиивного вида.
					//Из умного в стандартный указатель. В auto_ptr тоже есть.

int *p2 = new int(5);
unique_ptr<int> up3(p2);
up3.reset(); 				//Затирает данные на который указывает указатель и затем up3 стал пустым
	
int *p3 = new int(5);
unique_ptr<int> up4(p3);
up4.release(); 				//Данные остаются в памяти, но указатель о них забывает.


Самый полезный указатель shared_ptr (shared - общий). Указатели shared_ptr могут ссылаться на одни и теже данные. Когда объекты shared_ptr начнут уничтожаться, при выходе их из
зоны видимости, ошибки не возникнет, потому что данные будут уничтожены только в тот момент, когда будет уничтожен самый последний shared_ptr, который ссылается на эти данные.
Это работает так, когда мы создаём какой то один указатель типа shared_ptr и где то в динамической памяти выделяем место, присваиваем туда данные, в классе shared_ptr начинает
работать счётчик ссылок. Каждый раз, когда добавляется новый объект типа shared_ptr, который указывает на теже самые данные, счётчик увеличивает своё значение. Чтобы одни и теже
данные не затирались несколько раз, в деструкторе класса shared_ptr есть проверка, которая смотрит сколько ссылок осталось на данные. Если количество ссылок больше одной, то 
удаляется только указатель. Если ссылка осталась последней, то очищаются и данные и ссылка.

shared_ptr<int> sp1(new int(5));
shared_ptr<int> sp2(sp1);



______________________________________________________________________________________
Динамический массив и умные указатели

Об освобождении динамической памяти заботится shared_ptr. Для массива <int[]> не забыть указать квадратные скобки.
int size = 5;
int *arr = new int[size]{ 1, 6, 44, 9, 8 };
shared_ptr<int[]> ptr(arr); 					//Массив динамической памяти
//shared_ptr<int[]> sp1(new int[size]{ 1, 6, 44, 9, 8 }); 	//Тоже самое

for (int i = 0; i < size; i++)
{
	cout << ptr[i] << endl;
}

А чтобы создать двумерный массив надо так:

const int size = 5;
shared_ptr<int[][size]> ptr(new int[size][size]);

















