
______________________________________________________________________________________
Этапы компиляции C++

https://habr.com/ru/articles/478124/
http://knzsoft.ru/cpp-bgr-ls1/ - ТУТ более подробно.

В данной статье я хочу рассказать о том, как происходит компиляция программ, написанных на языке C++, и описать каждый этап компиляции.

Состав компилятора g++:
cpp — препроцессор
as — ассемблер
g++ — сам компилятор
ld — линкер

Исходный C++ (формата .cpp, например hello.cpp) файл — это всего лишь код, но его невозможно запустить как программу или использовать как библиотеку. Поэтому каждый исходный 
файл требуется скомпилировать в исполняемый файл, динамическую или статическую библиотеки.


Этапы компиляции:

1) Препроцессинг (предобработка) hello.ii
Препроцессор — это макро процессор, который преобразовывает вашу программу для дальнейшего компилирования. На данной стадии происходит происходит работа с препроцессорными 
директивами. Например, препроцессор добавляет хэдеры в код (#include), убирает комментирования, заменяет макросы (#define) их значениями, выбирает нужные куски кода в 
соответствии с условиями #if, #ifdef и #ifndef. На выходе получаем выходной файл с расширением hello.ii (файлы прошедшие через стадию препроцессинга C++ файлы имеют расширение 
.ii). В новом сгенерированном файле также можно увидеть огромное количество новых строк, это различные библиотеки и хэдеры подключаемых библиотек.


2) Компиляция (трансляция) hello.s
На данном шаге g++ выполняет свою главную задачу — компилирует, то есть преобразует полученный на прошлом шаге код без директив в ассемблерный код. Это промежуточный шаг между 
высокоуровневым языком и машинным (бинарным) кодом. Ассемблерный код — это доступное для понимания человеком представление машинного кода. На выходе получаем файл с расширением
hello.s. Мы можем все также посмотреть и прочесть полученный результат. Но для того, чтобы машина поняла наш код, требуется преобразовать его в машинный код, который мы и 
получим на следующем шаге. Компилятор работает с отдельными единицами трансляции. Это означает то, что компилятор как таковой никогда не видит всю картину нашего проекта целиком.

3) Ассемблирование hello.o
Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном файле. Объектный файл — это созданный ассемблером промежуточный файл, хранящий кусок 
машинного кода. Этот кусок машинного кода, который еще не был связан вместе с другими кусками машинного кода в конечную выполняемую программу, называется объектным кодом. 
Выполняется специальной утилитой as, выходной файл обычно имеет расширение .o (и называется объектным файлом). На данном этапе не происходит ничего интересного — просто 
инструкции, которые были в ассемблере, перегоняются в машинный код. Поэтому файлы .o бесполезно смотреть глазами, они бинарные, для этого есть специальные утилиты, например, 
objdump. Далее возможно сохранение данного объектного кода в статические библиотеки для того, чтобы не компилировать данный код снова. Но на данном шаге еще ничего не закончено,
ведь объектных файлов может быть много и нужно их всех соединить в единый исполняемый файл с помощью компоновщика (линкера). Поэтому мы переходим к следующей стадии.

4) Линковка (Компоновка) 
Компоновщик (линкер) связывает все объектные файлы и статические библиотеки в единый исполняемый файл, который мы и сможем запустить в дальнейшем. Нужна, если файлов несколько: 
мы запускаем препроцессор, трансляцию и ассемблирование независимо для каждого файла, а объединяются они только на этапе линковки. Для того, чтобы понять как происходит связка, 
следует рассказать о таблице символов: Таблица символов — это структура данных, создаваемая самим компилятором и хранящаяся в самих объектных файлах. Таблица символов хранит 
имена переменных, функций, классов, объектов и т.д., где каждому идентификатору (символу) соотносится его тип, область видимости. Также таблица символов хранит адреса ссылок на 
данные и процедуры в других объектных файлах. Именно с помощью таблицы символов и хранящихся в них ссылок линкер будет способен в дальнейшем построить связи между данными среди 
множества других объектных файлов и создать единый исполняемый файл из них.



______________________________________________________________________________________
Почему компиляция в C++ такая медленная?

Пример: Когда мы создаём наш проект, то упрощённая схема выглядит так:

foo.h
foo.cpp ----> foo.o ---\
bar.h                   \
bar.cpp ----> bar.o ----/ ====> linker ----> app.exe
main.cpp ---> main.o --/


Компилятор отдельно проходит по foo, отдельно по bar, и отдельно по main. Это и есть основной момент для понимания, почему компиляция в C++ такая медленная. Если мы представим,
что у нас есть проект, который содержит 100 .cpp файлов, и в каждом из этих .cpp файлов мы подключаем vector(так не нужно делать, это плохо). Получается, что мы создаём 100 единиц 
трансляции, и компилятор вынужден кажую из них отдельно обработать. И того получается, что когда каждая из этих единиц будет развёрнута, то в каждой из них будет скопипащен 
код из vector, и компилятор будет раз за разом все 100 раз перекомпилировать одно и тоже, поскольку он не может по другому, поэтому компиляция такая медленная.


#################
Пример 2: 
У нас есть файлы main.cpp, Foo.h, и Foo.cpp:

///////////////////
// Файл main.cpp
#include "Foo.h"

int main(int argc, char *argv[]) {
	Foo foo;
	foo.print();
}


// Файл Foo.h
#ifndef FOO_H
#define FOO_H

class Foo {
public: 
	Foo();
	void print();
}

#endif // FOO_H


// Файл Foo.cpp
#include <iostream>
#include "Foo.h"

Foo::Foo() {}

void Foo::print() {
	std::cout << "Hello world" << "\n";
}
///////////////////

Мы подключаем в main.cpp файл Foo.h, для того чтобы в main создать объект класса Foo. При компиляции у нас создастся две единицы трансляции main.cpp и Foo.cpp. Деректива 
препроцессора #include отработает, и у нас и в main.cpp и в Foo.cpp #include "Foo.h" заменится просто на 

class Foo {
public: 
	Foo();
	void print();
}


т.е. заменится на объявление класса Foo. Другими словами мы можем просто взять скопировать это объявление, и сами вместо #include "Foo.h" вставить это объявление, и у нас
всё прекрасно скомпилируется и в консоль выведется Hello world:


///////////////////
// Файл main.cpp
class Foo {
public: 
	Foo();
	void print();
}

int main(int argc, char *argv[]) {
	Foo foo;
	foo.print();
}


// Файл Foo.cpp
#include <iostream>

class Foo {
public: 
	Foo();
	void print();
}

Foo::Foo() {}

void Foo::print() {
	std::cout << "Hello world" << "\n";
}
///////////////////


Что сейчас произошло? Мы имеем main.cpp в котором просто объявлен какой то класс Foo, однако там нет определения (реализации), это просто объявление, однако всё работает. 
Этим определением мы обещаем компилятору, что такой класс существует, и что линковщик потом его свяжет. Т.е. при компиляции main.cpp, у нас просто под foo.print() остаётся 
какая то свободная ячейка, в которую потом линковщик запишет адрес, по которому можно вызвать это метод. У нас сейчас произошла связь линковщика, благодаря которому мы 
соединили несколько независимых частей нашего приложения, поэтому компилятору вообще не нужно знать полной картины нашего проекта, он оперирует только отдельными единицами
трансляции. Однако основной посыл здесь в том, что наш класс Foo был скомпилирован два раза, поскольку у нас имеется две независимые единицы трансляции, и сначала мы 
скомпилировали класс Foo в main.cpp, а затем в foo.cpp, хотя класс один и тот же. 

Справедливости ради, благодаря тому, что компилятор компилирует каждый .cpp файл отдельно, в этом есть и свои преимущества. Когда мы заходим в свой .cpp файл и изменяем там
что-то, не нужно потом пересобирать весь проект, достаточно перекомпилировать только тот .cpp файл, который был изменён. Но это касается только файлов с расширением .cpp, если
мы что-то изменили в файле .h, то придётся перекомпилировать все единицы трансляции, которые включают в себя этот конкретный .h файл, который был изменён.



______________________________________________________________________________________
Что мы можем сделать для ускорения скорости компиляции?

На самом деле есть одно простое правило: Стараемся избегать, на сколько это возможно, объявлять #include в .h файлах. Всё. В .h файлах Вместо #include используйте 
Forward declaration(смотри ниже).

Пример: 
Возьмём предыдущий пример с файлами main.cpp, Foo.h, и Foo.cpp:

///////////////////
// Файл main.cpp
#include "Foo.h"

int main(int argc, char *argv[]) {
	Foo foo;
}


// Файл Foo.h
#ifndef FOO_H
#define FOO_H

class Foo {
public: 
	Foo();
}

#endif // FOO_H


// Файл Foo.cpp
#include "Foo.h"

Foo::Foo() {}

///////////////////


Давайте разберёмся c #include. Почему в Foo.h нежелательно использовать какие либо #include? Представим, что мы хотим в Foo.cpp в определении конструктора класса Foo 
использовать std::vector. Мы можем поступить двумя путями: 1-ый подключить #include <vector> напрямую в сам файл Foo.cpp (в данном случае правильный вариант):

// Файл Foo.cpp
#include "Foo.h"
#include <vector>

Foo::Foo() {
	std::vector<int> vec;
}


а можем сделать 2-ой вариант: подключить #include <vector> в Foo.h (в данном случае неправильный вариант):


///////////////////
// Файл Foo.h
#ifndef FOO_H
#define FOO_H

#include <vector>

class Foo {
public: 
	Foo();
}

#endif // FOO_H


// Файл Foo.cpp
#include "Foo.h"

Foo::Foo() {
	std::vector<int> vec;
}

///////////////////


Если мы поставим #include <vector> в Foo.h файле, у нас произойдёт следующая ситуация: При компиляции единица трансляции Foo.cpp развернёт #include "Foo.h", в котором будет
#include <vector>, который компилятор тоже развернёт, всё это скомпилируется, и мы сможем использовать std::vector из файла Foo.cpp. Это хорошо, ведь нам как раз нужно 
использовать std::vector в Foo.cpp. Однако при этом в main.cpp у нас тоже есть подключение #include "Foo.h", но здесь в main.cpp std::vector мы не используем, а он и здесь
развернётся и скомпилируется, как и в Foo.cpp. Поскольку в main.cpp Foo.h у нас идёт через #include, соответсвтенно у нас в main.cpp развернётся весь Foo.h вместе и с
#include <vector>, и тогда в main.cpp тоже перекомпилируется std::vector, но он нам там не нужен, мы его там не используем, т.е. произойдёт лишняя компиляция std::vector,
соответственно увеличится время сборки проекта. Поэтому в .h файлах нужно стараться как можно меньше использовать #include.



______________________________________________________________________________________
Forward declaration

Добавим к примеру выше ещё один класс: Bar.h и Bar.cpp. Мы хотим в классе Foo иметь экземпляр этого объекта. Для этого в файле Foo.h мы должны объявить (заинклудить) Bar.h:


///////////////////
// Файл Foo.h
#ifndef FOO_H
#define FOO_H

#include "Bar.h"

class Foo {
public: 
	Foo();
private:
	Bar bar;
}

#endif // FOO_H


// Файл main.cpp
#include "Foo.h"

int main(int argc, char *argv[]) {
	Foo foo;
}
///////////////////


Наш main.cpp использует класс Foo, и для этого мы заинклудили #include "Foo.h". Однако теперь main.cpp также будет зависеть и от Bar.h, и постоянно его перекомпилировать, хотя в
main.cpp мы не используем класс Bar. 

Для решения этой проблемы мы можем использовать Forward declaration. Он нам говорит следующее: Если мы используем указатель или ссылку на класс, то нам не обязательно знать, какой
этот класс имеет размер, какие имеет поля и методы, нам сейчас не нужна про этот класс конкретная информация, нам лишь важно сказать компилятору что такой класс существует, и 
что его потом свяжет линковщик. Поэтому мы вместо #include "Bar.h" можем просто прописать объявление класса Bar:


// Файл Foo.h
#ifndef FOO_H
#define FOO_H

// #include "Bar.h" - в данном файле это не нужно

class Bar;	// Это Forward declaration класса Bar

class Foo {
public: 
	Foo();
private:
	Bar* bar;	// Указатель на экземпляр класса Bar, а не простая переменная.
}

#endif // FOO_H


В данной ситуации нашему компилятору этого будет достаточно. А самое главное main.cpp теперь не зависит от "Bar.h" и не будет его постоянно перекомпилировать, поскольку нет 
прямого инклуда #include "Bar.h" в Foo.h. А чтобы использовать весь функционал Bar.h, мы инклудим его в Foo.cpp и спокойно используем указатель bar:


// Файл Foo.cpp
#include "Foo.h"
#include "Bar.h"

Foo:Foo() {
	bar = new Bar();
}

Поскольку в Foo.cpp мы должны использовать класс Bar, значит мы должны знать про него конкретную информацию, а значит пора инклудить "Bar.h", здесь это оправдано, но в Foo.h
он нам не нужен, поэтому там мы его просто объявляем. Такая штука называется Forward declaration, и она очень сильно помогает оптимизировать время компиляции нашего проекта.




_______________________________________________________________________________________________________________________________________________________________________________
Препроцессор это некая программа которая проводит некоторые манипуляции с кодом ещё до компиляции. Предварительная обработка. Он умеет работать с нашими исходными файлами.
#Слово - деректива препроцессора, т.е. это какие-то команды препроцессору.
_______________________________________________________________________________________________________________________________________________________________________________
#include (включить) - подключает в наш код какой нибудь файл. Перед компиляцией код из подключаемого файла перепишется на место этого include, т.е. код просто копипастится на 
место этого #include. И потом весь код подключаемый + наш компилируется. 

_____________________________________________________________________________________________________________
#define (определить) - заменяет указанные символы в коде на другие символы. Можно создавать макроопределения.

Пример:
#define PI 3.14
int main()
{
	cout << PI << endl; //В консоль выведет 3.14


}


||||||||||||||||||||||||||||
Создаём функцию с помощью макроса:
#define FOO(x,y) ((x)*(y))
int main()
{
	cout << FOO(5,6) << endl; //Выведет 30.
}
По сути важно понимать что обычная функция будет вызываться уже в скомпилированной программе и будет происходить передача параметров работа со стеком и пр. А вот такие макросы 
собираются на этапе подготовки к компиляции препроцессором. И фактически это аналогично тому если бы мы руками в коде сделали Ctrl+С Ctrl+V и просто бы меняли параметры в этих 
кусочках т.е. с точки зрения выполнения программы тут вообще нет никаких вызовов функций.


||||||||||||||||||||||||||||
Условная компиляция. Выбираем какой код компилировать а какой нет. (Для отладки).

#define DEBUG//Переменная для отладки. Если переменная оперделена код будет писаться полностью, если закоментируем её, то инфа для отладки выводиться не будет.

int main()
{
	setlocale(LC_ALL, "Russian");
#ifdef DEBUG
	cout <<	"Начало цикла. (для отладки)" << endl;
#endif // DEBUG
	for (int i = 0; i < 4; i++)
		cout << i << endl;
#ifdef DEBUG
	cout << "Конец цикла. (для отладки)" << endl;
#endif 
}

||||||||||||||||||||||||||||
Так же есть и else
#define DEBUG

int main()
{
	setlocale(LC_ALL, "Russian");
#ifdef DEBUG // Если дебаг определён то будет работать эта часть кода
	cout <<	"DEBUG определён" << endl;
#else	// Если нет, то только эта.
	cout << "DEBUG Не определён" << endl;
#endif 
}

||||||||||||||||||||||||||||
Тоже самое только в другую сторону (инверсия).
#define DEBUG

int main()
{
	setlocale(LC_ALL, "Russian");
#ifndef DEBUG // Если дебаг определён то эта часть кода работать не будет (ifndef и ifdef это противоположности)
	cout <<	"1" << endl;
#else
	cout << "2" << endl;
#endif 
}

||||||||||||||||||||||||||||
Деректива со значением
#define DEBUG 5 // DEBUG = 5

int main()
{
	setlocale(LC_ALL, "Russian");
#if DEBUG > 4 //Если DEBUG больше 4 то выведется эта часть кода
	cout <<	"1" << endl;
#elif DEBUG == 2 //Если DEBUG равно 2 то выведется эта часть кода
	cout << "2" << endl;
#else	// Если нет, то выведется эта.
	cout << "2" << endl;
#endif 
}

||||||||||||||||||||||||||||
#pragma once - деректива препроцессора для решения задачи повтороного включения.




























