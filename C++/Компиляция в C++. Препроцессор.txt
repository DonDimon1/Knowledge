Рассмотрим подробно процесс компиляции C++ проектов. 

______________________________________________________________________________________
Этапы компиляции C++

https://habr.com/ru/articles/478124/
http://knzsoft.ru/cpp-bgr-ls1/ - ТУТ более подробно.
https://youtu.be/LqFtG7H53XU?si=37HJGIAINc75KbLj

Состав компилятора g++:
cpp — препроцессор
as — ассемблер
g++ — сам компилятор
ld — линкер


Исходный C++ (формата .cpp, например hello.cpp) файл — это всего лишь код, но его невозможно запустить как программу или использовать как библиотеку. Поэтому каждый исходный файл требуется скомпилировать в исполняемый файл, динамическую 
или статическую библиотеки. Для того чтобы наш исходный код, который написан в текстовом файле, превратился в исполняемое приложение, компилятор должен пройти четыре этапа.


Этапы компиляции:

1) Препроцессинг (предобработка) hello.i
Препроцессор — это макро процессор, который преобразовывает вашу программу для дальнейшего компилирования. На данной стадии происходит происходит работа с препроцессорными 
директивами (см. ниже). Например, препроцессор добавляет хэдеры в код (#include), убирает комментирования, заменяет макросы (#define) их значениями, выбирает нужные куски кода в 
соответствии с условиями #if, #ifdef и #ifndef. На выходе получаем выходной файл с расширением hello.i (файлы прошедшие через стадию препроцессинга C++ файлы имеют расширение 
.i). В новом сгенерированном файле также можно увидеть огромное количество новых строк, это различные библиотеки и хэдеры подключаемых библиотек.


2) Компиляция (трансляция) hello.s
На данном шаге g++ выполняет свою главную задачу — компилирует, то есть преобразует полученный на прошлом шаге код без директив в ассемблерный код. Это промежуточный шаг между 
высокоуровневым языком и машинным (бинарным) кодом. Ассемблерный код — это доступное для понимания человеком представление машинного кода. На выходе получаем файл с расширением
hello.s. Мы можем все также посмотреть и прочесть полученный результат. Но для того, чтобы машина поняла наш код, требуется преобразовать его в машинный код, который мы и 
получим на следующем шаге. Компилятор работает с отдельными единицами трансляции. Это означает то, что компилятор как таковой никогда не видит всю картину нашего проекта целиком.

3) Ассемблирование hello.o
Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном файле. Объектный файл — это созданный ассемблером промежуточный файл, хранящий кусок 
машинного кода. Этот кусок машинного кода, который еще не был связан вместе с другими кусками машинного кода в конечную выполняемую программу, называется объектным кодом. 
Выполняется специальной утилитой as, выходной файл обычно имеет расширение .o (и называется объектным файлом). На данном этапе не происходит ничего интересного — просто 
инструкции, которые были в ассемблере, перегоняются в машинный код. Поэтому файлы .o бесполезно смотреть глазами, они бинарные, для этого есть специальные утилиты, например, 
objdump. Далее возможно сохранение данного объектного кода в статические библиотеки для того, чтобы не компилировать данный код снова. Но на данном шаге еще ничего не закончено,
ведь объектных файлов может быть много и нужно их всех соединить в единый исполняемый файл с помощью компоновщика (линкера). Поэтому мы переходим к следующей стадии.

4) Линковка (Компоновка) 
Компоновщик (линкер) связывает все объектные файлы и статические библиотеки в единый исполняемый файл, который мы и сможем запустить в дальнейшем. Нужна, если файлов несколько: 
мы запускаем препроцессор, трансляцию и ассемблирование независимо для каждого файла, а объединяются они только на этапе линковки. Для того, чтобы понять как происходит связка, 
следует рассказать о таблице символов: Таблица символов — это структура данных, создаваемая самим компилятором и хранящаяся в самих объектных файлах. Таблица символов хранит 
имена переменных, функций, классов, объектов и т.д., где каждому идентификатору (символу) соотносится его тип, область видимости. Также таблица символов хранит адреса ссылок на 
данные и процедуры в других объектных файлах. Именно с помощью таблицы символов и хранящихся в них ссылок линкер будет способен в дальнейшем построить связи между данными среди 
множества других объектных файлов и создать единый исполняемый файл из них.


__________________________________________________________________________________
Единица трансляции (Translation units)

Если мы возьмём файл main.cpp где будет код, комментарии, директивы препроцессора и т.д, и если мы попробуем пропустить этап препроцессинга и сразу передать всё это в компилятор, то компилятор не сможет понять, что там написано.
Поэтому наш файл main.cpp не является самодостаточным для того чтобы считаться единицой трансляции, потому что он не может быть передан компилятору на компиляцию. И только после препроцессинга, появится файл, который будет
самодостаточным для того, чтобы пойти на этап компиляции. Соответственно единицей трансляции считается такой .cpp файл, который прошёл этап препроцессинга. 

А почему это называется единицей трансляции?
Так сложилось исторически. Трансляция это перевод с одного языка на другой. Любая программа, которая умеет переводить с одного языка на другой называется транслятор. Наш компилятор переводит с языка C++ на язык ассемблера, 
т.е. компилятор является частным случаем транслятора, поэтому он работает с единицами трансляции. Компилятор работает с каждой из единиц трансляции отдельно.




__________________________________________________________________________________
################################################################
__________________________________________________________________________________
Препроцессинг

Препроцессор это некая подпрограмма внутри компилятора, которая проводит некоторые манипуляции с кодом ещё до компиляции. Предварительная обработка. Он умеет работать с нашими исходными файлами.
#Слово - директива препроцессора, т.е. это какие-то команды препроцессору.

Препроцессор работает с каждым файлом отдельно, это важно.
_______________________________________________________________________________________________________________________________________________________________________________
#include (включить) - подключает в наш код какой нибудь файл. Но на самом деле это просто рекурсивный копипаст. Перед компиляцией код из подключаемого файла перепишется на место этого include, т.е. код просто копипастится на 
место этого #include. И потом весь код подключаемый + наш компилируется. 

Например у нас есть такой код:
#include <iostream>

int main () {
	std::cout << "Hello world" << std::endl;
}

Когда препроцессор видит директиву #include, то в нашем случае он берёт файл iostream и копирует всё что там находится в наш файл main.cpp. Однако он это делает рекурсивно, потому что в файле iostream тоже могут быть другие #include.


_____________________________________________________________________________________________________________
#define (определить) - заменяет указанные символы в коде на другие символы. Можно создавать макроопределения.

Пример:
#define PI 3.14
int main()
{
	cout << PI << endl; //В консоль выведет 3.14


}

Здесь используя директиву #define, мы объявили макрос PI, т.е. другими словами мы сказали препроцессору, чтобы когда он начал выполняться, он заменил все вхождения PI на 3.14. На самом деле это очень опасно (см. ниже).



||||||||||||||||||||||||||||
Создаём функцию с помощью макроса:
#define FOO(x,y) ((x)*(y))
int main()
{
	cout << FOO(5,6) << endl; //Выведет 30.
}
По сути важно понимать что обычная функция будет вызываться уже в скомпилированной программе и будет происходить передача параметров работа со стеком и пр. А вот такие макросы 
собираются на этапе подготовки к компиляции препроцессором. И фактически это аналогично тому если бы мы руками в коде сделали Ctrl+С Ctrl+V и просто бы меняли параметры в этих 
кусочках т.е. с точки зрения выполнения программы тут вообще нет никаких вызовов функций.


||||||||||||||||||||||||||||
Условная компиляция. Выбираем какой код компилировать а какой нет. (Для отладки).

#define DEBUG//Переменная для отладки. Если переменная оперделена код будет писаться полностью, если закоментируем её, то инфа для отладки выводиться не будет.

int main()
{
	setlocale(LC_ALL, "Russian");
#ifdef DEBUG
	cout <<	"Начало цикла. (для отладки)" << endl;
#endif // DEBUG
	for (int i = 0; i < 4; i++)
		cout << i << endl;
#ifdef DEBUG
	cout << "Конец цикла. (для отладки)" << endl;
#endif 
}

||||||||||||||||||||||||||||
Так же есть и else
#define DEBUG

int main()
{
	setlocale(LC_ALL, "Russian");
#ifdef DEBUG // Если дебаг определён то будет работать эта часть кода
	cout <<	"DEBUG определён" << endl;
#else	// Если нет, то только эта.
	cout << "DEBUG Не определён" << endl;
#endif 
}

||||||||||||||||||||||||||||
Тоже самое только в другую сторону (инверсия).
#define DEBUG

int main()
{
	setlocale(LC_ALL, "Russian");
#ifndef DEBUG // Если дебаг определён то эта часть кода работать не будет (ifndef и ifdef это противоположности)
	cout <<	"1" << endl;
#else
	cout << "2" << endl;
#endif 
}

||||||||||||||||||||||||||||
Директива со значением
#define DEBUG 5 // DEBUG = 5

int main()
{
	setlocale(LC_ALL, "Russian");
#if DEBUG > 4 //Если DEBUG больше 4 то выведется эта часть кода
	cout <<	"1" << endl;
#elif DEBUG == 2 //Если DEBUG равно 2 то выведется эта часть кода
	cout << "2" << endl;
#else	// Если нет, то выведется эта.
	cout << "2" << endl;
#endif 
}


##############
Эти директивы, которые здесь перечислены, они включены в стандарт C++:
#include 
#define
#ifdef
#ifndef
#endif

Однако имеются некоторые директивы, которые не включены в стандарт, они являются лишь расширением компиляторов (иногда только для конкретных).  Такие директивы начинаются со слова #pragma.


||||||||||||||||||||||||||||
#pragma once - директива препроцессора для решения задачи повтороного включения. Это не является частью стандарта, это лишь расширение, которые поддерживают все современные компиляторы.


_____________________________________________________________________________________________________________
У нас есть возможность проверить работу препроцессора. В данном примере это будет компилятор gcc MinGW. Для того чтобы получить файл который будет получен после препроцессинга, мы можем вызвать наш компилятор с ключём -E.
Этим мы говорим компилятору чтобы он выполнил препроцессинг и после заверши свою работу:

g++ -E main.cpp -o main.i

Например для следующего кода в main.cpp:

#define PI 3.14
int main() {
	double x = PI;
}

в файле main.i у нас будет:

"main.cpp"
"<built-in>"
"<command-line>"
"main.cpp"

int main() {
	double x = 3.14;
}

Т.е. после препроцессинга выполнились все директивы файла. #define отработал и заменил все вхождения PI на 3.14. Такие макросы, объявленные через #define это очень опасная штука, и вот почему:
Мы можем объявить #define private public:

#define private public

class A {
private:
	void f() {}
};

int main() {
	A a;
	a.f();
}

Функиця f является приватной для класса A, её можно использовать только в этом классе, и по идее мы не можем вызвать её в main у нас будет CE, однако у нас есть директива #define private public, которая заменяет все вхождения private на public,
и если мы это скомпилируем то всё будет работать, потому что при препроцессинге в файле main.i у нас private заменилось на public:

"main.cpp"
"<built-in>"
"<command-line>"
"main.cpp"

class A {
public:
	void f() {}
};

int main() {
	A a;
	a.f();
}

Таких приколов может быть много:

#define private public
#define for while
#define true false
#define new delete
#define main not_main
#define class struct

и так далее и это может сломать наш код.



###############
Однако #define не всегда работает как замена чего то на что-то. #define иногда работает в связке с другой директивой препроцессора #ifdef: Например, пока мы разрабатываем приложение, мы хотим в консоли видеть отладочную информацию,
но не хотим чтобы они попали в продакшен. Для этого мы можем сделать так: Мы можем объявить переменную #define DEBUG_LOG, а далее в коде проверять с помощью #ifdef объявлена ли эта переменная DEBUG_LOG. Если да, то эта часть кода
будет попадать в финальную версию бинарника и будет выводиться отладочная информация. 

#define DEBUG_LOG
#include <iostream>

int main() {
	int x = 42;
#ifdef DEBUG_LOG				// Проверяем объявлена ли переменная DEBUG_LOG
	std::cout << x << std::endl;
#endif
}

Если мы закомментируем строчку #define DEBUG_LOG, то на этапе препроцессинга код, который находится в #ifdef #endif, будет просто выкинут из нашего исходного кода, и информация больше не будет выводиться. Тоже самое можно сделать 
полностью на макросах:

#define STUPID_DEBUG_LOG

#ifdef STUPID_DEBUG_LOG			
#include <iostream>
#define LOG(x) std::cout << x << std::endl;
#else
#define LOG(x)
#endif

int main() {
	int x = 42;
	LOG(x);
}

Если мы закомментируем #define STUPID_DEBUG_LOG то у нас LOG(x) просто не будет ничего делать, а если мы оставим #define STUPID_DEBUG_LOG, то будет выводиться отладочная информация. Ровно по такому же принципу работают
#include guards (об этом позже).



###############
Есть директива #if, с помощью которой код компиялция кода будет происходить по условию. В данном случае код int x = 42; будет как будто закомментирован.

int main() {
#if 0
	int x = 42;
#endif
}


_____________________________________________________________________________________________________________
Препроцессор так же как и компилятор работает с каждым файлом отдельно. Это очень важно для того, чтобы понимать как работает #pragma once и #include guards. Допустим у нас есть два разных файла:

// файл foo.cpp
int GetPI() {
	return PI;
}

// файл main.cpp
#define PI 3.14159

int main() {
	double x = PI;
}

При компиляции будет CE, поскольку в foo.cpp не определено PI. Нам нужно в файле foo.cpp тоже также написать #define:

// файл foo.cpp
#define PI 5
int GetPI() {
	return PI;
}

и для этого файла будет своё PI. Препроцессор отдельно обработает main.cpp и foo.cpp. 




__________________________________________________________________________________
################################################################
__________________________________________________________________________________
Компиляция

Если у нас есть файл main.i, мы можем пройти второй этап компиляции:

g++ -S main.i -o main.s

Таким образом мы можем увидеть как будет выглядить наш файл на языке ассемблера.  

Однако этап компиляции сам состоит из нескольких этапов. Сначала компилятор будет создавать абстрактное синтаксическое дерево, оно ему понадобится позже. Здесь компилятор будет брать наш код, и разбивать на лексемы и токины, и создавать 
из этого дерево. Для примера рассмотрим выражение:

int x = 42;

Однако с точки зрения компилятора это не простое выражение, потому что ему из этого нужно пострить абстрактное синтаксическое дерево. Компилятор должен разбитьэто выражение на лексемы int, x, =, 42, ;, и понять за что отвечает каждая из них, что
int то ключевое слово, x то индефикаторб 42 это int литерал, и т.д.  Иммено на этом этапе, пока строится абстрактное синтаксическое дерево, у нас появляются ошибки парсинга, например если бы мы забыли указать точку с запятой. Также на этом этапе
у нас может возникнуть если мы используем неопределённую переменную. Так же здесь разворачиваются шаблоны.


__________________________________________________________________________________
Компилятор, по мимо всего прочего, умеет оптимизировать наш код. Однако то абстрактное синтаксическое дерево которое получается из исходного кода который мы пишем, это слишком сложно для того, чтобы всё это оптимизировать. Поэтому 
компилятор создаёт сначала промежуточное представление, которое должно упростить наш код. Т.е. цель промежуточного представления свести все наши конструкции языка которые мы там понаписали используя разные современные фишки и новые
стандартны и т.д. к четырём базовым простым операциям: 1) присваивание, 2) арифметика (сложение умножение), 3) условный и безусловный оператор (if и goto), 4) и вызов функций, и всё это ещё будет в виде трёх-адресного кода. Любая, какая бы 
сложная не была, программа или любой алгоритм всегда можно свести к базовым примитивам и написать на них эту программу и алгоритм, и компилятор этому следует.

Пример: Просто имеем цикл:

int main() {
	for (int i = 0; i < 10; ++i)
	{
	}
}

Посмотрим на промежуточное представление. В gcc за промежуточное представление отвечает gimple, мы можем взять его дамп и посмотреть что он там сделал:

g++ -fdump-tree-gimple main.cpp

Получаем файл main.cpp.004t.gimple:

main() 
{
  int D.2378;

  {
    {
      int i;

      i = 0;
      <D.2376>:
      if (i > 9) goto <D.2374>; else goto <D2377>;
      <D.2377>:
      i = i + 1;
      goto <D.2376>;
      <D.2374>;
    }
  }
}

Компилятор взял и вместо цикла написал нам условный оператор if и goto, т.е. он написал аналог нашего кода с идентичным функционалом используя только примитивные операции. На этом этапе мы уже не работаем с стандартом языка и вообще 
не работаем с классическим C++. Всё что мы видим на этом промежуточном представлении это всё придумки создателей компиляторов, т.е. это всё будет отличаться на разных компиляторах. 

Так же в промежуточных представлениях убирается весь ненужный код. Если мы добавим какой нибудь class A, но нигде его не используем, то его не будет в промежуточном представлении:

class A{};

int main() {
	for (int i = 0; i < 10; ++i)
	{
	}
}

и файл main.cpp.004t.gimple останется таким же. Однако если мы создадим объект a и в классе A добавим конструктор, то промежуточное представление изменится:

//файл main.cpp
class A{
public:
	A() {}
};

int main() {
	A a;

	for (int i = 0; i < 10; ++i)
	{
	}
}

//файл main.cpp.004t.gimple
main() 
{
  int D.2418;

  {
    struct A a;

    try
      {
        A::A (&a);
        {
          int i;

          i = 0;
          <D.2416>:
          if (i > 9) goto <D.2414>; else goto <D2417>;
          <D.2417>:
          i = i + 1;
          goto <D.2416>;
          <D.2414>;
          }
        }
    finally
      {
        a = {CLOBBER};
      }
    }
    D.2418 = 0;
    return D.2418;
}

A::A (struct A * const this) 
{

}

Здесь в промежуточном представлении появится функция, которая будет отвечать за наш конструктор. Можно обратить внимание на то, что у нас здесь передаётся то, что мы никогда явно не указываем указатель на себя(*const this).

В промежуточном представлении у нас получается трёх-адресный код. Это означает то, что на одно выражение у нас будет максимум три адреса. Пример:

// файл main.cpp
int main() {
	int a = 1;
	int b = 2;
	int c = 3;
	int res = a + b + c;
	return 0;
}

Здесь мы видим что у нас есть 4 переменные, и переменная res это результат сложения трёх переменных. В выражении int res = a + b + c; мы имеем 4 адреса(поскольку переменных 4), но в промежуточном представлении в этом выражении
у нас создастся ещё одна переменная, для того, чтобы в этом выражении не было 4 адреса:

//файл main.cpp.004t.gimple
int main() {
  int D.2377;
  {
    int a;
    int b;
    int c;
    int res;
    
    a = 1;
    b = 2;
    c = 3;
    _1 = a + b;
    res = c + _1;
    D.2377 = 0;
    return D.2377;
  }
  D.2377 = 0;
  return D.2377;
}

Здесь переменная _1 это временная переменная для того чтобы дальше в выражении res = c + _1; было всего три адреса.


Вообщем компилятор собирает такое представление и дальше собирается его оптимизировать. 

//файл main.cpp
int main() {
	int x = 10;
	int y = 20;
	int res = x + y;
	return res;
}

Для того чтобы посмотреть как же компилятор это всё оптимизирует мы можем написать:

g++ -O3 -fdump-tree-optimized main.cpp 
где O3 это флаг оптимизации (O0 - без оптимизации, O3- сильная оптимизация)

//файл main.cpp.232t.optimized

;; Function main (main, funcdef_no=0, decl_uid=2371, cgraph_uid=0, symbol_order=0) (executed once)

main () 
{
  <bb 2> [local count: 1073741825]:
  return 30;

}

Т.е. он просто удалил все наши переменные и просто вернул 30, потому что компилятор способен это посчитать в момент компиляции. Однако если мы нашу переменную res объявим как volatile:

//файл main.cpp
int main() {
	int x = 10;
	int y = 20;
	volatile int res = x + y;
	return res;
}

то компилятор её уже не будет оптимизировать:

//файл main.cpp.232t.optimized

;; Function main (main, funcdef_no=0, decl_uid=2371, cgraph_uid=0, symbol_order=0) (executed once)

main () 
{
  volatile int res;
  int _3;

  <bb 2> [local count: 1073741825]:
  res = {v} 30;
  _3 = {v} res;
  return _3;

}


Все шаги, которые мы сейчас делали, являются платформонезависящие. Неважно intel или amd, x64 или x86 это всё будет везде одинаково. А вот дальше уже идут шаги, которые зависят от конкретного CPU.



__________________________________________________________________________________
################################################################
__________________________________________________________________________________
Ассемблирование

Здесь мы превращаем полученный ассемблерный файл в объектный (бинарный) файл. Такой файл человек прочитать уже не может, этот файл будет понятен только процессору. Мы практически уже получаем наш исполняемый файл,
просто в объектном файле стоят заглушки в местах вызовов функций.

g++ -c main.s -o main.o


__________________________________________________________________________________
################################################################
__________________________________________________________________________________
Линковка (Компановка)

На этом этапе компилятор должен собрать все наши объектные файлы в единое целое. Пример:

//main.cpp
int sum(int a, int b);

int main() {
	sum(10, 20);
}

У нас имеется файл main.cpp в котором есть объявление функции sum, но нет её определения. В этом же файле мы и вызываем sum. Здесь будет ошибка, но в какой момент? При препроцессинге ошибок не будет, при компиляции здесь тоже 
ошибок не будет, это всё успешно преобразуется в ассемблер, при ассемблировании тут тоже ошибок не будет, потому что объектный код поставит вместо вызова функции sum некую заглушку, потом линковщик должен взять и написать
туда адрес. И вот тут мы получим ошибку линкера, он не найдёт определение функции sum. Но если бы где то в нашей программе мы написали определение этой функции, то линковщик никакой бы ошибки не выдавал.

g++ main.cpp -o main.exe

Будет undefined reference to sum. Тогда создадим новый файл foo.cpp и определим там функцию sum:

//foo.cpp
int sum(int a, int b) {
	return a + b;
}

g++ main.cpp foo.cpp -o maim.exe

Теперь никакой ошибки линковки нет, наше приложение успешно собралось. Что сейчас произошло? У нас есть два независимых файла, которые мы передали компилятору, и линковщик связал определение функции sum в файле main.cpp с
определением функции sum в файле foo.cpp. Т.е. линковщику достаточно просто чтобы хотябы где-то в каком то файле и месте мы сделали определение этой функции. У нас нет чёткой связи между этими двумя файлами, при процессе сборки
каждая единица трансляции компилируется отдельно, а потом линковщик это всё пытается связать, причём заметим что в нашем проекте нет даже .h файлов. .h файлы никогда напрямую не участвуют в процессе компиляции, они лишь 
косвенно участвуют в нём, когда через #include попадают в .cpp, т.е. попадают в единицу трансляции. Однако минусом того, что мы не создали .h файл, это то, что нам нужно объявлять одну и ту же сигнатуру функцию sum и в main.cpp и в foo.cpp.



__________________________________________________________________________________
################################################################
__________________________________________________________________________________
#pragma once и #include guards.

Зачем указывать данные команды? Например у нас есть такой проект: sum.h в котором определена шаблонная функция sum., и у нас здесь имеется и #pragma once и #include guards.

//файл sum.h
#pragma once

#ifdef SUM_H		// Это и есть include guards
#define SUM_H		// Это и есть include guards

template <typename T>
T sum(T a, T b) {
	return a + b;
}

#endif // SUM_H		// Это и есть include guards

В main.cpp мы подключаем "sum.h" для того чтобы вызвать sum(10, 20).

// файл main.cpp
#include "sum.h"

int main() {
	sum(10, 20);
}

И ещё у нас имеется файл foo.cpp, в котором мы тоже подключаем "sum.h" для использования функции sum. 

// файл foo.cpp
#include "sum.h"

void someFunction() {
	int result = sum(5, 10);
}

И того, не смотря на то, что у нас в файле sum.h включен #pragma once и #include guards, если мы сейчас выполним препроцессинг на оба файла main.cpp и foo.cpp, мы обноружим что в них обоих полностью скопируется определение, т.е. вся
функция sum. Произошло это так, потому что main.cpp и foo.cpp это две разные единицы трансляции. 

От чего же тогда защищают #pragma once и #include guards? Они защищают от повторного включения в один и тот же .cpp файл. Т.е. мы защищаем файл, в который будет включён наш текущий файл с #pragma once и #include guards, а не сам 
файл в  котором написаны сами #pragma once и  #include guards. Т.е. если мы напишем какой нибудь #include два раза, например так:

//файл sum.h
#pragma once

#ifdef SUM_H		// Это и есть include guards
#define SUM_H		// Это и есть include guards

template <typename T>
T sum(T a, T b) {
	return a + b;
}

#endif // SUM_H		// Это и есть include guards

// файл main.cpp
#include "sum.h"
#include "sum.h"

int main() {
	sum(10, 20);
}

то никакой ошибки не будет в main.cpp не будет, защита сработала. Однако если мы в файле sum.h уберём защиту:

//файл sum.h
template <typename T>
T sum(T a, T b) {
	return a + b;
}

// файл main.cpp
#include "sum.h"
#include "sum.h"

int main() {
	sum(10, 20);
}

то в файле main.cpp будет ошибка переопределения (redefinition), у нас два раза скопировалось оперделение функции sum в файл main.cpp. Конечно это довольно глупая ошибка, однако может быть другая ситуация. У нас в проекте есть 
файл foo.cpp в котором имеется функция someFunction(). И нам в main.cpp захотелось эту функцию использовать. В main.cpp мы подключили файлы sum.h и foo.cpp, однако foo.cpp тоже имеет подключение sum.h, и из-за этого мы и получаем 
двойное дублирование функции sum в main.cpp и redefinition соответственно.

//файл sum.h
template <typename T>
T sum(T a, T b) {
	return a + b;
}

// файл foo.cpp
#include "sum.h"

void someFunction() {
	int result = sum(5, 10);
}

// файл main.cpp
#include "sum.h"
#include "foo.cpp"

int main() {
	sum(10, 20);
	someFunction();
}

Поэтому в файле sum.h нам нужно установить защиту, и тогда все будет корректно.



__________________________________________________________________________________
################################################################
__________________________________________________________________________________
Почему компиляция в C++ такая медленная?

Пример: Когда мы создаём наш проект, то упрощённая схема выглядит так:

foo.h
foo.cpp ----> foo.o ---\
bar.h                   \
bar.cpp ----> bar.o ----/ ====> linker ----> app.exe
main.cpp ---> main.o --/


Компилятор отдельно проходит по foo, отдельно по bar, и отдельно по main. Это и есть основной момент для понимания, почему компиляция в C++ такая медленная. Если мы представим,
что у нас есть проект, который содержит 100 .cpp файлов, и в каждом из этих .cpp файлов мы подключаем vector(так не нужно делать, это плохо). Получается, что мы создаём 100 единиц 
трансляции, и компилятор вынужден кажую из них отдельно обработать. И того получается, что когда каждая из этих единиц будет развёрнута, то в каждой из них будет скопипащен 
код из vector, и компилятор будет раз за разом все 100 раз перекомпилировать одно и тоже, поскольку он не может по другому, поэтому компиляция такая медленная.


#################
Пример 2: 
У нас есть файлы main.cpp, Foo.h, и Foo.cpp:

///////////////////
// Файл main.cpp
#include "Foo.h"

int main(int argc, char *argv[]) {
	Foo foo;
	foo.print();
}


// Файл Foo.h
#ifndef FOO_H
#define FOO_H

class Foo {
public: 
	Foo();
	void print();
}

#endif // FOO_H


// Файл Foo.cpp
#include <iostream>
#include "Foo.h"

Foo::Foo() {}

void Foo::print() {
	std::cout << "Hello world" << "\n";
}
///////////////////

Мы подключаем в main.cpp файл Foo.h, для того чтобы в main создать объект класса Foo. При компиляции у нас создастся две единицы трансляции main.cpp и Foo.cpp. Директива 
препроцессора #include отработает, и у нас и в main.cpp и в Foo.cpp #include "Foo.h" заменится просто на 

class Foo {
public: 
	Foo();
	void print();
}


т.е. заменится на объявление класса Foo. Другими словами мы можем просто взять скопировать это объявление, и сами вместо #include "Foo.h" вставить это объявление, и у нас
всё прекрасно скомпилируется и в консоль выведется Hello world:


///////////////////
// Файл main.cpp
class Foo {
public: 
	Foo();
	void print();
}

int main(int argc, char *argv[]) {
	Foo foo;
	foo.print();
}


// Файл Foo.cpp
#include <iostream>

class Foo {
public: 
	Foo();
	void print();
}

Foo::Foo() {}

void Foo::print() {
	std::cout << "Hello world" << "\n";
}
///////////////////


Что сейчас произошло? Мы имеем main.cpp в котором просто объявлен какой то класс Foo, однако там нет определения (реализации), это просто объявление, однако всё работает. 
Этим определением мы обещаем компилятору, что такой класс существует, и что линковщик потом его свяжет. Т.е. при компиляции main.cpp, у нас просто под foo.print() остаётся 
какая то свободная ячейка, в которую потом линковщик запишет адрес, по которому можно вызвать это метод. У нас сейчас произошла связь линковщика, благодаря которому мы 
соединили несколько независимых частей нашего приложения, поэтому компилятору вообще не нужно знать полной картины нашего проекта, он оперирует только отдельными единицами
трансляции. Однако основной посыл здесь в том, что наш класс Foo был скомпилирован два раза, поскольку у нас имеется две независимые единицы трансляции, и сначала мы 
скомпилировали класс Foo в main.cpp, а затем в foo.cpp, хотя класс один и тот же. 

Справедливости ради, благодаря тому, что компилятор компилирует каждый .cpp файл отдельно, в этом есть и свои преимущества. Когда мы заходим в свой .cpp файл и изменяем там
что-то, не нужно потом пересобирать весь проект, достаточно перекомпилировать только тот .cpp файл, который был изменён. Но это касается только файлов с расширением .cpp, если
мы что-то изменили в файле .h, то придётся перекомпилировать все единицы трансляции, которые включают в себя этот конкретный .h файл, который был изменён.



______________________________________________________________________________________
Что мы можем сделать для ускорения скорости компиляции?

На самом деле есть одно простое правило: Стараемся избегать, на сколько это возможно, объявлять #include в .h файлах. Всё. В .h файлах Вместо #include используйте 
Forward declaration(смотри ниже).

Пример: 
Возьмём предыдущий пример с файлами main.cpp, Foo.h, и Foo.cpp:

///////////////////
// Файл main.cpp
#include "Foo.h"

int main(int argc, char *argv[]) {
	Foo foo;
}


// Файл Foo.h
#ifndef FOO_H
#define FOO_H

class Foo {
public: 
	Foo();
}

#endif // FOO_H


// Файл Foo.cpp
#include "Foo.h"

Foo::Foo() {}

///////////////////


Давайте разберёмся c #include. Почему в Foo.h нежелательно использовать какие либо #include? Представим, что мы хотим в Foo.cpp в определении конструктора класса Foo 
использовать std::vector. Мы можем поступить двумя путями: 1-ый подключить #include <vector> напрямую в сам файл Foo.cpp (в данном случае правильный вариант):

// Файл Foo.cpp
#include "Foo.h"
#include <vector>

Foo::Foo() {
	std::vector<int> vec;
}


а можем сделать 2-ой вариант: подключить #include <vector> в Foo.h (в данном случае неправильный вариант):


///////////////////
// Файл Foo.h
#ifndef FOO_H
#define FOO_H

#include <vector>

class Foo {
public: 
	Foo();
}

#endif // FOO_H


// Файл Foo.cpp
#include "Foo.h"

Foo::Foo() {
	std::vector<int> vec;
}

///////////////////


Если мы поставим #include <vector> в Foo.h файле, у нас произойдёт следующая ситуация: При компиляции единица трансляции Foo.cpp развернёт #include "Foo.h", в котором будет
#include <vector>, который компилятор тоже развернёт, всё это скомпилируется, и мы сможем использовать std::vector из файла Foo.cpp. Это хорошо, ведь нам как раз нужно 
использовать std::vector в Foo.cpp. Однако при этом в main.cpp у нас тоже есть подключение #include "Foo.h", но здесь в main.cpp std::vector мы не используем, а он и здесь
развернётся и скомпилируется, как и в Foo.cpp. Поскольку в main.cpp Foo.h у нас идёт через #include, соответсвтенно у нас в main.cpp развернётся весь Foo.h вместе и с
#include <vector>, и тогда в main.cpp тоже перекомпилируется std::vector, но он нам там не нужен, мы его там не используем, т.е. произойдёт лишняя компиляция std::vector,
соответственно увеличится время сборки проекта. Поэтому в .h файлах нужно стараться как можно меньше использовать #include.



______________________________________________________________________________________
Forward declaration

Добавим к примеру выше ещё один класс: Bar.h и Bar.cpp. Мы хотим в классе Foo иметь экземпляр этого объекта. Для этого в файле Foo.h мы должны объявить (заинклудить) Bar.h:


///////////////////
// Файл Foo.h
#ifndef FOO_H
#define FOO_H

#include "Bar.h"

class Foo {
public: 
	Foo();
private:
	Bar bar;
}

#endif // FOO_H


// Файл main.cpp
#include "Foo.h"

int main(int argc, char *argv[]) {
	Foo foo;
}
///////////////////


Наш main.cpp использует класс Foo, и для этого мы заинклудили #include "Foo.h". Однако теперь main.cpp также будет зависеть и от Bar.h, и постоянно его перекомпилировать, хотя в
main.cpp мы не используем класс Bar. 

Для решения этой проблемы мы можем использовать Forward declaration. Он нам говорит следующее: Если мы используем указатель или ссылку на класс, то нам не обязательно знать, какой
этот класс имеет размер, какие имеет поля и методы, нам сейчас не нужна про этот класс конкретная информация, нам лишь важно сказать компилятору что такой класс существует, и 
что его потом свяжет линковщик. Поэтому мы вместо #include "Bar.h" можем просто прописать объявление класса Bar:


// Файл Foo.h
#ifndef FOO_H
#define FOO_H

// #include "Bar.h" - в данном файле это не нужно

class Bar;	// Это Forward declaration класса Bar

class Foo {
public: 
	Foo();
private:
	Bar* bar;	// Указатель на экземпляр класса Bar, а не простая переменная.
}

#endif // FOO_H


В данной ситуации нашему компилятору этого будет достаточно. А самое главное main.cpp теперь не зависит от "Bar.h" и не будет его постоянно перекомпилировать, поскольку нет 
прямого инклуда #include "Bar.h" в Foo.h. А чтобы использовать весь функционал Bar.h, мы инклудим его в Foo.cpp и спокойно используем указатель bar:


// Файл Foo.cpp
#include "Foo.h"
#include "Bar.h"

Foo:Foo() {
	bar = new Bar();
}

Поскольку в Foo.cpp мы должны использовать класс Bar, значит мы должны знать про него конкретную информацию, а значит пора инклудить "Bar.h", здесь это оправдано, но в Foo.h
он нам не нужен, поэтому там мы его просто объявляем. Такая штука называется Forward declaration, и она очень сильно помогает оптимизировать время компиляции нашего проекта.






