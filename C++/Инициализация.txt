Member initializer list


class Complex {
	double re = 0.0;
	double im = 0.0;
public:
	// Member initializer list
	Complex(double real) : re(real) {	// Хороший кодстайл один вызов вместо двух. Здесь инициализация полей происходит до входа в тело конструктора
						// Т.е. переменные сразу определяются нужным значением, не используя значение по умолчанию.
		// re = real; 	// Плохой кодстайл 2 вызова вместо одного. Здесь переменная сначала инициализируется значением по умолчания (в нашем случае 0.0), а
				// уже затем происходит присваивание нужного значения. Зачем делать две операции, когда можно сделать одну?				
	}
}

int main() {

	// Виды инициализации:
	Complex c(5.0); 	// Direct initialization (прямамя инициализация)
	Complex c2 = 5.0; 	// Value initialization
	Complex c3{5.0};	// 
	Complex c4 = {5.0};
	
}



#######################
Присваивание аргументов конструктора членам класса. C++ использует списки инициализации (Member initializer list)

class Person {
private:
	std::string name;
	int age;

public:
	Person(std::string n, int a): name(n), age(a) {
		/* empty */
	}
};

Здесь список инициализации членов класса это : name(n), age(a) {
Есть одна странная оговорка, члены класса инициализируются в том порядке, в котором они объявлены в определении класса, а не в том, в котором они стоят в списке инициализации. Если мы инициализируем переменные в неправильном
порядке, может возникнуть ситуация что переменная будет зависить ещё от неинициализированной переменной и будет UB.





______________________________________________________
Агрегатная инициализация

class Complex {
public:
	double re = 0.0;
	double im = 0.0;
}

int main() {
	S s{3, 2}; 	// Агрегатная инициализация. Работает, если поля публичные. Если есть хоть один конструктор, агрегатная инициализация перестаёт работать, и такой вызов 
			// будет означать вызов конструктора.
}

______________________________________________________
initializer list (не путать с Member initializer list)

Когда мы пишем:
std::vector<int> v = {1, 2, 3, 4, 5}; // это как работает? Какой конструктор вызывается?

Мы можем создать вектор от любого кол-ва аргументов, но мы же не можем создать конструктор от любого кол-ва аргументов. Там должен быть конструктор который принимает нечто,
что может хранить в себе любое кол-во аргументов.

Но на самом деле там есть конструктор от std::initializer list

Фигурные скобочки могут обозначать одно из трёх:
1) Агрегатную инициализацию
2) Обычный вызов конструктора
3) И initializer list

#include <cstring>

class String {			// Реализовываем строку
	int* arr = nullptr;	// Указатель на область динамической памяти
	size_t sz = 0;		// Сколько элементов реально лежит
	size_t cap = 0;		// Под сколько элементов выделена память

public:
	String(){}		// Default constructor

	/*			// Это не нужно для initializer list. Тут в видосе просто показан нетривиальный конструктор

	String(size_t n, char c) : arr(new char[n + 1]), sz(n), cap(n + 1) { 	// n + 1 для нуль терминатора. (Пример нетривиального конструктора)
		memset(arr, c, n); // Заполняет n байт начиная с указателя arr значением c
		arr[sz] = '\0';
		// std::fill(arr, arr + sz, c); // Тоже самое что и memset. Указатель на начало, указатель на конец, чем заполнить
		// Здесь не нужно реализовывать свой цикл, т.к. memset и std::fill оптимизированны лучше (в 8 раз быстрее)
	}*/

	String(std::initializer_list<char> list) 		// Принимаем по значению а не по ссылку, т.к. initializer_list лёгкий тип и его копирование тривиально
			: arr(new char[list.size() + 1])
			, sz(list.size())
			, cap(sz + 1) {
		std::copy(list.begin(), list.end(), arr);	
		arr[sz] = '\0';
	}

	~String() {
		delete[] arr;
	}
};

int main() {
	String s = {'a', 'b', 'c', 'd'}; // С помощью конструктора std::initializer_list мы можем инициализировать так.
}

Путаница заключается в том, что у нас есть конструктор от двух аргументов String(size_t n, char c), а ещё есть конструктор от initializer list. И если мы напишем:

int main() {
	String s = {'a', 'b', 'c', 'd'};	// какой конструктор вызовется?
	String s2{2, 'a'};			// какой конструктор вызовется?
}
			
У нас есть конструктор от числа и символа, а есть конструктор от initializer list. И в первом и во втором случае вызовется конструктор initializer_list.
Правило такое: Если у нас есть хоть один конструктор от initializer list, то дальше когда мы создаём фигурные скобочки (инициализация фигурными скобками) в первую очередь 
рассматриваются конструкторы от initializer list, и только если ни один из них не подходит, рассматриваются остальные конструкторы.

Но если написать круглые скобочки, то это уже будет обычный конструктор:

	String s2(2, 'a'); // Вызовется обычный конструктор String(size_t n, char c) и конструктор от initializer_list рассматриваться не будет.
