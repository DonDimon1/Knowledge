
______________________________________________________________________________________
######################################################################################
######################################################################################
______________________________________________________________________________________
Unions and type aliasing

Задание на дом реализовать std::variant.

_____________________________________________
Unions and their usage

Unions это ещё один вид базовых типов, как class, struct или enam. В union так же могут быть поля и методы, но когда мы пишем union с некоторыми полями, размер union это максимум из размеров полей, а не сумма, как в случае struct. union
это штука, которая хранит одномоментно один из своих полей:

union U {
	int x;
	double y;
};

int main() {
	U u;
}

в данном случае либо int x, либо double y. Хранение происходит на одном и том же адресе. Из этого следует, что если мы сначала указали x, затем y, то мы можем заметить что x поменялся после указания y:

U u;				// Когда мы так пишем, это означает что по умолчанию он инициализирует первое поле, т.е. в нашем случае это int x.
u.x = 5;
u.y = 3.14;
std::cout << u.x << '\n';	// Вывод 1374389535

потому что они лежали на одном адресе. Перезаписав double y, мы перезаписали и int x. union используется когда нам нужно хранить в одной переменной разные типы, соответсвтенно sizeof union с точностью до выравнивания, это максимум
из полей, которые в нём лежат. Интереснее становится когда в union появляются нетривиальные типы. Например, если мы просто добавим std::string, то будет CE, потому что если в union есть хотябы одино поле с нетривиальным конструктором,
то конструктор по умолчанию не генерируется, поэтому нужно описать что такое union: 

union U {
	int x;
	double y;
	std::string s;			// Нетривиальный тип

	U() {}				// поэтому нужен конструктор и деструктор
	~U() {}
};

int main() {
	U u;
	u.x = 5;
	std::cout << u.x << '\n';
	u.s = "abc";
	std::cout << u.s << '\n';
}

Однако если мы запустим код то у нас будет такой вывод:

5
Segmentation fault (core dumped)

Почему это Segmentation fault? Потому что мы не создаём строку на новом месте, мы пытаемся сделать присваивание. Формально выражение u.s = "abc" это вызов оператора присваивания от левого операнда std::string и правого операнда 
const char*, т.е. здесь происходит вызов оператора присваивание у std::string, который конечно же начинает с того, что всё делает оператор присваивания, например удаляет старую строку, но там не было старой строки, там были байты,
которые кодируются в целочисленную пятёрку, поэтому мы по факту сейчас пытаемся вызвать delete от памяти, которая на самом деле не является строкой. Так как же положить в union строку, если там раньше лежал int? Через placement new:

U u;
u.x = 5;
new (&u.s) std::string("abc");		// Правильный способ положить std::string в union.
std::cout << u.s << '\n';

Хорошо, а что если после того как мы положили строку в union, мы хотим положить туда обратно int, что нам нужно делать? Мы конечно можем просто сказать u.x = 8, и Segmentation fault не будет, но будет утечка памяти, потому что никто за
нас не вызовет деструктор строки. Для того, чтобы правильно вызвать деструктор, нужно написать так:

u.s.~basic_string<char>(); 
u.x = 8;

Почему не std::string? Потому что std::string это alias basic_string<char>. Если бы мы написали u.s.~string(), то компилятор бы не понял потому что он не знает класса string: expected class-name before '('.


Что ещё может быть у union? Как мы говорили, могут быть методы, но не могут быть виртуальные функции. У union не может быть родителей и от union нельзя наследоваться. У union не может быть не статических членов типа ссылка. Как и в 
struct по умолчанию все поля public, но можно сделать private.


###
Member lifetime

Существует важное понятие: active member of union. В каждый момент времени в рантайме существует понятие активного члена у union. Активного член union это тот единственный член, обращение к которому сейчас не UB. Когда мы кладём в 
union какой то член с помощью присваивания или placement new, то он становится активным.


###################################
Анонимные union

Это когда мы не даём union название, а пишем вот так:

int main() {
	union {
		int a;
		const char* p;
	};
	
	a = 1;
	p = "Jennifer";
}

Это значит что поля этого union выбрасываются в обемлюющую область видимости, т.е. это как если бы мы просто в main локально объявили этот int a и const char* p, но сделал так что они шарят общий адрес. Мы можем присваивать и в a и в p,
но они будут перезатирать друг друга.


###################################
Примеры использования union в стандартной библиотеке

На самом деле в классе std::string используется union. У std::string есть анонимный union в полях класса т.е. два поля класса шарят один и тот же адрес, и он выглядит так:

_Alloc_hider _M_dataplus;
size_type _M_string_length;

enam { _S_local_capacity = 15 / sizeof(_CharT) };

union {
	_CharT 		_M_local_buf[_S_local_capacity + 1];
	size_type	_M_allocated_capacity;
};

т.е. у нас в скоупе класса есть _CharT и size_type и они перезатирают друг друга, поскольку эти поля лежат на одном адресе. Это нужно для оптимизации SSO - Small String Optimization. std::string не хранит на куче строку если она слишком
короткая. Если строка настолько короткая, что она сама собой занимает меньше места чем указатель, то зачем выделять под неё память на куче. Примерно это здесь и написано. У нас в std::string есть поле size_type _M_string_length 
(т.е. длина), и есть union, который хранит одно из двух, либо _M_local_buf (массив чаров), либо _M_allocated_capacity (число). _M_local_buf это массив чаров размера 15 / sizeof(_CharT) + 1, ну т.е. максимум строку длины 15 мы будем 
хранить на стеке, а не на куче. 

_Alloc_hider это структура с empty-base optimization, штука которая наследуется от аллокатора и прячет аллокатор, чтобы не делать аллокатор отдельным полем, но по сути _Alloc_hider это просто указатель на данные. Т.е. этот самый 
указатель, который мы всегда называли str (указатель на настоящие данные), только он обёрнут в структуру _Alloc_hider. Т.е. _Alloc_hider _M_dataplus это указатель на данные. И теперь есть два варианта чему равен этот указатель: этот
указатель, в зависимости от того, короткая строка или длинная, либо указывает куда то на кучу, либо указывает на адрес локального буфера _M_local_buf. Но если он указывает на адрес локального буфера, то _M_allocated_capacity не нужно,
поэтому можно локальный буфер положить на место _M_allocated_capacity. 

Получается std::string состоит из следующих полей: указатель, число, либо  capacity, либо массив чаров. Отсюда следствие: в std::string если строка короткая, одно поле является указателем на другое поле. Когда мы изучали std::vector, мы
говорили что нельзя перекладывать объекты из одного массива в другой, просто используя memcpy, потому что это не работает для объектов, у которых одно поле является указателем на другое поле. std::string тоже бы упал если бы мы его так
копировали с помощью memcpy, потому что в нём, если он короткий, одно поле является указателем на другое поле.



_____________________________________________
std::variant (since C++17)

Это венец творения современных плюсов XD. Пользоваться union в чистом виде бывает сложно, в чистом виде это зло, это рассадник UB. Давайте сделаем что-то типо union, только чтобы он сам следил за тем, кто там удалился, а кто создался.
У нас уже был класс std::any, который хранил что угодно, но это всё он делал на куче. std::variant в отличии от std::any ничего не будет хранить на куче, мы будем позволять хранить один из нескольких типов в каждый момент времени, и 
подменять себя на другой тип. Мы можем там хранить что угодно, но для того чтобы достать объект, нам нужно как и в std::tuple использовать std::get с указанием типа, и если мы не угадали то будет исключение std::bad_variant_access. Это
работает только в рантайме, поскольку это нельзя отследить в компайлтайме. Порядок перечисления типов в std::variant не на что не влияет, однако, если мы инициализируем std::variant по умолчанию, то он инициализирует первый тип.

#include <variant>

int main() {
	std::variant<int, double, std::string> v = 5;
	std::cout << std::get<int>(v) << '\n';

	v = 3.14;
	std::cout << std::get<double>(v) << '\n';

	v = "abc";
	std::cout << std::get<std::string>(v) << '\n';
}

Мы присваиваем std::variant значение, и он сам понимает что за тип, но что если бы мы сделали так:

std::variant<int, double, std::string> v = 'a';

Мы пытаемся создать std::variant от char, а у него есть варианты только int, double и std::string. ВНИМАНИЕ! std::variant что при конструировании, что при присваивании, выберет тот вариант, который наиболее предпочтителен по правилам 
перегрузки, в данном случае это будет тип int, а символ 'a' в int это будет 97. Если есть неоднозначность, то это CE, например классический пример неоднозначности при перегрузке:

std::variant<int, double, std::string> v = 3ull;	

error: conversion from 'long long unsigned int', потому что он не может выбрать к чему сконвертировать long long, потому что сконвертировать к int и double одинаково плохо.

std::variant это по сути union, который дополнительно помнит номер активного члена, когда переприсваивают ему активный член, он уничтожает текущий активный член и запоминает новый. Т.е. он должен под капотом помнить деструктор, который
он должен вызвать, когда ему заменяют активный член, и когда его заменяют, он перезапоминает что нужно делать, когда ему сделали присваивание. Т.е. если у нас например сейчас в std::variant лежит строка, и мы присваиваем ей новую строку:

std::variant<int, double, std::string> v = "abc";
v = "cde";

то он не будет уничтожать старую строку и присваивать новую, а просто сделает присваивание строк. Из-за всего этого sizeof std::variant больше чем просто максимальный размер из полей как у union.



###################################
std::visit

Одна из замечательных возможностей, который предоставляет std::variant это функция std::visit. Пусть у нас есть std::variant и мы можем написать функцию его посищения. В аргументах этой функции сначала передаём функтор, который говорит 
что нужно сделать, затем std::variant. Функтор м.б. шаблонным. В этот функтор функция std::visit отдаёт всё то, что лежит в std::variant, т.е. этот функтор должен уметь принимать всё то, что может хранить std::variant.

std::variant<int, double, std::string> v = "cde";

std::visit(
	[](const auto& item) -> int {
		if constexpr (std::is_same_v<decltype(item), int>) {
			std::cout << "int! " << item << "\n";
		} else {
			std::cout << "not int!\n";
		}
		return 0;
	},
	v);

// Вывод: not int!

В нашем случае наш функтор умеет принимать любой тип, и он в зависимости от того, что он принял, делает разные вещи. std::visit должен что-то возвращать, поэтому мы возвращаем 0. Почему std::variant последний параметр, а не первый, ведь
так было бы читабельнее? Потому что std::visit умеет принимать переменное число std::variant:

template <class Visitor, class... Variants>
constexpr visit( Visitor&& vis, Variants&&... vars );

Заведём ещё один такой же std::variant, но в него положим int, и тогда мы увидим visitor посетит каждый std::variant, но в первом обнаружит не int, а во втором int. Однако для того чтобы посетить несколько std::variant, у нас visitor
должен принимать несколько аргументов:

std::variant<int, double, std::string> v = "cde";
auto v2 = v;
v2 = 5;

std::visit(
	[](const auto& item, const auto&) -> int {
		if constexpr (std::is_same_v<decltype(item), int>) {
			std::cout << "int! " << item << "\n";
		} else {
			std::cout << "not int!\n";
		}
		return 0;
	},
	v, v2);

У нас есть std::visit, который в зависимости от того что лежит в std::variant выводит либо int, либо не int, мы можем делать std::visit от нескольких std::variant сразу, но тогда visitor должен быть от нескольких std::variant сразу.

Однако в данном случае если мы напишем так:

v2 = 5;

std::visit(
	[](const auto& item) -> int {
		if constexpr (std::is_same_v<decltype(item), int>) {
			std::cout << "int! " << item << "\n";
		} else {
			std::cout << "not int!\n";
		}
		return 0;
	},
	v2);

Он выдаст not int, потому что нужно делать decltype от std::remove_reference, потому что на самом деле там не int, а const int&. Если мы напишем так:

if constexpr (std::is_same_v<decltype(item), const int&>) {

он выдаст: int 5. 

Аналогично если мы напишем шаблонизацию так:

v2 = 5;

std::visit(
	[]<typename T>(const T& item) -> int {
		if constexpr (std::is_same_v<T, int>) {
			std::cout << "int! " << item << "\n";
		} else {
			std::cout << "not int!\n";
		}
		return 0;
	},
	v2);

он выдаст: int 5. 

Пример с вопросом: Почему это компилируется, почему компилятор справляется такое сделать, в зависимости от того int там или не int, выводит либо одно либо другое:

std::variant<int, double, std::string> v = "cde";
auto v2 = v;
v2 = 5;

std::vector<decltype(v)> vec;
vec.push_back(v);
vec.push_back(v2);

for (const auto& var: vec) {
	std::visit(
		[]<typename T>(const T& item) -> int {
			if constexpr (std::is_same_v<T, int>) {
				std::cout << "int! " << item << "\n";
			} else {
				std::cout << "not int!\n";
			}
			return 0;
		},
		var);
}

Вывод: 
not int!
int! 5

Тут есть три уровня понимания: 0 уровень - вы вообще не понимаете в чём проблема, 1 уровень - вы понимаете в чём проблема, и кажется что так не должно работать, 2 уровень - понимаем почему это всё таки работает. Почему это работает, у 
нас что динамическая типизация появилась в языке или что? Что нас может смущать: например почему if constexpr работает корректно, он как будто в рантайме умудряется понять что там лежит? Там же может лежать то одно, то другое, почему
это работает для обоих случаев, как if constexpr просчитывает это в компайлтайме? Для того чтобы это понять, нужно вспомнить что такое обощённая лямбда - генерируется класс замыкания, в котором есть шаблонный оператор круглые скобочки
от T, и когда вызывается функция std::visit, когда компилятор видит от какого std::variant мы вызываем эту лямбду, генерируются просто все версии этого оператора, т.е. инстанцируются оператор круглые скобочки со всеми возможными типами
которые есть в std::variant. Просто во время инстанцирования шаблонного метода компилятор понимает, что если он инсатнцирует для int сейчас, то эта версия if constexpr актуальна, если он сейчас инстанцирует для double, то другая. На
самом деле в данном примере у этого объекта замыкания есть три версии круглых скобочек, по одной для каждого возможного типа того, что лежит в std::variant, и в тех из них, которые удовлетворяют if constexpr написан один код, а в тех
которые не удовлетворяют написан другой код. Как именно std::visit выбирает правильную версию функции, это вопрос реализации std::visit. Сейчас нужно понять, что просто три версии круглых скобочек сгенерировано для этой лямбды, и это 
не противоречет статической типизации, все три версии существуют, и задача std::visit просто в том, чтобы посмотрев, что лежит в std::variant, попросить правильный оператор круглые скобочки. Обычные шаблоны инстанцируются лениво, однако
std::visit так устроен, что он заставляет инстанцировать все версии, а потом выбирает правильную.


###################################
Overload pattern

То что мы сейчас увидим называется overload паттерн. У нас есть структура Overload которая наследуется от переменного числа шаблонных аргументов (так можно делать). В этой структуре написано using Ts::operator()... так писать можно с 
C++17, если мы унаследовались от переменного числа родителей, то мы можем сделать using тоже с многоточием по этим родителям, и означает то, что мы внесём в тело структуры Overload все круглые скобочки от каждого из родителей. Теперь у
нас в структуре Overload есть все операторы круглые скобочки () которые были хоть у одного из родителей.

Строка template<class... Ts> Overload(Ts...) -> Overload<Ts...> это explicit deduction guide для вывода шаблонных параметров класса. Если мы хотим сконструировать Overload от каких то типов, как компилятору понять какие у него должны 
быть шаблонные параметры? Как раз с помощью этой строки мы говорим, что если вызывается конструктор Overload от каких то типов (Ts...), то это значит что нужно такие сделать ему шаблонные аргументы <Ts...>. А почему вообще можно 
конструировать Overload от Ts..., а потому что если у нас переменное число родителей, то у нас агрегатная инициализация работает по родителям (это обсуждалось когда мы разбирали CTAD). 

В main у нас есть вектор из std::variant, в каждом из которых может лежать либо std::vector от int, либо double, либо std::string. Этот вектор из std::variant мы инициализируем числом 1.5, вектором от int и строкой, т.о. у нас получается
вектор из трёх std::variant. Теперь мы заводим вещь DisplayMe - это Overload созданная от следующих двух вещей: лямбда, принимающая вектор от int, и выводящая все элементы вектора, а также лямбда принимающая что угодно, в которой 
проверяется что если это std::string то скажи что это стринг и выведи его, иначе если это double то скажи что это double и выведи его. И в конце для каждого std::variant из вектора vecVariant, делаем std::visit с функтором DisplayMe
от каждого этого std::variant. 


template <typename... Ts>
struct Overload: Ts... {
	using Ts::operator()...;	// since C++17
};

template<class... Ts> Overload(Ts...) -> Overload<Ts...>;

int main() {
	std::vector<std::variant<std::vector<int>, double, std::string>>
		vecVariant = { 1.5, std::vector<int>{1, 2, 3, 4, 5}, "Hellow "};

	auto DisplayMe = Overload {
		[](std::vector<int>& myVec) {
			for(auto v: myVec) std::cout << v << " ";
			std::cout << '\n';
		},
		[](auto& arg) {
			if constexpr (std::is_same_v<std::decay_t<decltype(arg)>, std::string>) {
				std::cout << "string" << arg << '\n';
			} else if constexpr (std::is_same_v<std::decay_t<decltype(arg)>, double>) {
				std::cout << "double " << arg << '\n';
			}
		},
	};

	for (auto v : vecVariant) {
		std::visit(DisplayMe, v);
	} 
}

И это всё компилируется и выводит так:
double 1.5
1 2 3 4 5
string Hello

Сначало он понимает что это double, потом он понимает что это вектор от int, потом он выбирает версию от std::string. Заметьте у нас Overload от двух штуковин (от двух лямбд), когда мы выбираемся от double, мы попадаем во вторую версию
(вторую лямбду) и дальше срабатывает if constexpr и говорит что это double. Второй раз мы вызываемся от std::variant в котором лежит вектор от int, и из этих двух версий он выбирает первую (первую лямбду) и делает то что там написано.
И в третий раз мы вызываемся от std::variant в котором лежит std::string и мы опять попадаем во вторую версию и попадаем версию if constexpr от std::string. Почему это называется Overload? Потому что по сути мы сделали перегрузку 
visitor, т.е. у нас есть версия на случай вектора, и есть версия на случай всего остального. Мы сделали объект Overload создав его от двух лямбд. Overload это штука которая наследуется от всех своих шаблонных параметров, а какие у неё
шаблонные параметры? Такие, от чего её создали, такие у неё и шаблонные параметры. Значит структура Overload создалась от двух таких замыканий (closures), компилятор сгенерировал один объект closure с оператором круглые скобочки от
вектора, друго объект closure с шаблонным оператором круглые скобочки, и у нас получился объект Overload унаследовавшийся от двух closures и привнёвших себе от них обоих оператор круглые скобочки. Что он себе привнёс? От одного closure
оператор круглые скобочки от вектора, а от другого привнёс себе шаблонный оператор круглые скобочки. Дальше в конце в цикле мы вызываем этот Overload сначала от std::variant в котором лежит double, потом в котором лежит вектор. Если мы
вызываемся от std::variant в котором лежит double, у нас есть круглые скобочки от вектора и шаблонные круглые скобочки. Какие ему выбрать? Конечно шаблонные, потому что круглые скобочки от вектора не подходят. Если мы вызываемся от
std::variant в котором лежит вектор, он наоборот выбирает круглые скобочки от вектора, поскольку частное лучше общего. Ну и в третьем случае он опять выбирает шаблонные круглые скобочки. 

Начиная с C++20 компилятор сам умеет выводить шаблонные аргументы и deduction guide не нужны, мы можем не писать строку template<class... Ts> Overload(Ts...) -> Overload<Ts...>. Если мы создались от списка предков агрегатной 
инициализацией то начиная с C++20 компилятор умеет сам выводить шаблонные параметры какими были наши предки.


std::any это прокаченный void*, а std::variant это прокаченный union.



###################################
string bug example wich SSO

Пример с собеседования. Мы запускаем следующий код и ловим Segmentation fault, почему? У нас есть структура Item в которой есть только одно строковое поле. Так же у нас есть класс Storage, в котором есть вектор от Item и std::unordered_map от 
std::string_view и size_t. В класс Storage мы добавили три строки с помощью метода add, и дальше мы хотим для всех этих строк выполнить функцию for_each, в которой просто выводится строка name, а потом мы просто пытаемся достать снова 
строку уже по имени и затем падаем. Когда мы вызываем метод add мы в вектор муваем Item, а в std::unordered_map во-первых записываем строку, путём того, что из только что добавленного последнего элемента вектора в котором лежит Item 
достаём саму строку name и сохраняем в std::unordered_map std::string_view,  и во-вторых запоминаем id. Мув std::string_view это тоже самое что и копирование std::string_view, потому что std::string_view это тривиальный объект, в нём лежит всего два 
указателя на начало и конец строки. std::string_view это не владеющий данными тип, это просто очки с фильтрами на которые мы смотрим на строки.

struct Item {
	std::string name;
};

class Storage {
public:
	size_t add(Item&& item) {
		size_t id = by_id_.size();
		by_id_.emplace_back(std::move(item));
		by_name_.emplace(by_id_.back().name, id);
		return id;
	}

	Item* get_by_id(size_t id) {
		return id < by_id_.size() ? &by_id_[id] : nullptr;
	}

	Item* get_by_name(const std::string_view& name) {
		return by_name_.contains(name) ? get_by_id(by_name_.at(name)) : nullptr;
	}

	template <class F>
	void for_each(F&& f) {
		std::for_each(by_id_.begin(), by_id_.end(), f);
	}

private:
	std::vector<Item> by_id_;
	std::unordered_map<std::string_view, size_t> by_name_;
};

int main() {
	Storage s;
	s.add(Item{"abc"});
	s.add(Item{"cde"});
	s.add(Item{"def"});

	s.for_each([](auto&& item) {
		std::cout << item.name << '\n';
	});

	auto item = s.get_by_name("abc");
	std::cout << item->name << '\n';
}

Вывод:
abc
cde
def
Segmentation fault (core dumped)

Если мы закоментим вызов for_each Segmentation fault всё ровно остаётся, проблема не в нём. Проблема и не в std::string_view. Но если мы введём в строки больше символов:


int main() {
	Storage s;
	s.add(Item{"abcaaaaaaaaaaaaaaaaa"});
	s.add(Item{"cdeaaaaaaaaaaaaaaaaa"});
	s.add(Item{"defaaaaaaaaaaaaaaaaa"});

	auto item = s.get_by_name("abcaaaaaaaaaaaaaaaaa");
	std::cout << item->name << '\n';
}

то Segmentation fault не будет и всё будет корректно.

Вывод:
abcaaaaaaaaaaaaaaaaa

Что происходит когда мы делаем add? У нас в std::unordered_map по сути хранятся указатели на начало и конец строки (потому что std::string_view это пара указателей), но это была маленькая строки, и на самом деле это были указатели на поля 
старого std::string, пока это была короткая строка она на самом деле хранилась на стеке, т.е. этот std::string_view на самом деле указывал на поля той строки, которую при очередной реалокации переложили в другое место а старую дропнули.
Если бы строки были длинные, то это работает, потому что строка лежит на куче и std::string_view хранит указатели на начало и конец строки которая не меняется, потому что они остаются лежать на куче, но если строки короткие, то 
std::string_view хранит указатели на начало и конец короткой строки, т.е. на самом деле они хранят указатели на тот самый буффер, который является полем std::stirng, т.е. в частности они хранят указатели на нечто, что лежит на стеке как поля
стринга, но когда вектор реалоцируется старые объекты стринга уничтожаются и перекладываются на новое место и поля старого стринга конечно же не валидны. Это баг связанный с SSO - Small String Optimization, с этим нужно быть 
аккуратным. Тут огромная проблема что мы скомбинировали то что нельзя комбинировать - короткие строки, std::vector и std::string_view. Нам хоть и гарантирует безопасность и std::vector и std::string, но в комбинации всё ровно что-то
может пойти не так, например как в этом примере (это C++ детка).
 

###################################
tree traversal

Ещё один пример. Есть известная задача: у нас есть бинарное дерево и нужно посчитать кол-во листьев. Сейчас сделаем это модным методом с помощью рекурсивных лямбд и Overload паттерна. С помощью std::variant дерево у нас будет 
либо листом, либо Node*. В функции подсчёта листьев у нас будет Overload который унаследовался от двух closure. В Overload у нас есть оператор круглые скобочки от Leaf и от Node*, и если мы явно принимаем себя, то в наследнике это 
должно быть тем самым объектом наследника, т.е. self это будет объект Overload, а не closure от которого унаследовался Overload.  

struct Leaf {};	
struct Node;

using Tree = std::variant<Leaf, Node*>;

struct Node {
	Tree left;
	Tree right;
};

template <typename... Ts>
struct Overload: Ts... {
	using Ts::operator()...;
};

// Функция подсчёта листьев
int countLeaves(const Tree& tree) {
	return std::visit(Overload{
		[](const Leaf&) { return 1;},				// Если мы попали в лист, то нужно вернуть 1
		[](this const auto& self, const Node* node) -> int {		// А если мы попали в Node* 
			return std::visit(self, node->left)		// 
				+ std::visit(self, node->right);
		}
	}
	, tree);
};


_____________________________________________
Реализация std::variant и std::visit (Лекция 58 здесь реально сложно)

Первым делом нам нужно придумать конструкторы и деструктор. Какие у variant должны быть конструктры? variant должен уметь конструироваться от любого из типов, который в нём могут храниться, и он должен это делать по правилам перегрузки, 
т.е. если у нас есть variant от int, double и std::string и мы пытаемся сконструировать variant от float, то должен выбраться тот тип из N этих типов, который наиболее подходит по правиламразрешения перегурзки, т.е. в данном случае 
должен выбраться double, потому что конверсия от double в данном случае проще чем от других типов. Если нет типа к которому можно сконвертировать или если это ambiguous (неоднозначная) конверсия, т.е. обе конверсии одинаково хороши, 
например если бы у нас был variant от int и float а мы бы конструировались от double, то это должен быть CE со словами неоднозначный вызов конструктора, потому что и от int и от float можно конструироваться одинаково. Один из самых 
интересных вопросов и для нас это новая идея которую мы в коде ещё не встречали: это как написать такие конструкторы, чтобы они выбирались по правилам перегрузки. 

Чтобы решить эту проблему давайте унаследуемся от переменного числа родителей, и у каждого из них будет конструктор от соответсвтующего типа, а потом заюзаем все конструкторы и превнесём их в область видимости, т.о. мы получим перегрузку
между нужными конструкторами.

template <typename T>
struct VariantAlternative {
	VariantAlternative(const T& value) {
	
	}
};

template <typename... Types>
class Variant: private VariantAlternative<Types>... {
public:
	using VariantAlternative<Types>::VariantAlternative...;

};


Теперь нужно понять какие у нас будут поля. Есть два варианта как можно реализовать поля variant: можно сделать шаблонный union с переменным кол-вом аргументов, т.е. union в котором поля это все эти типы, это как std::tuple 
только union, т.е. по сути почти тоже самое что и std::tuple, только union вместо struct:

template <typename... Types>			// Общая версия.
union VariadicUnion;

template <typename Head>			// Специализация для одного типа
union VariadicUnion<Head> {
	Head head;
};

template <typename Head, typename... Tail>	// Общая специализация	
union VariadicUnion<Head, Tail...> {
	Head head;
	VariadicUnion<Tail...> tail;
};

и теперь мы можем в полях сохранить такой VariadicUnion от наших Types:

template <typename... Types>
class Variant: private VariantAlternative<Types>... {
private:
	VariadicUnion<Types...> varun;

public:
	using VariantAlternative<Types>::VariantAlternative...;		// Новое поле

};

А все ли это поля? Можем ли мы обойтись только таким полем? Нет. Нам нужно чтобы variant помнил в рантайме какой в нём сейчас лежит тип, для того чтобы когда мы подменяли тип, он смог уничтожить в рантайме старый и положить новый. 
Собственно главное преимущиство variant над union в том, что union не помнит кто в нём сейчас активный, и если мы не отгадали кто активный, то UB, а variant помнит, и он не даёт нам обратиться к неактивным, он просто подменяет за нас.
Поэтому он должен помнить индекс:

template <typename... Types>
class Variant: private VariantAlternative<Types>... {
private:
	VariadicUnion<Types...> varun;
	size_t active_index;

public:
	using VariantAlternative<Types>::VariantAlternative...;

};

В чём плюс такой реализации? Нам не нужно париться про alignment (выравнивание). union выравнивает все поля как надо. Однако можно реализовать и без union, можно просто хранить массив char, размера sizof максимум и alignof сколько надо.
Вероятно это даже более удобная реализация в конечном счёте, потому что если мы начнём писать реализацию с union, тогда многие функции придётся реализовывать с шаблонной рекурсией. Выбор за нами. В таком случае нам нужна метафункция
которая нам скажет максимальный размер типа из пакета:

template <typename Head, typename... Tail>
struct max_sizeof {
	static const size_t value = sizeof...(Tail) > 0
		? std::max(sizeof(Head), max_sizeof<Tail...>::value)
		: sizeof(Head);
};

template <typename... Types>
constexpr size_t max_sizeof_v = max_sizeof<Types...>::value; 

template <typename T>
struct VariantAlternative {
	VariantAlternative(const T& value) {
	
	}
};

template <typename... Types>
class Variant: private VariantAlternative<Types>... {
private:
	///VariadicUnion<Types...> varun;		// Первая реализация
	char buffer[max_sizeof_v<Types...>];		// Вторая реализация, нужно ещё сделать alignment, для этого просто надо тоже написать метафункцию
	size_t active_index;

public:
	using VariantAlternative<Types>::VariantAlternative...;

};

Как будут выглядить поля мы поняли. Так всё таки тогда как будут выглядить конструкторы? У нас есть класс VariantAlternative, который конструируется от данного T, и что теперь? Нужно положить в буффер наш value, т.е. вызвать placement
new на буффер от value. А где взять буффер? В полях VariantAlternative мы ничего хранить не хотим, даже просто указатель на этот буффер, потому что мы от всего этого наследуемся и у нас будет N указателей храниться в variant. Мы верим
что VariantAlternative никогда не существует сам по себе, он всегда родитель какого-то variant, VariantAlternative это приватный класс и его будет использовать только variant. VariantAlternative это пустой класс без полей, и мы знаем
что VariantAlternative никогда не сущесвтует сам по себе, он всегда является родителем variant. Это значит что мы можем в VariantAlternative предпологать, что если сделать просто static_cast this к variant, то это будет корректный каст
и мы увидим поля variant по этому адресу, и первое из них будет буффер. Чтобы скастовать нам нужно сделать forward declaration самого Variant, но всё ровно не понятно static_cast Variant<от чего>? Для решения этой проблемы Variant нам 
нужно использовать CRTP. Но наследоваться от VariantAlternative с параметром <T, и сам этот Variant> это перебор, можно сказать проще, мы будем наследоваться от тех же типов Types. Пишем специализации для max_sizeof. Теперь правильно 
наследуемся от VariantAlternative. У нас получилась очень хитрая конструкция: class Variant: private VariantAlternative<Types, Types...>... здесь Variant это приватный наследник VariantAlternative с параметрами <Types, Types...>... 
В этом шаблонном типе два раза распаковывается пакет, один раз внутри угловых скобок, другой раз вне угловых скобок. Т.е. если у нас есть Variant с параметрами int, double, char:

Variant<int, double, char>: VariantAlternative<int, int, double, char>,
			    VariantAlternative<double, int, double, char>,
			    VariantAlternative<char, int, double, char>;

то это будет наследник VariantAlternative с параметрами int, int, double, char, потом VariantAlternative с параметрами double, int, double, char, потом VariantAlternative с параметрами char, int, double, char, т.е. будет повторяться
3 раза и первый тип будет отличаться, т.е. мы три раза унаследовались.  Три раза поскольку мы распаковывали пкает внутри и снаружи. 
Также компилятор требует чтобы мы написали конструктор и деструктор по умолчанию для VariantAlternative. Поскольку наследование приватное у нас будет ошибка в static_cast. VariantAlternative это приватный неследник Variant, т.е.
Variant скрывает от всех что он наследник VariantAlternative, в том числе и от самого VariantAlternative. Значит нам нужно чтобы VariantAlternative был другом Variant. Потом дописываем конструктор VariantAlternative, делаем placement new
в буффер. Также нужно запомнить какой у нас по номеру тип, и номер нужно записать такой, какой был номер T в пакете типов, а это вычисляется в компайлтайме. Для этого нам нужно написать метафункцию, которая возвращает номер индекса в 
пакете. Получается каждый VariantAlternative знает свой индекс в пакете.

Мы научились писать конструктор) Теперь нужно написать деструктор, это следующая проблема. Мы бы хотели скастить наш буфер к указателю на тот тип, который сейчас у нас активный и вызвать деструктор этого T, но мы не можем в 
static_cast подложить тип, который будет известен только в рантайме. Мы не хотим виртуализацию и даже свою таблицу виртуальных функций. У нас уже есть CRTP и это в каком то смысле замена виртуальным функциям. Мы уже выбрали другой путь и
если мы сейчас попытаемся ещё и вирутальную таблицу сюда прикрутить, тогда может было и CRTP не делать. Мы можем в VariantAlternative написать функцию destroy, в которой мы будем вызывать все деструкторы. Чтобы вызвать из деструктора
Variant все функции destroy, нужно использовать fold expression и оператор запятая по всем родителям. Мы вызвали destroy у всех предков, но сработал только тот из них, который был реально активный. 


template <typename... Types>
class Variant;	// forward declaration 

template <typename... Types>
const size_t get_index_by_type = 0;								// Метафункция не реализована, это нужно сделать самому)

template <typename T, typename... Types>
struct VariantAlternative {
	static const size_t index = get_index_by_type<T, Types...>;

	VariantAlternative() {}
	~VariantAlternative() {}

	VariantAlternative(const T& value) {
		auto* this_variant =  static_cast<Variant<Types...>*>(this);	
		new (this_variant->buffer) T(value);
		this_variant->active_index = index;
	}
	VariantAlternative(T&& value) {
		auto* this_variant =  static_cast<Variant<Types...>*>(this);	
		new (this_variant->buffer) T(std::move(value));
		this_variant->active_index = index;
	}

	void destroy() {
		auto* this_variant =  static_cast<Variant<Types...>*>(this);
		if (this_variant->active_index == index) {
			reinterpred_cast<T*>(this_variant->buffer)->~T();
		}
	}
};

template <typename... Types>									// Общая специализация
struct max_sizeof;

template <typename T>										// Специализация для одного типа
struct max_sizeof<T> {
	static const size_t value = sizeof(T);
};

template <typename Head, typename... Tail>							// Специализация для многих типов
struct max_sizeof<Head, Tail...> {
	static const size_t value = std::max(sizeof(Head), max_sizeof<Tail...>::value);
};

template <typename... Types>
constexpr size_t max_sizeof_v = max_sizeof<Types...>::value; 

template <typename... Types>
class Variant: private VariantAlternative<Types, Types...>... {
private:
	///VariadicUnion<Types...> varun;		// Первая реализация
	char buffer[max_sizeof_v<Types...>];		// Вторая реализация, нужно ещё сделать alignment
	size_t active_index;

	template <typename T, typename... Ts>
	friend struct VariantAlternative;

public:
	using VariantAlternative<Types, Types...>::VariantAlternative...;
	
	~Variant() {
		(VariantAlternative<Types, Types...>::destroy(), ...);		// fold expression
	}
};


Однако сейчас в этой реализации есть UB, оно заключается вот в чём: мы из VariantAlternative(const T& value) кастим себя к Variant, а потом делаем placement new по адресу (this_variant->buffer) T(value). Это UB, потому что мы создаём 
родителя, но в этот момент ещё не началось время жизни полей наследника. Мы из конструктора родителя делаем что-то с полями наследника, хотя поля наследника ещё не созданы и формально не началось их время жизни. Обращение
к полям наследника валидно лишь когда они хотябы созданы. Это не очевидная проблема и чтобы её исправить, нужно сделать Variant наследником не только VariantAlternative, нам нужно сделать так, чтобы был ещё класс VariantStorage,
который содержит все поля Variant, т.е. все поля нужно вынести в верхнего наследника и тогда VariantAlternative будет создаваться уже в момент, когда VariantStorage формально создан, тогда у нас будет всё корректно:

template <typename... Types>
class Variant: private VariantStorage,
	     private VariantAlternative<Types, Types...>... {



###################################
Реализация std::visit

Копи, мув конструкторы и оператор присваивания уже не так интересно. Но нам нужно ещё обсудить реализацию std::visit. Что делает std::visit? Он принимает visitor и несколько (важно что несколько а не один) std::variant, и у каждого из 
этих std::variant вызываем visitor в пакете, но этот visitor должен выбрать правильный тип std::variant от которого вызваться, вот как это сделать? Сначала поймём как сделать std::visit от одного std::variant. Идея следующая: у 
VariantAlternative дооперделим метод visit и у Variant сделаем какой-нибудь приватный метод private visit, visit будет другом std::variant и visit будет вызывать этот private visit. private visit будет проходиться по всем 
VariantAlternative, проверяем что VariantAlternative активна, и если она активна, то вызываем visit от неё, visit вызовется от нужной версии перегрузки visitor. Функтор visitor должен уметь вызываться от всех типов которые может хранить
Variant. Но что если visitor от нескольких std::variant? visitor от нескольких std::variant это такой функтор, что например у нас есть N std::variant и этот visit он от N параметров, и от каждого из std::variant он должен выбрать 
правильный тип аргумента и вызваться от него. Т.е. если у нас visit от двух std::variant то visitor принимает два аргумента и каждый из них м.б. чем-то или чем-то другим, и вот нужен visitor, который вызовется от правильной версии там и
там. Если у нас N std::variant и в каждом k разных типов, то у нас будет k в N-нной степени возможных функций, которые потенциально м.б. вызовет std::visit. Если мы возьмём размеры вариантов и перемножим то сложность функции visit будет
равна произведению размеров вариантов. visit создаёт k в степени N где k размер std::variant, N - кол-во std::variant различных перегрузок и выбирает из них нужную. Как она это делает? Поскольку в компйл тайме мы заранее не знаем какая 
версия будет выбрана, это значит что нам ни как не обойтись без того, чтобы сгенерировать для функции visit все эти перегрузки. Т.е. по сути нам нужно сгенерировать таблицу размера k в N-нной, в каждой ячейке которой будет указатель на 
функцию (По сути Декартово произведение), и мы выбираем из них нужную версию.

Какой возвращаемый тип у std::visit? decltype от того добра что мы вызвали и будет возвращаемым типом.


_____________________________________________
Laundry problem. std::launder

Интересная задача: что выведет этот код? Пока не будем говорить как это относиться к теме std::variant и union.

struct A {
	virtual int f();
};

struct B : A {
	int f() override { new (this) A; return 1; }
};

int A::f() { new (this) B; return 2; }

int h() {
	A a;
	int n = a.f();
	int m = a.f();
	return n + m;
};

int main() {
	std::cout << h() << '\n';
}

У нас есть функция h, в ней мы создаём объект a типа A, это объект родителя. Дальше мы вызываем функцию f у объекта a и она нам возвращает 2, но перед этим она подкладывает на свой собственный адрес объект B. Проблема в том, что мы
берём функцию f() которая нам возвращает 2 у родителя, но прежде чем вернуть 2, она вызывает placement new на себя же и кладёт туда объект наследника. Потом мы второй раз вызываем функцию f() у объекта a, но там уже лежит наследник,
так вообще можно? Что должно произойти? При вызове функции f() во второй раз должна ли вызваться версия наследника или нет, сработает ли виртуальность? Ну казалось бы, когда мы вызываем виртуальную функцию компилятор должен 
посмотреть что это объект полиморфный, значит он начинается с указателя на vtable, пойти по этому указателю, вызвать нужную версию, т.е. формально согласно правилам которые мы знаем должно вывестись 3, потому что по правилам вызова
виртуальных функций второй раз мы должны пойти честно по указателю, посмотреть туда, увидить что уже указатель другой, пойти в версию B, и вызвать её. Однако на самом деле выведется 4, и почему то так не происходит. Компилятор имеет
право считать, что тип A не поменялся от того, что у него вызвали какой-то метод. Не мог поменяться тип переменной a, если у неё просто вызвать метод. Если бы у нас было бы так:

 int h() {
	A* a = new A;
	int n = a->f();
	int m = a->f();
	return n + m;
};

то тогда бы вывелось 3, но без указателей это уже не воспроизводится. Если что, то оба примеры это UB, просто первый пример воспроизводит проблему, а второй пример с указателем нет. На разных компиляторах это работает по разному, и 
называется оптимизация девиртуализации, компилятор видит что ни кто никакого указателя на B не создавал и компилятор имеет право считать что вызвов метода a.f() не подменяет тип.  

Как это связано с std::variant? Представим что у нас есть std::variant, который хранит Base и Derived. И вот мы варианту что-то присвоили, а он такой new от буффер Derived от value. И вот мы вызвали метод класса, а он взял и placement 
new другого типа на тот же адрес положил. После этого мы начинаем вызывать методы той штуки, которая лежит по тому адресу, а у компилятора есть формальное право оптимизировать такие вызовы функций, считая что тип не менялся, что
мы не кладём по одному и тому же адресу новый тип, чтобы компилятор не ходил заново в таблицу виртуальных функций. Это работает не только для виртуальных, это проблема актуальна не только для примера с наследованием и 
виртуальностью, эта проблема актуальна ещё для константных типов.

Представим что у нас есть структура x у которой есть поле const int и double. Положем int в кучу, а потом на этот же адрес положим int с новым значением, а int у нас был константным. Если мы после этого по указателю p достанем n, то 
что мы увидим 7 или 42?

struct X {
	const int n;
	double d;
};

X* p = new X{7, 8.8};
new (p) X{42, 9.9};

int i = p->n;			// UB
auto d = p->d;
 
Формально по стандарту это UB, потому что если после того как время жизни объекта закончилось перед тем как занятые этим объектом storage переиспользован или освобождён, новый объект создан по тому же адресу на котором лежал оригинальный
объект, то имя оригинального объекта автоматически начнёт относиться к новому объекту и как только время жизни нового объекта началось, это имя м.б. использовано для манипуляций над новым объектом, если (конъюнкция условий):
1) место хранения для нового объекта точно совпадает с местом хранения, которое занимал старый объект, и
2) новый объект имеет тот же тип, что и исходный объект (игнорируя cv-квалификаторы верхнего уровня), и
3) тип исходного объекта был не константным, и если исходного объект был классом, и у него не было константных или ссылочных полей, и
4) старый и новый тип не являются подобъектами базового класса.

Предыдущие два примера как раз являются контрпримером к этому списку требований. В первом примере у нас было имя и мы использовали это имя, хотя под ним уже лежал другой объект и оно не сработало, потому что тип подменился, получается
мы нарушили условие 2. Во втором примере нарушено третье условие, мы положили по этому же адресу через placement new новый объект с новым значением const int, и начали через этот указатель доставать этот int, но так нельзя делать 
согласно пункту 3, который говорит что нельзя подложить под тот же указатель другой объект, если там имеется константное поле.

Как следствие: если у нас есть std::variant и есть какой то указатель, а мы подложили на этот же указатель с помощью placement new новый объект другого типа и обращаемся к нему, это всё UB.

Пример из стандарта C++20: У нас есть объект типа C и мы в оператора присваивания C сделали деструтор this, а потом placement new (this) C(other), так можно делать? Можно, при условии что не было константных полей, здесь данное условие
выполнено.

struct C {
	int i;
	void f();
	const C& operator=(const C&);
};

const C& C::operator=(const C& other) {
	if (this != &other) {
		this->~C();				// lifetime of *this ends
		new (this) C(other);			// new object of type C created
		f();					// well-defined
	}
	return *this;
}

C c1;
C c2;
c1 = c2;						// well-defined
c1.f();							// well-defined; c1 refers to a new object of type C

Но если мы placement new сделали на другой тип, или если у нас были константные поля, то это UB, и если эти условия не выполнены, то указатель на новый объект м.б. получен из указателя, представляющего адрес его хранилища, путём вызова
функции std::launder.


###################################
std::launder (отмывать) (since C++17)

Сейчас мы познакомимся пожалуй с самой непонятной и труднообъяснимой что она делает функцией - std::launder в стандартной библиотеке. Функция, объяснить смысл которой сложнее всего, она гораздо непонятней чем std::move или std::forward.

std::launder берёт указатель и возвращает указатель на тоже самое ничего не поменяв. Единственное, если мы вызвали эту функцию над указателем, то гарантируется что компилятор забудет то, что он знал об этом указателе раньше.

Вернёмся к предыдущему примеру. У нас был объект a и мы взяли указатель на него, указатель разыменовали и вызвали f. 

int h() {
	A a;
	int n = a.f();
	int m = (&a)->f();
	return n + m;
};

Ничего не поменялось, вывод остался также 4. Но если мы попросим тот же указатель, но только прогнать его через std::launder:

int h() {
	A a;
	int n = a.f();
	int m = std::launder(&a)->f();
	return n + m;
};

то выведется 3. Как это работает? Я не знаю, это нельзя написать используя C++, это встроенная в компилятор функция, написанная скорее всего на языке intermediate representation (IR). (Прикольная история про создание этой функции 
Лекция 59 16.40). Одна из причин введения этой функции заключался в том, что в стандарте C++14 нашли баг. Баг заключался в том, что если мы храним в std::vector константные объекты, или просто объекты с константными полями, то у 
нас UB в std::vector хахахахах. Баг происходит именно по этой причине, потому что если мы делаем в std::vector push_back(), потом pop_back(), потом опять push_back() а у нас было константное поле, то согласно предыдущей формулировки из
стандарта, компилятор имеет право предполагать что оно не поменялось. В статье посвещённой мотивации добавления функции std::launder в стандарт C++17 от 2017 года от автора Nicolai Josuttis (один из членов комитета по стандартизации)
написано: "Следовательно, в текущее время (для кода на C++ вплоть до версии C++14) любой контейнер, такой как std::vector, использующий элементы с константными или ссылочными членами, почти сразу сталкивается с неопределённым 
поведением. Например:"

struct X {
	const int i;
	X(int _i) : i(_i) {}
	friend std::ostream& operator<< (std::ostream& os, const X& x) {
		return os << x.i;
	}
};

std::vector<X> v;
v.push_back(X(42));
v.clear();
v.push_back(X(77));
std::cout << v[0];		// undefined behavior

Сейчас настал такой момент, когда на этом примере пора понять что стандарт это некоторый очень очень большой документ и на самом деле никто не знает C++ полностью даже его создатель. В стандарте C++ на протяжении многих лет из этих 
определений формально следовало, что std::vector который хранит такие типы это UB, и этот баг долго не замечали, потому что пойди и сам разберись что там формально следует, а компиляторы они же рады оптимизировать, разработчики 
компиляторов видят такую формулировку в стандарте, и они пишут оптимизации исходя из этого, и в какой-то момент это выстреливает, потому что разработчики компиляторов написали оптимизацию, согласно тому что они там наопределяли, и 
что-то упало, и они пришли в комитет и сказали, ребята что-то тут у вас не так, кажется у вас где-то противоречие в ваших формулировках, если сопоставить это и то, то у вас UB. Вот тогда и ввели функцию std::launder.

Мораль: если мы собираемся на storage, на котором раньше лежал не такой тип, который у нас сейчас, положить другой тип, то делайте не new от этого storage, а new от std::launder от этого указателя новый тип. И если там был константный 
тип или тип у которого константные или ссылочные поля то тоже самое. Если мы вызываем std::launder, то мы предотвращаем оптимизации компилятора связанные например с девиртуализацией, и с тем, что он заранее знает, что там константа.
В чём причина всего UB, в том что компилятор оптимизирует, в первом примере компилятор решил не идти в таблицу виртуальных функций второй раз, потому что для него это очевидно что

int n = a.f();
int m = a.f();

при вызове метода одного и того же объекта тип этого объекта не будет меняться. Компилятор думает что здесь можно соптимизировать, и главное что стандарт это разрешает, а потом оказывается что невсегда это можно делать. Тоже самое и
с константами. Т.е. мы с помощью std::launder предотварщаем оптимизации компилятора, это так называемое Provenance fence, как в многопоточке есть барьеры, это тоже барьер в каком то смысле, т.е. после вызова std::launder компилятор
обязан забыть все предположения об этом указателе,об этой ссылке или об этом имени, которые он делал до этого. launder переводиться как стирка, а вообще ещё бывает launder денег (отмывание денег), так вот launder так назвали, потому
что мы вызвали std::launder от чего-то и как бы после этого мы забыли происхождение откуда он к нам пришёл, типо это мог быть како-то грязный указатель, но мы забыли, мы говорим компилятору считай что ты ничего не знаешь откуда взялся
этот указатель.

Однако в статье есть интересное замечание: "Однако для всех контейнеров на основе аллокатора, таких как std:: vector, все еще существует проблема: std::launder не помогает избежать неопределённого поведения.". Потому что на самом деле
std::vector хранит не сырую T* а typename std::allocator_traits::pointer, а это м.б. не сырой сишный указатель, а какой то fancy pointer т.е. надстройка над сишным указателем, std::launder к которому не применим, и соответсвтенно вызов 
std::launder от него ничего не делает. Устройство std::vector:

template <typename T, typename A = std::allocator<T>>
class vector {
public:
	typedef typename std::allocator_traits<A> ATR;
	typedef typename ATR::pointer pointer;
private:
	A _alloc;			// current allocator
	pointer _elems;		// array of elements
	size_t _size;		// number of elements
	size_t _capa;		// capacity
/...
};

Т.е. если у нас в контейнере нестандартный аллокатор в котором указатель это не сишный сырой указатель, а какой то fancy указатель, то "Таким образом, std::launder не решает проблему избежания неопределённого поведения в контейнерах на 
базе аллокатора при наличии элементов с константными/референсными членами".
 
###
Пример использования std::launder из стандарта (рекомендация стандарта как нужно использовать std::launder)

У нас есть указатель на const X и мы создали const X со значением 3, далее мы достаём константный int 

struct X { int n; };
const X *p = new const X{3};		// Создали указатель на константный X, и создали константную структуру X с неконстантным полем n = 3.
const int a = p->n;			// Далее мы  дохраняем отдельно n.
new (const_cast<X*>(p)) const X{5};	// p does not point to new object because its type is const 
const int b = p->n;			// UB
const int c = std::launder(p)->n;	// OK, c обязано будь равно 5


_____________________________________________
strict aliasing problem

Что выведет следующий код?  

long long foo(long long* a, int* b) {
	if (*a != 11)
		*b = 11;		// ???
	return *a;
}

int main() {
	long long a = 22;
	
	a = foo(&a, (int*)&a);	// C-style каст к int, в данном случае это будет reinterpred_cast. 
	std::cout << a;
}

Обращение по указателю на не соответствующий тип через reinterpred_cast это UB, это пример того как это UB может проявиться. В выводе мы получаем 11, но если мы это скомпилируем с оптимизацией -O2, то будет не 11, а 22. Почему?
Вот это *b = 11; как будто не сделалось. Почему-то если мы включаем оптимизатор, то как будто не делается присваивание 11, а 22 так и остаётся, почему? В C++ унаследовано от C так называемое правило aliasing (алиасинга) типов 
(хз как это переводится на русский, наверное псевдонимизация типов). aliasing это когда мы можем обращаться к одному типу по указателю или по ссылке на другой тип. Вообще это UB обращаться по указателю на один тип через указатель
на другой тип, если это не какие-то специальные случаи. Мы многократно делали так, например, по указателю на char обращались к какому-то там типу, мы брали указатель на char и кастовали его к указателю на какой-то другой тип. А 
вообще нормально ли так делать? Ну например как в данном случае, если мы по указателю на long long и по указателю на int пытаемся обратиться к одному и тому же, то это как мы видим это UB. В чём именно кроется причина UB? Дело в том,
что где-то в стандарте написано, что вообще нельзя через указатель на long long и через указатель на int обращаться к одному и тому же, под ними не может лежать один и тот же объект. Компилятор предполагает, что поскольку правила  
aliasing (алиасинга) типов запрещают нам через long long* и через int* обращаться к одному и тому же, значит компилятор думает что, то что лежит под a и то что лежит под b никак не связано. Поэтому,когда мы один раз прочитали что
лежит под a в строке if (*a != 11), нам не нужно читать второй раз что лежит под a в строке return *a; Мы проверили что под a не 11 и поменяли b, но мы уже запомнили что было под a и мы не будем читать второй раз его, потому что 
компилятор считает, что от того что мы поменяли *b не поменялось a, это же разные переменные, они и не могут быть одной и той же переменной, потому что правило aliasing (алиасинга) запрещают обращаться через long long и через int
на одно и тоже, значит это разные вещи, значит от того что мы поменяли b не могло поменяться a, и значит второй раз мы не будем считывать a.

Какие есть выходы из этого? Можно отключить оптимизацию strict aliasing -fno-strict-aliasing, тогда будет 11. А можно например сделать так, заменить int на char. Что тогда будет?

long long foo(long long* a, char* b) {	// Поменяли int на char
	if (*a != 11)
		*b = 11;		
	return *a;
}

int main() {
	long long a = 22;
	
	a = foo(&a, (char*)&a);	// Поменяли int на char
	std::cout << a;
}

Тогда тоже будет 11. Дело в том что для типа char сделано исключение в стандарте (и для std::byte). Через указатель на char можно обращаться к любому другому типу и правило aliasing (алиасинга) типов не нарушается, потому что в нём 
написано:
"Если программа пытается получить доступ к значению объекта через glvalue типа, отличающегося от одного из следующих, то это UB." И далее приведён список того, через что можно обращаться к объекту:

1) Через динамический тип объекта:
void *p = malloc( sizeof(int) ); 		// We have allocated storage but not started the lifetime of an object
int *ip = new (p) int(0);		// Placement new changes thy dynamic type of the object to int
std::cout << *ip << "\n";		// *ip gives us a glvalue expression of type int which matches the dynamic type of the allocated object

2) cv-qualified версию динамического типа объекта
int x = 1;
const int *cip = &x;
std::cout << *cip << "\n";		// *cip gives us a glvalue expression of type const int which is a cv-qualified version of the dynamic type of x

3) Через тип похожий (как определено в пунке 7.5 стандарта C++17) на динамический типа объекта (TODO посмотреть что за пункт 7.5)
int *a[3];
const int *const *p = a;
const int *q = p[1];			// ok, read of 'int*' through lvalue of similar type 'const int*;

4) Через тип который является знаковым или беззнаковым типом соответствующим динамическому типу объекта
// Both si and ui are signed or iunsigned types corresponding to each others dynamic types
// We can see from this godbolt the optimizer assumes aliasing.
signed int foo( signed int &si, unsigned int &ui ) {
	si = 1;
	ui = 2;

	return si;
} 

5) Тип, который является типом signed ot unsigned, соответствующим cv-qualified версии динамического типа объекта
signed int foo( const signed int &si, int &si2 ); // Hard to show this one assumes alising

6) и 7) смотри в стандарте если нужно

И наконец 8) Типы char, unsigned char, или std::byte.

Если мы через что-то из этого обращаемся к объекту по указателю, то это не UB, а если не через это, то это UB, и мы таким образом можем нарваться на проблему, которая называется проблема strict aliasing.


Как ещё можно решить эту проблему? Есть одно ключевое слово которое можно написать - volatile (с английского нестабильный, очень резко меняющийся). Это то слово, наряду с const, которое cv-qualified type.

long long foo(volatile long long* a, int* b) {		// Написали volatile
	if (*a != 11)
		*b = 11;		
	return *a;
}

int main() {
	long long a = 22;
	
	a = foo(&a, (int*)&a);	
	std::cout << a;
}

Можно сделать тип volatile. volatile это ключевое слово, это ещё один квалификатор типа как и const, которое абсолютно как const синтаксически себя ведёт, т.е. каст к нему неявный разрешён, а обратный нет, его можно подкладывать под
указатели и под ссылки (volatile каста нет если что). volatile это такая вещь, которую нужно всегда проверять чему равна, даже если нам кажется что она не могла поменяться между двумя её последовательными чтениями. volatile это 
квалификатор типа, который запрещает компилятору оптимизиации чтения этой переменной, оно говорит что обращение к этой переменной нельзя оптимизировать. И если мы напишем его, то даже с оптимизацией O2 у нас всё ровно 
будет выводиться 11, а не 22. Мы буквально запретили компилятору оптимизировать чтение этой переменной и теперь он объязан буквально делать с переменной то, что мы ему сказали.

Как ещё это влияет? Представим что у нас где-то в коде написано такое подряд:

*a = 5;
*a = 6;

Если сгенерировать ассемблер под это и посмотреть как компилятор соптимизирует, то мы увидим что код строчки *a = 5 вообще не будет выполнен, будет сразу выполнен код строчки *a = 6, т.е. будет сразу присваивание 6, потому что зачем 
нам переприсваивать два раза, если можно соптимизировать и присвоить сразу второй вариант, компилятор имеет право это соптимизировать. Но если эта переменная volatile, то тогда компилятор уже не имеет такого права, и если у нас
написано volatile, то компилятор сделает буквально как у нас написано, он сделает все записи и чтения ничего не пропустив, вот что такое volatile.

Правда сейчас ключевое слово volatile не рекомендуется к использованию, в C++20 одно из принятых предложений был deprecated almost allof volatile usages. Даже в нашем сценарии volatile это такой себе выход, потому что просто не нужно 
нарушать strict aliasing и всё, volatile это типа такой костыль, чтобы починить UB, но на самом деле это просто проблема в нашем коде, здесь volatile не нужен мы просто объяснили что он делает, но это не его прикладное приминение ( хз
когда он по настоящему нужен на самом деле XD).


