https://metanit.com/cpp/qt/7.1.php

Модель

Базовым классом всех моделей является класс QAbstractItemModel. Тип QAbstractItemModel предоставляет интерфейс для данных, достаточно гибкий для работы с самыми разными 
представлениями данных - в виде таблиц, списков и деревьев.

Однако при реализации новых моделей для структур данных в виде списков и таблиц более предпочтительно использовать классы QAbstractListModel и QAbstractTableModel, так как 
они предоставляют соответствующие реализации по умолчанию. Каждый из этих классов может быть подклассом для создания моделей для специализированных списков и таблиц. Также 
Qt предоставляет несколько готовых моделей, которые можно использовать для обработки данных:

1) QStringListModel: используется для хранения простого списка элементов QString

2) QStandardItemModel управляет более сложными древовидными структурами элементов, каждый из которых может содержать произвольные данные.

3) QFileSystemModel предоставляет информацию о файлах и каталогах в локальной файловой системе.

4) QSqlQueryModel, QSqlTableModel и QSqlRelationalTableModel используются для доступа к базам данных.



Представления

Представления (Views) представляют объекты классов, унаследованных от абстрактного класса QAbstractItemView. Для различных типов представлений предусмотрен ряд реализаций:

1) QListView отображает список элементов

2) QTableView отображает данные из модели в виде таблицы

3) QTreeView показывает данные модели в виде дерева

Хотя эти классы представляют собой готовые к использованию реализации, также можно создать их подклассы для большей настройки представлений. В частности, в фреймворке Qt 
уже имеется ряд виджетов, которые унаследованы от этих классов



Делегаты

Делегаты обеспечивают контроль над представлением элементов, отображаемых в представлении. Шаблон M/V, в отличие от шаблона MVC, не имеет специального компонента для обработки 
ввода пользователя. Представление в первую очередь отвечает за отображение данных модели пользователю и позволяет ему взаимодействовать с ней. Чтобы добавить некоторую гибкость 
в способ получения действий пользователя, ввод пользователя обрабатываются делегатами.

Делегаты представляют объекты абстрактного класса QAbstractItemDelegate. Qt также предоставляет две реализацию по умолчанию для различных ситуаций - класс QStyledItemDelegate 
и QItemDelegate. Разница между ними в том, что QStyledItemDelegate использует текущий стиль для рисования своих элементов. Поэтому рекомендуеncz использовать QStyledItemDelegate
в качестве базового класса при реализации пользовательских делегатов или при работе с таблицами стилей Qt.

Простейший пример View-Model

#include <QApplication>
#include <QWidget>
#include <QListView>
#include <QStringListModel>
 
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
 
    QWidget* widget = new QWidget;
    widget->setWindowTitle("METANIT.COM");
    widget->setMinimumHeight(150);
    widget->setMinimumWidth(250);
 
    // определяем данные для модели
    QStringList list = { "Tom", "Bob", "Sam" };
    // определяем модель
    QStringListModel *model = new QStringListModel(list);
 
    // определяем представление
    QListView *view = new QListView(widget);
    // устанавливаем модель для представления
    view->setModel(model);
 
    widget->show();
    return a.exec();
}

Здесь модель представляет объект QStringListModel, который инкапсулирует список строк. Собственно список строк - QStringList - это и есть те данные, с которыми работает модель.

В качестве представления здесь применяется объект QListView - виджет, который отображает элементы модели в сиде списка. Для установки модели у представления применяется метод 
setModel(), в который передается объект модели:

view->setModel(model);

Таким образом, QListView будет связан с моделью QStringListModel и автоматически отобразит ее данные:

Tom

Bob

Sam


______________________________________________________________________________________
Модель QStandardItemModel

Модель QStandardItemModel предназначена для определения широкого круга представлений - простых списков, таблиц и иерархических данных в виде деревьев. Каждый отдельный элемент 
в этой модели представлен типом QStandardItem.

#include <QStandardItemModel> //Для модели


В общем случае объект QStandardItemModel можно представить в виде таблицы. Для создания объекта модели в ее конструктор можно передать количество строк и столбцов:
QStandardItemModel(QObject *parent = nullptr)
QStandardItemModel(int rows, int columns, QObject *parent = nullptr)

Например, определим модель из 3 строк и 2 столбцов:
QStandardItemModel model(3, 2); // 3 строки, 2 столбца
 
std::cout << model.rowCount() << std::endl;         // 3
std::cout << model.columnCount() << std::endl;      // 2

Можно определить пустую модель и по ходу добавлять в нее строки и столбцы. Для установки содержимого для определенной ячейки таблицы применяется метод setItem()
void setItem(int row, int column, QStandardItem *item)
void setItem(int row, QStandardItem *item)

С каждой ячейкой таблицы ассоциируется определенный объект QStandardItem, который передается в метод в качестве последнего параметра. В конструктор класса QStandardItem можно 
передать непосредственно его содержимое в виде объекта QString:


______________________________________________________________________________________
QTableView. Табличные представления

https://metanit.com/cpp/qt/7.6.php

Класс QTableView представляет реализацию класса QAbstractItemView, которая предназначена для отображения данных в виде таблицы.

#include <QApplication>
#include <QTableView>
#include <QStandardItemModel>
 
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
 
    QWidget* widget = new QWidget;
    widget->setWindowTitle("METANIT.COM");
    widget->setMinimumHeight(150);
    widget->setMinimumWidth(250);
 
    // определяем данные для модели
    QStandardItemModel* model=  new QStandardItemModel(3, 2); // 3 строки, 2 столбца
    model->setItem(0, 0, new QStandardItem("Tom"));
    model->setItem(0, 1, new QStandardItem(39));
    model->setItem(1, 0, new QStandardItem("Bob"));
    model->setItem(1, 1, new QStandardItem(43));
    model->setItem(2, 0, new QStandardItem("Sam"));
    model->setItem(2, 1, new QStandardItem(28));
 
    // установка заголовков таблицы
    model->setHeaderData(0, Qt::Horizontal, "Name");
    model->setHeaderData(1, Qt::Horizontal, "Age");
 
    // определяем представление
    QTableView *view = new QTableView(widget);
    // устанавливаем модель для представления
    view->setModel(model);
 
    widget->show();
    return a.exec();
}

Здесь в качестве модели данных для QTableView применяется модель QStandardItemModel, которая представляет таблицу из трех строк и двух столбцов. Условно первый столбец 
представляет имя пользователя, а второй столбец - возраст.



______________________________________________________________________________________
QSqlTableModel

QSqlTableModel — это высокоуровневый интерфейс для чтения и записи записей базы данных из одной таблицы. Он построен поверх нижнего уровня.QSqlQueryи может использоваться 
для предоставления данных для просмотра таких классов, какQTableView.


























